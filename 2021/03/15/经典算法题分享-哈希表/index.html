<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="">
  <meta name="author" content="Ye hongzhi">
  <meta name="keywords" content="">
  <title>经典算法题分享(哈希表) - 叶洪智的技术分享</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>YeHongzhi's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/img/post.png')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期一, 三月 15日 2021, 10:50 晚上
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    5.3k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      22 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
            <div class="scroll-down-bar">
              <i class="fas fa-angle-down scroll-down-arrow"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <blockquote>
<p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章主要讲解leetcode上，关于哈希表(简单难度)的算法题目。</p>
<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p><strong>题目</strong>：</p>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例1</strong>：</p>
<pre><code class="java">输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</code></pre>
<p><strong>示例2</strong>：</p>
<pre><code class="java">输入：nums = [3,2,4], target = 6
输出：[1,2]</code></pre>
<h2 id="解法1-暴力解法"><a href="#解法1-暴力解法" class="headerlink" title="解法1(暴力解法)"></a>解法1(暴力解法)</h2><p>思路：</p>
<p>因为在数组中有两个整数的和等于目标值，很自然地我们就会想到一个个来尝试。我们知道目标值target和nums[i]，只需要找到nums[j]，然后返回<code>new int[]{i,j}</code>即可。</p>
<p>代码如下：</p>
<pre><code class="java">public int[] twoSum(int[] nums, int target) {
    for (int i = 0; i &lt; nums.length; i++) {
        //由于数组中同一个元素不能使用两遍，所以j从i的下一个元素开始
        for (int j = i + 1; j &lt; nums.length; j++) {
            if (target - nums[i] == nums[j]) {
                return new int[]{i, j};
            }
        }
    }
    return new int[]{};
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_1.png" srcset="/img/loading.gif" alt=""></p>
<p>按道理嵌套循环的话，时间应该会久一点，居然仅用了0ms，我也不太相信，但是提交了三四次也是这个结果，不管了，哈哈~</p>
<p>假如我们想去掉嵌套循环，优化一下，怎么做呢？没错，就是今天的主角，哈希表！</p>
<h2 id="解法2-HashMap"><a href="#解法2-HashMap" class="headerlink" title="解法2(HashMap)"></a>解法2(HashMap)</h2><p>思路：</p>
<p>创建一个Map集合，key是nums[i]元素的值，value是下标值i。当<strong>target - 当前遍历的元素的差值</strong>在map中存在时，就返回<code>new int[]{map.get(target-nums[i]),i}</code>。如果不在map集合中，就把元素值和元素下标存进map集合中。</p>
<p>代码如下：</p>
<pre><code class="java">public int[] twoSum(int[] nums, int target) {
    //map的key是nums[i]的值，value是下标i
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; nums.length; i++) {
        //获取结果值与nums[i]的差值
        int diff = target - nums[i];
        //如果包含的话，返回结果
        if (map.containsKey(diff)) {
            return new int[]{map.get(diff), i};
        } else {
            map.put(nums[i], i);
        }
    }
    return new int[]{};
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_2.png" srcset="/img/loading.gif" alt=""></p>
<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h1><p><strong>题目</strong>：</p>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p><strong>示例 1</strong>：</p>
<pre><code class="java">输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]</code></pre>
<p><strong>实例2</strong>：</p>
<pre><code class="java">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]</code></pre>
<h2 id="解法1-暴力解法-1"><a href="#解法1-暴力解法-1" class="headerlink" title="解法1(暴力解法)"></a>解法1(暴力解法)</h2><p>嵌套循环，比较两个数组中的元素，如果<code>nums1[i] == nums2[j]</code>的话，表示两个数组中都有的数字，则添加到HashSet(去重)，最后再把HashSet转换成数组输出。</p>
<p>代码如下：</p>
<pre><code class="java">public int[] intersection(int[] nums1, int[] nums2) {
    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
    for (int i = 0; i &lt; nums1.length; i++) {
        for (int j = 0; j &lt; nums2.length; j++) {
            if (nums1[i] == nums2[j]) {
                set.add(nums1[i]);
            }
        }
    }
    //HashSet转换成数组输出
    return set.stream().mapToInt(Integer::intValue).toArray();
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_3.png" srcset="/img/loading.gif" alt=""></p>
<p>经典的击败5%的用户，这是很正常的结果，因为使用了嵌套循环，而且还要把HashSet转换成数组，非常耗费性能，那么有没有优化空间呢，答案是肯定有的。</p>
<h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>如果要判断一个整数是否包含在无序的数组中，只能从头遍历到尾。既然数组在判断时需要从头到尾遍历这么耗费性能，那我们能不能换一种数据结构，做到快速判断是否包含在其中呢，答案就是哈希表。HashSet的底层就是一个哈希表，所以我们把nums1的数全部存入一个HashSet中，然后再遍历nums2，判断nums中的元素是否包含在HashSet中即可。</p>
<p>代码如下：</p>
<pre><code class="java">public int[] intersection(int[] nums1, int[] nums2) {
    Set&lt;Integer&gt; s1 = new HashSet&lt;&gt;();
    for (int n1 : nums1) {
        s1.add(n1);
    }
    Set&lt;Integer&gt; s2 = new HashSet&lt;&gt;();
    for (int n2 : nums2) {
        if (s1.contains(n2)) {
            s2.add(n2);
        }
    }
    //把set集合转成数组，返回
    int[] res = new int[s2.size()];
    int i = 0;
    for (Integer num : s2) {
        res[i] = num;
        i++;
    }
    return res;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_4.png" srcset="/img/loading.gif" alt=""></p>
<h1 id="350-两个数组的交集II"><a href="#350-两个数组的交集II" class="headerlink" title="350. 两个数组的交集II"></a>350. 两个数组的交集II</h1><p><strong>题目</strong>：</p>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p> <strong>示例1</strong>：</p>
<pre><code class="java">输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]</code></pre>
<p><strong>示例2</strong>：</p>
<pre><code class="java">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]</code></pre>
<p><strong>说明</strong>：</p>
<ul>
<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>这道题是上面那道题的变形，不同在于输出结果不需要去重。因此我们不能使用HashSet存储，而要改用HashMap，key是数组中的元素，value是元素的个数。在判断是否包含在其中的时候，还要判断个数是否大于0，每添加一个元素到结果集中就从HashMap中减去一个元素的个数。</p>
<p>最后把结果集转成数组返回即可。</p>
<p>代码如下：</p>
<pre><code class="java">public int[] intersect(int[] nums1, int[] nums2) {
    //key为num1的元素，value为元素出现的次数
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for (int num : nums1) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    for (int num : nums2) {
        if (map.containsKey(num) &amp;&amp; map.get(num) &gt; 0) {
            list.add(num);
            map.put(num, map.get(num) - 1);
        }
    }
    int[] res = new int[list.size()];
    for (int i = 0; i &lt; list.size(); i++) {
        res[i] = list.get(i);
    }
    return res;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_5.png" srcset="/img/loading.gif" alt=""></p>
<h1 id="771-宝石与石头"><a href="#771-宝石与石头" class="headerlink" title="771. 宝石与石头"></a>771. 宝石与石头</h1><p><strong>题目</strong>：</p>
<p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
<p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p>
<p><strong>示例1</strong>：</p>
<pre><code class="java">输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;
输出: 3</code></pre>
<p><strong>示例2</strong>：</p>
<pre><code class="java">输入: J = &quot;z&quot;, S = &quot;ZZ&quot;
输出: 0</code></pre>
<p><strong>注意:</strong></p>
<ul>
<li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li>
<li><code>J</code> 中的字符不重复。</li>
</ul>
<h2 id="解法1-HashSet"><a href="#解法1-HashSet" class="headerlink" title="解法1(HashSet)"></a>解法1(HashSet)</h2><p>这也是一个很典型的使用哈希表判断是否包含在集合中的题目。思路还是跟前面判断交集的一样，先把其中一个字符串遍历每个字符，放进HashSet，然后再遍历另一个字符串，判断是否包含在其中，包含则数量加一。最后返回结果。</p>
<p>代码如下：</p>
<pre><code class="java">public int numJewelsInStones(String jewels, String stones) {
    Set&lt;Character&gt; set = new HashSet&lt;&gt;();
    for (char j : jewels.toCharArray()) {
        set.add(j);
    }
    int count = 0;
    for (char s : stones.toCharArray()) {
        if(set.contains(s)){
            count++;
        }
    }
    return count;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_6.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="解法2-简化版哈希表"><a href="#解法2-简化版哈希表" class="headerlink" title="解法2(简化版哈希表)"></a>解法2(简化版哈希表)</h2><p>上面的解法执行用时2ms已经很快了，但是如果细心想一下，其实没必要使用HashSet集合，因为题目已经告诉我们只有字母，因此我们大可以使用一个数组模拟一个哈希表，优化一下。</p>
<p>代码如下：</p>
<pre><code class="java">public int numJewelsInStones(String jewels, String stones) {
    //大写字母&#39;A&#39;的ASCII码是65，小写字母&#39;z&#39;的ASCII码是122
    //所以使用一个长度58的数组已经足够
    boolean[] bools = new boolean[58];
    for (char j : jewels.toCharArray()) {
        //类似哈希映射，把对应下标标记为true
        bools[j - &#39;A&#39;] = true;
    }
    int count = 0;
    for (char s : stones.toCharArray()) {
        boolean bool = bools[s - &#39;A&#39;];
        //如果对应下标为true，则是宝石
        if (bool) {
            count++;
        }
    }
    return count;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_7.png" srcset="/img/loading.gif" alt=""></p>
<h1 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h1><p><strong>题目</strong>：</p>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p><strong>示例</strong>：</p>
<pre><code class="java">s = &quot;leetcode&quot;
返回 0

s = &quot;loveleetcode&quot;
返回 2</code></pre>
<p><strong>提示：</strong>你可以假定该字符串只包含小写字母。</p>
<h2 id="解法1-HashMap"><a href="#解法1-HashMap" class="headerlink" title="解法1(HashMap)"></a>解法1(HashMap)</h2><p>我们可以遍历两次，第一次遍历使用HashMap记录字符出现的次数，第二次遍历找出只出现一次的字符，返回它的索引。</p>
<p>代码如下：</p>
<pre><code class="java">public int firstUniqChar(String s) {
    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
    char[] chars = s.toCharArray();
    for (char c : chars) {
        map.put(c, map.getOrDefault(c, 0) + 1);
    }
    for (int i = 0; i &lt; chars.length; i++) {
        Integer count = map.get(chars[i]);
        if (count == 1) {
            return i;
        }
    }
    return -1;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_8.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="解法2-1"><a href="#解法2-1" class="headerlink" title="解法2"></a>解法2</h2><p>显然解法1耗时过长，不是很理想。怎么优化呢，要抓住题目给的提示，只包含小写字母。既然只含有小写字母，那么我们就可以简化哈希表，使用一个数组代替。</p>
<p>代码如下：</p>
<pre><code class="java">public int firstUniqChar(String s) {
    int[] hash = new int[26];
    char[] chars = s.toCharArray();
    for (char ch : chars) {
        hash[ch - &#39;a&#39;]++;
    }
    for (int i = 0; i &lt; chars.length; i++) {
        if (hash[chars[i] - &#39;a&#39;] == 1) {
            return i;
        }
    }
    return -1;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_9.png" srcset="/img/loading.gif" alt=""></p>
<h1 id="1365-有多少小于当前数字的数字"><a href="#1365-有多少小于当前数字的数字" class="headerlink" title="1365. 有多少小于当前数字的数字"></a>1365. 有多少小于当前数字的数字</h1><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。</p>
<p>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。</p>
<p>以数组形式返回答案。</p>
<p><strong>示例1</strong>：</p>
<pre><code class="java">输入：nums = [8,1,2,2,3]
输出：[4,0,1,1,3]
解释： 
对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
对于 nums[1]=1 不存在比它小的数字。
对于 nums[2]=2 存在一个比它小的数字：（1）。 
对于 nums[3]=2 存在一个比它小的数字：（1）。 
对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。</code></pre>
<p><strong>示例2</strong>：</p>
<pre><code class="java">输入：nums = [6,5,4,8]
输出：[2,1,0,3]</code></pre>
<p><strong>示例3</strong>：</p>
<pre><code class="java">输入：nums = [7,7,7,7]
输出：[0,0,0,0]</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 500</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h2 id="解法1-暴力法"><a href="#解法1-暴力法" class="headerlink" title="解法1(暴力法)"></a>解法1(暴力法)</h2><p>暴力法思路很简单粗暴，就是拿每一个元素跟数组中除了自身之外的每一个元素对比，只要元素大于数组中其他的数就计数加一，最后把计数收集起来就是结果。</p>
<p>代码如下：</p>
<pre><code class="java">public int[] smallerNumbersThanCurrent(int[] nums) {
    int[] res = new int[nums.length];
    int count = 0;
    for (int i = 0; i &lt; nums.length; i++) {
        int num = nums[i];
        for (int j = 0; j &lt; nums.length; j++) {
            //排除跟自己对比
            if (i == j) {
                continue;
            }
            //如果元素本身比其他数要大，计数+1
            if (num &gt; nums[j]) {
                count++;
            }
        }
        //收集计数
        res[i] = count;
        //计数器归0
        count = 0;
    }
    return res;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_10.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="解法2-2"><a href="#解法2-2" class="headerlink" title="解法2"></a>解法2</h2><p>明显解法1使用了嵌套循环，导致耗时太多，结果不太理想。优化代码前，我们可以先看看提示<code>0 &lt;= nums[i] &lt;= 100</code>，也就是说元素的值在0到100范围内。我们可以使用一个101长度的数组统计元素出现的次数，当我们要计算有多少少于该元素的数字时，就只需要该元素前面所有元素出现的次数即可。</p>
<p>代码如下：</p>
<pre><code class="java">public int[] smallerNumbersThanCurrent(int[] nums) {
    int[] hash = new int[101];
    //使用数组统计数字出现的次数
    for (int num : nums) {
        //元素值相当于下标，类似于哈希映射
        hash[num]++;
    }
    int[] res = new int[nums.length];
    for (int i = 0; i &lt; nums.length; i++) {
        //计数
        int count = 0;
        //统计在该元素前的所有元素(也就是小于该元素的数字)出现的次数
        for (int j = nums[i] - 1; j &gt;= 0; j--) {
            //计数器累加，j就是统计哈希表的下标
            count += hash[j];
        }
        res[i] = count;
    }
    return res;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_11.png" srcset="/img/loading.gif" alt=""></p>
<h1 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389. 找不同"></a>389. 找不同</h1><p>题目：</p>
<p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，它们只包含小写字母。</p>
<p>字符串 <strong>t</strong> 由字符串 <strong>s</strong> 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 <strong><em>t</em></strong> 中被添加的字母。</p>
<p><strong>示例1</strong>：</p>
<pre><code class="java">输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;
输出：&quot;e&quot;
解释：&#39;e&#39; 是那个被添加的字母。</code></pre>
<p><strong>示例2</strong>：</p>
<pre><code class="java">输入：s = &quot;&quot;, t = &quot;y&quot;
输出：&quot;y&quot;</code></pre>
<p><strong>示例3</strong>：</p>
<pre><code class="java">输入：s = &quot;a&quot;, t = &quot;aa&quot;
输出：&quot;a&quot;</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 1000</code></li>
<li><code>t.length == s.length + 1</code></li>
<li><code>s</code> 和 <code>t</code> 只包含小写字母</li>
</ul>
<h2 id="解法1-HashMap-1"><a href="#解法1-HashMap-1" class="headerlink" title="解法1(HashMap)"></a>解法1(HashMap)</h2><p>使用HashMap记录字符串s中每一个字符出现的次数，然后遍历字符串t，通过字符获取字符出现的次数，次数大于0就减一，次数等于0则表示是添加的字母，返回该字母。</p>
<p>代码如下：</p>
<pre><code class="java">public char findTheDifference(String s, String t) {
    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
    for (char c : s.toCharArray()) {
        map.put(c, map.getOrDefault(c, 0) + 1);
    }
    for (char c : t.toCharArray()) {
        Integer count = map.getOrDefault(c, 0);
        if (count &gt; 0) {
            map.put(c, count - 1);
        } else {
            return c;
        }
    }
    return &#39; &#39;;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_12.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="解法2-3"><a href="#解法2-3" class="headerlink" title="解法2"></a>解法2</h2><p>关键是抓住提示，字符串s和t只包含小写字母，所以我们还是可以使用数组简化HashMap。小写字母只有26个，所以我们创建一个26长度的int数组，统计s字符串中字符出现的次数。其他逻辑和解法1一样即可。</p>
<p>代码如下：</p>
<pre><code class="java">public char findTheDifference(String s, String t) {
    int[] hash = new int[26];
    for (char c : s.toCharArray()) {
        hash[c - &#39;a&#39;]++;
    }
    for (char c : t.toCharArray()) {
        if (hash[c - &#39;a&#39;] &gt; 0) {
            hash[c - &#39;a&#39;]--;
        } else {
            return c;
        }
    }
    return &#39; &#39;;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_13.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="解法3-排序法"><a href="#解法3-排序法" class="headerlink" title="解法3(排序法)"></a>解法3(排序法)</h2><p>把两个字符串转成字符数组，然后对两个数组排序。对排序好的数组进行遍历对比，只要出现不相等的字符，就是要返回的字符。</p>
<p>代码如下：</p>
<pre><code class="java">public char findTheDifference(String s, String t) {
    char[] sChars = s.toCharArray();
    char[] tChars = t.toCharArray();
    Arrays.sort(sChars);
    Arrays.sort(tChars);
    int length = Math.min(sChars.length, tChars.length);
    int i = 0;
    while (i &lt; length) {
        char sChar = sChars[i];
        char tChar = tChars[i];
        if (sChar != tChar) {
            return tChar;
        }
        i++;
    }
    return tChars[tChars.length - 1];
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_14.png" srcset="/img/loading.gif" alt=""></p>
<p>效率虽然没有哈希表快，但是也是一种不错的解题思路。</p>
<h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h1><p><strong>题目</strong>：</p>
<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p>
<p><strong>示例1</strong>：</p>
<pre><code class="java">输入: [1,2,3,1]
输出: true</code></pre>
<p><strong>示例2</strong>：</p>
<pre><code class="java">输入: [1,2,3,4]
输出: false</code></pre>
<p><strong>示例3</strong>：</p>
<pre><code class="java">输入: [1,1,1,3,3,4,3,2,4,2]
输出: true</code></pre>
<h2 id="解法1-1"><a href="#解法1-1" class="headerlink" title="解法1"></a>解法1</h2><p>假如使用嵌套循环，是会超出时间限制的，所以不能考虑用暴力法。一般来说，判断一个元素是否包含在其中肯定是HashSet最快，所以我们可以用HashSet容纳元素，然后判断一下是否包含，包含则返回true，不包含则继续装入，如果遍历结束都没有返回true，则返回false。</p>
<p>代码如下：</p>
<pre><code class="java">public boolean containsDuplicate(int[] nums) {
    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
    for (int num : nums) {
        if (!set.contains(num)) {
            set.add(num);
        } else {
            return true;
        }
    }
    return false;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_15.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="解法2-4"><a href="#解法2-4" class="headerlink" title="解法2"></a>解法2</h2><p>其实HashSet本身就有去重的效果，我们把所有的元素装入到HashSet中，如果有重复的元素则长度和原来的长度不相等。</p>
<p>代码如下：</p>
<pre><code class="java">public boolean containsDuplicate(int[] nums) {
    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
    for (int num : nums) {
        set.add(num);
    }
    return set.size() != nums.length;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_16.png" srcset="/img/loading.gif" alt=""></p>
<h1 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h1><p><strong>题目</strong>：</p>
<p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p>
<p>注意:<br>假设字符串的长度不会超过 1010。</p>
<p><strong>示例1</strong>：</p>
<pre><code class="java">输入:
&quot;abccccdd&quot;

输出:
7

解释:
我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</code></pre>
<h2 id="解法1-2"><a href="#解法1-2" class="headerlink" title="解法1"></a>解法1</h2><p>回文字符串就是从左往右读和从右往左读都是一样的字符串，也就是左右对称的字符串。要做到左右对称，其实很简单，只要是偶数个相同的字符就可以，比如有两个”a”，左右两端各放一个就对称了。</p>
<p>所以我们用一个HashMap来统计字符出现的次数，然后遍历，判断如果是偶数就累加字母出现的次数，如果是奇数就减一让他变成偶数再累加，最后就得到答案res，但是还没大功告成，因为中点插进一个字母，他还是对称的，所以最后要判断一下累加的长度是否等于原来的字符串长度，再决定要不要再加上一个字母的长度。</p>
<p>代码如下：</p>
<pre><code class="java">public int longestPalindrome(String s) {
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
    //统计字符出现的次数
    for (char c : s.toCharArray()) {
        map.put(c, map.getOrDefault(c, 0) + 1);
    }
    int res = 0;
    for (Character key : map.keySet()) {
        Integer val = map.get(key);
        //如果是奇数次，减一成为偶数，再累加
        if (val % 2 != 0) {
            res += (val - 1);
        } else {
            //如果是偶数次，直接累加
            res += val;
        }
    }
    int length = s.length();
    return res == length ? length : (res + 1);
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_17.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="解法2-优化"><a href="#解法2-优化" class="headerlink" title="解法2(优化)"></a>解法2(优化)</h2><p>题目说明是包含大写字母和小写字母，所以我们还是可以使用数组来代替HashMap，以此提高代码的执行效率。我们只需要一个长度为128的数组来统计字符出现的次数，代替HashMap。其他逻辑不变即可。</p>
<p>代码如下：</p>
<pre><code class="java">public int longestPalindrome(String s) {
    int[] hash = new int[128];
    for (char c : s.toCharArray()) {
        hash[c - &#39;A&#39;]++;
    }
    int res = 0;
    for (int count : hash) {
        if (count % 2 != 0) {
            res += (count - 1);
        } else {
            res += count;
        }
    }
    int length = s.length();
    return res == length ? length : (res + 1);
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_18.png" srcset="/img/loading.gif" alt=""></p>
<h1 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h1><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p>
<p><strong>示例1</strong>：</p>
<pre><code class="java">输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</code></pre>
<p><strong>示例2</strong>：</p>
<pre><code class="java">输入：n = 0
输出：0</code></pre>
<p><strong>示例3</strong>：</p>
<pre><code class="java">输入：n = 1
输出：0</code></pre>
<h2 id="解法1-暴力法-1"><a href="#解法1-暴力法-1" class="headerlink" title="解法1(暴力法)"></a>解法1(暴力法)</h2><p>其实这是一个很经典的数学问题，比如要判断223是不是质数，最粗暴的方法就是，223对(2到222)进行取余，每次取余的余数都不为0，那就是质数。但是如果n的值非常大，那就会超过时间限制。</p>
<p>代码如下：</p>
<pre><code class="java">public int countPrimes(int n) {
    int count = 0;
    for (int i = 0; i &lt; n; i++) {
        //判断是否是质数，是质数则计数+1
        if (isPrimes(i)) {
            count++;
        }
    }
    return count;
}

//判断一个数是否是质数
private boolean isPrimes(int num) {
    if (num &lt;= 1) {
        return false;
    }
    if (num == 2) {
        return true;
    }
    //循环取余，只要有一次返回余数为0则是非质数
    for (int i = 2; i &lt; num; i++) {
        if (num % i == 0) {
            return false;
        }
    }
    //如果余数都不为0则是质数
    return true;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_19.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="解法2-5"><a href="#解法2-5" class="headerlink" title="解法2"></a>解法2</h2><p>不如反向思维一下，我们使用一个boolean[]数组记录每个数是否是质数，然后从2开始找出非质数都标记成true，标记完成之后就可以统计质数的数量是多少了。</p>
<pre><code class="java">public int countPrimes(int n) {
    boolean[] booleans = new boolean[n];
    for (int i = 2; i &lt; n; i++) {
        for (int j = 2; j * i &lt; n; j++) {
            booleans[i * j] = true;
        }
    }
    int count = 0;
    //从2开始统计
    for (int i = 2; i &lt; booleans.length; i++) {
        if (!booleans[i]) {
            count++;
        }
    }
    return count;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_20.png" srcset="/img/loading.gif" alt=""></p>
<p>其实上面的代码还可以优化一下，不需要遍历两次，把统计和标记放在一个循环即可。代码如下：</p>
<pre><code class="java">public int countPrimes(int n) {
    int count = 0;
    boolean[] booleans = new boolean[n];
    for (int i = 2; i &lt; n; i++) {
        if (!booleans[i]) {
            for (int j = 2; j * i &lt; n; j++) {
                booleans[i * j] = true;
            }
            count++;
        }
    }
    return count;
}</code></pre>
<p>提交代码，结果如下：</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_21.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><p>万万没想到，这个题目还有0ms的题解！这是我在提交记录中一不留神看到的，截图给大伙看看。</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_22.png" srcset="/img/loading.gif" alt=""></p>
<p>然后我点开代码一看，好家伙，震惊我一整年！</p>
<pre><code class="java">public int countPrimes(int n) {
    switch (n) {
        case 0: return 0;
        case 1: return 0;
        case 2: return 0;
        case 3: return 1;
        case 4: return 2;
        case 5: return 2;
        case 6: return 3;
        case 7: return 3;
        case 8: return 4;
        case 9: return 4;
        case 10: return 4;
        case 11: return 4;
        case 12: return 5;
        case 13: return 5;
        case 14: return 6;
        case 15: return 6;
        case 10000: return 1229;
        case 499979: return 41537;
        case 999983: return 78497;
        case 1500000: return 114155;
        case 5000000: return 348513;
        default: return -1;
    }
}</code></pre>
<p>我当然不相信这是能通过的啦，于是复制了这段代码提交试试，没想到还真行呀！</p>
<p><img src="https://static.lovebilibili.com/leetcode_hash_23.png" srcset="/img/loading.gif" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>哈希表的算法题中有很多问题其实在实际项目中也会遇到，比如找出两个集合的交集，找出集合中重复的元素等等，所以做一做算法题对我们的编码能力会有很大的提升。</p>
<p>这篇文章讲到这里了，感谢大家的阅读，希望看完这篇文章能有所收获！</p>
<p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p>
<p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p>
<p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p>
<blockquote>
<p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p>
</blockquote>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95">算法</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "经典算法题分享(哈希表)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
