<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>重温并发知识从ThreadLocal开始</title>
    <link href="/2021/09/25/%E9%87%8D%E6%B8%A9%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BB%8EThreadLocal%E5%BC%80%E5%A7%8B/"/>
    <url>/2021/09/25/%E9%87%8D%E6%B8%A9%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BB%8EThreadLocal%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h1><p>ThreadLocal提供线程的局部变量，这种变量与普通变量的区别在于，每个访问这种变量的线程都有自己的、独立的变量副本。用于解决多线程间的数据隔离问题。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>其实ThreadLocal在很多开源框架中都有应用：</p><ul><li>Spring中的事务管理器，比如TransactionSynchronizationManager等。</li><li>Mybatis中的ErrorContext类，使用ThreadLocal实现线程安全的单例。</li><li>存储session中的一些参数，比如用户信息等。</li></ul><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>ThreadLocal提供了4个常用方法：</p><ul><li><p><code>set()</code>方法，设置当前线程中变量的副本。</p></li><li><p><code>get()</code>方法，获取 <code>ThreadLocal</code>在当前线程中保存的变量副本。</p></li><li><p><code>remove()</code>方法，清空当前线程中变量的副本。</p></li><li><p><code>initialValue()</code>是一个 <code>protected</code>方法，一般是用来重写的，如果在没有set的时候就调用 <code>get</code>，会调用 <code>initialValue</code>方法初始化内容。</p></li></ul><pre><code class="java">private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;(){    //重写此方法，初始化ThreadLocal的value    @Override    protected SimpleDateFormat initialValue() {        return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    }};</code></pre><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>那么怎么实现数据隔离的，我们从源码的角度进行分析。</p><p>我们先看ThreadLocal类的get()方法。</p><pre><code class="java">public T get() {    Thread t = Thread.currentThread();    //通过当前线程获取ThreadLocalMap    ThreadLocalMap map = getMap(t);    if (map != null) {        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) {            @SuppressWarnings(&quot;unchecked&quot;)            T result = (T)e.value;            return result;        }    }    return setInitialValue();}private T setInitialValue() {    T value = initialValue();    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);    return value;}//返回Thread实例的成员变量threadLocalsThreadLocalMap getMap(Thread t) {    return t.threadLocals;}//给Thread实例的成员变量threadLocals赋值void createMap(Thread t, T firstValue) {    t.threadLocals = new ThreadLocalMap(this, firstValue);}</code></pre><p>从源码可以看出，数据是存在于Thread类的成员变量threadLocals</p><pre><code class="java">/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;</code></pre><p>上面写了一段注释，翻译过来就是，关于该线程的ThreadLocal的值，由ThreadLocal类进行维护。</p><p>所以很清楚了，数据隔离的实现是因为ThreadLocal类操作的是Thread的成员变量threadLocals。每个线程Thread都有自己的threadLocals，从而互相不影响。</p><p>threadLocals这个成员变量的本质又是ThreadLocalMap类，它是ThreadLocal的内部类，下面我们研究一下这个内部类的数据结构。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>先看一下源码：</p><pre><code class="java">static class ThreadLocalMap {    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {        /** The value associated with this ThreadLocal. */        Object value;        Entry(ThreadLocal&lt;?&gt; k, Object v) {            super(k);            value = v;        }    }    //初始化容量    private static final int INITIAL_CAPACITY = 16;    //散列表    private Entry[] table;    //有效数量    private int size = 0;    //负载因子    private int threshold;    private void setThreshold(int len) {        threshold = len * 2 / 3;    }    //构造器    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {        table = new Entry[INITIAL_CAPACITY];        int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);        table[i] = new Entry(firstKey, firstValue);        size = 1;        setThreshold(INITIAL_CAPACITY);    }}</code></pre><p>这一看跟HashMap还有几分相似，但是哈希冲突的处理方式，ThreadLocalMap采用的是开放寻址法(自行百度一下，这里不多解释了)，大概长这个样子：</p><p><img src="https://static.lovebilibili.com/ThreadLocal_01.png" srcset="/img/loading.gif" alt=""></p><p>所以这里可以看出ThreadLocal的引用可以定位到ThreadLocalMap里散列表table[]里的值。</p><h1 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h1><p><img src="https://static.lovebilibili.com/ThreadLocal_02.png" srcset="/img/loading.gif" alt=""></p><p>我们从源码中可以看到Entry是继承WeakReference类，key是弱引用，value是强引用。为什么要设计成弱引用？不如反过来想，如果设置成强引用会有什么效果。</p><p>如果Entry对象的Key每个都强引用到ThreadLocal对象的话，那么这个ThreadLocal对象就会因为和Entry对象存在强引用关联而无法被GC回收，造成内存泄漏，除非线程结束后，线程被回收了，ThreadLocalMap才会跟着回收。</p><p>当作为Key的ThreadLocal对象设置成弱引用对象后，在系统GC的时候，ThreadLocal对象就会被回收。</p><p>但是这样就能防止内存泄漏吗？</p><p>其实不然！因为Value还是强引用对象，当Key被回收后，key变成了null值，而Value依然存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，而这块value也永远不会被访问到了，最终造成内存泄漏。</p><p>所以在设计ThreadLocalMap时就考虑到这个问题，在ThreadLocal的<code>get()、set()、remove()</code>的时候都会清除线程ThreadLocalMap里所有key为<code>null</code>的value。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>其实ThreadLocal并没有解决多线程间数据共享的问题，而是使数据在不同线程有不同的副本，那么就不需要解决共享数据的问题。</p></li><li><p>每个线程持有一个ThreadLocalMap对象，该ThreadLocalMap对象只会被持有它的线程访问，所以不存在线程安全问题。</p></li><li><p>ThreadLocalMap的数据结构类似HashMap，里面由Entry[]数组、size、负载因子等组成，采用开放寻址法解决哈希冲突。</p></li><li><p>ThreadLocalMap的Entry对ThreadLocal对象是弱引用，GC回收后，会产生一些key为null的value无法被访问，也无法被回收，最终导致内存泄漏。预防措施是调用ThreadLocal的remove()方法，清除掉ThreadLocalMap里面key为null的value。</p></li></ul><p>非常感谢你的阅读，希望这篇文章能给到你帮助和启发。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BaseMapper源码分析</title>
    <link href="/2021/09/25/BaseMapper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/09/25/BaseMapper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="抛出疑问"><a href="#抛出疑问" class="headerlink" title="抛出疑问"></a>抛出疑问</h1><p>Mybatis-plus的确能让我们写少很多重复代码，非常好用。那么其中最方便的就是Mapper接口继承<code>BaseMapper</code>就能获得增删改查的这个功能。那么这个功能的底层代码，究竟是怎么实现的呢？</p><h1 id="原生Mybatis配置的原理"><a href="#原生Mybatis配置的原理" class="headerlink" title="原生Mybatis配置的原理"></a>原生Mybatis配置的原理</h1><p>毕竟Mybatis-plus是Mybatis的加强，所以Mybatis-plus肯定是基于Mybatis原来的机制来扩展的，沿着这个思路，我们先搞清楚一个问题，就是<code>原生的mapper.xml文件最后是怎么跟对应的Mapper接口产生联系的</code>。</p><p>既然是配置，那么在Mybatis里肯定有对应的配置类，这个类就是<code>MappedStatement</code>。最终在<code>Configuration</code>类中把<code>MappedStatement</code>对象添加进<code>mappedStatements</code>集合中进行管理。源码如下：</p><pre><code class="java">public class Configuration {    protected final Map&lt;String, MappedStatement&gt; mappedStatements = new StrictMap&lt;MappedStatement&gt;(&quot;Mapped Statements collection&quot;);      public void addMappedStatement(MappedStatement ms) {        mappedStatements.put(ms.getId(), ms);    }}</code></pre><p>假如有个mapper.xml文件定义如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.yehongzhi.mydemo.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;getUserList&quot; resultType=&quot;com.yehongzhi.mydemo.model.User&quot;&gt;        select * from user    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>我们用debug模式来验证一下：</p><p><img src="https://static.lovebilibili.com/mybatis_plus_source_1.jpg" srcset="/img/loading.gif" alt=""></p><p>由此可以看出，Mybatis底层在解析Mapper.xml文件最后是转成一个<code>MappedStatement</code>对象进行管理。跟着这个思路，我们能不能根据<strong>特定的规律</strong>创建<code>MappedStatement</code>对象放进<code>mappedStatements</code>集合中，那不就能实现Mybatis-plus的<code>BaseMapper</code>的功能了吗！</p><h1 id="Mybatis-plus源码分析"><a href="#Mybatis-plus源码分析" class="headerlink" title="Mybatis-plus源码分析"></a>Mybatis-plus源码分析</h1><p>首先找到<code>MybatisPlusAutoConfiguration</code>配置类，会创建<strong>MybatisSqlSessionFactoryBean</strong>。</p><p><img src="https://static.lovebilibili.com/mybatis-plus_source_02.png" srcset="/img/loading.gif" alt=""></p><p>并设置<code>MybatisConfiguration</code>作为配置类。</p><p><img src="https://static.lovebilibili.com/mybatis-plus_source_03.png" srcset="/img/loading.gif" alt=""></p><p>这个<code>MybatisConfiguration</code>是很重要的类，里面会初始化一个<code>mybatisMapperRegistry</code>，后面有用。</p><pre><code class="xml">public class MybatisConfiguration extends Configuration {    /**    * Mapper 注册    */    protected final MybatisMapperRegistry mybatisMapperRegistry = new MybatisMapperRegistry(this);}</code></pre><p>当创建<code>MybatisSqlSessionFactoryBean</code>时，会调用<code>afterPropertiesSet()</code>方法创建<code>sqlSessionFactory</code>。</p><pre><code class="java">@Overridepublic void afterPropertiesSet() throws Exception {    notNull(dataSource, &quot;Property &#39;dataSource&#39; is required&quot;);    state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null),          &quot;Property &#39;configuration&#39; and &#39;configLocation&#39; can not specified with together&quot;);    this.sqlSessionFactory = buildSqlSessionFactory();}</code></pre><p>然后<code>buildSqlSessionFactory()</code>方法的主要内容是解析mapper的xml文件。</p><p><img src="https://static.lovebilibili.com/mybatis-plus_source_04.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/mybatis-plus_source_05.png" srcset="/img/loading.gif" alt=""></p><p>然后继续深入，看<code>bindMapperForNamespace()</code>方法。</p><p><img src="https://static.lovebilibili.com/mybatis-plus_source_06.png" srcset="/img/loading.gif" alt=""></p><p>接着用<code>MapperAnnotationBuilder</code>类进行解析。</p><p><img src="https://static.lovebilibili.com/mybatis-plus_source_08.png" srcset="/img/loading.gif" alt=""></p><p>接着在parse()方法里进行基本的SQL注入：</p><p><img src="https://static.lovebilibili.com/mybatis-plus_source_09.png" srcset="/img/loading.gif" alt=""></p><p>关键就在这个SQL注入器里。</p><p><img src="https://static.lovebilibili.com/mybatis-plus_source_10.png" srcset="/img/loading.gif" alt=""></p><p>所以关键在于<code>AbstractMethod</code>，这里用了模板模式。</p><pre><code class="java">public abstract class AbstractMethod implements Constants {    protected Configuration configuration;    protected LanguageDriver languageDriver;    protected MapperBuilderAssistant builderAssistant;    /**     * 注入自定义方法     */    public void inject(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo) {        this.configuration = builderAssistant.getConfiguration();        this.builderAssistant = builderAssistant;        this.languageDriver = configuration.getDefaultScriptingLanguageInstance();        /* 注入自定义方法 */        injectMappedStatement(mapperClass, modelClass, tableInfo);    }    /**     * 注入自定义 MappedStatement     *     * @param mapperClass mapper 接口     * @param modelClass  mapper 泛型     * @param tableInfo   数据库表反射信息     * @return MappedStatement     */    public abstract MappedStatement injectMappedStatement(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo);}</code></pre><p>利用模板模式，子类只需要重写<code>injectMappedStatement()</code>方法，上面初始化的部分都可以共用。<code>AbstractMethod</code>的子类有很多，我们选个有代表性的看一下，就可以推断其他的用途，比如Insert类。</p><p><img src="https://static.lovebilibili.com/mybatis-plus_source_11.png" srcset="/img/loading.gif" alt=""></p><p>由此可看出，BaseMapper里的语句信息模板，来自于枚举<code>SqlMethod</code>。</p><p><img src="https://static.lovebilibili.com/mybatis-plus_source_12.png" srcset="/img/loading.gif" alt=""></p><p>最终就是转成<code>MappedStatement</code>对象，然后添加注册，于是乎就有了这些CRUD操作的方法。</p><p><img src="https://static.lovebilibili.com/mybatis-plus_source_13.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下加载BaseMapper的过程：</p><ol><li>初始化<code>MybatisConfiguration</code>和<code>mybatisMapperRegistry</code>。</li><li>解析Mapper类，获取<strong>AbstractMethod</strong>集合。</li><li>遍历<strong>AbstractMethod</strong>集合，然后调用各自实现的<code>injectMappedStatement()</code>方法，注入SQL。</li><li>添加注册<code>MappedStatement</code>对象。</li></ol><p>非常感谢你的阅读，希望这篇文章能给到你帮助和启发。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-plus，真香！</title>
    <link href="/2021/07/06/Mybatis-plus%EF%BC%8C%E7%9C%9F%E9%A6%99%EF%BC%81/"/>
    <url>/2021/07/06/Mybatis-plus%EF%BC%8C%E7%9C%9F%E9%A6%99%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>mybatis相信都不陌生，目前互联网公司大部分都使用mybatis作为持久层框架，无他，因为可以直接在xml文件中编写SQL语句操作数据库，灵活。但是我们在使用的时候，也会发现有很多增删改查的SQL是每个表都会有的基本操作，如果每个表都写一套增删改查的SQL显然是非常耗时耗力的。</p><p>于是乎，就有了mybatis-plus这个框架。正如官网所说，mybatis-plus是<code>为简化开发而生</code>。</p><p>mybatis-plus有以下特点：</p><ul><li>只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑。</li><li>只需简单配置，即可快速进行单表CRUD操作，节省大量时间。</li><li>代码生成，物理分页，性能分析等功能一应俱全。</li></ul><h1 id="一、整合mybatis-plus"><a href="#一、整合mybatis-plus" class="headerlink" title="一、整合mybatis-plus"></a>一、整合mybatis-plus</h1><p>这里用的是SpringBoot2.5.2做演示。首先导入依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 引入 mybatis-plus --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后在application.properties文件配置数据库信息：</p><pre><code class="properties">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/user?createDatabaseIfNotExist=truespring.datasource.username=rootspring.datasource.password=root123456#mapper.xml文件路径地址mybatis-plus.mapper-locations=classpath:mapper/*Mapper.xml</code></pre><p>在启动类加上扫描注解：</p><pre><code class="java">@SpringBootApplication@MapperScan(basePackages = &quot;com.yehongzhi.mydemo.mapper&quot;)public class MydemoApplication {    public static void main(String[] args) {        SpringApplication.run(MydemoApplication.class, args);    }}</code></pre><p>其实这样就完成了，但是我们要建个表进行测试。</p><pre><code class="sql">CREATE TABLE `user` (  `id` char(36) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;ID&#39;,  `name` varchar(255) DEFAULT &#39;&#39; COMMENT &#39;姓名&#39;,  `age` int(3) DEFAULT NULL COMMENT &#39;年龄&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 初始化4条数据INSERT INTO `user`.`user` (`id`, `name`, `age`) VALUES (&#39;1345fc0985b111eba0e488d7f66fdab8&#39;, &#39;观辰&#39;, &#39;20&#39;);INSERT INTO `user`.`user` (`id`, `name`, `age`) VALUES (&#39;d47561e885b011eba0e488d7f66fdab8&#39;, &#39;姚大秋&#39;, &#39;30&#39;);INSERT INTO `user`.`user` (`id`, `name`, `age`) VALUES (&#39;ef2741fe87f011eba0e488d7f66fdab8&#39;, &#39;周星驰&#39;, &#39;60&#39;);INSERT INTO `user`.`user` (`id`, `name`, `age`) VALUES (&#39;ff784f6b85b011eba0e488d7f66fdab8&#39;, &#39;李嘉晟&#39;, &#39;33&#39;);</code></pre><p>建了表之后，再创建一个User实体类对应：</p><pre><code class="java">//表名@TableName(&quot;user&quot;)public class User {    //主键    @TableId(type = IdType.UUID)    private String id;    //姓名    private String name;    //年龄    private Integer age;    //getter、setter方法}</code></pre><p>接着创建UserMapper接口类,，然后继承BaseMapper：</p><pre><code class="java">@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; {}</code></pre><p>创建一个UserMapper.xml与UserMapper对应：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.yehongzhi.mydemo.mapper.UserMapper&quot;&gt;&lt;/mapper&gt;</code></pre><p>最后我们写一个UserService接口，查询user表：</p><pre><code class="java">@Servicepublic class UserServiceImpl implements UserService {    @Resource    private UserMapper userMapper;    @Override    public List&lt;User&gt; getList() {        return userMapper.selectList(null);    }}</code></pre><p>启动项目，测试是没问题的：</p><p><img src="https://static.lovebilibili.com/mybatis-plus_01.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、CRUD操作"><a href="#二、CRUD操作" class="headerlink" title="二、CRUD操作"></a>二、CRUD操作</h1><p>整合完了之后，按照mybatis-plus的官方说明，是有简单的单表CRUD操作功能。</p><p>这些单表的CRUD操作其实都放在BaseMapper里面了，所以当我们继承了BaseMapper类之后，就会获得mybatis-plus的增强特性，其中就包括单表的CRUD操作。</p><h2 id="1、insert操作"><a href="#1、insert操作" class="headerlink" title="1、insert操作"></a>1、insert操作</h2><p>BaseMapper直接提供一个insert()方法，传一个实体类。</p><pre><code class="java">@Servicepublic class UserServiceImpl implements UserService {    @Resource    private UserMapper userMapper;    @Override    public int insertOne(User user) {        return userMapper.insert(user);    }}</code></pre><p>接着在Controller调用，因为在User类上面贴了注解<code>@TableId</code>，所以会自动生成ID。</p><pre><code class="java">@TableName(&quot;user&quot;)public class User {    @TableId(type = IdType.UUID)    private String id;    //省略...}</code></pre><p>Controller层代码：</p><pre><code class="java">@RequestMapping(&quot;/insert&quot;)public String insertUser(@RequestParam(name = &quot;name&quot;) String name,                         @RequestParam(name = &quot;age&quot;) Integer age) {    User user = new User();    user.setName(name);    user.setAge(age);    //在实体类使用了@TableId注解，ID会自动生成    int i = userService.insertOne(user);    return i == 1 ? &quot;success&quot; : &quot;fail&quot;;}</code></pre><h2 id="2、update操作"><a href="#2、update操作" class="headerlink" title="2、update操作"></a>2、update操作</h2><p>BaseMapper直接提供一个updateById()方法，传一个实体类。</p><pre><code class="java">@Overridepublic int updateOne(User user) {    return userMapper.updateById(user);}</code></pre><p>Controller层代码：</p><pre><code class="java">@RequestMapping(&quot;/update&quot;)public String updateUser(@RequestParam(name = &quot;id&quot;) String id,                         @RequestParam(name = &quot;name&quot;,required = false) String name,                         @RequestParam(name = &quot;age&quot;,required = false) Integer age) {    User user = new User();    user.setId(id);    user.setName(name);    user.setAge(age);    int i = userService.updateOne(user);    return i == 1 ? &quot;success&quot; : &quot;fail&quot;;}</code></pre><h2 id="3、delete操作"><a href="#3、delete操作" class="headerlink" title="3、delete操作"></a>3、delete操作</h2><p>BaseMapper直接提供一个deleteById()方法，传主键值。</p><pre><code class="java">@Overridepublic int deleteOne(String id) {    return userMapper.deleteById(id);}</code></pre><p>Controller层代码：</p><pre><code class="java">@RequestMapping(&quot;/delete&quot;)public String deleteUser(@RequestParam(name = &quot;id&quot;) String id) {    int i = userService.deleteOne(id);    return i == 1 ? &quot;success&quot; : &quot;fail&quot;;}</code></pre><p>除此之外，还有批量删除deleteBatchIds方法，传主键值的集合：</p><pre><code class="java">@Overridepublic int deleteBatch(List&lt;String&gt; ids){    return userMapper.deleteBatchIds(ids);}</code></pre><p>Controller层代码：</p><pre><code class="java">@RequestMapping(&quot;/deleteBatch&quot;)public String deleteBatchUser(@RequestParam(name = &quot;ids&quot;) String ids) {    List&lt;String&gt; list = Arrays.asList(ids.split(&quot;,&quot;));    int i = userService.deleteBatch(list);    return i == list.size() ? &quot;success&quot; : &quot;fail&quot;;}</code></pre><h1 id="三、条件构造器-Wrapper"><a href="#三、条件构造器-Wrapper" class="headerlink" title="三、条件构造器(Wrapper)"></a>三、条件构造器(Wrapper)</h1><p>条件构造器在Mybatis-plus各种方法中都有出现，比如：</p><pre><code class="java">Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; updateWrapper);int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);</code></pre><p>Wrapper通俗点理解就是定义where语句后面的查询条件，是Mybatis-Plus里功能比较强大的工具。Wrapper是一个抽象类，下面有很多子类，我们先看个类图混个眼熟。</p><p><img src="https://static.lovebilibili.com/mybatis-plus_02.png" srcset="/img/loading.gif" alt=""></p><p>常用的子类实现有四个，分别是：</p><ul><li>QueryWrapper</li><li>UpdateWrapper</li><li>LambdaQueryWrapper</li><li>LambdaUpdateWrapper</li></ul><h2 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h2><p>主要用于生成where条件，举个例子，我们用name查询user表：</p><pre><code class="java">public List&lt;User&gt; queryUserByName(String name) {    //相当于：SELECT * FROM user WHERE name = ?    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    //eq()表示相等    queryWrapper.eq(&quot;name&quot;, name);    return userMapper.selectList(queryWrapper);}</code></pre><p>我们看日志打印：</p><pre><code class="java">==&gt;  Preparing: SELECT id,name,age FROM user WHERE name = ?==&gt; Parameters: 姚大秋(String)&lt;==    Columns: id, name, age&lt;==        Row: d47561e885b011eba0e488d7f66fdab8, 姚大秋, 30&lt;==      Total: 1</code></pre><p>假如我们要like查询，可以这样写：</p><pre><code class="java">public List&lt;User&gt; queryUserLikeName(String name) {    //相当于：SELECT * FROM user WHERE name like %#{name}%    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.like(&quot;name&quot;,name);    return userMapper.selectList(queryWrapper);}</code></pre><p>假如要查询年龄大于30岁，可以这样：</p><pre><code class="java">public List&lt;User&gt; queryUserGtByAge(int age) {    //相当于：SELECT * FROM user WHERE age &gt; ?    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.gt(&quot;age&quot;, age);    //小于是lt()    //大于等于是ge()    //小于等于是le()    //范围的话，则使用between()    return userMapper.selectList(queryWrapper);}</code></pre><p>如果要查询某个字段不为空，可以这样：</p><pre><code class="java">public List&lt;User&gt; queryUserByNameNotNull() {    //相当于：SELECT * FROM user WHERE name IS NOT NULL    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.isNotNull(&quot;name&quot;);    //查询某个字段为空，则使用isNull()    return userMapper.selectList(queryWrapper);}</code></pre><p>如果使用IN查询，可以这样：</p><pre><code class="java">public List&lt;User&gt; queryUserByIds(List&lt;String&gt; ids) {    //相当于：SELECT * FROM user WHERE name IN (&#39;id1&#39;,&#39;id2&#39;);    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.in(&quot;id&quot;, ids);    //相反也提供了notIn()方法    return userMapper.selectList(queryWrapper);}</code></pre><p>如果需要排序，可以这样写：</p><pre><code class="java">public List&lt;User&gt; queryUserOrderByAge() {    //相当于：SELECT * FROM user ORDER BY age ASC    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.orderByAsc(&quot;age&quot;);    //相反的，如果降序则使用orderByDesc()方法    return userMapper.selectList(queryWrapper);}</code></pre><p>如果需要子查询，可以这样写：</p><pre><code class="java">public List&lt;User&gt; queryUserInSql() {    //相当于：SELECT * FROM user WHERE id IN (SELECT id FROM user WHERE age &gt; 30)    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.inSql(&quot;id&quot;,&quot;select id from user where age &gt; 30&quot;);    return userMapper.selectList(queryWrapper);}</code></pre><p>大部分的方法都是源自AbstractWrapper抽象类，除此之外还有很多功能，这里就不一一介绍下去了，有兴趣的可以到官网的<a href="https://mp.baomidou.com/guide/wrapper.html" target="_blank" rel="noopener">条件构造器</a>慢慢探索。</p><h2 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h2><p>UpdateWrapper也是AbstractWrapper抽象类的子类实现，所以上述的设置条件的方法都有，不同的是，UpdateWrapper会有set()和setSql()设置更新的值。举个例子：</p><pre><code class="java">public int updateUserNameById(String id, String name) {    //相当于：UPDATE user SET name = ? where id = ?    UpdateWrapper&lt;User&gt; userUpdateWrapper = new UpdateWrapper&lt;&gt;();    userUpdateWrapper.eq(&quot;id&quot;, id);    //设置set关键字后面的语句，相当于set name = #{name}    userUpdateWrapper.set(&quot;name&quot;, name);    return userMapper.update(new User(), userUpdateWrapper);}</code></pre><p>setSql()就是设置SET关键字后面拼接的部分SQL语句，举个例子：</p><pre><code class="java">public int updateUserBySql(String id, String name) {    //相当于：UPDATE user SET name = ? where id = ?    UpdateWrapper&lt;User&gt; userUpdateWrapper = new UpdateWrapper&lt;&gt;();    userUpdateWrapper.setSql(&quot;name = &#39;&quot; + name + &quot;&#39;&quot;);    userUpdateWrapper.eq(&quot;id&quot;, id);    return userMapper.update(new User(), userUpdateWrapper);}</code></pre><p>setSql()就是纯粹的SQL语句拼接，我们可以看到SET后面接的是name=’大D’，而不是占位符会有SQL注入的风险。</p><pre><code class="java">==&gt;  Preparing: UPDATE user SET name = &#39;大D&#39; WHERE id = ?==&gt; Parameters: d47561e885b011eba0e488d7f66fdab8(String)&lt;==    Updates: 1</code></pre><h2 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a>LambdaQueryWrapper</h2><p>用LambdaQueryWrapper的好处在于消除硬编码，比如QueryWrapper在查询<code>name=?</code>时，需要这样写：</p><pre><code class="java">QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();//使用&quot;name&quot;字符串，就是硬编码queryWrapper.eq(&quot;name&quot;, name);</code></pre><p>如果换成LambdaQueryWrapper就可以这样写：</p><pre><code class="java">public List&lt;User&gt; lambdaQueryUserByName(String name) {    //相当于：SELECT id,name,age FROM user WHERE name = ?    LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new QueryWrapper&lt;User&gt;().lambda();    lambdaQueryWrapper.eq(User::getName, name);    return userMapper.selectList(lambdaQueryWrapper);}</code></pre><p>再比如使用模糊查询，可以这样写：</p><pre><code class="java">public List&lt;User&gt; lambdaQueryUserLikeName(String name) {    LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new QueryWrapper&lt;User&gt;().lambda();    lambdaQueryWrapper.like(User::getName, name);    return userMapper.selectList(lambdaQueryWrapper);}</code></pre><h2 id="LambdaUpdateWrapper"><a href="#LambdaUpdateWrapper" class="headerlink" title="LambdaUpdateWrapper"></a>LambdaUpdateWrapper</h2><p>跟上面差不多，LambdaUpdateWrapper也可以消除硬编码：</p><pre><code class="java">public int lambdaUpdateUserNameById(String id, String name) {    //相当于：UPDATE user SET name=? WHERE id = ?    LambdaUpdateWrapper&lt;User&gt; lambdaUpdateWrapper = new UpdateWrapper&lt;User&gt;().lambda();    lambdaUpdateWrapper.set(User::getName, name);    lambdaUpdateWrapper.eq(User::getId, id);    return userMapper.update(new User(), lambdaUpdateWrapper);}</code></pre><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>Mybatis-plus提供了分页插件支持分页查询，只需要几个步骤即可实现。</p><p>首先添加一个配置类：</p><pre><code class="java">@Configurationpublic class MybatisPlusConfig {    @Bean    public PaginationInterceptor paginationInterceptor() {        return new PaginationInterceptor();    }}</code></pre><p>第二步，在UserMapper类里定义分页查询方法：</p><pre><code class="java">@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; {    //分页查询方法    IPage&lt;User&gt; selectPageByName(Page&lt;User&gt; page, @Param(&quot;name&quot;) String name);}</code></pre><p>对应的UserMapper.xml方法：</p><pre><code class="xml">&lt;select id=&quot;selectPageByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.yehongzhi.mydemo.model.User&quot;&gt;    select * from `user` where name = #{name}&lt;/select&gt;</code></pre><p>第三步，在userService里调用：</p><pre><code class="java">public IPage&lt;User&gt; selectPageByName(long pageNo, long pageSize, String name) {    Page&lt;User&gt; page = new Page&lt;&gt;();    //设置当前页码    page.setCurrent(pageNo);    //设置每页显示数    page.setSize(pageSize);    return userMapper.selectPageByName(page, name);}</code></pre><p>最后写个Controller接口测试：</p><pre><code class="java">@RequestMapping(&quot;/queryPage/ByName&quot;)public IPage&lt;User&gt; selectPageByName(@RequestParam(&quot;pageNo&quot;) long pageNo,                                    @RequestParam(&quot;pageSize&quot;) long pageSize,                                    @RequestParam(&quot;name&quot;) String name) {    return userService.selectPageByName(pageNo, pageSize, name);}</code></pre><p>查看控制台日志：</p><pre><code class="java">==&gt;  Preparing: SELECT COUNT(1) FROM `user` WHERE name = ?==&gt; Parameters: 杜琪峰(String)&lt;==    Columns: COUNT(1)&lt;==        Row: 1==&gt;  Preparing: select * from `user` where name = ? LIMIT ?,?==&gt; Parameters: 杜琪峰(String), 0(Long), 10(Long)&lt;==    Columns: id, name, age&lt;==        Row: d47561e885b011eba0e488d7f66fdab8, 杜琪峰, 30&lt;==      Total: 1</code></pre><p>分页查询成功！</p><h1 id="自定义主键生成器"><a href="#自定义主键生成器" class="headerlink" title="自定义主键生成器"></a>自定义主键生成器</h1><p>有时在实际开发中，可能会遇到，Mybatis-plus提供的主键生成策略并不能满足，需要自定义主键ID生成策略，怎么设置呢？</p><p>很简单，根据官网的说明，我们先定义一个主键生成器：</p><p><img src="https://static.lovebilibili.com/mybatis-plus_03.png" srcset="/img/loading.gif" alt=""></p><pre><code class="java">@Componentpublic class SnowflakeKeyGenerator implements IdentifierGenerator {    //自己实现的一个雪花ID生成工具类    @Resource    private SnowflakeIdWorker snowflakeIdWorker;    @Override    public Number nextId(Object entity) {        //使用雪花ID生成器，生成一个雪花ID        long nextId = snowflakeIdWorker.nextId();        System.out.println(String.format(&quot;使用自定义ID生成器，生成雪花ID:%s&quot;, nextId));        return nextId;    }}</code></pre><p>然后我们在需要使用该自定义ID生成器的实体类上面加上注解属性：</p><pre><code class="java">@TableName(&quot;user&quot;)public class User {    //属性设置为：IdType.ASSIGN_ID    @TableId(type = IdType.ASSIGN_ID)    private String id;    //省略...}</code></pre><p>接着测试一下，我们可以看到控制台有打印日志：</p><p><img src="https://static.lovebilibili.com/mybatis-plus_04.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>除了上面介绍的功能之外，Mybatis-plus还有很多功能，比如：代码生成器、扩展等等。这里就不再一一介绍了，实际上我们掌握上面介绍的CRUD、条件构造器、分页查询、自定义主键策略，基本上已经足够日常的开发。</p><p>当然如果你觉得会用还不够，还想要看懂框架的源码实现，那没问题。下一篇文章，我就讲讲框架的源码分析，敬请期待，</p><p>非常感谢你的阅读，希望这篇文章能给到你帮助和启发。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础不简单，谈谈hashCode()和equals()之间的联系</title>
    <link href="/2021/07/06/Java%E5%9F%BA%E7%A1%80%E4%B8%8D%E7%AE%80%E5%8D%95%EF%BC%8C%E8%B0%88%E8%B0%88hashCode-%E5%92%8Cequals-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/"/>
    <url>/2021/07/06/Java%E5%9F%BA%E7%A1%80%E4%B8%8D%E7%AE%80%E5%8D%95%EF%BC%8C%E8%B0%88%E8%B0%88hashCode-%E5%92%8Cequals-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>其实很早我就注意到阿里巴巴Java开发规范有一句话：<code>只要重写 equals，就必须重写 hashCode</code>。</p><p><img src="https://static.lovebilibili.com/hashcode_equals_1.png" srcset="/img/loading.gif" alt=""></p><p>我想很多人都会问为什么，所谓<code>知其然知其所以然</code>，对待知识不单止知道结论还得知道原因。</p><h1 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h1><p>hashCode()方法的作用是获取哈希码，返回的是一个int整数</p><p><img src="https://static.lovebilibili.com/hashcode_equals_2.png" srcset="/img/loading.gif" alt=""></p><p>学过数据结构的都知道，哈希码的作用是确定对象在哈希表的索引下标。比如HashSet和HashMap就是使用了hashCode方法确定索引下标。如果两个对象返回的hashCode相同，就被称为“哈希冲突”。</p><h1 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h1><p>equals()方法的作用很简单，就是判断两个对象是否相等，equals()方法是定义在Object类中，而所有的类的父类都是Object，所以如果不重写equals方法则会调用Object类的equals方法。</p><p><img src="https://static.lovebilibili.com/hashcode_equals_3.png" srcset="/img/loading.gif" alt=""></p><p>Object类的equals方法是用“==”号进行比较，在很多时候，因为==号比较的是两个对象的内存地址而不是实际的值，所以不是很符合业务要求。所以很多时候我们需要重写equals方法，去比较对象中每一个成员变量的值是否相等。</p><h1 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h1><blockquote><p> 重写equals()方法就可以比较两个对象是否相等，为什么还要重写hashcode()方法呢？</p></blockquote><p>因为HashSet、HashMap底层在添加元素时，会先判断对象的hashCode是否相等，如果hashCode相等才会用equals()方法比较是否相等。换句话说，HashSet和HashMap在判断两个元素是否相等时，<strong>会先判断hashCode，如果两个对象的hashCode不同则必定不相等</strong>。</p><p><img src="https://static.lovebilibili.com/hashcode_equals_8.png" srcset="/img/loading.gif" alt=""></p><p>下面我们做一个试验，有一个User类，只重写equals()方法，然后放到Set集合中去重。</p><pre><code class="java">public class User {    private String id;    private String name;    private Integer age;    public User(String id, String name, Integer age) {        this.id = id;        this.name = name;        this.age = age;    }    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        User user = (User) o;        return Objects.equals(id, user.id) &amp;&amp;            Objects.equals(name, user.name) &amp;&amp;            Objects.equals(age, user.age);    }    //getter、setter、toString方法}</code></pre><p>然后我们循环创建10个成员变量的值都是一样的User对象，最后放到Set集合中去重。</p><pre><code class="java">public static void main(String[] args) {    List&lt;User&gt; list = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 10; i++) {        User user = new User(&quot;1&quot;, &quot;张三&quot;, 18);        list.add(user);    }    Set&lt;User&gt; set = new HashSet&lt;&gt;(list);    for (User user : set) {        System.out.println(user);    }    List&lt;User&gt; users = list.stream().distinct().collect(Collectors.toList());    System.out.println(users);}</code></pre><p>按道理我们预期会去重，只剩下一个“张三”的user，但实际上因为没有重写hashCode方法，所以没有去重。</p><p><img src="https://static.lovebilibili.com/hashcode_equals_4.png" srcset="/img/loading.gif" alt=""></p><p>接着我们在User类里面重写一些hashCode方法再试试，其他不变。</p><pre><code class="java">public class User {    //其他不变    //重写hashCode方法    @Override    public int hashCode() {        return Objects.hash(id, name, age);    }}</code></pre><p>再运行，结果正确。</p><p><img src="https://static.lovebilibili.com/hashcode_equals_5.png" srcset="/img/loading.gif" alt=""></p><p>究其原因在于HashSet会先判断hashCode是否相等，如果hashCode不相等就直接认为两个对象不相等，不会再用equals()比较了。我们不妨看看重写hashCode方法和不重写hashCode方法的哈希码。</p><p>这是不重写hashCode方法的情况，每个user对象的哈希码都不一样，所以HashSet会认为都不相等。</p><p><img src="https://static.lovebilibili.com/hashcode_equals_6.png" srcset="/img/loading.gif" alt=""></p><p>这是重写hashCode方法的情况，因为是用对象所有的成员变量的值计算出的哈希码，所以只要两个对象的成员变量都是相等的，则生成的哈希码是相同的。</p><p><img src="https://static.lovebilibili.com/hashcode_equals_7.png" srcset="/img/loading.gif" alt=""></p><p>那么有些人看到这里，就会问，如果两个对象返回的哈希码都是一样的话，是不是就<strong>一定相等</strong>？</p><p>答案是不一定的，因为HashSet、HashMap判断哈希码相等后还会再用equals()方法判断。</p><p>总而言之：</p><ul><li>哈希码不相等，则两个对象一定不相同。</li><li>哈希码相等，两个对象不一定相同。</li><li>两个对象相同，则哈希码和值都一定相等。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以回到开头讲的那句，<code>只要重写 equals，就必须重写 hashCode</code>，这是一个很重要的细节，如果不注意的话，很容易发生业务上的错误。</p><p>特别是有时候我们明明用了HashSet，distinct()去重，但是就是不生效，这时应该回头看看重写了equals()和hashCode()方法了吗？</p><p>那么这篇文章就写到这里了，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈MYSQL索引是如何提高查询效率的</title>
    <link href="/2021/05/30/%E8%B0%88%E8%B0%88MYSQL%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E7%9A%84/"/>
    <url>/2021/05/30/%E8%B0%88%E8%B0%88MYSQL%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都知道当查询数据库变慢时，需要建索引去优化。但是只知道索引能优化显然是不够的，我们更应该知道索引的原理，因为不是加了索引就一定会提升性能。那么接下来就一起探索MYSQL索引的原理吧。</p><h1 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h1><p>索引其实是一种能高效帮助MYSQL获取数据的数据结构，通常保存在磁盘文件中，好比一本书的目录，能加快数据库的查询速度。除此之外，索引是有序的，所以也能提高数据的排序效率。</p><p>通常MYSQL的索引包括聚簇索引，覆盖索引，复合索引，唯一索引，普通索引，通常底层是B+树的数据结构。</p><p>总结一下，索引的优势在于：</p><ul><li>提高查询效率。</li><li>降低数据排序的成本。</li></ul><p>缺点在于：</p><ul><li>索引会占用磁盘空间。</li><li>索引会降低更新表的效率。因为在更新数据时，要额外维护索引文件。</li></ul><h1 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h1><ul><li>聚簇索引</li></ul><p>索引列的值必须是唯一的，并且不能为空，一个表只能有一个聚簇索引。</p><ul><li>唯一索引</li></ul><p>索引列的值是唯一的，值可以为空。</p><ul><li>普通索引</li></ul><p>没有什么限制，允许在定义索引的列中插入重复值和空值。</p><ul><li>复合索引</li></ul><p>也叫组合索引，用户可以在多个列上组合建立索引，遵循“最左匹配原则”，在条件允许的情况下使用复合索引可以替代多个单列索引的使用。</p><h1 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h1><p>我们都知道索引的底层数据结构采用的是B+树，但是在讲B+树之前，要先知道B树，因为B+树是在B树上面进行改进优化的。</p><p>首先讲一下B树的特点：</p><ul><li>B树的每个节点都存储了多个元素，每个内节点都有多个分支。</li><li>节点中元素包含键值和数据，节点中的键值从小到大排序。</li><li>父节点的数据不会出现在子节点中。</li><li>所有的叶子节点都在同一层，叶节点具有相同的深度。</li></ul><p><img src="https://static.lovebilibili.com/mysql_suoyin_1.png" srcset="/img/loading.gif" alt=""></p><p>在上面的B树中，假如我们要找值等于18的数据，查找路径就是磁盘块1-&gt;磁盘块3-&gt;磁盘块8。</p><p>过程如下：</p><p>第一次磁盘IO：首先加载磁盘块1到内存中，在内存中遍历比较，因为17&lt;18&lt;50，所以走中间P2，定位到磁盘块3。</p><p>第二次磁盘IO：加载磁盘块3到内存，依然是遍历比较，18&lt;25，所以走左边P1，定位到磁盘块8。</p><p>第三次磁盘IO：加载磁盘块8到内存，在内存中遍历，18=18，找到18，取出data。</p><p>如图所示：</p><p><img src="https://static.lovebilibili.com/mysql_suoyin_2.png" srcset="/img/loading.gif" alt=""></p><p>如果data存储的是行数据，直接返回，如果存的是磁盘地址则根据磁盘地址到磁盘中取出数据。可以看出B树的查询效率是很高的。</p><blockquote><p>B树存在着什么问题，需要改进优化呢？</p></blockquote><p>第一个问题：B树在范围查询时，性能并不理想。假如要查询13到30之间的数据，查询到13后又要回到根节点再去查询后面的数据，就会产生多次的查询遍历。</p><p>第二个问题：因为非叶子节点和叶子节点都会存储数据，所以占用的空间大，一个页可存储的数据量就会变少，树的高度就会变高，磁盘的IO次数就会变多。</p><p>基于以上两个问题，就出现了B树的升级版，B+树。</p><p>B+树与B树最大的区别在于两点：</p><ul><li>B+树只有叶子节点存储数据，非叶子节点只存储键值。而B树的非叶子节点和叶子节点都会存储数据。</li><li>B+树的最底层的叶子节点会形成一个双向有序链表，而B树不会。</li></ul><p>如图所示：</p><p><img src="https://static.lovebilibili.com/mysql_suoyin_3.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>B+树的等值查询过程是怎么样的？</p></blockquote><p>如果在B+树中进行等值查询，比如查询等于13的数据。</p><p>查询路径为：磁盘块1-&gt;磁盘块2-&gt;磁盘块6。</p><p>第一次IO：加载磁盘块1，在内存中遍历比较，13&lt;17，走左边，找到磁盘块2。</p><p>第二次IO：加载磁盘块2，在内存中遍历比较，10&lt;13&lt;15，走中间，找到磁盘块6。</p><p>第三次IO：加载磁盘块6，依次遍历，找到13=13，取出data。</p><p>所以B+树在等值查询的效率是很高的。</p><blockquote><p>B+树的范围查询过程又是怎么样呢？</p></blockquote><p>比如我们要进行范围查询，查询大于5并且小于15的数据。</p><p>查询路径为：磁盘块1-&gt;磁盘块2-&gt;磁盘块5-&gt;磁盘块6。</p><p>第一次IO：加载磁盘块1，比较得出5&lt;17，然后走左边，找到磁盘块2。</p><p>第二次IO：加载磁盘块2，比较5&lt;10，然后还是走左边，找到磁盘块5。</p><p>第三次IO：加载磁盘块5，然后找大于5的数据。</p><p>第四次IO：由于最底层是有序的双向链表，所以继续往右遍历即可，直到不符合小于15的数据为止。</p><p>过程如图所示：</p><p><img src="https://static.lovebilibili.com/mysql_suoyin_4.png" srcset="/img/loading.gif" alt=""></p><p>所以在范围查询的时候，是不需要像B树一样，再回到根节点，这就是底层采用双向链表的好处。</p><p>所以B+树的优势在于，能<strong>保证等值查询和范围查询的快速查找</strong>。</p><h1 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h1><p>我们常用的MySQL存储引擎一般是InnoDB，所以接下来讲讲几种不同的索引的底层数据结构，以及查找过程。</p><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>前面讲过，每个InnoDB表有且仅有一个聚簇索引。除此之外，聚簇索引在表的创建有以下几点规则：</p><ul><li>在表中，如果定义了主键，InnoDB会将主键索引作为聚簇索引。</li><li>如果没有定义主键，则会选择第一个不为NULL的唯一索引列作为聚簇索引。</li><li>如果以上两个都没有。InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增。</li></ul><p>除了聚簇索引之外的索引都称为非聚簇索引，区别在于，聚簇索引的叶子节点存储的数据是整行数据，而非聚簇索引存储的是该行的主键值。</p><p>比如有一张user表，如图所示：</p><p><img src="https://static.lovebilibili.com/mysql_suoyin_5.png" srcset="/img/loading.gif" alt=""></p><p>底层的数据结构就像这样：</p><p><img src="https://static.lovebilibili.com/mysql_suoyin_6.png" srcset="/img/loading.gif" alt=""></p><p>当我们用主键值去查询的时候，查询效率是很快的，因为可以直接返回数据。</p><p><img src="https://static.lovebilibili.com/mysql_suoyin_7.png" srcset="/img/loading.gif" alt=""></p><h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>也就是用得最多的一种索引，比如我要为user表的age列创建索引，SQL语句可以这样写：</p><pre><code class="sql">CREATE INDEX INDEX_USER_AGE ON `user`(age);</code></pre><p>普通索引属于非聚簇索引，所以叶子节点存储的是主键值，底层的数据结构大概长这个样子：</p><p><img src="https://static.lovebilibili.com/mysql_suoyin_8.png" srcset="/img/loading.gif" alt=""></p><p>比如要查询age=33的数据，那么首先查到磁盘块7的age=33的数据，获取到主键值，主键值为4。</p><p>接着再通过主键值等于4，查询到该行的数据。所以总得来说，底层会进行两次查询。</p><p>这种先通过查询主键值，再通过主键值查询到数据的过程就叫做回表查询。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>既然上面提到了回表查询，那么自然而然会想到，有没有什么办法能避免回表查询呢？答案肯定是有的，那就是使用覆盖索引。</p><p>覆盖索引不是一种索引的类型，而是一种使用索引的方式。假设你需要查询的列是建立了索引，查询的结果在索引列上就能获取，那就可以用覆盖索引。</p><p>比如上面的例子，我们通过age=33查询，我需要查询的结果就只要age这一列，那就可以用到覆盖索引，如图所示：</p><p><img src="https://static.lovebilibili.com/mysql_suoyin_9.png" srcset="/img/loading.gif" alt=""></p><p>使用到覆盖索引的话，就能避免回表查询，所以在写SQL语句时尽量不要写<code>SELECT *</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章主要讲的是索引的类型，索引的数据结构，以及InnoDB表中常用的几种索引。当然，除了上述讲的这些之外，还有很多关于索引的知识，比如索引失效的场景，索引创建的原则等等，由于篇幅过长，留着以后再讲。</p><p>那么这篇文章就写到这里了，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是雪花ID？</title>
    <link href="/2021/05/30/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%AA%E8%8A%B1ID%EF%BC%9F/"/>
    <url>/2021/05/30/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%AA%E8%8A%B1ID%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="为什么使用雪花ID"><a href="#为什么使用雪花ID" class="headerlink" title="为什么使用雪花ID"></a>为什么使用雪花ID</h1><p>在以前的项目中，最常见的两种主键类型是自增Id和UUID，在比较这两种ID之前首先要搞明白一个问题，就是为什么主键有序比无序查询效率要快，因为自增Id和UUID之间最大的不同点就在于有序性。</p><p>我们都知道，当我们定义了主键时，数据库会选择表的主键作为聚集索引(B+Tree)，mysql 在底层是以数据页为单位来存储数据的。</p><p>也就是说如果主键为<code>自增 id</code>的话，mysql 在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。<strong>如果一个数据页存满了，mysql 就会去申请一个新的数据页来存储数据</strong>。如果主键是<code>UUID</code>，为了确保索引有序，mysql 就需要将每次插入的数据都放到合适的位置上。<strong>这就造成了页分裂，这个大量移动数据的过程是会严重影响插入效率的</strong>。</p><p>一句话总结就是，InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的。</p><p>但是为什么很多情况又不用<code>自增id</code>作为主键呢？</p><ul><li>容易导致主键重复。比如导入旧数据时，线上又有新的数据新增，这时就有可能在导入时发生主键重复的异常。为了避免导入数据时出现主键重复的情况，要选择在应用停业后导入旧数据，导入完成后再启动应用。显然这样会造成不必要的麻烦。而UUID作为主键就不用担心这种情况。</li><li>不利于数据库的扩展。当采用自增id时，分库分表也会有主键重复的问题。UUID则不用担心这种问题。</li></ul><p>那么问题就来了，<code>自增id</code>会担心主键重复，<code>UUID</code>不能保证有序性，有没有一种ID既是有序的，又是唯一的呢？</p><p>当然有，就是<code>雪花ID</code>。</p><h1 id="什么是雪花ID"><a href="#什么是雪花ID" class="headerlink" title="什么是雪花ID"></a>什么是雪花ID</h1><p>snowflake是Twitter开源的分布式ID生成算法，结果是64bit的Long类型的ID，有着全局唯一和有序递增的特点。</p><p><img src="https://static.lovebilibili.com/snowflake_01.png" srcset="/img/loading.gif" alt=""></p><ul><li>最高位是符号位，因为生成的 ID 总是正数，始终为0，不可用。</li><li>41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。</li><li>10位的机器标识，10位的长度最多支持部署1024个节点。</li><li>12位的计数序列号，序列号即一系列的自增ID，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。</li></ul><p>缺点也是有的，就是强依赖机器时钟，如果机器上时钟回拨，有可能会导致主键重复的问题。</p><h1 id="Java实现雪花ID"><a href="#Java实现雪花ID" class="headerlink" title="Java实现雪花ID"></a>Java实现雪花ID</h1><p>下面是用Java实现雪花ID的代码，供大家参考一下。</p><pre><code class="java">public class SnowflakeIdWorker {    /**     * 开始时间：2020-01-01 00:00:00     */    private final long beginTs = 1577808000000L;    private final long workerIdBits = 10;    /**     * 2^10 - 1 = 1023     */    private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);    private final long sequenceBits = 12;    /**     * 2^12 - 1 = 4095     */    private final long maxSequence = -1L ^ (-1L &lt;&lt; sequenceBits);    /**     * 时间戳左移22位     */    private final long timestampLeftOffset = workerIdBits + sequenceBits;    /**     * 业务ID左移12位     */    private final long workerIdLeftOffset = sequenceBits;    /**     * 合并了机器ID和数据标示ID，统称业务ID，10位     */    private long workerId;    /**     * 毫秒内序列，12位，2^12 = 4096个数字     */    private long sequence = 0L;    /**     * 上一次生成的ID的时间戳，同一个worker中     */    private long lastTimestamp = -1L;    public SnowflakeIdWorker(long workerId) {        if (workerId &gt; maxWorkerId || workerId &lt; 0) {            throw new IllegalArgumentException(String.format(&quot;WorkerId必须大于或等于0且小于或等于%d&quot;, maxWorkerId));        }        this.workerId = workerId;    }    public synchronized long nextId() {        long ts = System.currentTimeMillis();        if (ts &lt; lastTimestamp) {            throw new RuntimeException(String.format(&quot;系统时钟回退了%d毫秒&quot;, (lastTimestamp - ts)));        }        // 同一时间内，则计算序列号        if (ts == lastTimestamp) {            // 序列号溢出            if (++sequence &gt; maxSequence) {                ts = tilNextMillis(lastTimestamp);                sequence = 0L;            }        } else {            // 时间戳改变，重置序列号            sequence = 0L;        }        lastTimestamp = ts;        // 0 - 00000000 00000000 00000000 00000000 00000000 0 - 00000000 00 - 00000000 0000        // 左移后，低位补0，进行按位或运算相当于二进制拼接        // 本来高位还有个0&lt;&lt;63，0与任何数字按位或都是本身，所以写不写效果一样        return (ts - beginTs) &lt;&lt; timestampLeftOffset | workerId &lt;&lt; workerIdLeftOffset | sequence;    }    /**     * 阻塞到下一个毫秒     *     * @param lastTimestamp     * @return     */    private long tilNextMillis(long lastTimestamp) {        long ts = System.currentTimeMillis();        while (ts &lt;= lastTimestamp) {            ts = System.currentTimeMillis();        }        return ts;    }    public static void main(String[] args) {        SnowflakeIdWorker snowflakeIdWorker = new SnowflakeIdWorker(7);        for (int i = 0; i &lt; 10; i++) {            long id = snowflakeIdWorker.nextId();            System.out.println(id);        }    }}</code></pre><p>main方法，测试结果如下：</p><pre><code class="java">184309536616640512184309536616640513184309536616640514184309536616640515184309536616640516184309536616640517184309536616640518184309536616640519184309536616640520184309536616640521</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在大部分公司的开发项目中里，雪花ID是主流的ID生成策略，除了自己实现之外，目前市场上也有很多开源的实现，比如：</p><ul><li>美团开源的<a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">Leaf</a></li><li>百度开源的<a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener">UidGenerator</a></li></ul><p>有兴趣的可以自行观摩一下，那么这篇文章就写到这里了，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOM怎么办，教你生成dump文件以及查看</title>
    <link href="/2021/05/30/OOM%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%8C%E6%95%99%E4%BD%A0%E7%94%9F%E6%88%90dump%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E6%9F%A5%E7%9C%8B/"/>
    <url>/2021/05/30/OOM%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%8C%E6%95%99%E4%BD%A0%E7%94%9F%E6%88%90dump%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E6%9F%A5%E7%9C%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常开发中，即使代码写得有多谨慎，免不了还是会发生各种意外的事件，比如服务器内存突然飙高，又或者发生内存溢出(OOM)。当发生这种情况时，我们怎么去排查，怎么去分析原因呢？</p><p>这时就引出这篇文章要讲的dump文件，各位看官且往下看。</p><h1 id="什么是dump文件"><a href="#什么是dump文件" class="headerlink" title="什么是dump文件"></a>什么是dump文件</h1><p>dump文件是一个进程或者系统在某一个给定的时间的快照。</p><p>dump文件是用来给驱动程序编写人员调试驱动程序用的，这种文件必须用专用工具软件打开。</p><p>dump文件中包含了程序运行的模块信息、线程信息、堆栈调用信息、异常信息等数据。</p><p>在服务器运行我们的Java程序时，是无法跟踪代码的，所以当发生线上事故时，dump文件就成了一个很关键的分析点。</p><h1 id="如何生成dump文件"><a href="#如何生成dump文件" class="headerlink" title="如何生成dump文件"></a>如何生成dump文件</h1><p>这里介绍两种方式，一种是主动的，一种是被动的。</p><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>主动生成dump文件。首先要查找运行的Java程序的pid。</p><p>使用<code>top</code>命令：</p><p><img src="https://static.lovebilibili.com/dump_01.png" srcset="/img/loading.gif" alt=""></p><p>然后使用jmap命令生成dump文件。file后面是保存的文件名称，1246则是java程序的PID。</p><pre><code class="shell">jmap -dump:format=b,file=user.dump 1246</code></pre><p><img src="https://static.lovebilibili.com/dump_02.png" srcset="/img/loading.gif" alt=""></p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>其实在很多时候我们是不知道何时会发生OOM，所以需要在发生OOM时自动生成dump文件。</p><p>其实很简单，只需要在启动时加上如下参数即可。HeapDumpPath表示生成dump文件保存的目录。</p><pre><code class="shell">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\tmp</code></pre><p>我们还需要模拟出OOM错误，以此触发产生dump文件，首先写个接口：</p><pre><code class="java">private static Map&lt;String, String&gt; map = new HashMap&lt;&gt;();@RequestMapping(&quot;/oom&quot;)public String oom() throws Exception {    for (int i = 0; i &lt; 100000; i++) {        map.put(&quot;key&quot; + i, &quot;value&quot; + i);    }    return &quot;oom&quot;;}</code></pre><p>然后在启动时设置堆内存大小为32M。</p><pre><code class="shell">-Xms32M -Xmx32M</code></pre><p>因为要后台启动，并且输出日志，所以最后启动命令就是这样：</p><pre><code class="shell">nohup java -jar -Xms32M -Xmx32M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local user-0.0.1-SNAPSHOT.jar  &gt; log.file  2&gt;&amp;1 &amp;</code></pre><p>然后请求oom的接口，查看日志，果然发生了OOM错误。</p><p><img src="https://static.lovebilibili.com/dump_03.png" srcset="/img/loading.gif" alt=""></p><p>查看保存dump的目录，果然生成了对应的dump文件。</p><p><img src="https://static.lovebilibili.com/dump_04.png" srcset="/img/loading.gif" alt=""></p><h1 id="如何查看dump文件"><a href="#如何查看dump文件" class="headerlink" title="如何查看dump文件"></a>如何查看dump文件</h1><p>这里我介绍使用<code>Jprofiler</code>，有可视化界面，功能也比较完善，能够打开JVM工具(通过-XX:+HeapDumpOnOutOfMemoryError JVM参数触发)创建的hporf文件。</p><p>安装过程这里就省略了，网上谷歌，百度自行查找。我们把刚刚自动生成的<code>java_pid1257.hprof</code>用<code>Jprofiler</code>打开，看到是这个样子。</p><p><img src="https://static.lovebilibili.com/dump_05.png" srcset="/img/loading.gif" alt=""></p><p>明显可以看出HashMap的Node对象，还有String对象的实例很多，占用内存也是最多的。这里还不够明显，我们看Biggest Objects。</p><p><img src="https://static.lovebilibili.com/dump_06.png" srcset="/img/loading.gif" alt=""></p><p>这里就看出是UserController类的HashMap占用了大量的内存。所以造成OOM的原因不难看出，就是在UserController里的Map集合。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当然线上的代码量，类的数量，实例的数量都非常庞大，所以没有那么简单就能找出报错的原因，但是要用什么工具，怎么用至少要知道，那么当遇到问题时，才不会慌张。</p><p>我问过一些技术大佬，为什么技术大佬代码写得不是很多，但是工资却特别高。大佬说，那是因为当线上出现问题时，大佬能解决大家解决不了的问题，这种能力就体现出他个人的价值。</p><p>一句话讲完，业务代码大部分程序员都会写，而线上排错能力并不是大部分程序员都会排。</p><p>这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解String类</title>
    <link href="/2021/05/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3String%E7%B1%BB/"/>
    <url>/2021/05/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3String%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p>在Java中String类的使用的频率可谓相当高。它是Java语言中的核心类，在java.lang包下，主要用于字符串的比较、查找、拼接等等操作。如果要深入理解一个类，最好的方法就是看看源码：</p><pre><code class="java">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    /** The value is used for character storage. */    private final char value[];    /** Cache the hash code for the string */    private int hash; // Default to 0    //...}</code></pre><p>从源码中，可以看出以下几点：</p><ul><li>String类被final关键字修饰，表示String类不能被继承，并且它的成员方法都默认为final方法。</li><li>String类实现了Serializable、CharSequence、 Comparable接口。</li><li>String类的值是通过char数组存储的，并且char数组被private和final修饰，字符串一旦创建就不能再修改。</li></ul><p>下面通过几个问题不断加深对String类的理解。</p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>上面说字符串一旦创建就不能再修改，String类提供的replace()方法不就可以替换修改字符串的内容吗？</p><p>实际上replace()方法并没有对原字符串进行修改，而是创建了一个新的字符串返回，看看源码就知道了。</p><pre><code class="java">public String replace(char oldChar, char newChar) {    if (oldChar != newChar) {        int len = value.length;        int i = -1;        char[] val = value; /* avoid getfield opcode */        while (++i &lt; len) {            if (val[i] == oldChar) {                break;            }        }        if (i &lt; len) {            char buf[] = new char[len];            for (int j = 0; j &lt; i; j++) {                buf[j] = val[j];            }            while (i &lt; len) {                char c = val[i];                buf[i] = (c == oldChar) ? newChar : c;                i++;            }            //创建一个新的字符串返回            return new String(buf, true);        }    }    return this;}</code></pre><p>其他方法也是一样，无论是sub、concat还是replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p><strong>为什么要使用final关键字修饰String类？</strong></p><p>首先要讲final修饰类的作用，<strong>被final修饰的类不能被继承</strong>，类中的所有成员方法都会被隐式地指定为final方法。也就是不能拥有子类，成员方法也不能被重写。</p><p>回到问题，String类被final修饰主要基于安全性和效率两点考虑。</p><ul><li>安全性</li></ul><p>因为字符串是不可变的，所以<strong>是多线程安全的</strong>，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p><p>String被许多的Java类(库)用来当做参数，比如网络连接地址URL，文件路径path，还有反射机制所需要的String参数等，假若String不是固定不变的，将会引起各种安全隐患。</p><ul><li>效率</li></ul><p><strong>字符串不变性保证了hash码的唯一性</strong>，因此可以放心的进行缓存，这也是一种性能优化手段，意味着不必每次都取计算新的哈希码。</p><p><strong>只有当字符串是不可变的，字符串池才有可能实现</strong>，字符串常量池是java堆内存中一个特殊的存储区域，当创建一个String对象，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。</p><h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><p>字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，所以在实例化字符串的时候使用字符串常量池进行优化。</p><p>池化思想其实在Java中并不少见，字符串常量池也是类似的思想，当创建字符串时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。</p><p>我们可以写个简单的例子证明：</p><pre><code class="java">public static void main(String[] args) throws Exception {    String s1 = &quot;abc&quot;;    String s2 = &quot;abc&quot;;    System.out.println(s1 == s2);//true}</code></pre><p><img src="https://static.lovebilibili.com/string_final_01.png" srcset="/img/loading.gif" alt=""></p><p>还有一个面试中经常问的，new String(“abc”)创建了几个对象？</p><p>这可能就是想考你对字符串常量池的理解，我一般回答是一个或者两个对象。</p><p>如果之前”abc”字符串没有使用过，毫无疑问是创建两个对象，堆中创建了一个String对象，字符串常量池创建了一个，一共两个。</p><p>如果之前已经使用过了”abc”字符串，则不会再在字符串常量池创建对象，而是从字符串常量缓冲区中获取，只会在堆中创建一个String对象。</p><pre><code class="java">String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;);//s2这行代码，只会创建一个对象</code></pre><h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><p>字符串的拼接在Java中是很常见的操作，但是拼接字符串并不是简简单单地使用”+”号即可，还有一些要注意的点，否则会造成效率低下。</p><p>比如下面这段代码：</p><pre><code class="java">public static void main(String[] args) throws Exception {    String s = &quot;&quot;;    for (int i = 0; i &lt; 10; i++) {        s+=i;    }    System.out.println(s);//0123456789}</code></pre><p>在循环内使用+=拼接字符串会有什么问题呢？我们反编译一下看看就知道了。</p><p><img src="https://static.lovebilibili.com/string_final_02.png" srcset="/img/loading.gif" alt=""></p><p>其实反编译后，我们可以看到String类使用”+=”拼接的底层其实是使用StringBuilder，先初始化一个StringBuilder对象，然后使用append()方法拼接，最后使用toString()方法得到结果。</p><p>问题在于如果在循环体内使用+=拼接，会创建很多临时的StringBuilder对象，拼接后再调用toString()赋给原String对象。这会生成大量临时对象，严重影响性能。</p><p>所以在循环体内进行字符串拼接时，建议使用StringBuilder或者StringBuffer类，例子如下：</p><pre><code class="java">public static void main(String[] args) throws Exception {    StringBuilder s = new StringBuilder();    for (int i = 0; i &lt; 10; i++) {        s.append(i);    }    System.out.println(s.toString());//0123456789}</code></pre><p>StringBuilder和StringBuffer的区别在于，StringBuffer的方法都被sync关键字修饰，所以是线程安全的，而StringBuilder则是线程不安全的(效率高)。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾一下，本文介绍了String类的不可变的特点，还有字符串常量池的作用，最后简单地从JVM编译的层面对字符串拼接提出一点建议。所谓温故而知新，即使是一些很基础很常见的类，如果深入去探索的话，也会有一番收获。</p><p>这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈MySQL的MVCC机制</title>
    <link href="/2021/04/25/%E8%B0%88%E8%B0%88MySQL%E7%9A%84MVCC%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/04/25/%E8%B0%88%E8%B0%88MySQL%E7%9A%84MVCC%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>无论是上一篇文章讲的事务隔离级别，还是之前讲的undo log日志，其实都涉及到MVCC机制，那么什么是MVCC机制，它的作用是什么，下面就让我们带着问题一起学习吧。</p><h1 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h1><p>MVCC全称是多版本并发控制 (Multi-Version Concurrency Control)，只有在InnoDB引擎下存在。MVCC机制的作用其实就是避免同一个数据在不同事务之间的竞争，提高系统的并发性能。</p><p>它的特点如下：</p><ul><li>允许多个版本同时存在，并发执行。</li><li>不依赖锁机制，性能高。</li><li>只在读已提交和可重复读的事务隔离级别下工作。</li></ul><h1 id="为什么使用MVCC"><a href="#为什么使用MVCC" class="headerlink" title="为什么使用MVCC"></a>为什么使用MVCC</h1><p>在早期的数据库中，只有读读之间的操作才可以并发执行，读写，写读，写写操作都要阻塞，这样就会导致MySQL的并发性能极差。</p><p>采用了MVCC机制后，只有写写之间相互阻塞，其他三种操作都可以并行，这样就可以提高了MySQL的并发性能。</p><h1 id="MVCC机制的原理"><a href="#MVCC机制的原理" class="headerlink" title="MVCC机制的原理"></a>MVCC机制的原理</h1><p>在讲解MVCC机制的原理之前首先要介绍几个概念。</p><h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>ReadView可以理解为数据库中某一个时刻所有未提交事务的快照。ReadView有几个重要的参数：</p><ul><li>m_ids：表示生成ReadView时，当前系统正在活跃的读写事务的事务Id列表。</li><li>min_trx_id：表示生成ReadView时，当前系统中活跃的读写事务的最小事务Id。</li><li>max_trx_id：表示生成ReadView时，当前时间戳InnoDB将在下一次分配的事务id。</li><li>creator_trx_id：当前事务id。</li></ul><p>所以当创建ReadView时，可以知道这个时间点上未提交事务的所有信息。</p><h2 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h2><p>InnoDB存储引擎中，它的聚簇索引记录中都包含两个必要的隐藏列，分别是：</p><ul><li>trx_id：事务Id，每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给<code>trx_id</code>隐藏列。</li><li>roll_pointer：回滚指针，每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo log</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><h2 id="事务链"><a href="#事务链" class="headerlink" title="事务链"></a>事务链</h2><p>每次对记录进行修改时，都会记录一条undo log信息，每一条undo log信息都会有一个roll_pointer属性(INSERT操作没有这个属性，因为之前没有更早的版本)，可以将这些undo日志都连起来，串成一个链表。事务链如下图一样：</p><p><img src="https://static.lovebilibili.com/mysql_mvvc_01.png" srcset="/img/loading.gif" alt=""></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们都知道，MySQL事务隔离级别有四种，分别是读未提交(Read Uncommitted，简称RU)、读已提交(Read Committed，简称RC)、可重复读(Repeatable Read，简称RR)、串行化(Serializable)，只有RC和RR才跟MVCC机制相关，RU和Serializable都不会使用到MVCC机制。因为在读未提交(RU)级别下是直接返回记录上的最新值，Serializable级别下则会对所有读取的行都加锁。</p><p>RC和RR隔离级别的实现就是通过版本控制来完成，核心处理逻辑就是<strong>判断所有版本中哪个版本是当前事务可见的处理</strong>，通过什么判断呢？就是上文讲到的ReadView，ReadView包含了当前系统活跃的读写事务的信息，判断的逻辑如下：</p><ul><li>如果被访问版本的trx_id属性值小于ReadView的最小事务Id，表示该版本的事务在生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值大于ReadView的最大事务Id，表示该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值在m_ids列表最小事务Id和最大事务Id之间，那就需要判断一下 trx_id 属性值是不是包含在 m_ids 列表中，如果包含的话，说明创建 ReadView 时生成该版本的事务还是活跃的，所以该版本不可以访问；如果不包含的话，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>我们下面举例说明RC和RR隔离级别的区别，假如有一条user数据，初始值name=”刘德华”，然后经过下面的更新，时间点如下：</p><p><img src="https://static.lovebilibili.com/mysql_mvvc_02.png" srcset="/img/loading.gif" alt=""></p><p>RC隔离级别的MVCC：</p><p><strong>RC隔离级别的事务在每次查询开始时都会生成一个独立的 ReadView</strong>。</p><p>在T4时间点时，版本链如下所示：</p><p><img src="https://static.lovebilibili.com/mysql_mvvc_03.png" srcset="/img/loading.gif" alt=""></p><p>在T4时间点的Select语句执行时，当前时间系统正在活跃的事务有trx_id为100和200都未提交，所以此时生成的ReadView的事务列表是[100,200]，因此查询语句会根据当前版本链中小于事务列表中的最大的版本数据，即查询到的是刘德华。</p><p>在T6时间点时，版本链如下所示：</p><p><img src="https://static.lovebilibili.com/mysql_mvvc_04.png" srcset="/img/loading.gif" alt=""></p><p>在T6时间点的Select语句执行时，当前时间系统正在活跃的事务有trx_id为200未提交，所以此时生成的ReadView的事务列表时[200]，因此查询语句会根据当前版本链中小于事务列表中的最大的版本数据，即查询到的是古天乐。</p><p>在T8时间点时，版本链如下所示：</p><p><img src="https://static.lovebilibili.com/mysql_mvvc_05.png" srcset="/img/loading.gif" alt=""></p><p>在T6时间点的Select语句执行时，当前时间系统正在活跃的事务都已经提交，所以此时生成的ReadView的事务列表为空，因此查询语句会直接查询当前数据库最新数据，即查询到的是麦长青。</p><p>由于每次查询都会生成新的ReadView，所以有可能出现不可重复读的问题。</p><p>RR隔离级别的MVCC：</p><p><strong>RR隔离级别的事务在第一次读取数据时生成ReadView，之后的查询都不会再生成，所以一个事务的查询结果每次都是一样的</strong>。</p><p>因为三次查询都是在同一个事务tx_300中。</p><p>所以在第一次查询，也就是T4时间点时会生成ReadView，事务列表为[100,200]，所以当前可见版本的查询结果为刘德华。</p><p>第二次查询，T6时间点不会生成新的ReadView，所以查询结果依然是刘德华。</p><p>第三次查询，T8时间一样，不会生成ReadView，沿用T4时间点生成的ReadView，所以查询结果依然是刘德华。</p><p><img src="https://static.lovebilibili.com/mysql_mvvc_06.png" srcset="/img/loading.gif" alt=""></p><p>由于在同一个事务中，RR级别的事务在查询中只会生成一个ReadView，所以能解决不可重复读的问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要理解MVCC机制，关键在于要理解ReadView、隐藏列、事务链三者在其中的作用。还有就是只有RC和RR的隔离级别才会使用MVCC机制，两者最大的区别在于生成ReadView的时机的不同，RC级别生成ReadView的时机是每次查询都会生成新的ReadView，而RR级别是在当前事务第一次查询时生成，并且生成的ReadView会一直沿用到事务提交为止，保证可重复读。</p><p>这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是脏读、不可重复读、幻读</title>
    <link href="/2021/04/21/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB/"/>
    <url>/2021/04/21/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="脏读、不可重复读、幻读"><a href="#脏读、不可重复读、幻读" class="headerlink" title="脏读、不可重复读、幻读"></a>脏读、不可重复读、幻读</h1><p>在现代关系型数据库中，事务机制是非常重要的，假如在多个事务并发操作数据库时，如果没有有效的机制进行避免就会导致出现脏读，不可重复读，幻读。</p><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>1、在事务A执行过程中，事务A对数据资源进行了修改，事务B读取了事务A修改后的数据。</p><p>2、由于某些原因，事务A并没有完成提交，发生了RollBack操作，则事务B读取的数据就是脏数据。</p><p>这种读取到另一个事务未提交的数据的现象就是脏读(Dirty Read)。</p><p><img src="https://static.lovebilibili.com/mysql_sw_1.png" srcset="/img/loading.gif" alt=""></p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致。</p><p>这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读(Nonrepeatable Read)。</p><p><img src="https://static.lovebilibili.com/mysql_sw_2.png" srcset="/img/loading.gif" alt=""></p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。</p><p>幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。</p><p><img src="https://static.lovebilibili.com/mysql_sw_3.png" srcset="/img/loading.gif" alt=""></p><h2 id="第一类更新丢失"><a href="#第一类更新丢失" class="headerlink" title="第一类更新丢失"></a>第一类更新丢失</h2><p>事务A和事务B都对数据进行更新，但是事务A由于某种原因事务回滚了，把已经提交的事务B的更新数据给覆盖了。这种现象就是第一类更新丢失。</p><p><img src="https://static.lovebilibili.com/mysql_sw_4.png" srcset="/img/loading.gif" alt=""></p><h2 id="第二类更新丢失"><a href="#第二类更新丢失" class="headerlink" title="第二类更新丢失"></a>第二类更新丢失</h2><p>其实跟第一类更新丢失有点类似，也是两个事务同时对数据进行更新，但是事务A的更新把已提交的事务B的更新数据给覆盖了。这种现象就是第二类更新丢失。</p><p><img src="https://static.lovebilibili.com/mysql_sw_5.png" srcset="/img/loading.gif" alt=""></p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>为了解决以上的问题，主流的关系型数据库都会提供四种事务的隔离级别。事务隔离级别从低到高分别是：读未提交、读已提交、可重复读、串行化。事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。所以在设置数据库的事务隔离级别时需要做一下权衡，<strong>MySQL默认是可重复读的级别</strong>。</p><h2 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h2><p>读未提交(Read Uncommitted)，是最低的隔离级别，所有的事务都可以看到其他未提交的事务的执行结果。只能防止第一类更新丢失，不能解决脏读，可重复读，幻读，所以很少应用于实际项目。</p><h2 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h2><p>读已提交(Read Committed)， 在该隔离级别下，一个事务的更新操作结果只有在<strong>该事务提交之后，另一个事务才可能读取到同一笔数据更新后的结果</strong>。可以防止脏读和第一类更新丢失，但是不能解决可重复读和幻读的问题。</p><h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><p>可重复读(Repeatable Read)，MySQL默认的隔离级别。在该隔离级别下，一个事务多次读同一个数据，在这个事务还没结束时，其他事务不能访问该数据(包括了读写)，这样就可以在同一个事务内两次读到的数据是一样的。可以防止脏读、不可重复读、第一类更新丢失、第二类更新丢失的问题，不过还是会出现幻读。</p><h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><p>串行化(Serializable)，这是最高的隔离级别。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。在这个级别，可以解决上面提到的所有并发问题，但可能导致大量的超时现象和锁竞争，通常不会用这个隔离级别。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>下面我们对事务的隔离级别和对并发问题的解决情况，请看下图：</p><p><img src="https://static.lovebilibili.com/mysql_sw_6.png" srcset="/img/loading.gif" alt=""></p><p>这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超详细的Sentinel入门</title>
    <link href="/2021/04/06/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84Sentinel%E5%85%A5%E9%97%A8/"/>
    <url>/2021/04/06/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84Sentinel%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="一、什么是Sentinel"><a href="#一、什么是Sentinel" class="headerlink" title="一、什么是Sentinel"></a>一、什么是Sentinel</h1><p>Sentinel定位是分布式系统的流量防卫兵。目前互联网应用基本上都使用微服务，微服务的稳定性是一个很重要的问题，而<strong>限流、熔断降级</strong>是微服务保持稳定的一个重要的手段。</p><p>下面看官网的一张图，了解一下Sentinel的主要特性：</p><p><img src="https://static.lovebilibili.com/sentinel_01.png" srcset="/img/loading.gif" alt=""></p><p>在Sentinel之前其实就有Hystrix做熔断降级的事情，我们都知道出现新的事物肯定是原来的东西有不足的地方。</p><blockquote><p>那Hystrix有什么不足之处呢？</p></blockquote><ul><li>Hystrix常用的线程池隔离会造成线程上下切换的overhead比较大。</li><li>Hystrix没有监控平台，需要我们自己搭建。</li><li>Hystrix支持的熔断降级维度较少，不够细粒，而且缺少管理控制台。</li></ul><blockquote><p>Sentinel有哪些组成部分？</p></blockquote><ul><li>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li><li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li></ul><blockquote><p>Sentinel有哪些特征？</p></blockquote><ul><li><p><strong>丰富的应用场景</strong>。控制突发流量在可控制的范围内，消息削峰填谷，集群流量控制，实时熔断下游不可用的应用等等。</p></li><li><p><strong>完备的实时监控</strong>。Sentinel 提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p></li><li><p><strong>广泛的开源生态</strong>。Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</p></li><li><p><strong>完善的 SPI 扩展点</strong>。Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p></li></ul><h1 id="二、Hello-World"><a href="#二、Hello-World" class="headerlink" title="二、Hello World"></a>二、Hello World</h1><p>一般要学一种没接触过的技术框架，肯定要先做个Hello World熟悉一下。</p><blockquote><p>引入Maven依赖</p></blockquote><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;    &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;    &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>需要提醒一下，Sentinel仅支持JDK 1.8或者以上的版本</p><blockquote><p>定义规则</p></blockquote><p>通过定义规则来控制该资源每秒允许通过的请求次数，例如下面的代码定义了资源 <code>HelloWorld</code> 每秒最多只能通过 20 个请求。</p><pre><code class="java">private static void initFlowRules(){    List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;();    FlowRule rule = new FlowRule();    rule.setResource(&quot;HelloWorld&quot;);    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);    // Set limit QPS to 20.    rule.setCount(20);    rules.add(rule);    FlowRuleManager.loadRules(rules);}</code></pre><blockquote><p>编写Hello World代码</p></blockquote><p>其实代码编写很简单，首先需要定义一个资源entry，然后用<code>SphU.entry(&quot;HelloWorld&quot;)</code>和<code>entry.exit()</code>把需要流量控制的代码包围起来。代码如下：</p><pre><code class="java">public static void main(String[] args) throws Exception {    initFlowRules();    while (true) {        Entry entry = null;        try {            entry = SphU.entry(&quot;HelloWorld&quot;);            /*您的业务逻辑 - 开始*/            System.out.println(&quot;hello world&quot;);            /*您的业务逻辑 - 结束*/        } catch (BlockException e1) {            /*流控逻辑处理 - 开始*/            System.out.println(&quot;block!&quot;);            /*流控逻辑处理 - 结束*/        } finally {            if (entry != null) {                entry.exit();            }        }    }}</code></pre><p>运行结果如下：</p><p><img src="https://static.lovebilibili.com/sentinel_02.png" srcset="/img/loading.gif" alt=""></p><p>我们根据目录查看日志，文件名格式为${appName}-metrics.log.xxx：</p><pre><code class="java">|--timestamp-|------date time----|-resource-|p |block|s |e|rt1616607101000|2021-03-25 01:31:41|HelloWorld|20|11373|20|0|1|0|0|01616607102000|2021-03-25 01:31:42|HelloWorld|20|24236|20|0|0|0|0|0</code></pre><p> <code>p</code> 代表通过的请求。</p><p> <code>block</code> 代表被阻止的请求。</p><p><code>s</code> 代表成功执行完成的请求个数。 </p><p><code>e</code> 代表用户自定义的异常。</p><p> <code>rt</code> 代表平均响应时长。</p><h1 id="三、使用Sentinel的方式"><a href="#三、使用Sentinel的方式" class="headerlink" title="三、使用Sentinel的方式"></a>三、使用Sentinel的方式</h1><p>下面结合实际案例，写一个Controller接口进行示范练习。</p><pre><code class="java">@RestController@RequestMapping(&quot;/user&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/list&quot;)    public List&lt;User&gt; getUserList() {        return userService.getList();    }}@Servicepublic class UserServiceImpl implements UserService {    //模拟查询数据库数据，返回结果    @Override    public List&lt;User&gt; getList() {        List&lt;User&gt; userList = new ArrayList&lt;&gt;();        userList.add(new User(&quot;1&quot;, &quot;周慧敏&quot;, 18));        userList.add(new User(&quot;2&quot;, &quot;关之琳&quot;, 20));        userList.add(new User(&quot;3&quot;, &quot;王祖贤&quot;, 21));        return userList;    }}</code></pre><p>假设我们要让这个查询接口限流，怎么做呢？</p><h2 id="1-抛出异常的方式"><a href="#1-抛出异常的方式" class="headerlink" title="1) 抛出异常的方式"></a>1) 抛出异常的方式</h2><p><code>SphU</code> 包含了 try-catch 风格的 API。用这种方式，当资源发生了限流之后会抛出 <code>BlockException</code>。这个时候可以捕捉异常，进行限流之后的逻辑处理。</p><pre><code class="java">@RestController@RequestMapping(&quot;/user&quot;)public class UserController {    //资源名称    public static final String RESOURCE_NAME = &quot;userList&quot;;    @Resource    private UserService userService;    @RequestMapping(&quot;/list&quot;)    public List&lt;User&gt; getUserList() {        List&lt;User&gt; userList = null;        Entry entry = null;        try {            // 被保护的业务逻辑            entry = SphU.entry(RESOURCE_NAME);            userList = userService.getList();        } catch (BlockException e) {            // 资源访问阻止，被限流或被降级            return Collections.singletonList(new User(&quot;xxx&quot;, &quot;资源访问被限流&quot;, 0));        } catch (Exception e) {            // 若需要配置降级规则，需要通过这种方式记录业务异常            Tracer.traceEntry(e, entry);        } finally {            // 务必保证 exit，务必保证每个 entry 与 exit 配对            if (entry != null) {                entry.exit();            }        }        return userList;    }}</code></pre><p>实际上还没写完，还要定义限流的规则。</p><pre><code class="java">@SpringBootApplicationpublic class SpringmvcApplication {    public static void main(String[] args) throws Exception {        SpringApplication.run(SpringmvcApplication.class, args);        //初始化限流规则        initFlowQpsRule();    }    //定义了每秒最多接收2个请求    private static void initFlowQpsRule() {        List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;();        FlowRule rule = new FlowRule(UserController.RESOURCE_NAME);        // set limit qps to 2        rule.setCount(2);        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);        rule.setLimitApp(&quot;default&quot;);        rules.add(rule);        FlowRuleManager.loadRules(rules);    }}</code></pre><p>然后启动项目，测试。快速刷新几次，我们就看到触发限流的逻辑了。</p><p><img src="https://static.lovebilibili.com/sentinel_03.png" srcset="/img/loading.gif" alt=""></p><h2 id="2-返回布尔值的方式"><a href="#2-返回布尔值的方式" class="headerlink" title="2) 返回布尔值的方式"></a>2) 返回布尔值的方式</h2><p>抛出异常的方式是当被限流时以抛出异常的形式感知，我们通过捕获异常进行限流的处理，这种方式跟上面不同的在于不抛出异常，而是返回一个布尔值，我们通过判断布尔值来进行限流逻辑的处理。这样我们就可以很容易写出<code>if-else</code>结构的代码。</p><pre><code class="java">public static final String RESOURCE_NAME_QUERY_USER_BY_ID = &quot;queryUserById&quot;;@RequestMapping(&quot;/get/{id}&quot;)public String queryUserById(@PathVariable(&quot;id&quot;) String id) {    if (SphO.entry(RESOURCE_NAME_QUERY_USER_BY_ID)) {        try {            //被保护的逻辑            //模拟数据库查询数据            return JSONObject.toJSONString(new User(id, &quot;Tom&quot;, 25));        } finally {            //关闭资源            SphO.exit();        }    } else {        //资源访问阻止，被限流或被降级        return &quot;Resource is Block!!!&quot;;    }}</code></pre><p>添加规则的代码跟前面的例子一样，我就不写了，然后启动项目，测试。</p><p><img src="https://static.lovebilibili.com/sentinel_04.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-注解的方式"><a href="#3-注解的方式" class="headerlink" title="3) 注解的方式"></a>3) 注解的方式</h2><p>看了上面两种方式，肯定有人会说，代码侵入性太强了，如果原来旧的系统要接入的话，要改原来的代码。众所周知，旧代码是不能动的，否则后果很严重。</p><p>那么注解的方式就很好地解决了这个问题。注解式怎么写呢？</p><pre><code class="java">@Servicepublic class UserServiceImpl implements UserService {    //资源名称    public static final String RESOURCE_NAME_QUERY_USER_BY_NAME = &quot;queryUserByUserName&quot;;    //value是资源名称，是必填项。blockHandler填限流处理的方法名称    @Override    @SentinelResource(value = RESOURCE_NAME_QUERY_USER_BY_NAME, blockHandler = &quot;queryUserByUserNameBlock&quot;)    public User queryByUserName(String userName) {        return new User(&quot;0&quot;, userName, 18);    }    //注意细节，一定要跟原函数的返回值和形参一致，并且形参最后要加个BlockException参数    //否则会报错，FlowException: null    public User queryUserByUserNameBlock(String userName, BlockException ex) {        //打印异常        ex.printStackTrace();        return new User(&quot;xxx&quot;, &quot;用户名称：{&quot; + userName + &quot;},资源访问被限流&quot;, 0);    }}</code></pre><p>写完这个核心代码后，还要加个配置，否则不生效。</p><p>引入<code>sentinel-annotation-aspectj</code>的Maven依赖。</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;    &lt;artifactId&gt;sentinel-annotation-aspectj&lt;/artifactId&gt;    &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后将<code>SentinelResourceAspect</code>注册为一个Bean。</p><pre><code class="java">@Configurationpublic class SentinelAspectConfiguration {    @Bean    public SentinelResourceAspect sentinelResourceAspect() {        return new SentinelResourceAspect();    }}</code></pre><p>别忘了添加规则，可以参考第一个例子，这里就不写了。</p><p>最后启动项目，测试，刷新多几次接口后，出发限流，可以看到以下结果。</p><p><img src="https://static.lovebilibili.com/sentinel_05.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-熔断降级"><a href="#4-熔断降级" class="headerlink" title="4) 熔断降级"></a>4) 熔断降级</h2><p>除了可以对接口进行限流之外，当接口出现异常时，Sentinel也可以提供熔断降级的功能。</p><p>在<code>@SentinelResource</code>注解中有一个属性<code>fallback</code>，当抛出非BlockException的异常时，就会进入到fallback方法中，实现熔断机制，这有点类似于Hystrix的FallBack。</p><p>我们拿上面的例子做示范，如果userName为空则抛出RuntimeException。然后我们设置fallback属性的属性值，也就是fallback的方法，返回系统异常。</p><pre><code class="java">@Override@SentinelResource(value = RESOURCE_NAME_QUERY_USER_BY_NAME, blockHandler = &quot;queryUserByUserNameBlock&quot;, fallback = &quot;queryUserByUserNameFallBack&quot;)public User queryByUserName(String userName) {    if (userName == null || &quot;&quot;.equals(userName)) {        //抛出异常        throw new RuntimeException(&quot;queryByUserName() command failed, userName is null&quot;);    }    return new User(&quot;0&quot;, userName, 18);}public User queryUserByUserNameFallBack(String userName, Throwable ex) {    //打印日志    ex.printStackTrace();    return new User(&quot;-1&quot;, &quot;用户名称：{&quot; + userName + &quot;},系统异常，请稍后重试&quot;, 0);}</code></pre><p>然后启动项目，故意不传userName，进行测试，可以看到走了fallback的方法逻辑。</p><p><img src="https://static.lovebilibili.com/sentinel_06.png" srcset="/img/loading.gif" alt=""></p><p>IDEA控制台也可以看到自定义的异常信息。</p><p><img src="https://static.lovebilibili.com/sentinel_07.png" srcset="/img/loading.gif" alt=""></p><h1 id="四、管理控制台"><a href="#四、管理控制台" class="headerlink" title="四、管理控制台"></a>四、管理控制台</h1><p>上面讲完了Sentinel的基本用法，实际上重头戏在Sentinel的管理控制台，管理控制台提供了很多实用的功能。下面我们看看怎么使用。</p><p>首先下载控制台的jar包，当然你也可以通过下载源码编译得到。</p><pre><code class="java">//下载页面地址https://github.com/alibaba/Sentinel/releases</code></pre><p>然后使用以下命令启动：</p><pre><code class="java">java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.1.jar</code></pre><p>启动成功后，访问<code>http://localhost:8080</code>，默认登录的用户名和密码都是<code>sentinel</code>。</p><p><img src="https://static.lovebilibili.com/sentinel_08.png" srcset="/img/loading.gif" alt=""></p><p>登录进去之后，可以看到主页面，有许多功能菜单，这里就不一一介绍了。</p><p><img src="https://static.lovebilibili.com/sentinel_09.png" srcset="/img/loading.gif" alt=""></p><h2 id="客户端接入控制台"><a href="#客户端接入控制台" class="headerlink" title="客户端接入控制台"></a>客户端接入控制台</h2><p>那么我们自己的应用怎么接入到控制台，使用控制台对应用的流量进行监控呢，诸位客官，请继续往下看。</p><p>首先添加maven依赖，客户端需要引入 Transport 模块来与 Sentinel 控制台进行通信。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;    &lt;artifactId&gt;sentinel-transport-simple-http&lt;/artifactId&gt;    &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>配置filter，把所有访问的 Web URL 自动统计为 Sentinel 的资源。</p><pre><code class="java">@Configurationpublic class FilterConfig {    @Bean    public FilterRegistrationBean sentinelFilterRegistration() {        FilterRegistrationBean&lt;Filter&gt; registration = new FilterRegistrationBean&lt;&gt;();        registration.setFilter(new CommonFilter());        registration.addUrlPatterns(&quot;/*&quot;);        registration.setName(&quot;sentinelFilter&quot;);        registration.setOrder(1);        return registration;    }}</code></pre><p>在启动命令中加入以下配置，<code>-Dcsp.sentinel.dashboard.server=consoleIp:port</code> 指定控制台地址和端口，<code>-Dcsp.sentinel.api.port=xxxx</code> 指定客户端监控 API 的端口(默认是8019，因为控制台已经使用了8719，应用端为了防止冲突就使用8720)：</p><pre><code class="java">-Dserver.port=8888 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dcsp.sentinel.api.port=8720 -Dproject.name=sentinelDemo</code></pre><p><img src="https://static.lovebilibili.com/sentinel_11.png" srcset="/img/loading.gif" alt=""></p><p>启动项目，我们可以看到多了一个应用名称sentinelDemo，点击机器列表，查看健康状况。</p><p><img src="https://static.lovebilibili.com/sentinel_12.png" srcset="/img/loading.gif" alt=""></p><p>请求<code>/user/list</code>接口，然后我们可以看到实时监控的接口的QPS情况。</p><p><img src="https://static.lovebilibili.com/sentinel_10.png" srcset="/img/loading.gif" alt=""></p><p>这样就代表客户端接入控制台成功了！</p><h2 id="动态规则"><a href="#动态规则" class="headerlink" title="动态规则"></a>动态规则</h2><p>Sentinel 的理念是开发者只需要关注资源的定义，当资源定义成功后可以动态增加各种流控降级规则。Sentinel 提供两种方式修改规则：</p><ul><li>通过 API 直接修改 (<code>loadRules</code>)</li><li>通过 <code>DataSource</code> 适配不同数据源修改</li></ul><p>手动通过API定义规则，前面Hello World的例子已经写过，是一种硬编码的形式，因为不够灵活，所以肯定不能应用于生产环境。</p><p>所以要引入<code>DataSource</code>，规则设置可以存储在数据源中，通过更新数据源中存储的规则，推送到Sentinel规则中心，客户端就可以实时获取最新的规则，根据最新的规则进行限流、降级。</p><p>一般<code>DataSource</code>拓展常见的实现方式有：</p><ul><li>拉模式：<strong>客户端主动向某个规则管理中心定期轮询拉取规则</strong>，这个规则中心可以是SQL、文件等。优点是比较简单，缺点是无法及时获取变更。</li><li>推模式：规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用Nacos、Zookeeper 等配置中心。这种方式有更好的实时性和一致性保证，比较推荐使用这种方式。</li></ul><h3 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h3><p>pull模式的数据源一般是可写入的(比如本地文件)。首先要在客户端注册数据源，将对应的读数据源注册至对应的 RuleManager；然后将写数据源注册至 transport 的 <code>WritableDataSourceRegistry</code> 中。</p><p>由此看出这是一个双向读写的过程，我们既可以在应用本地直接修改文件来更新规则，也可以通过 Sentinel 控制台推送规则。下图为控制台推送规则的流程图。</p><p><img src="https://static.lovebilibili.com/sentinel_13.png" srcset="/img/loading.gif" alt=""></p><p>首先引入maven依赖。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;    &lt;artifactId&gt;sentinel-datasource-extension&lt;/artifactId&gt;    &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>使用SPI机制进行扩展，创建一个实现类，实现InitFunc接口的init()方法。</p><pre><code class="java">public class FileDataSourceInit implements InitFunc {    public FileDataSourceInit() {    }    @Override    public void init() throws Exception {        String filePath = System.getProperty(&quot;user.home&quot;) + &quot;\\sentinel\\rules\\sentinel.json&quot;;        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; ds = new FileRefreshableDataSource&lt;&gt;(            filePath, source -&gt; JSON.parseObject(source, new TypeReference&lt;List&lt;FlowRule&gt;&gt;() {            })        );        // 将可读数据源注册至 FlowRuleManager.        FlowRuleManager.register2Property(ds.getProperty());        WritableDataSource&lt;List&lt;FlowRule&gt;&gt; wds = new FileWritableDataSource&lt;&gt;(filePath, this::encodeJson);        // 将可写数据源注册至 transport 模块的 WritableDataSourceRegistry 中.        // 这样收到控制台推送的规则时，Sentinel 会先更新到内存，然后将规则写入到文件中.        WritableDataSourceRegistry.registerFlowDataSource(wds);    }    private &lt;T&gt; String encodeJson(T t) {        return JSON.toJSONString(t);    }}</code></pre><p>在项目的 <code>resources/META-INF/services</code> 目录下创建文件，名为<code>com.alibaba.csp.sentinel.init.InitFunc</code> ，内容则是FileDataSourceInit的全限定名称：</p><pre><code class="java">io.github.yehongzhi.springmvc.config.FileDataSourceInit</code></pre><p><img src="https://static.lovebilibili.com/sentinel_14.png" srcset="/img/loading.gif" alt=""></p><p>接着在${home}目录下，创建<code>\sentinel\rules</code>目录，再创建sentinel.json文件。</p><p><img src="https://static.lovebilibili.com/sentinel_15.png" srcset="/img/loading.gif" alt=""></p><p>然后启动项目，发送请求，当客户端接收到请求后就会触发初始化操作。初始化完成后我们到控制台，然后设置流量限流规则。</p><p><img src="https://static.lovebilibili.com/sentinel_16.png" srcset="/img/loading.gif" alt=""></p><p>新增后，本地文件<code>sentinel.json</code>同时也保存了规则内容（压缩成一行的json）。</p><pre><code class="json">[{&quot;clusterConfig&quot;:{&quot;acquireRefuseStrategy&quot;:0,&quot;clientOfflineTime&quot;:2000,&quot;fallbackToLocalWhenFail&quot;:true,&quot;resourceTimeout&quot;:2000,&quot;resourceTimeoutStrategy&quot;:0,&quot;sampleCount&quot;:10,&quot;strategy&quot;:0,&quot;thresholdType&quot;:0,&quot;windowIntervalMs&quot;:1000},&quot;clusterMode&quot;:false,&quot;controlBehavior&quot;:0,&quot;count&quot;:3.0,&quot;grade&quot;:1,&quot;limitApp&quot;:&quot;default&quot;,&quot;maxQueueingTimeMs&quot;:500,&quot;resource&quot;:&quot;userList&quot;,&quot;strategy&quot;:0,&quot;warmUpPeriodSec&quot;:10}]</code></pre><p>我们可以通过修改文件来更新规则内容，也可以通过控制台推送规则到文件中，这就是拉模式。缺点是不保证一致性，实时性不保证，拉取过于频繁也可能会有性能问题。</p><h3 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h3><p>刚刚说了拉模式实时性不能保证，推模式就解决了这个问题。除此之外还可以持久化，也就是数据保存在数据源中，即使重启也不会丢失之前的配置，这也解决了原始模式存在内存中不能持久化的问题。</p><p>可以和Sentinel配合使用的数据源有很多种，比如ZooKeeper，Nacos，Apollo等等。这里介绍使用Nacos的方式。</p><p>首先要启动Nacos服务器，然后登录到Nacos控制台，添加一个命名空间，添加配置。</p><p><img src="https://static.lovebilibili.com/sentinel_19.png" srcset="/img/loading.gif" alt=""></p><p>接着我们就要改造Sentinel的源码。因为官网提供的Sentinel的jar是原始模式的，所以需要改造，所以我们需要拉取源码下来改造一下，然后自己编译jar包。</p><blockquote><p>源码地址：<a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel</a></p></blockquote><p>拉取下来之后，导入到IDEA中，然后我们可以看到以下目录结构。</p><p><img src="https://static.lovebilibili.com/sentinel_17.png" srcset="/img/loading.gif" alt=""></p><p>首先修改sentinel-dashboard的<code>pom.xml</code>文件：</p><p><img src="https://static.lovebilibili.com/sentinel_18.png" srcset="/img/loading.gif" alt=""></p><p>第二步，把test目录下的四个关于Nacos关联的类，移到rule目录下。</p><p><img src="https://static.lovebilibili.com/sentinel_20.png" srcset="/img/loading.gif" alt=""></p><p>FlowRuleNacosProvider和FlowRuleNacosPublisher不需要怎么改造，本人不太喜欢名称后缀，所以去掉了后面的后缀。</p><p><img src="https://static.lovebilibili.com/sentinel_21.png" srcset="/img/loading.gif" alt=""></p><p>接着NacosConfig添加Nacos的地址配置。</p><p><img src="https://static.lovebilibili.com/sentinel_22.png" srcset="/img/loading.gif" alt=""></p><p>最关键的是FlowControllerV1的改造，这是规则配置的增删改查的一些接口。</p><p>把移动到rule目录下的两个服务，添加到FlowControllerV1类中。</p><pre><code class="java">@Autowired@Qualifier(&quot;flowRuleNacosProvider&quot;)private DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;@Autowired@Qualifier(&quot;flowRuleNacosPublisher&quot;)private DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher;</code></pre><p>添加私有方法publishRules()，用于推送配置：</p><pre><code class="java">private void publishRules(/*@NonNull*/ String app) throws Exception {    List&lt;FlowRuleEntity&gt; rules = repository.findAllByApp(app);    rulePublisher.publish(app, rules);}</code></pre><p>修改apiQueryMachineRules()方法。</p><p><img src="https://static.lovebilibili.com/sentinel_23.png" srcset="/img/loading.gif" alt=""></p><p>修改apiAddFlowRule()方法。</p><p><img src="https://static.lovebilibili.com/sentinel_24.png" srcset="/img/loading.gif" alt=""></p><p>修改apiUpdateFlowRule()方法。</p><p><img src="https://static.lovebilibili.com/sentinel_25.png" srcset="/img/loading.gif" alt=""></p><p>修改apiDeleteFlowRule()方法。</p><p><img src="https://static.lovebilibili.com/sentinel_26.png" srcset="/img/loading.gif" alt=""></p><p>Sentinel控制台的项目就改造完成了，用于生产环境就编译成jar包运行，如果是学习可以直接在IDEA运行。</p><p>我们在前面创建的HelloWord工程的pom.xml文件加上依赖。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;    &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后在application.yml文件加上以下配置：</p><pre><code class="yaml">spring:  cloud:    sentinel:      datasource:        flow:          nacos:            server-addr: localhost:8848            namespace: 05f447bc-8a0b-4686-9c34-344d7206ea94            dataId: springmvc-sentinel-flow-rules            groupId: SENTINEL_GROUP            # 规则类型，取值见：            # org.springframework.cloud.alibaba.sentinel.datasource.RuleType            rule-type: flow            data-type: json  application:    name: springmvc-sentinel-flow-rules</code></pre><p>以上就完成了全部的配置和改造，启动Sentinel控制台，还有Java应用。</p><p>打开Nacos控制台，我们添加限流配置如下：</p><p><img src="https://static.lovebilibili.com/sentinel_27.png" srcset="/img/loading.gif" alt=""></p><p>配置内容如下：</p><pre><code class="json">[{&quot;app&quot;:&quot;springmvc-sentinel-flow-rules&quot;,&quot;clusterConfig&quot;:{&quot;acquireRefuseStrategy&quot;:0,&quot;clientOfflineTime&quot;:2000,&quot;fallbackToLocalWhenFail&quot;:true,&quot;resourceTimeout&quot;:2000,&quot;resourceTimeoutStrategy&quot;:0,&quot;sampleCount&quot;:10,&quot;strategy&quot;:0,&quot;thresholdType&quot;:0,&quot;windowIntervalMs&quot;:1000},&quot;clusterMode&quot;:false,&quot;controlBehavior&quot;:0,&quot;count&quot;:1.0,&quot;grade&quot;:1,&quot;limitApp&quot;:&quot;default&quot;,&quot;maxQueueingTimeMs&quot;:500,&quot;resource&quot;:&quot;userList&quot;,&quot;strategy&quot;:0,&quot;warmUpPeriodSec&quot;:10},{&quot;app&quot;:&quot;springmvc-sentinel-flow-rules&quot;,&quot;clusterConfig&quot;:{&quot;acquireRefuseStrategy&quot;:0,&quot;clientOfflineTime&quot;:2000,&quot;fallbackToLocalWhenFail&quot;:true,&quot;resourceTimeout&quot;:2000,&quot;resourceTimeoutStrategy&quot;:0,&quot;sampleCount&quot;:10,&quot;strategy&quot;:0,&quot;thresholdType&quot;:0,&quot;windowIntervalMs&quot;:1000},&quot;clusterMode&quot;:false,&quot;controlBehavior&quot;:0,&quot;count&quot;:3.0,&quot;grade&quot;:1,&quot;limitApp&quot;:&quot;default&quot;,&quot;maxQueueingTimeMs&quot;:500,&quot;resource&quot;:&quot;queryUserByUserName&quot;,&quot;strategy&quot;:0,&quot;warmUpPeriodSec&quot;:10}]</code></pre><p>然后我们打开Sentinel控制台，能看到配置，证明Nacos的配置推送成功了。</p><p><img src="https://static.lovebilibili.com/sentinel_28.png" srcset="/img/loading.gif" alt=""></p><p>我们尝试调用Java应用的接口，测试是否生效。</p><p><img src="https://static.lovebilibili.com/sentinel_29.png" srcset="/img/loading.gif" alt=""></p><p>可以看到限流是生效的，再看看Sentinel监控的QPS情况。</p><p><img src="https://static.lovebilibili.com/sentinel_30.png" srcset="/img/loading.gif" alt=""></p><p>从QPS监控的情况看，最高的QPS只有3，其他请求都被拒绝了，证明限流配置是实时生效的。</p><p><img src="https://static.lovebilibili.com/sentinel_31.png" srcset="/img/loading.gif" alt=""></p><p>配置信息也被持久化到Nacos相关的配置表中。</p><p>这时候，再回头看Sentinel官网上关于推模式的架构图就比较清楚了。</p><p><img src="https://static.lovebilibili.com/sentinel_33.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章主要介绍了Sentinel的基本用法，还有动态规则的两种方式，除此之外当然还有许多功能，这里由于篇幅问题就不一一介绍了，有兴趣的朋友可以自己探索一下。我个人觉得Sentinel是一个非常优秀的组件，比原来用的Hystrix的确有着非常大的改进，值得推荐。</p><p>我们看到官网上登记的企业列表，也有很多知名企业在使用，相信以后Sentinel会越来越好。</p><p><img src="https://static.lovebilibili.com/sentinel_32.png" srcset="/img/loading.gif" alt=""></p><p>这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL中必须了解的三种日志</title>
    <link href="/2021/03/21/MySQL%E4%B8%AD%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%97%A5%E5%BF%97/"/>
    <url>/2021/03/21/MySQL%E4%B8%AD%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家有没有想过为什么MySQL数据库可以实现主从复制，实现持久化，实现回滚的呢？其实关键在于MySQL里的三种<code>log</code>，分别是：</p><ul><li>binlog</li><li>redo log</li><li>undo log</li></ul><p>这三种log也是面试经常会问的问题，下面我们一起来探讨一下吧。</p><h1 id="一、binlog"><a href="#一、binlog" class="headerlink" title="一、binlog"></a>一、binlog</h1><p>binlog应该是日常中听的最多的关于mysql中的log。</p><blockquote><p>那么什么是binlog呢？</p></blockquote><p>binlog是用于<strong>记录数据库表结构和表数据变更的二进制日志</strong>，比如insert、update、delete、create、truncate等等操作，不会记录select、show操作，因为没有对数据本身发生变更。</p><blockquote><p>binlog文件长什么样子呢？</p></blockquote><p>使用<code>mysqlbinlog</code>命令可以查看。</p><p><img src="https://static.lovebilibili.com/mysql_log_1.png" srcset="/img/loading.gif" alt=""></p><p>会记录下每条变更的sql语句，还有执行开始时间，结束时间，事务id等等信息。</p><blockquote><p>如何查看binlog是否打开，如果没打开怎么设置？</p></blockquote><p>使用命令<code>show variables like &#39;%log_bin%&#39;;</code>查看binlog是否打开。</p><p><img src="https://static.lovebilibili.com/mysql_log_2.png" srcset="/img/loading.gif" alt=""></p><p>如果像上图一样，没有开启binlog，那怎么开启呢？</p><p>找到<code>my.cnf</code>配置文件，增加下面配置(mysql版本5.7.31)：</p><pre><code class="cnf"># 打开binloglog-bin=mysql-bin# 选择ROW(行)模式binlog-format=ROW</code></pre><p>修改后，重启mysql，配置生效。</p><p>执行<code>SHOW MASTER STATUS;</code>可以查看当前写入的binlog文件名。</p><p><img src="https://static.lovebilibili.com/mysql_log_3.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>binlog用来干嘛的呢？</p></blockquote><p>第一，用于主从复制。一般在公司中做一主二从的结构时，就需要master节点打开binlog日志，从机订阅binlog日志的信息，因为binlog日志记录了数据库数据的变更，所以当master发生数据变更时，从机也能随着master节点的数据变更而变更，做到主从复制的效果。</p><p><img src="https://static.lovebilibili.com/mysql_log_5.jpg" srcset="/img/loading.gif" alt=""></p><p>第二，用于数据恢复。因为binlog记录了数据库的变更，所以可以用于数据恢复。我们看到上面图中有个字段叫Position，这个参数是用于记录binlog日志的指针。当我们需要恢复数据时，只要指定<strong>–start-position</strong>和<strong>–stop-position</strong>，或者指定<strong>–start-datetime</strong>和<strong>–stop-datetime</strong>，那么就可以恢复指定区间的数据。</p><h1 id="二、redo-log"><a href="#二、redo-log" class="headerlink" title="二、redo log"></a>二、redo log</h1><p>假设有一条update语句：</p><pre><code class="sql">UPDATE `user` SET `name`=&#39;刘德华&#39; WHERE `id`=&#39;1&#39;;</code></pre><p>我们想象一下mysql修改数据的步骤，肯定是先把<code>id</code>=’1’的数据查出来，然后修改名称为’刘德华’。再深层一点，mysql是使用页作为存储结构，所以MySQL会先把这条记录所在的页加载到内存中，然后对记录进行修改。但是我们都知道mysql支持持久化，最终数据都是存在于磁盘中。</p><p>假设需要修改的数据加载到内存中，并且修改成功了，但是还没来得及刷到磁盘中，这时数据库宕机了，那么这次修改成功后的数据就丢失了。</p><p>为了避免出现这种问题，MySQL引入了redo log。</p><p><img src="https://static.lovebilibili.com/mysql_log_4.png" srcset="/img/loading.gif" alt=""></p><p>如图所示，当执行数据变更操作时，首先把数据也加载到内存中，然后在内存中进行更新，更新完成后写入到redo log buffer中，然后由redo log buffer在写入到redo log file中。</p><p>redo log file记录着xxx页做了xxx修改，所以即使mysql发生宕机，也可以通过redo log进行数据恢复，也就是说在内存中更新成功后，即使没有刷新到磁盘中，但也不会因为宕机而导致数据丢失。</p><blockquote><p>redo log与事务机制是如何配合工作的？</p></blockquote><p><img src="https://static.lovebilibili.com/mysql_log_7.png" srcset="/img/loading.gif" alt=""></p><p>如图所示：</p><p>第1-3步骤就是把数据变更，然后写入到内存中。</p><p>第4步记录到redo log中，然后把记录置为prepare(准备)状态。</p><p>第5，6步提交事务，提交事务之后，第7步把记录状态改成commit(提交)状态。</p><p>保证了事务与redo log的一致性。</p><blockquote><p>binlog和redo log都可以数据恢复，有什么区别？</p></blockquote><p>redo log是恢复在内存更新后，还没来得及刷到磁盘的数据。</p><p>binlog是存储所有数据变更的情况，理论上只要记录在binlog上的数据，都可以恢复。</p><p>举个例子，<strong>假如不小心整个数据库的数据被删除了，能使用redo log文件恢复数据吗</strong>？</p><p>不可以使用redo log文件恢复，只能使用binlog文件恢复。因为redo log文件不会存储历史所有的数据的变更，当内存数据刷新到磁盘中，redo log的数据就失效了，也就是redo log文件内容是会被覆盖的。</p><blockquote><p>binlog又是在什么时候记录的呢？</p></blockquote><p>答，在提交事务的时候。</p><p><img src="https://static.lovebilibili.com/mysql_log_8.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、undo-log"><a href="#三、undo-log" class="headerlink" title="三、undo log"></a>三、undo log</h1><p>undo log的作用主要<strong>用于回滚</strong>，mysql数据库的事务的原子性就是通过undo log实现的。我们都知道原子性是指对数据库的一系列操作，要么全部成功，要么全部失败。</p><p>undo log主要存储的是数据的逻辑变化日志，比如说我们要<code>insert</code>一条数据，那么undo log就会生成一条对应的delete日志。简单点说，undo log记录的是数据修改之前的数据，因为需要支持回滚。</p><p>那么当需要回滚时，只需要利用undo log的日志就可以恢复到修改前的数据。</p><p>undo log另一个作用是<strong>实现多版本控制(MVCC)</strong>，undo记录中包含了记录更改前的镜像，<strong>如果更改数据的事务未提交</strong>，对于隔离级别大于等于read commit的事务而言，<strong>不应该返回更改后数据，而应该返回老版本的数据</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学完之后，我们知道这三种日志在mysql中都有着重要的作用，再回顾一下：</p><ul><li>binlog主要用于复制和数据恢复。</li><li>redo log用于恢复在内存更新后，还没来得及刷到磁盘的数据。</li><li>undo log用于实现回滚和多版本控制。</li></ul><p>这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典算法题分享(哈希表)</title>
    <link href="/2021/03/15/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E4%BA%AB-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2021/03/15/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E4%BA%AB-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章主要讲解leetcode上，关于哈希表(简单难度)的算法题目。</p><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p><strong>题目</strong>：</p><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例1</strong>：</p><pre><code class="java">输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</code></pre><p><strong>示例2</strong>：</p><pre><code class="java">输入：nums = [3,2,4], target = 6输出：[1,2]</code></pre><h2 id="解法1-暴力解法"><a href="#解法1-暴力解法" class="headerlink" title="解法1(暴力解法)"></a>解法1(暴力解法)</h2><p>思路：</p><p>因为在数组中有两个整数的和等于目标值，很自然地我们就会想到一个个来尝试。我们知道目标值target和nums[i]，只需要找到nums[j]，然后返回<code>new int[]{i,j}</code>即可。</p><p>代码如下：</p><pre><code class="java">public int[] twoSum(int[] nums, int target) {    for (int i = 0; i &lt; nums.length; i++) {        //由于数组中同一个元素不能使用两遍，所以j从i的下一个元素开始        for (int j = i + 1; j &lt; nums.length; j++) {            if (target - nums[i] == nums[j]) {                return new int[]{i, j};            }        }    }    return new int[]{};}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_1.png" srcset="/img/loading.gif" alt=""></p><p>按道理嵌套循环的话，时间应该会久一点，居然仅用了0ms，我也不太相信，但是提交了三四次也是这个结果，不管了，哈哈~</p><p>假如我们想去掉嵌套循环，优化一下，怎么做呢？没错，就是今天的主角，哈希表！</p><h2 id="解法2-HashMap"><a href="#解法2-HashMap" class="headerlink" title="解法2(HashMap)"></a>解法2(HashMap)</h2><p>思路：</p><p>创建一个Map集合，key是nums[i]元素的值，value是下标值i。当<strong>target - 当前遍历的元素的差值</strong>在map中存在时，就返回<code>new int[]{map.get(target-nums[i]),i}</code>。如果不在map集合中，就把元素值和元素下标存进map集合中。</p><p>代码如下：</p><pre><code class="java">public int[] twoSum(int[] nums, int target) {    //map的key是nums[i]的值，value是下标i    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; nums.length; i++) {        //获取结果值与nums[i]的差值        int diff = target - nums[i];        //如果包含的话，返回结果        if (map.containsKey(diff)) {            return new int[]{map.get(diff), i};        } else {            map.put(nums[i], i);        }    }    return new int[]{};}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_2.png" srcset="/img/loading.gif" alt=""></p><h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h1><p><strong>题目</strong>：</p><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1</strong>：</p><pre><code class="java">输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]</code></pre><p><strong>实例2</strong>：</p><pre><code class="java">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]</code></pre><h2 id="解法1-暴力解法-1"><a href="#解法1-暴力解法-1" class="headerlink" title="解法1(暴力解法)"></a>解法1(暴力解法)</h2><p>嵌套循环，比较两个数组中的元素，如果<code>nums1[i] == nums2[j]</code>的话，表示两个数组中都有的数字，则添加到HashSet(去重)，最后再把HashSet转换成数组输出。</p><p>代码如下：</p><pre><code class="java">public int[] intersection(int[] nums1, int[] nums2) {    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();    for (int i = 0; i &lt; nums1.length; i++) {        for (int j = 0; j &lt; nums2.length; j++) {            if (nums1[i] == nums2[j]) {                set.add(nums1[i]);            }        }    }    //HashSet转换成数组输出    return set.stream().mapToInt(Integer::intValue).toArray();}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_3.png" srcset="/img/loading.gif" alt=""></p><p>经典的击败5%的用户，这是很正常的结果，因为使用了嵌套循环，而且还要把HashSet转换成数组，非常耗费性能，那么有没有优化空间呢，答案是肯定有的。</p><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>如果要判断一个整数是否包含在无序的数组中，只能从头遍历到尾。既然数组在判断时需要从头到尾遍历这么耗费性能，那我们能不能换一种数据结构，做到快速判断是否包含在其中呢，答案就是哈希表。HashSet的底层就是一个哈希表，所以我们把nums1的数全部存入一个HashSet中，然后再遍历nums2，判断nums中的元素是否包含在HashSet中即可。</p><p>代码如下：</p><pre><code class="java">public int[] intersection(int[] nums1, int[] nums2) {    Set&lt;Integer&gt; s1 = new HashSet&lt;&gt;();    for (int n1 : nums1) {        s1.add(n1);    }    Set&lt;Integer&gt; s2 = new HashSet&lt;&gt;();    for (int n2 : nums2) {        if (s1.contains(n2)) {            s2.add(n2);        }    }    //把set集合转成数组，返回    int[] res = new int[s2.size()];    int i = 0;    for (Integer num : s2) {        res[i] = num;        i++;    }    return res;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_4.png" srcset="/img/loading.gif" alt=""></p><h1 id="350-两个数组的交集II"><a href="#350-两个数组的交集II" class="headerlink" title="350. 两个数组的交集II"></a>350. 两个数组的交集II</h1><p><strong>题目</strong>：</p><p>给定两个数组，编写一个函数来计算它们的交集。</p><p> <strong>示例1</strong>：</p><pre><code class="java">输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2]</code></pre><p><strong>示例2</strong>：</p><pre><code class="java">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9]</code></pre><p><strong>说明</strong>：</p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>这道题是上面那道题的变形，不同在于输出结果不需要去重。因此我们不能使用HashSet存储，而要改用HashMap，key是数组中的元素，value是元素的个数。在判断是否包含在其中的时候，还要判断个数是否大于0，每添加一个元素到结果集中就从HashMap中减去一个元素的个数。</p><p>最后把结果集转成数组返回即可。</p><p>代码如下：</p><pre><code class="java">public int[] intersect(int[] nums1, int[] nums2) {    //key为num1的元素，value为元素出现的次数    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int num : nums1) {        map.put(num, map.getOrDefault(num, 0) + 1);    }    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    for (int num : nums2) {        if (map.containsKey(num) &amp;&amp; map.get(num) &gt; 0) {            list.add(num);            map.put(num, map.get(num) - 1);        }    }    int[] res = new int[list.size()];    for (int i = 0; i &lt; list.size(); i++) {        res[i] = list.get(i);    }    return res;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_5.png" srcset="/img/loading.gif" alt=""></p><h1 id="771-宝石与石头"><a href="#771-宝石与石头" class="headerlink" title="771. 宝石与石头"></a>771. 宝石与石头</h1><p><strong>题目</strong>：</p><p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p><strong>示例1</strong>：</p><pre><code class="java">输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3</code></pre><p><strong>示例2</strong>：</p><pre><code class="java">输入: J = &quot;z&quot;, S = &quot;ZZ&quot;输出: 0</code></pre><p><strong>注意:</strong></p><ul><li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li><li><code>J</code> 中的字符不重复。</li></ul><h2 id="解法1-HashSet"><a href="#解法1-HashSet" class="headerlink" title="解法1(HashSet)"></a>解法1(HashSet)</h2><p>这也是一个很典型的使用哈希表判断是否包含在集合中的题目。思路还是跟前面判断交集的一样，先把其中一个字符串遍历每个字符，放进HashSet，然后再遍历另一个字符串，判断是否包含在其中，包含则数量加一。最后返回结果。</p><p>代码如下：</p><pre><code class="java">public int numJewelsInStones(String jewels, String stones) {    Set&lt;Character&gt; set = new HashSet&lt;&gt;();    for (char j : jewels.toCharArray()) {        set.add(j);    }    int count = 0;    for (char s : stones.toCharArray()) {        if(set.contains(s)){            count++;        }    }    return count;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_6.png" srcset="/img/loading.gif" alt=""></p><h2 id="解法2-简化版哈希表"><a href="#解法2-简化版哈希表" class="headerlink" title="解法2(简化版哈希表)"></a>解法2(简化版哈希表)</h2><p>上面的解法执行用时2ms已经很快了，但是如果细心想一下，其实没必要使用HashSet集合，因为题目已经告诉我们只有字母，因此我们大可以使用一个数组模拟一个哈希表，优化一下。</p><p>代码如下：</p><pre><code class="java">public int numJewelsInStones(String jewels, String stones) {    //大写字母&#39;A&#39;的ASCII码是65，小写字母&#39;z&#39;的ASCII码是122    //所以使用一个长度58的数组已经足够    boolean[] bools = new boolean[58];    for (char j : jewels.toCharArray()) {        //类似哈希映射，把对应下标标记为true        bools[j - &#39;A&#39;] = true;    }    int count = 0;    for (char s : stones.toCharArray()) {        boolean bool = bools[s - &#39;A&#39;];        //如果对应下标为true，则是宝石        if (bool) {            count++;        }    }    return count;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_7.png" srcset="/img/loading.gif" alt=""></p><h1 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h1><p><strong>题目</strong>：</p><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p><strong>示例</strong>：</p><pre><code class="java">s = &quot;leetcode&quot;返回 0s = &quot;loveleetcode&quot;返回 2</code></pre><p><strong>提示：</strong>你可以假定该字符串只包含小写字母。</p><h2 id="解法1-HashMap"><a href="#解法1-HashMap" class="headerlink" title="解法1(HashMap)"></a>解法1(HashMap)</h2><p>我们可以遍历两次，第一次遍历使用HashMap记录字符出现的次数，第二次遍历找出只出现一次的字符，返回它的索引。</p><p>代码如下：</p><pre><code class="java">public int firstUniqChar(String s) {    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();    char[] chars = s.toCharArray();    for (char c : chars) {        map.put(c, map.getOrDefault(c, 0) + 1);    }    for (int i = 0; i &lt; chars.length; i++) {        Integer count = map.get(chars[i]);        if (count == 1) {            return i;        }    }    return -1;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_8.png" srcset="/img/loading.gif" alt=""></p><h2 id="解法2-1"><a href="#解法2-1" class="headerlink" title="解法2"></a>解法2</h2><p>显然解法1耗时过长，不是很理想。怎么优化呢，要抓住题目给的提示，只包含小写字母。既然只含有小写字母，那么我们就可以简化哈希表，使用一个数组代替。</p><p>代码如下：</p><pre><code class="java">public int firstUniqChar(String s) {    int[] hash = new int[26];    char[] chars = s.toCharArray();    for (char ch : chars) {        hash[ch - &#39;a&#39;]++;    }    for (int i = 0; i &lt; chars.length; i++) {        if (hash[chars[i] - &#39;a&#39;] == 1) {            return i;        }    }    return -1;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_9.png" srcset="/img/loading.gif" alt=""></p><h1 id="1365-有多少小于当前数字的数字"><a href="#1365-有多少小于当前数字的数字" class="headerlink" title="1365. 有多少小于当前数字的数字"></a>1365. 有多少小于当前数字的数字</h1><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。</p><p>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。</p><p>以数组形式返回答案。</p><p><strong>示例1</strong>：</p><pre><code class="java">输入：nums = [8,1,2,2,3]输出：[4,0,1,1,3]解释： 对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 对于 nums[1]=1 不存在比它小的数字。对于 nums[2]=2 存在一个比它小的数字：（1）。 对于 nums[3]=2 存在一个比它小的数字：（1）。 对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。</code></pre><p><strong>示例2</strong>：</p><pre><code class="java">输入：nums = [6,5,4,8]输出：[2,1,0,3]</code></pre><p><strong>示例3</strong>：</p><pre><code class="java">输入：nums = [7,7,7,7]输出：[0,0,0,0]</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 500</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="解法1-暴力法"><a href="#解法1-暴力法" class="headerlink" title="解法1(暴力法)"></a>解法1(暴力法)</h2><p>暴力法思路很简单粗暴，就是拿每一个元素跟数组中除了自身之外的每一个元素对比，只要元素大于数组中其他的数就计数加一，最后把计数收集起来就是结果。</p><p>代码如下：</p><pre><code class="java">public int[] smallerNumbersThanCurrent(int[] nums) {    int[] res = new int[nums.length];    int count = 0;    for (int i = 0; i &lt; nums.length; i++) {        int num = nums[i];        for (int j = 0; j &lt; nums.length; j++) {            //排除跟自己对比            if (i == j) {                continue;            }            //如果元素本身比其他数要大，计数+1            if (num &gt; nums[j]) {                count++;            }        }        //收集计数        res[i] = count;        //计数器归0        count = 0;    }    return res;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_10.png" srcset="/img/loading.gif" alt=""></p><h2 id="解法2-2"><a href="#解法2-2" class="headerlink" title="解法2"></a>解法2</h2><p>明显解法1使用了嵌套循环，导致耗时太多，结果不太理想。优化代码前，我们可以先看看提示<code>0 &lt;= nums[i] &lt;= 100</code>，也就是说元素的值在0到100范围内。我们可以使用一个101长度的数组统计元素出现的次数，当我们要计算有多少少于该元素的数字时，就只需要该元素前面所有元素出现的次数即可。</p><p>代码如下：</p><pre><code class="java">public int[] smallerNumbersThanCurrent(int[] nums) {    int[] hash = new int[101];    //使用数组统计数字出现的次数    for (int num : nums) {        //元素值相当于下标，类似于哈希映射        hash[num]++;    }    int[] res = new int[nums.length];    for (int i = 0; i &lt; nums.length; i++) {        //计数        int count = 0;        //统计在该元素前的所有元素(也就是小于该元素的数字)出现的次数        for (int j = nums[i] - 1; j &gt;= 0; j--) {            //计数器累加，j就是统计哈希表的下标            count += hash[j];        }        res[i] = count;    }    return res;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_11.png" srcset="/img/loading.gif" alt=""></p><h1 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389. 找不同"></a>389. 找不同</h1><p>题目：</p><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，它们只包含小写字母。</p><p>字符串 <strong>t</strong> 由字符串 <strong>s</strong> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <strong><em>t</em></strong> 中被添加的字母。</p><p><strong>示例1</strong>：</p><pre><code class="java">输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;输出：&quot;e&quot;解释：&#39;e&#39; 是那个被添加的字母。</code></pre><p><strong>示例2</strong>：</p><pre><code class="java">输入：s = &quot;&quot;, t = &quot;y&quot;输出：&quot;y&quot;</code></pre><p><strong>示例3</strong>：</p><pre><code class="java">输入：s = &quot;a&quot;, t = &quot;aa&quot;输出：&quot;a&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 1000</code></li><li><code>t.length == s.length + 1</code></li><li><code>s</code> 和 <code>t</code> 只包含小写字母</li></ul><h2 id="解法1-HashMap-1"><a href="#解法1-HashMap-1" class="headerlink" title="解法1(HashMap)"></a>解法1(HashMap)</h2><p>使用HashMap记录字符串s中每一个字符出现的次数，然后遍历字符串t，通过字符获取字符出现的次数，次数大于0就减一，次数等于0则表示是添加的字母，返回该字母。</p><p>代码如下：</p><pre><code class="java">public char findTheDifference(String s, String t) {    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();    for (char c : s.toCharArray()) {        map.put(c, map.getOrDefault(c, 0) + 1);    }    for (char c : t.toCharArray()) {        Integer count = map.getOrDefault(c, 0);        if (count &gt; 0) {            map.put(c, count - 1);        } else {            return c;        }    }    return &#39; &#39;;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_12.png" srcset="/img/loading.gif" alt=""></p><h2 id="解法2-3"><a href="#解法2-3" class="headerlink" title="解法2"></a>解法2</h2><p>关键是抓住提示，字符串s和t只包含小写字母，所以我们还是可以使用数组简化HashMap。小写字母只有26个，所以我们创建一个26长度的int数组，统计s字符串中字符出现的次数。其他逻辑和解法1一样即可。</p><p>代码如下：</p><pre><code class="java">public char findTheDifference(String s, String t) {    int[] hash = new int[26];    for (char c : s.toCharArray()) {        hash[c - &#39;a&#39;]++;    }    for (char c : t.toCharArray()) {        if (hash[c - &#39;a&#39;] &gt; 0) {            hash[c - &#39;a&#39;]--;        } else {            return c;        }    }    return &#39; &#39;;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_13.png" srcset="/img/loading.gif" alt=""></p><h2 id="解法3-排序法"><a href="#解法3-排序法" class="headerlink" title="解法3(排序法)"></a>解法3(排序法)</h2><p>把两个字符串转成字符数组，然后对两个数组排序。对排序好的数组进行遍历对比，只要出现不相等的字符，就是要返回的字符。</p><p>代码如下：</p><pre><code class="java">public char findTheDifference(String s, String t) {    char[] sChars = s.toCharArray();    char[] tChars = t.toCharArray();    Arrays.sort(sChars);    Arrays.sort(tChars);    int length = Math.min(sChars.length, tChars.length);    int i = 0;    while (i &lt; length) {        char sChar = sChars[i];        char tChar = tChars[i];        if (sChar != tChar) {            return tChar;        }        i++;    }    return tChars[tChars.length - 1];}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_14.png" srcset="/img/loading.gif" alt=""></p><p>效率虽然没有哈希表快，但是也是一种不错的解题思路。</p><h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h1><p><strong>题目</strong>：</p><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><p><strong>示例1</strong>：</p><pre><code class="java">输入: [1,2,3,1]输出: true</code></pre><p><strong>示例2</strong>：</p><pre><code class="java">输入: [1,2,3,4]输出: false</code></pre><p><strong>示例3</strong>：</p><pre><code class="java">输入: [1,1,1,3,3,4,3,2,4,2]输出: true</code></pre><h2 id="解法1-1"><a href="#解法1-1" class="headerlink" title="解法1"></a>解法1</h2><p>假如使用嵌套循环，是会超出时间限制的，所以不能考虑用暴力法。一般来说，判断一个元素是否包含在其中肯定是HashSet最快，所以我们可以用HashSet容纳元素，然后判断一下是否包含，包含则返回true，不包含则继续装入，如果遍历结束都没有返回true，则返回false。</p><p>代码如下：</p><pre><code class="java">public boolean containsDuplicate(int[] nums) {    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();    for (int num : nums) {        if (!set.contains(num)) {            set.add(num);        } else {            return true;        }    }    return false;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_15.png" srcset="/img/loading.gif" alt=""></p><h2 id="解法2-4"><a href="#解法2-4" class="headerlink" title="解法2"></a>解法2</h2><p>其实HashSet本身就有去重的效果，我们把所有的元素装入到HashSet中，如果有重复的元素则长度和原来的长度不相等。</p><p>代码如下：</p><pre><code class="java">public boolean containsDuplicate(int[] nums) {    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();    for (int num : nums) {        set.add(num);    }    return set.size() != nums.length;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_16.png" srcset="/img/loading.gif" alt=""></p><h1 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h1><p><strong>题目</strong>：</p><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p><p>注意:<br>假设字符串的长度不会超过 1010。</p><p><strong>示例1</strong>：</p><pre><code class="java">输入:&quot;abccccdd&quot;输出:7解释:我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</code></pre><h2 id="解法1-2"><a href="#解法1-2" class="headerlink" title="解法1"></a>解法1</h2><p>回文字符串就是从左往右读和从右往左读都是一样的字符串，也就是左右对称的字符串。要做到左右对称，其实很简单，只要是偶数个相同的字符就可以，比如有两个”a”，左右两端各放一个就对称了。</p><p>所以我们用一个HashMap来统计字符出现的次数，然后遍历，判断如果是偶数就累加字母出现的次数，如果是奇数就减一让他变成偶数再累加，最后就得到答案res，但是还没大功告成，因为中点插进一个字母，他还是对称的，所以最后要判断一下累加的长度是否等于原来的字符串长度，再决定要不要再加上一个字母的长度。</p><p>代码如下：</p><pre><code class="java">public int longestPalindrome(String s) {    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();    //统计字符出现的次数    for (char c : s.toCharArray()) {        map.put(c, map.getOrDefault(c, 0) + 1);    }    int res = 0;    for (Character key : map.keySet()) {        Integer val = map.get(key);        //如果是奇数次，减一成为偶数，再累加        if (val % 2 != 0) {            res += (val - 1);        } else {            //如果是偶数次，直接累加            res += val;        }    }    int length = s.length();    return res == length ? length : (res + 1);}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_17.png" srcset="/img/loading.gif" alt=""></p><h2 id="解法2-优化"><a href="#解法2-优化" class="headerlink" title="解法2(优化)"></a>解法2(优化)</h2><p>题目说明是包含大写字母和小写字母，所以我们还是可以使用数组来代替HashMap，以此提高代码的执行效率。我们只需要一个长度为128的数组来统计字符出现的次数，代替HashMap。其他逻辑不变即可。</p><p>代码如下：</p><pre><code class="java">public int longestPalindrome(String s) {    int[] hash = new int[128];    for (char c : s.toCharArray()) {        hash[c - &#39;A&#39;]++;    }    int res = 0;    for (int count : hash) {        if (count % 2 != 0) {            res += (count - 1);        } else {            res += count;        }    }    int length = s.length();    return res == length ? length : (res + 1);}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_18.png" srcset="/img/loading.gif" alt=""></p><h1 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h1><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p><p><strong>示例1</strong>：</p><pre><code class="java">输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</code></pre><p><strong>示例2</strong>：</p><pre><code class="java">输入：n = 0输出：0</code></pre><p><strong>示例3</strong>：</p><pre><code class="java">输入：n = 1输出：0</code></pre><h2 id="解法1-暴力法-1"><a href="#解法1-暴力法-1" class="headerlink" title="解法1(暴力法)"></a>解法1(暴力法)</h2><p>其实这是一个很经典的数学问题，比如要判断223是不是质数，最粗暴的方法就是，223对(2到222)进行取余，每次取余的余数都不为0，那就是质数。但是如果n的值非常大，那就会超过时间限制。</p><p>代码如下：</p><pre><code class="java">public int countPrimes(int n) {    int count = 0;    for (int i = 0; i &lt; n; i++) {        //判断是否是质数，是质数则计数+1        if (isPrimes(i)) {            count++;        }    }    return count;}//判断一个数是否是质数private boolean isPrimes(int num) {    if (num &lt;= 1) {        return false;    }    if (num == 2) {        return true;    }    //循环取余，只要有一次返回余数为0则是非质数    for (int i = 2; i &lt; num; i++) {        if (num % i == 0) {            return false;        }    }    //如果余数都不为0则是质数    return true;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_19.png" srcset="/img/loading.gif" alt=""></p><h2 id="解法2-5"><a href="#解法2-5" class="headerlink" title="解法2"></a>解法2</h2><p>不如反向思维一下，我们使用一个boolean[]数组记录每个数是否是质数，然后从2开始找出非质数都标记成true，标记完成之后就可以统计质数的数量是多少了。</p><pre><code class="java">public int countPrimes(int n) {    boolean[] booleans = new boolean[n];    for (int i = 2; i &lt; n; i++) {        for (int j = 2; j * i &lt; n; j++) {            booleans[i * j] = true;        }    }    int count = 0;    //从2开始统计    for (int i = 2; i &lt; booleans.length; i++) {        if (!booleans[i]) {            count++;        }    }    return count;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_20.png" srcset="/img/loading.gif" alt=""></p><p>其实上面的代码还可以优化一下，不需要遍历两次，把统计和标记放在一个循环即可。代码如下：</p><pre><code class="java">public int countPrimes(int n) {    int count = 0;    boolean[] booleans = new boolean[n];    for (int i = 2; i &lt; n; i++) {        if (!booleans[i]) {            for (int j = 2; j * i &lt; n; j++) {                booleans[i * j] = true;            }            count++;        }    }    return count;}</code></pre><p>提交代码，结果如下：</p><p><img src="https://static.lovebilibili.com/leetcode_hash_21.png" srcset="/img/loading.gif" alt=""></p><h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><p>万万没想到，这个题目还有0ms的题解！这是我在提交记录中一不留神看到的，截图给大伙看看。</p><p><img src="https://static.lovebilibili.com/leetcode_hash_22.png" srcset="/img/loading.gif" alt=""></p><p>然后我点开代码一看，好家伙，震惊我一整年！</p><pre><code class="java">public int countPrimes(int n) {    switch (n) {        case 0: return 0;        case 1: return 0;        case 2: return 0;        case 3: return 1;        case 4: return 2;        case 5: return 2;        case 6: return 3;        case 7: return 3;        case 8: return 4;        case 9: return 4;        case 10: return 4;        case 11: return 4;        case 12: return 5;        case 13: return 5;        case 14: return 6;        case 15: return 6;        case 10000: return 1229;        case 499979: return 41537;        case 999983: return 78497;        case 1500000: return 114155;        case 5000000: return 348513;        default: return -1;    }}</code></pre><p>我当然不相信这是能通过的啦，于是复制了这段代码提交试试，没想到还真行呀！</p><p><img src="https://static.lovebilibili.com/leetcode_hash_23.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>哈希表的算法题中有很多问题其实在实际项目中也会遇到，比如找出两个集合的交集，找出集合中重复的元素等等，所以做一做算法题对我们的编码能力会有很大的提升。</p><p>这篇文章讲到这里了，感谢大家的阅读，希望看完这篇文章能有所收获！</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎么在Java中自定义注解</title>
    <link href="/2021/03/08/%E6%80%8E%E4%B9%88%E5%9C%A8Java%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    <url>/2021/03/08/%E6%80%8E%E4%B9%88%E5%9C%A8Java%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h1><p>注解是JDK1.5引入的新特性，主要用于简化代码，提高编程的效率。其实在日常开发中，注解并不少见，比如Java内置的<code>@Override</code>、<code>@SuppressWarnings</code>，或者Spring提供的<code>@Service</code>、<code>@Controller</code>等等，随着这些注解使用的频率越来越高，作为开发人员当真有必要深入学习一番。</p><h1 id="Java内置的注解"><a href="#Java内置的注解" class="headerlink" title="Java内置的注解"></a>Java内置的注解</h1><p>先说说Java内置的三个注解，分别是：</p><p><code>@Override</code>：检查当前的方法定义是否覆盖父类中的方法，如果没有覆盖，编译器就会报错。</p><p><code>@SuppressWarnings</code>：忽略编译器的警告信息。</p><p><img src="https://static.lovebilibili.com/zhujie_3.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/zhujie_4.png" srcset="/img/loading.gif" alt=""></p><p><code>@Deprecated</code>：用于标识该类或方法已过时，建议开发人员不要使用该类或方法。</p><p><img src="https://static.lovebilibili.com/zhujie_1.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/zhujie_2.png" srcset="/img/loading.gif" alt=""></p><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>元注解其实就是描述注解的注解。主要有四个元注解，分别是：</p><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>用于描述注解的使用范围，也就是注解可以用在什么地方，取值有：</p><p>CONSTRUCTOR：用于描述构造器。</p><p>FIELD：用于描述字段。</p><p>LOCAL_VARIABLE：用于描述局部变量。</p><p>METHOD：用于描述方法。</p><p>PACKAGE：用于描述包。</p><p>PARAMETER：用于描述参数。</p><p>TYPE：用于描述类，包括class，interface，enum。 </p><h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p><strong>表示需要在什么级别保存该注释信息，用于描述注解的生命周期</strong>，取值由枚举RetentionPoicy定义。</p><p><img src="https://static.lovebilibili.com/zhujie_5.png" srcset="/img/loading.gif" alt=""></p><p>SOURCE：在源文件中有效（即源文件保留），仅出现在源代码中，而被编译器丢弃。</p><p>CLASS：在class文件中有效（即class保留），但会被JVM丢弃。</p><p>RUNTIME：JVM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。</p><p>如果只是做一些检查性操作，使用SOURCE，比如@Override，@SuppressWarnings。</p><p>如果要在编译时进行一些预处理操作，就用 CLASS。</p><p>如果需要获取注解的属性值，去做一些运行时的逻辑，可以使用RUNTIME。</p><h2 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h2><p>将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。它是一个标记注解，没有成员。</p><p><img src="https://static.lovebilibili.com/zhujie_6.png" srcset="/img/loading.gif" alt=""></p><h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p>是一个标记注解，用来指定该注解可以被继承。使用 @Inherited 注解的 Class 类，表示这个注解可以被用于该 Class 类的子类。</p><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>下面实战一下，自定义一个注解@LogApi，用于方法上，当被调用时即打印日志，在控制台显示调用方传入的参数和调用返回的结果。</p><h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><p>首先定义注解<code>@LogApi</code>，在方法上使用，为了能在反射中读取注解信息，当然是设置为<code>RUNTIME</code>。</p><pre><code class="java">@Target(value = ElementType.METHOD)@Documented@Retention(value = RetentionPolicy.RUNTIME)public @interface LogApi {}</code></pre><p>这种没有属性的注解，属于标记注解。</p><p>多说几句，如果需要传递属性值，也可以设置属性值value，比如<code>@RequestMapping</code>注解。</p><pre><code class="java">@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping {    @AliasFor(&quot;path&quot;)    String[] value() default {};}</code></pre><p>如果在使用时。只设置value值，可以忽略value，比如这样：</p><pre><code class="java">//完整是@RequestMapping(value = {&quot;/list&quot;})//忽略value不写@RequestMapping(&quot;/list&quot;)public Map&lt;String, Object&gt; list() throws Exception {    Map&lt;String, Object&gt; userMap = new HashMap&lt;&gt;();    userMap.put(&quot;1号佳丽&quot;, &quot;李嘉欣&quot;);    userMap.put(&quot;2号佳丽&quot;, &quot;袁咏仪&quot;);    userMap.put(&quot;3号佳丽&quot;, &quot;张敏&quot;);    userMap.put(&quot;4号佳丽&quot;, &quot;张曼玉&quot;);    return userMap;}</code></pre><h2 id="标记注解"><a href="#标记注解" class="headerlink" title="标记注解"></a>标记注解</h2><p>刚刚定义完注解之后，就可以在需要的地方标记注解，很简单。</p><pre><code class="java">@LogApi@RequestMapping(&quot;/list&quot;)public Map&lt;String, Object&gt; list() throws Exception {    //业务代码...}</code></pre><h2 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h2><p>最关键的一步来了，解析注解，一般在项目中会使用Spring的AOP技术解析注解，当然如果只需要解析一次的话，也可以使用Spring容器的生命周期函数。</p><p>这里的场景是打印每次方法被调用的日志，所以使用AOP比较合适。</p><p>创建一个切面类<code>LogApiAspect</code>进行解析。</p><pre><code class="java">@Aspect@Componentpublic class LogApiAspect {    //切面点为标记了@LogApi注解的方法    @Pointcut(&quot;@annotation(io.github.yehongzhi.user.annotation.LogApi)&quot;)    public void logApi() {    }    //环绕通知    @Around(&quot;logApi()&quot;)    @SuppressWarnings(&quot;unchecked&quot;)    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {        long starTime = System.currentTimeMillis();        //通过反射获取被调用方法的Class        Class type = joinPoint.getSignature().getDeclaringType();        //获取类名        String typeName = type.getSimpleName();        //获取日志记录对象Logger        Logger logger = LoggerFactory.getLogger(type);        //方法名        String methodName = joinPoint.getSignature().getName();        //获取参数列表        Object[] args = joinPoint.getArgs();        //参数Class的数组        Class[] clazz = new Class[args.length];        for (int i = 0; i &lt; args.length; i++) {            clazz[i] = args[i].getClass();        }        //通过反射获取调用的方法method        Method method = type.getMethod(methodName, clazz);        //获取方法的参数        Parameter[] parameters = method.getParameters();        //拼接字符串，格式为{参数1:值1,参数2::值2}        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; parameters.length; i++) {            Parameter parameter = parameters[i];            String name = parameter.getName();            sb.append(name).append(&quot;:&quot;).append(args[i]).append(&quot;,&quot;);        }        if (sb.length() &gt; 0) {            sb.deleteCharAt(sb.lastIndexOf(&quot;,&quot;));        }        //执行结果        Object res;        try {            //执行目标方法，获取执行结果            res = joinPoint.proceed();            logger.info(&quot;调用{}.{}方法成功，参数为[{}]，返回结果[{}]&quot;, typeName, methodName, sb.toString(), JSONObject.toJSONString(res));        } catch (Exception e) {            logger.error(&quot;调用{}.{}方法发生异常&quot;, typeName, methodName);            //如果发生异常，则抛出异常            throw e;        } finally {            logger.info(&quot;调用{}.{}方法，耗时{}ms&quot;, typeName, methodName, (System.currentTimeMillis() - starTime));        }        //返回执行结果        return res;    }}</code></pre><p>定义完切面类后，需要在启动类添加启动AOP的注解。</p><pre><code class="java">@SpringBootApplication//添加此注解，开启AOP@EnableAspectJAutoProxypublic class UserApplication {    public static void main(String[] args) {        SpringApplication.run(UserApplication.class, args);    }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们再在Controller控制层增加一个有参数的接口。</p><pre><code class="java">@LogApi@RequestMapping(&quot;/get/{id}&quot;)public String get(@PathVariable(name = &quot;id&quot;) String id) throws Exception {    HashMap&lt;String, Object&gt; user = new HashMap&lt;&gt;();    user.put(&quot;id&quot;, id);    user.put(&quot;name&quot;, &quot;关之琳&quot;);    user.put(&quot;经典角色&quot;, &quot;十三姨&quot;);    return JSONObject.toJSONString(user);}</code></pre><p>启动项目，然后请求接口<code>list()</code>，我们可以看到控制台出现被调用方法的日志信息。</p><p><img src="https://static.lovebilibili.com/zhujie_7.png" srcset="/img/loading.gif" alt=""></p><p>请求有参数的接口<code>get()</code>，可以看到参数名称和参数值都被打印在控制台。</p><p><img src="https://static.lovebilibili.com/zhujie_8.png" srcset="/img/loading.gif" alt=""></p><p>这种记录接口请求参数和返回值的功能，在实际项目中基本上都会使用，因为这能利于系统的排错和性能调优等等。</p><p>我们也可以在这个例子中，学会使用注解和切面编程，可谓是一举两得！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>注解的使用能大大地减少开发的代码量，所以在实际项目的开发中会使用到非常多的注解。特别是做一些公共基础的功能，比如日志记录，事务管理，权限控制这些功能，使用注解就非常高效且优雅。</p><p>对于自定义注解，主要有三个步骤，<strong>定义注解，标记注解，解析注解</strong>，并不是很难。</p><p>这篇文章讲到这里了，感谢大家的阅读，希望看完这篇文章能有所收获！</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础不简单，讲一讲枚举</title>
    <link href="/2021/03/08/Java%E5%9F%BA%E7%A1%80%E4%B8%8D%E7%AE%80%E5%8D%95%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E6%9E%9A%E4%B8%BE/"/>
    <url>/2021/03/08/Java%E5%9F%BA%E7%A1%80%E4%B8%8D%E7%AE%80%E5%8D%95%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="什么是枚举"><a href="#什么是枚举" class="headerlink" title="什么是枚举"></a>什么是枚举</h1><p>枚举是JDK1.5新增的一种数据类型，是一种特殊的类，常用于表示一组常量，比如一年四季，12个月份，星期一到星期天，服务返回的错误码，结算支付的方式等等。枚举是使用enum关键字来定义。</p><h1 id="枚举的使用"><a href="#枚举的使用" class="headerlink" title="枚举的使用"></a>枚举的使用</h1><p>在使用枚举之前我们先探讨一个问题，为什么要使用枚举。</p><p>现在有个业务场景是结算支付，有支付宝和微信支付两种方式，1表示支付宝，2表示微信支付，还需要根据编码(1或2)获取相应的英文名，如果不用枚举，我们就要这样写。</p><pre><code class="java">public class PayTypeUtil {    //支付宝    private static final int ALI_PAY = 1;    //微信支付    private static final int WECHAT_PAY = 2;    //根据编码获取支付方式的名称    public String getPayName(int code) {        if (ALI_PAY == code) {            return &quot;Ali_Pay&quot;;        }        if (WECHAT_PAY == code) {            return &quot;Wechat_Pay&quot;;        }        return null;    }}</code></pre><p>如果这时，产品经理说要增加一个银联支付，就要加多if的判断，就会造成有多少种支付方式，就有多少个<code>if</code>，非常难看。</p><p>如果使用枚举，就变得很优雅，先看代码：</p><pre><code class="java">public enum PayTypeEnum {    /** 支付宝*/    ALI_PAY(1, &quot;ALI_PAY&quot;),    /** 微信支付*/    WECHAT_PAY(2, &quot;WECHAT_PAY&quot;);    private int code;    private String describe;    PayTypeEnum(int code, String describe) {        this.code = code;        this.describe = describe;    }    //根据编码获取支付方式    public PayTypeEnum find(int code) {        for (PayTypeEnum payTypeEnum : values()) {            if (payTypeEnum.getCode() == code) {                return payTypeEnum;            }        }        return null;    }    //getter、setter方法}</code></pre><p>当我们需要扩展，只需要定义多一个实例即可，其他代码都不用动，比如加多一个银联支付。</p><pre><code class="java">/** 支付宝*/ALI_PAY(1, &quot;ALI_PAY&quot;),/** 微信支付*/WECHAT_PAY(2, &quot;WECHAT_PAY&quot;),//只需要加多一行代码即可完成扩展/** 银联支付*/UNION_PAY(3,&quot;UNION_PAY&quot;);</code></pre><p>一般在实际项目中，最多的写法就是这样，主要是简单明了，易于扩展。</p><p>第二种常见的用法是结合switch-case使用，比如我定义一个一年四季的枚举。</p><pre><code class="java">public enum Season {    //春    SPRING,    //夏    SUMMER,     //秋    AUTUMN,     //冬    WINTER;}</code></pre><p>然后结合switch使用。</p><pre><code class="java">public static void main(String[] args) throws Exception{    doSomething(Season.SPRING);}private static void doSomething(Season season){    switch (season){        case SPRING:            System.out.println(&quot;不知细叶谁裁出，二月春风似剪刀&quot;);            break;        case SUMMER:            System.out.println(&quot;接天莲叶无穷碧，映日荷花别样红&quot;);            break;        case AUTUMN:            System.out.println(&quot;停车坐爱枫林晚，霜叶红于二月花&quot;);            break;        case WINTER:            System.out.println(&quot;梅花香自苦寒来，宝剑锋从磨砺出&quot;);            break;        default:            System.out.println(&quot;垂死病中惊坐起，笑问客从何处来&quot;);    }}</code></pre><p>可能很多人觉得直接用int，String类型配合switch使用就够了，为什么还要支持枚举，这样的设计是不是显得很多余，其实非也。</p><p>不妨反过来想，假如用1到4代表四季，接收的参数类型就是int，在没有提示的情况下，我们仅仅只知道数int类型是很难猜到需要传入数字的范围，字符串也是一样，如果不用枚举你是很难一眼看出需要传入什么参数，这才是最关键的。</p><p>如果使用枚举，那么问题就迎刃而解，当你调用doSomething()方法时，一看到枚举就知道传入的是哪几个参数，因为已经在枚举类里面定义好了。<strong>这对于项目交接，还有代码的可读性都是非常有利的</strong>。</p><p>这种限制不单止限制了调用方，也限制了传入的参数只能是定义好的枚举，不用担心传入的参数错误导致的程序错误。</p><p>所以枚举类使用得恰当，对于项目的可维护性是有很大提升的。</p><h1 id="枚举本身的方法"><a href="#枚举本身的方法" class="headerlink" title="枚举本身的方法"></a>枚举本身的方法</h1><p>首先我们先以上面的支付类型枚举PayTypeEnum为例子，看看有哪些自带的方法。</p><h2 id="valueOf-方法"><a href="#valueOf-方法" class="headerlink" title="valueOf()方法"></a>valueOf()方法</h2><p>这是一个静态方法，传入一个字符串(枚举的名称)，获取枚举类。如果传入的名称不存在，则报错。</p><pre><code class="java">public static void main(String[] args) throws Exception{    System.out.println(PayTypeEnum.valueOf(&quot;ALI_PAY&quot;));    System.out.println(PayTypeEnum.valueOf(&quot;HUAWEI_PAY&quot;));}</code></pre><p><img src="https://static.lovebilibili.com/enum_1.png" srcset="/img/loading.gif" alt=""></p><h2 id="values-方法"><a href="#values-方法" class="headerlink" title="values()方法"></a>values()方法</h2><p>返回包含枚举类中所有枚举数据的一个数组。</p><pre><code class="java">public static void main(String[] args) throws Exception {    PayTypeEnum[] payTypeEnums = PayTypeEnum.values();    for (PayTypeEnum payTypeEnum : payTypeEnums) {        System.out.println(&quot;code: &quot; + payTypeEnum.getCode() + &quot;,describe: &quot; + payTypeEnum.getDescribe());    }}</code></pre><p><img src="https://static.lovebilibili.com/enum_2.png" srcset="/img/loading.gif" alt=""></p><h2 id="ordinal-方法"><a href="#ordinal-方法" class="headerlink" title="ordinal()方法"></a>ordinal()方法</h2><p>默认情况下，枚举类会给定义的枚举提供一个默认的次序，ordinal()方法就可以返回枚举的次序。</p><pre><code class="java">public static void main(String[] args) throws Exception {    PayTypeEnum[] payTypeEnums = PayTypeEnum.values();    for (PayTypeEnum payTypeEnum : payTypeEnums) {        System.out.println(&quot;ordinal: &quot; + payTypeEnum.ordinal() + &quot;, Enum: &quot; + payTypeEnum);    }}/**ordinal: 0, Enum: ALI_PAYordinal: 1, Enum: WECHAT_PAYordinal: 2, Enum: UNION_PAY*/</code></pre><h2 id="name-、toString-方法"><a href="#name-、toString-方法" class="headerlink" title="name()、toString()方法"></a>name()、toString()方法</h2><p>返回定义枚举用的名称。</p><pre><code class="java">public static void main(String[] args) throws Exception {    for (Season season : Season.values()) {        System.out.println(season.name());    }    for (Season season : Season.values()) {        System.out.println(season.toString());    }}</code></pre><p>输出结果都是一样的：</p><pre><code class="java">SPRINGSUMMERAUTUMNWINTER</code></pre><p>为什么？因为底层代码是一样，返回的是name。</p><pre><code class="java">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable {    public final String name() {        return name;    }    public String toString() {        return name;    }}</code></pre><p>区别在于toString()方法没有被final修饰，可以重写，name()方法不能重写。</p><h2 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h2><p>因为枚举类实现了Comparable接口，所以必须重写compareTo()方法，比较的是枚举的次序，也就是ordinal，源码如下：</p><pre><code class="java">public final int compareTo(E o) {    Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;    Enum&lt;E&gt; self = this;    if (self.getClass() != other.getClass() &amp;&amp; // optimization        self.getDeclaringClass() != other.getDeclaringClass())        throw new ClassCastException();    return self.ordinal - other.ordinal;}</code></pre><p>因为实现Comparable接口，所以可以用来排序，比如这样：</p><pre><code class="java">public static void main(String[] args) throws Exception {    //这里是乱序的枚举数组    Season[] seasons = new Season[]{Season.WINTER, Season.AUTUMN, Season.SPRING, Season.SUMMER};    //调用sort方法排序，按默认次序排序    Arrays.sort(seasons);    for (Season season : seasons) {        System.out.println(season);    }}</code></pre><p>输出结果，按照默认次序排序：</p><pre><code class="java">SPRINGSUMMERAUTUMNWINTER</code></pre><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>以枚举Season为例，分析一下枚举的底层。表面上看，一个枚举很简单：</p><pre><code class="java">public enum Season {    //春    SPRING,    //夏    SUMMER,    //秋    AUTUMN,    //冬    WINTER;}</code></pre><p>实际上编译器在编译的时候做了很多动作，我们使用<code>javap -v</code>对Season.class文件反编译，可以看到很多细节。</p><p>首先我们看到枚举是继承了抽象类Enum的类。</p><pre><code class="java">Season extends java.lang.Enum&lt;Season&gt;</code></pre><p>第二，通过一段静态代码块初始化枚举。</p><pre><code class="java">  static {};    descriptor: ()V    flags: ACC_STATIC    Code:      stack=4, locals=0, args_size=0         0: new           #4                  // class io/github/yehongzhi/user/redisLock/Season         3: dup         4: ldc           #7                  // String SPRING         6: iconst_0         7: invokespecial #8                  // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V        10: putstatic     #9                  // Field SPRING:Lio/github/yehongzhi/user/redisLock/Season;        13: new           #4                  // class io/github/yehongzhi/user/redisLock/Season        16: dup        17: ldc           #10                 // String SUMMER        19: iconst_1        20: invokespecial #8                  // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V        23: putstatic     #11                 // Field SUMMER:Lio/github/yehongzhi/user/redisLock/Season;        26: new           #4                  // class io/github/yehongzhi/user/redisLock/Season        29: dup        30: ldc           #12                 // String AUTUMN        32: iconst_2        33: invokespecial #8                  // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V        36: putstatic     #13                 // Field AUTUMN:Lio/github/yehongzhi/user/redisLock/Season;        39: new           #4                  // class io/github/yehongzhi/user/redisLock/Season        42: dup        43: ldc           #14                 // String WINTER        45: iconst_3        46: invokespecial #8                  // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V        49: putstatic     #15                 // Field WINTER:Lio/github/yehongzhi/user/redisLock/Season;        52: iconst_4        53: anewarray     #4                  // class io/github/yehongzhi/user/redisLock/Season        56: dup        57: iconst_0        58: getstatic     #9                  // Field SPRING:Lio/github/yehongzhi/user/redisLock/Season;        61: aastore        62: dup        63: iconst_1        64: getstatic     #11                 // Field SUMMER:Lio/github/yehongzhi/user/redisLock/Season;        67: aastore        68: dup        69: iconst_2        70: getstatic     #13                 // Field AUTUMN:Lio/github/yehongzhi/user/redisLock/Season;        73: aastore        74: dup        75: iconst_3        76: getstatic     #15                 // Field WINTER:Lio/github/yehongzhi/user/redisLock/Season;        79: aastore        80: putstatic     #1                  // Field $VALUES:[Lio/github/yehongzhi/user/redisLock/Season;        83: return</code></pre><p>这段静态代码块的作用就是生成四个静态常量字段的值，还生成了$VALUES字段，用于保存枚举类定义的枚举常量。相当于执行了以下代码：</p><pre><code class="java">Season SPRING = new Season1();Season SUMMER = new Season2();Season AUTUMN = new Season3();Season WINTER = new Season4();Season[] $VALUES = new Season[4];$VALUES[0] = SPRING;$VALUES[1] = SUMMER;$VALUES[2] = AUTUMN;$VALUES[3] = WINTER;</code></pre><p>第三个，关于values()方法，这是一个静态方法，作用是返回该枚举类的数组，底层实现原理，其实是这样的。</p><pre><code class="java">public static io.github.yehongzhi.user.redisLock.Season[] values();    Code:       0: getstatic     #1                  // Field $VALUES:[Lio/github/yehongzhi/user/redisLock/Season;       3: invokevirtual #2                  // Method &quot;[Lio/github/yehongzhi/user/redisLock/Season;&quot;.clone:()Ljava/lang/Object;       6: checkcast     #3                  // class &quot;[Lio/github/yehongzhi/user/redisLock/Season;&quot;       9: areturn</code></pre><p>其实是将静态代码块初始化的$VALUES数组克隆一份，然后强转成Season[]返回。相当于这样：</p><pre><code class="java">public static Season[] values(){    return (Season[])$VALUES.clone();}</code></pre><p>所以表面上，只是加了一个enum关键字定义枚举，但是底层一旦确认是枚举类，则会由编译器对枚举类进行特殊处理，通过静态代码块初始化枚举，只要是枚举就一定会提供values()方法。</p><p>通过反编译我们也知道所有的枚举父类都是抽象类Enum，所以Enum有的成员变量，实现的接口，子类也会有。</p><p>所以只要是枚举都会有name，ordinal这两个字段，并且我们看Enum的构造器。</p><pre><code class="java">/*** Sole constructor.  Programmers cannot invoke this constructor.* It is for use by code emitted by the compiler in response to* enum type declarations.*/protected Enum(String name, int ordinal) {    this.name = name;    this.ordinal = ordinal;}</code></pre><p>翻译一下上面那段英文，意思大概是：唯一的构造器，程序员没法调用此构造器，它是供编译器响应枚举类型声明而使用的。得出结论，枚举实例的创建也是由编译器完成的。</p><h1 id="枚举实现单例"><a href="#枚举实现单例" class="headerlink" title="枚举实现单例"></a>枚举实现单例</h1><p>很多人都说，枚举类是最好的实现单例的一种方式，因为枚举类的单例是线程安全，并且是唯一一种不会被破坏的单例模式实现。也就是不能通过反射的方式创建实例，保证了整个应用中只有一个实例，非常硬核的单例。</p><pre><code class="java">public class SingletonObj {    //内部类使用枚举    private enum SingletonEnum {        INSTANCE;        private SingletonObj singletonObj;        //在枚举类的构造器里初始化singletonObj        SingletonEnum() {            singletonObj = new SingletonObj();        }        private SingletonObj getSingletonObj() {            return singletonObj;        }    }    //对外部提供的获取单例的方法    public static SingletonObj getInstance() {        //获取单例对象，返回        return SingletonEnum.INSTANCE.getSingletonObj();    }    //测试    public static void main(String[] args) {        SingletonObj a = SingletonObj.getInstance();        SingletonObj b = SingletonObj.getInstance();        System.out.println(a == b);//true    }}</code></pre><p>假如有人想通过反射创建枚举类呢，我们以Season枚举为例。</p><pre><code class="java">public static void main(String[] args) throws Exception {    Constructor&lt;Season&gt; constructor = Season.class.getDeclaredConstructor(String.class, int.class);    constructor.setAccessible(true);    //通过反射调用构造器，创建枚举    Season season = constructor.newInstance(&quot;NEW_SPRING&quot;, 4);    System.out.println(season);}</code></pre><p>然后就会报错，因为不允许对枚举的构造器使用反射调用。</p><p><img src="https://static.lovebilibili.com/enum_3.png" srcset="/img/loading.gif" alt=""></p><p>查看源码，就可以看到，有个专门针对枚举的<code>if</code>判断。</p><pre><code class="java">public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException,IllegalArgumentException, InvocationTargetException {    if (!override) {        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {            Class&lt;?&gt; caller = Reflection.getCallerClass();            checkAccess(caller, clazz, null, modifiers);        }    }    //判断是否是枚举，如果是枚举的话，报、抛出异常    if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)        //抛出异常，不能通过反射创建枚举        throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);    ConstructorAccessor ca = constructorAccessor;   // read volatile    if (ca == null) {        ca = acquireConstructorAccessor();    }    @SuppressWarnings(&quot;unchecked&quot;)    T inst = (T) ca.newInstance(initargs);    return inst;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>枚举看起来好像是很小一部分的知识，其实深入挖掘的话，我们会发现还是有很多地方值得学习的。第一点使用枚举定义常量更容易扩展，而且代码可读性更强，维护性更好。接着第二点是需要了解枚举自带的方法。第三点通过反编译，探索编译器在编译阶段为枚举做了什么事情。最后再讲一下枚举实现单例模式的例子。</p><p>这篇文章讲到这里了，感谢大家的阅读，希望看完这篇文章能有所收获！</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis如何实现分布式锁</title>
    <link href="/2021/02/22/Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2021/02/22/Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果在一个分布式系统中，我们从数据库中读取一个数据，然后修改保存，这种情况很容易遇到并发问题。因为读取和更新保存不是一个原子操作，在并发时就会导致数据的不正确。这种场景其实并不少见，比如电商秒杀活动，库存数量的更新就会遇到。如果是单机应用，直接使用本地锁就可以避免。如果是分布式应用，本地锁派不上用场，这时就需要引入分布式锁来解决。</p><p>由此可见分布式锁的目的其实很简单，就是<strong>为了保证多台服务器在执行某一段代码时保证只有一台服务器执行</strong>。</p><p>为了保证分布式锁的可用性，至少要确保锁的实现要同时满足以下几点：</p><ul><li>互斥性。在任何时刻，保证只有一个客户端持有锁。</li><li>不能出现死锁。如果在一个客户端持有锁的期间，这个客户端崩溃了，也要保证后续的其他客户端可以上锁。</li><li>保证上锁和解锁都是同一个客户端。</li></ul><p>一般来说，实现分布式锁的方式有以下几种：</p><ul><li>使用MySQL，基于唯一索引。</li><li>使用ZooKeeper，基于临时有序节点。</li><li><strong>使用Redis，基于setnx命令</strong>。</li></ul><p>本篇文章主要讲解Redis的实现方式。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>Redis实现分布式锁主要利用Redis的<code>setnx</code>命令。<code>setnx</code>是<code>SET if not exists</code>(如果不存在，则 SET)的简写。</p><pre><code class="shell">127.0.0.1:6379&gt; setnx lock value1 #在键lock不存在的情况下，将键key的值设置为value1(integer) 1127.0.0.1:6379&gt; setnx lock value2 #试图覆盖lock的值，返回0表示失败(integer) 0127.0.0.1:6379&gt; get lock #获取lock的值，验证没有被覆盖&quot;value1&quot;127.0.0.1:6379&gt; del lock #删除lock的值，删除成功(integer) 1127.0.0.1:6379&gt; setnx lock value2 #再使用setnx命令设置，返回0表示成功(integer) 1127.0.0.1:6379&gt; get lock #获取lock的值，验证设置成功&quot;value2&quot;</code></pre><p>上面这几个命令就是最基本的用来完成分布式锁的命令。</p><p>加锁：使用<code>setnx key value</code>命令，如果key不存在，设置value(加锁成功)。如果已经存在lock(也就是有客户端持有锁了)，则设置失败(加锁失败)。</p><p>解锁：使用<code>del</code>命令，通过删除键值释放锁。释放锁之后，其他客户端可以通过<code>setnx</code>命令进行加锁。</p><p>key的值可以根据业务设置，比如是用户中心使用的，可以命令为<code>USER_REDIS_LOCK</code>，value可以使用uuid保证唯一，用于标识加锁的客户端。保证加锁和解锁都是同一个客户端。</p><p>那么接下来就可以写一段很简单的加锁代码：</p><pre><code class="java">private static Jedis jedis = new Jedis(&quot;127.0.0.1&quot;);private static final Long SUCCESS = 1L;/**  * 加锁  */public boolean tryLock(String key, String requestId) {    //使用setnx命令。    //不存在则保存返回1，加锁成功。如果已经存在则返回0，加锁失败。    return SUCCESS.equals(jedis.setnx(key, requestId));}//删除key的lua脚本，先比较requestId是否相等，相等则删除private static final String DEL_SCRIPT = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;/**  * 解锁  */public boolean unLock(String key, String requestId) {    //删除成功表示解锁成功    Long result = (Long) jedis.eval(DEL_SCRIPT, Collections.singletonList(key), Collections.singletonList(requestId));    return SUCCESS.equals(result);}</code></pre><p><img src="https://static.lovebilibili.com/redis_lock_1.png" srcset="/img/loading.gif" alt=""></p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>这仅仅满足上述的第一个条件和第三个条件，保证上锁和解锁都是同一个客户端，也保证只有一个客户端持有锁。</p><p>但是第二点没法保证，因为如果一个客户端持有锁的期间突然崩溃了，就会导致无法解锁，最后导致出现死锁的现象。</p><p><img src="https://static.lovebilibili.com/redis_lock_2.png" srcset="/img/loading.gif" alt=""></p><p>所以要有个超时的机制，在设置key的值时，需要加上有效时间，如果有效时间过期了，就会自动失效，就不会出现死锁。然后加锁的代码就会变成这样。</p><pre><code class="java">public boolean tryLock(String key, String requestId, int expireTime) {    //使用jedis的api，保证原子性    //NX 不存在则操作 EX 设置有效期，单位是秒    String result = jedis.set(key, requestId, &quot;NX&quot;, &quot;EX&quot;, expireTime);    //返回OK则表示加锁成功    return &quot;OK&quot;.equals(result);}</code></pre><p><img src="https://static.lovebilibili.com/redis_lock_3.png" srcset="/img/loading.gif" alt=""></p><p>但是聪明的同学肯定会问，有效时间设置多长，假如我的业务操作比有效时间长，我的业务代码还没执行完就自动给我解锁了，不就完蛋了吗。</p><p>这个问题就有点棘手了，在网上也有很多讨论，第一种解决方法就是靠程序员自己去把握，预估一下业务代码需要执行的时间，然后设置有效期时间比执行时间长一些，保证不会因为自动解锁影响到客户端业务代码的执行。</p><p>但是这并不是万全之策，比如网络抖动这种情况是无法预测的，也有可能导致业务代码执行的时间变长，所以并不安全。</p><p>有一种方法比较靠谱一点，就是给锁续期。在Redisson框架实现分布式锁的思路，就使用watchDog机制实现锁的续期。当加锁成功后，同时开启守护线程，默认有效期是30秒，每隔10秒就会给锁续期到30秒，只要持有锁的客户端没有宕机，就能保证一直持有锁，直到业务代码执行完毕由客户端自己解锁，如果宕机了自然就在有效期失效后自动解锁。</p><p><img src="https://static.lovebilibili.com/redis_lock_4.png" srcset="/img/loading.gif" alt=""></p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>但是聪明的同学可能又会问，你这个锁只能加一次，不可重入。可重入锁意思是在外层使用锁之后，内层仍然可以使用，那么可重入锁的实现思路又是怎么样的呢？</p><p>在Redisson实现可重入锁的思路，使用Redis的哈希表存储可重入次数，当加锁成功后，使用<code>hset</code>命令，value(重入次数)则是1。</p><pre><code class="java">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot; +&quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &quot; +&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +&quot;return nil; &quot; +&quot;end; &quot;</code></pre><p>如果同一个客户端再次加锁成功，则使用<code>hincrby</code>自增加一。</p><pre><code class="java">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot; +&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot; +&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +&quot;return nil; &quot; +&quot;end; &quot; +&quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;</code></pre><p><img src="https://static.lovebilibili.com/redis_lock_6.png" srcset="/img/loading.gif" alt=""></p><p>解锁时，先判断可重复次数是否大于0，大于0则减一，否则删除键值，释放锁资源。</p><pre><code class="java">protected RFuture&lt;Boolean&gt; unlockInnerAsync(long threadId) {    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) == 0) then &quot; +&quot;return nil;&quot; +&quot;end; &quot; +&quot;local counter = redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1); &quot; +&quot;if (counter &gt; 0) then &quot; +&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); &quot; +&quot;return 0; &quot; +&quot;else &quot; +&quot;redis.call(&#39;del&#39;, KEYS[1]); &quot; +&quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot; +&quot;return 1; &quot;+&quot;end; &quot; +&quot;return nil;&quot;,Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));}</code></pre><p><img src="https://static.lovebilibili.com/redis_lock_7.png" srcset="/img/loading.gif" alt=""></p><p>为了保证操作原子性，加锁和解锁操作都是使用lua脚本执行。</p><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>上面的加锁方法是加锁后立即返回加锁结果，如果加锁失败的情况下，总不可能一直轮询尝试加锁，直到加锁成功为止，这样太过耗费性能。所以需要利用发布订阅的机制进行优化。</p><p>步骤如下：</p><p>当加锁失败后，订阅锁释放的消息，自身进入阻塞状态。</p><p>当持有锁的客户端释放锁的时候，发布锁释放的消息。</p><p>当进入阻塞等待的其他客户端收到锁释放的消息后，解除阻塞等待状态，再次尝试加锁。</p><p><img src="https://static.lovebilibili.com/redis_lock_5.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上的实现思路仅仅考虑在单机版Redis上，如果是集群版Redis需要考虑的问题还要再多一点。Redis由于他的高性能读写能力，所以在并发高的场景下使用Redis分布式锁会多一点。</p><p>问题一，二，三其实就是redis分布式锁不断改良发展的过程，第一个问题是设置有效期防止死锁，并且引入守护线程给锁续期，第二个问题是支持可重入锁，第三个问题是加锁失败后阻塞等待，等锁释放后再次尝试加锁。Redisson框架解决这三个问题的思路也非常值得学习。</p><p>这篇文章就写到这里了，非常感谢大家的阅读，希望看完之后能得到一些启发和收获。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典leetcode算法题分享(字符串)</title>
    <link href="/2021/02/13/%E7%BB%8F%E5%85%B8leetcode%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E4%BA%AB-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/02/13/%E7%BB%8F%E5%85%B8leetcode%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E4%BA%AB-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很多人做leetcode题目找不到方向，或者说很难持之以恒，我这里推荐一种方法，从简单难度开始刷，刷完这个标签的简单难度，再换一个标签，这样循序渐进，把做题的量慢慢提高，还有难度逐渐加大。<strong>对于初学者，最重要是趁热打铁，而不是东打一枪西放一炮，趁热打铁才能形成做题的思路</strong>。</p><p>还有一个问题是，一开始做题往往我们没有思路，只会想到暴力解法，效率只有惨淡的5%，遇到这种情况是很正常的，因为还没开始形成解题的思维。我们可以先看看题解，看完思路再自己写，千万不要照抄，要自己想出来才能锻炼编程能力。</p><p>所谓<code>talking is cheap, show me code</code>，那么我们就从字符串开始吧！</p><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><p><strong>题目</strong>：</p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>1.左括号必须用相同类型的右括号闭合。<br>2.左括号必须以正确的顺序闭合。</p><p><strong>解题思路</strong>：</p><p>这道题可以应用于校验JSON格式的括号是否正确。从题目上可以知道有效的括号是有左括号，也会有相同类型的右括号，并且按照正确的顺序闭合。</p><p>那么应该采取什么方法校验呢？我马上想到的是通过成对成对地删除有效的括号，从最里面一直往外层删除，最后能删除完，变成空字符串就代表是有效括号返回true，否则返回false。</p><p>代码如下：</p><pre><code class="java">public boolean isValid(String s) {    if (s == null) {        return false;    }    if (&quot;&quot;.equals(s)) {        return true;    }    //去掉空格字符    s = s.replace(&quot; &quot;, &quot;&quot;);    //如果是长度是奇数，直接返回false    if (s.length() % 2 != 0) {        return false;    }    //如果长度等于0表示是有效的括号，返回true，否则返回false    return dealString(s) == 0;}private int dealString(String s) {    if (s.length() == 0) {        return 0;    }    for (int i = 0; i &lt; s.length() - 1; i++) {        //获取相邻的两个字符        String str = String.valueOf(s.charAt(i)) + s.charAt(i + 1);        if (&quot;{}&quot;.equals(str) || &quot;[]&quot;.equals(str) || &quot;()&quot;.equals(str)) {            //如果是有效的括号就删除            int index = s.indexOf(str);            s = s.substring(0, index) + s.substring(index + 2);            //删除后的字符串，再递归继续删除            return dealString(s);        }    }    return s.length();}</code></pre><p>一写完代码，感觉思路清晰，代码整洁，还使用了递归，简直so easy！</p><p>然而一运行…成年人的崩溃就在一瞬间！</p><p><img src="https://static.lovebilibili.com/string_sf_1.png" srcset="/img/loading.gif" alt=""></p><p>为什么会这么低的效率呢，其实想想就知道，我每次遍历字符串就只删一个有效的括号，如果出现类似这种”[[{}{}{}{}{}{}]]”，就会遍历非常多次！所以不能这样玩！</p><p>怎么删效率比较高呢？最好是不要重复去遍历，一次遍历删完效率是最高的。</p><p>关键是怎么找到<strong>最里层</strong>的有效括号，其实就是找到第一个右括号，然后判断左边的括号是否能匹配，能匹配的话就是最里层的有效括号，然后删除掉。删除后，因为字符串的长度变短了两位，所以我们把指针往左边移动两位即可。这样遍历下来，就只会遍历一次。最后还是判断字符串的长度。</p><p>代码如下：</p><pre><code class="java">public boolean isValid(String s) {    if (s == null) {        return false;    }    if (&quot;&quot;.equals(s)) {        return true;    }    //去掉空格字符    s = s.replace(&quot; &quot;, &quot;&quot;);    //如果是长度是奇数，直接返回false    if (s.length() % 2 != 0) {        return false;    }    StringBuilder toCheck = new StringBuilder(s);    for (int i = 0; i &lt; toCheck.length(); i++) {        //获取当前的字符        char current = toCheck.charAt(i);        //判断是右边的括号才进行处理        if (current == &#39;)&#39; || current == &#39;]&#39; || current == &#39;}&#39;) {            //如果第一个符号就是右括号，直接返回false            if (i == 0) {                return false;            }            //如果右边的括号和左边相邻的括号可以匹配，直接删除，并且指针往左边移动两位            if (isPair(toCheck.charAt(i - 1), current)) {                toCheck.delete(i - 1, i + 1);                i -= 2;            }        }    }    return toCheck.length() == 0;}private boolean isPair(char a, char b) {    if (b == &#39;)&#39;) {        return a == &#39;(&#39;;    }    if (b == &#39;]&#39;) {        return a == &#39;[&#39;;    }    if (b == &#39;}&#39;) {        return a == &#39;{&#39;;    }    return false;}</code></pre><p><img src="https://static.lovebilibili.com/string_sf_2.png" srcset="/img/loading.gif" alt=""></p><p>执行用时2ms，还不错，那么这题就算pass了！</p><p>当然除了我说的这种方式之外，题解里有大佬是使用栈来解决，大家有兴趣可以看看。</p><p><img src="https://static.lovebilibili.com/string_sf_3.png" srcset="/img/loading.gif" alt=""></p><h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h1><p><strong>题目</strong>：</p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p><strong>解题思路</strong>：</p><p>一看到这道题，直呼是送分题，这反转字符串不就是JavaAPI就有了吗，于是乎直接大胆的，两行代码搞定，好家伙！一下子重拾回作为程序员的信心！</p><p>代码如下：</p><pre><code class="java">public void reverseString(char[] s) {    char[] chars = new StringBuilder(new String(s)).reverse().toString().toCharArray();    System.arraycopy(chars, 0, s, 0, chars.length);}</code></pre><p>但是效率呢？成年人的崩溃往往就在一瞬间！</p><p><img src="https://static.lovebilibili.com/string_sf_4.png" srcset="/img/loading.gif" alt=""></p><p>用了2ms，仅仅击败了9.82%的用户，证明有更快的解法。</p><p>而且题目要求原地修改输入数组、使用 O(1) 的额外空间解决，所以上面的解法不符合题目要求。如果不使用额外空间，最直接的方式马上想到头尾交换，第二位跟倒数第二位交换，一直交换到中间，最后整个char[]数组就反转过来了。</p><p>代码如下：</p><pre><code class="java">public void reverseString(char[] s) {    //如果长度小于2，直接返回    if (s.length &lt; 2) {        return;    }    //右边索引，从末尾开始    int r = s.length - 1;    //左边索引，从0开始    int l = 0;    //如果左边的索引值小于右边的索引值就循环，否则跳出循环    while (l &lt; r) {        //交换值        char temp = s[l];        s[l] = s[r];        s[r] = temp;        //左右索引向中间移动        l++;        r--;    }}</code></pre><p><img src="https://static.lovebilibili.com/string_sf_5.png" srcset="/img/loading.gif" alt=""></p><p>这个效率不用芜湖，已经起飞了！上面那个算法其实就是双指针，应该是比较简单高效的解法之一了。</p><h1 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387.字符串中的第一个唯一字符"></a>387.字符串中的第一个唯一字符</h1><p><strong>题目</strong>：</p><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p>示例：</p><pre><code class="java">s = &quot;leetcode&quot;返回 0s = &quot;loveleetcode&quot;返回 2</code></pre><p><strong>提示</strong>：你可以假定该字符串只包含小写字母。</p><p><strong>解题思路</strong>：</p><p>一看到不重复，二话不说直接想到HashMap，什么？还有顺序，那就用LinkedHashMap，key保存字符，value保存出现的次数，遍历完字符串之后，找出第一个不重复的字符即可。</p><p>不多哔哔，上代码！</p><pre><code class="java">public int firstUniqChar(String s) {    char[] chars = s.toCharArray();    Map&lt;Character, Integer&gt; map = new LinkedHashMap&lt;&gt;();    //统计出现的次数    for (Character ch : chars) {        Integer count = map.get(ch);        if (count == null) {            map.put(ch, 1);        } else {            count++;            map.put(ch, count);        }    }    //找出第一个出现不重复的字符    for (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) {        Integer count = entry.getValue();        if (count == 1) {            Character ch = entry.getKey();            //返回下标            return s.indexOf(ch);        }    }    return -1;}</code></pre><p>看看效率如何？38ms！成年人的崩溃往往就在一瞬间…</p><p><img src="https://static.lovebilibili.com/string_sf_6.png" srcset="/img/loading.gif" alt=""></p><p>思路是没错的，用哈希表解决，但是没有利用上提示，提示说只有小写字母，小写字母只有26个，所以使用一个长度为26的数组作为哈希表即可，使用Map集合的话，put方法里面的逻辑非常多，会浪费性能。</p><p>所以我们把Map集合改成长度为26的数组即可，上代码：</p><pre><code class="java">public int firstUniqChar(String s) {    char[] chars = s.toCharArray();    int[] hashArray = new int[26];    //统计字符出现的次数    for (Character ch : chars) {        hashArray[ch - &#39;a&#39;]++;    }    //找出只出现一次的字符，然后返回下标    for (int i = 0; i &lt; chars.length; i++) {        Character ch = chars[i];        int count = hashArray[ch - &#39;a&#39;];        if (count == 1) {            return i;        }    }    return -1;}</code></pre><p>不用说，效率肯定提升数倍，7ms！</p><p><img src="https://static.lovebilibili.com/string_sf_7.png" srcset="/img/loading.gif" alt=""></p><h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h1><p><strong>题目</strong>：</p><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明</strong>：本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1</strong>:</p><pre><code class="java">输入: &quot;A man, a plan, a canal: Panama&quot;输出: true</code></pre><p><strong>示例 2</strong>:</p><pre><code class="java">输入: &quot;race a car&quot;输出: false</code></pre><p><strong>解题思路</strong>：</p><p>什么是回文串呢，就是一个字符串从左往右读，然后从右往左读都是一样的，比如”aabaa”，也就是把字符串反转过来跟原来的字符串是相等的，就称为回文串。</p><p>题目说只考虑字母和数字字符，并且忽略大小写，然后验证是不是回文串。很简单啦，遍历字符串，然后根据题目过滤出字母和数字字符，然后拼接出新的字符串，最后反转对比一下，如果相等就返回true，不相等就返回false。</p><p>不多哔哔，直接上代码！</p><pre><code class="java">public boolean isPalindrome(String s) {    StringBuilder sb = new StringBuilder();    for (char c : s.toCharArray()) {        //只拼接数字和字母的字符        if (Character.isDigit(c) || Character.isLetter(c)) {            //如果是字母则全部转为小写            if (Character.isLetter(c)) {                c = Character.toLowerCase(c);            }            sb.append(c);        }    }    //反转字符串，验证是否是回文串    String s1 = sb.toString();    return s1.equals(sb.reverse().toString());}</code></pre><p>居然用时7ms，我不能接受！</p><p><img src="https://static.lovebilibili.com/string_sf_8.png" srcset="/img/loading.gif" alt=""></p><p>其实判断回文串根本没必要遍历完整个字符串，可以一边遍历一边判断的！</p><p>因为是对称的，所以利用双指针，一个指针从左往右，一个指针从右往左，左右两边取值，对比符合条件(数字或者字母)的字符，如果中途发现不相等直接返回false，如果遍历完都是相等的话，那就返回true。</p><p>废话不多说，直接看代码。</p><pre><code class="java">public boolean isPalindrome(String s) {    char[] chars = s.toCharArray();    int leftIndex = 0;    int rightIndex = chars.length - 1;    char left;    char right;    while (leftIndex &lt; rightIndex) {        //过滤掉不是数字或者字母的字符        while (leftIndex &lt; rightIndex &amp;&amp; !Character.isLetterOrDigit(chars[leftIndex])) {            leftIndex++;        }        //左边索引的值        left = chars[leftIndex];        //过滤掉不是数字或者字母的字符        while (leftIndex &lt; rightIndex &amp;&amp; !Character.isLetterOrDigit(chars[rightIndex])) {            rightIndex--;        }        //右边索引的值        right = chars[rightIndex];        //如果不相等则返回false        if (Character.toLowerCase(left) != Character.toLowerCase(right)) {            return false;        } else {            //如果相等则继续比较，左指针往右移，右指针往左移            leftIndex++;            rightIndex--;        }    }    return true;}</code></pre><p>桀桀桀，双指针的威力竟恐怖如斯！</p><p><img src="https://static.lovebilibili.com/string_sf_9.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面这四道题，表面看起来好像有点难度，实际上就是Paper Tiger(纸老虎)，没什么好怕的，做多了之后自然就有思路了。对于初学者，不要怕使用暴力解法，先用暴力解法找找感觉，找找思路，然后看看能不能优化一下暴力解法。</p><p>上面讲了四道关于字符串的算法题，因为不可能一篇文章讲完所有的题目，所以如果希望提高自己的编程能力，还需要自己到leetcode上做一做。</p><p>这篇文章就讲到这里，最后感谢大家的阅读，希望能给大家带来一些启发。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩转布隆过滤器，其实很简单</title>
    <link href="/2021/01/31/%E7%8E%A9%E8%BD%AC%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E5%85%B6%E5%AE%9E%E5%BE%88%E7%AE%80%E5%8D%95/"/>
    <url>/2021/01/31/%E7%8E%A9%E8%BD%AC%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E5%85%B6%E5%AE%9E%E5%BE%88%E7%AE%80%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi</a></p></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>布隆过滤器(BloomFilter)是由一个叫“布隆”的小伙子在1970年提出的，它是一个很长的二进制向量，主要<strong>用于判断一个元素是否在一个集合中</strong>。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在介绍原理之前，要先讲一下<strong>Hash函数</strong>的概念。</p><p>我们在Java中的HashMap，HashSet其实也接触过hashcode()这个函数，哈希函数是可以将任意大小的输入数据转换成特定大小的输出数据的函数，转换后的数据称为<strong>哈希值</strong>。</p><p>哈希函数有以下特点：</p><ul><li>如果根据同一个哈希函数得到的哈希值不同，那么这两个哈希值的原始输入值肯定不同。</li><li>如果根据同一个哈希函数得到的两个哈希值相等，两个哈希值的原始输入值有可能相等，有可能不相等。</li></ul><p>布隆过滤器是由一个很长的二进制向量和一系列的哈希函数组成。那么布隆过滤器是怎么判断一个元素是否在一个集合中的呢？</p><p>假设布隆过滤器的底层存储结构是一个长度为16的位数组，初始状态时，它的所有位置都设置为0。</p><p><img src="https://static.lovebilibili.com/redis_bl_01.png" srcset="/img/loading.gif" alt=""></p><p>当有变量添加到布隆过滤器中，通过K个映射函数将变量映射到位数组的K个点，并把这K个点的值设置为1(假设有三个映射函数)。</p><p><img src="https://static.lovebilibili.com/redis_bl_02.png" srcset="/img/loading.gif" alt=""></p><p>查询某个变量是否存在的时候，我们只需要通过同样的K个映射函数，找到对应的K个点，判断K个点上的值是否全都是1，<strong>如果全都是1则表示很可能存在</strong>，如果<strong>K个点上有任何一个是0则表示一定不存在</strong>。</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>第一个问题，为什么说全都是1的情况是很可能存在，而不是一定存在呢？</p><p>还记得前面说的哈希函数的特点，根据同一个哈希函数得到相同的哈希值，输入值不一定相等。类似于Java中两个对象的hashcode相等，但是不一定相等的道理。说白了，映射函数得到位数组上映射点全都是1，不一定是要查询的这个变量之前存进来时设置的，也有可能是其他变量映射的点。</p><p>所以这里引出了布隆过滤器的其中一个特点，<strong>存在一定的误判</strong>。</p><p>第二个问题，布隆过滤器能不能删除元素呢？</p><p>答案是不能的。因为在位数组上的同一个点有可能有多个输入值映射，如果删除了会影响布隆过滤器里其他元素的判断结果。</p><p><img src="https://static.lovebilibili.com/redis_bl_03.png" srcset="/img/loading.gif" alt=""></p><p>如上图，如果删除obj1，把4,7,15置为0，那么判断obj2是否存在时就会导致因为映射点7是0，结果判断obj2是不存在的，结果出错。</p><p>这是第二个特点，<strong>不能删除布隆过滤器里的元素。</strong></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p><strong>优点：</strong></p><ul><li>在空间和时间方面，都有着巨大的优势。因为不是存完整的数据，是一个二进制向量，能节省大量的内存空间，时间复杂度方面，是根据映射函数查询，假设有K个映射函数，那么时间复杂度就是O(K)。</li><li>因为存的不是元素本身，而是二进制向量，所以在一些对<strong>保密性</strong>要求严格的场景有一定优势。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>存在一定的误判。</strong>存进布隆过滤器里的元素越多，误判率越高。</li><li><strong>不能删除布隆过滤器里的元素。</strong>随着使用的时间越来越长，因为不能删除，存进里面的元素越来越多，占用内存越来越多，误判率越来越高，最后不得不重置。</li></ul><h1 id="应用于缓存穿透"><a href="#应用于缓存穿透" class="headerlink" title="应用于缓存穿透"></a>应用于缓存穿透</h1><p><strong>用于缓解缓存穿透。</strong>缓存穿透的问题主要是因为传进来的key在Redis中是不存在的，那么就会直接打在DB上，造成DB压力增大。</p><p><img src="https://static.lovebilibili.com/redis_hc_2.png" srcset="/img/loading.gif" alt=""></p><p>针对这种情况，可以在Redis前加上布隆过滤器，预先把数据库中的数据加入到布隆过滤器中，因为布隆过滤器的底层数据结构是一个二进制向量，所以占用的空间并不是很大。<strong>在查询Redis之前先通过布隆过滤器判断是否存在，如果不存在就直接返回，如果存在的话，按照原来的流程还是查询Redis，Redis不存在则查询DB</strong>。</p><p>这里主要利用的是<strong>布隆过滤器判断结果是不存在的话就一定不存在</strong>这一个特点，但是由于布隆过滤器有一定的误判，所以并不能说完全解决缓存穿透，但是能很大程度缓解缓存穿透的问题。</p><p><img src="https://static.lovebilibili.com/redis_bl_04.png" srcset="/img/loading.gif" alt=""></p><h1 id="布隆过滤器插件"><a href="#布隆过滤器插件" class="headerlink" title="布隆过滤器插件"></a>布隆过滤器插件</h1><p>我们知道布隆过滤器的底层原理之后，理论上是可以自己</p><p>在Redis4.0后，官方提供了布隆过滤器的插件功能，布隆过滤器可以作为一个插件加载到Redis服务器直接使用。</p><p>首先安装Redis，网上有很多安装教程，这里就不多赘述。这里我用的是Redis6.0.10版本。安装完Redis之后，下载插件，使用git命令拉取：</p><pre><code class="shell">git clone https://github.com/RedisBloom/RedisBloom.git</code></pre><p>拉取下来之后会得到一个RedisBloom的项目。</p><p><img src="https://static.lovebilibili.com/redis_bl_05.png" srcset="/img/loading.gif" alt=""></p><p>然后cd到文件夹/RedisBloom，使用make命令编译。</p><p><img src="https://static.lovebilibili.com/redis_bl_06.png" srcset="/img/loading.gif" alt=""></p><p>编译完成后生成一个redisbloom.so文件。</p><p><img src="https://static.lovebilibili.com/redis_bl_07.png" srcset="/img/loading.gif" alt=""></p><p>在启动Redis时，加载布隆过滤器模块到服务器中即可。</p><pre><code class="shell">./src/redis-server --loadmodule /usr/local/RedisBloom/redisbloom.so</code></pre><p>最后使用客户端测试一下。</p><pre><code class="she">redis-6.0.10]$ ./src/redis-cli 127.0.0.1:6379&gt; bf.add user sam(integer) 1127.0.0.1:6379&gt; bf.add user jack(integer) 1127.0.0.1:6379&gt; bf.exists user jack(integer) 1127.0.0.1:6379&gt; bf.exists user tom(integer) 0</code></pre><p>布隆过滤器的基本指令如下：</p><ul><li>bf.add 添加元素到布隆过滤器</li><li>bf.exists 判断元素是否在布隆过滤器</li><li>bf.madd 添加多个元素到布隆过滤器</li><li>bf.mexists 判断多个元素是否在布隆过滤器</li></ul><pre><code class="shell">127.0.0.1:6379&gt; bf.madd user mike rose1) (integer) 12) (integer) 1127.0.0.1:6379&gt; bf.mexists user blue mike1) (integer) 02) (integer) 1</code></pre><p>在实际开发中，一般都是使用Java程序操作Redis，不太可能直接使用命令行判断，Java程序怎么操作呢？</p><p>首先引入依赖，我使用的是SpringBoot2.0，所以引入依赖是3.15.0。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.redisson&lt;/groupId&gt;    &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.15.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>接着写个main方法示范一下。</p><pre><code class="java">public static void main(String[] args) throws Exception {    Config config = new Config();    config.useSingleServer().setAddress(&quot;redis://192.168.0.109:6379&quot;);    RedissonClient client = Redisson.create(config);    RBloomFilter&lt;String&gt; bloomFilter = client.getBloomFilter(&quot;user&quot;);    //尝试初始化，预计元素55000000，期望误判率0.03    bloomFilter.tryInit(55000000L, 0.03);    //添加元素到布隆过滤器中    bloomFilter.add(&quot;tom&quot;);    bloomFilter.add(&quot;mike&quot;);    bloomFilter.add(&quot;rose&quot;);    bloomFilter.add(&quot;blue&quot;);    System.out.println(&quot;布隆过滤器元素总数为：&quot; + bloomFilter.count());//布隆过滤器元素总数为：4    System.out.println(&quot;是否包含tom：&quot; + bloomFilter.contains(&quot;tom&quot;));//是否包含tom：true    System.out.println(&quot;是否包含lei：&quot; + bloomFilter.contains(&quot;lei&quot;));//是否包含lei：false    client.shutdown();}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>布隆过滤器有着明显的优缺点，所以在使用的时候需要充分地考虑场景，还是那句话，没有最好的技术，看菜下饭才是硬道理。除了在缓存穿透中使用之外，其实还可以使用于元素去重，web拦截器等等。</p><p>这篇文章就讲到这里，感谢大家的阅读，希望看完之后能有所收获。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是缓存雪崩，缓存击穿，缓存穿透</title>
    <link href="/2021/01/24/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    <url>/2021/01/24/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis作为目前使用最广泛的缓存，相信大家都不陌生。但是使用缓存并没有这么简单，还要考虑缓存雪崩，缓存击穿，缓存穿透的问题，什么是缓存雪崩，击穿，穿透呢，出现这些问题又怎么解决呢，接下来学习一下吧。</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p><strong>什么是缓存雪崩？</strong></p><p>当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。</p><p><img src="https://static.lovebilibili.com/redis_hc_1.png" srcset="/img/loading.gif" alt=""></p><p><strong>分析：</strong></p><p>造成缓存雪崩的关键在于在同一时间大规模的key失效。为什么会出现这个问题呢，有几种可能，第一种可能是Redis宕机，第二种可能是采用了相同的过期时间。搞清楚原因之后，那么有什么解决方案呢？</p><p><strong>解决方案：</strong></p><p>1、在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。</p><p>如果真的发生了缓存雪崩，有没有什么兜底的措施？</p><p>2、使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</p><p>3、提高数据库的容灾能力，可以使用分库分表，读写分离的策略。</p><p>4、为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。</p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p><strong>什么是缓存击穿？</strong></p><p>其实跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。</p><p><strong>分析：</strong></p><p>关键在于某个热点的key失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</p><p><strong>解决方案：</strong></p><p>1、上面说过了，如果业务允许的话，对于热点的key可以设置永不过期的key。</p><p>2、使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p><strong>什么是缓存穿透？</strong></p><p>我们使用Redis大部分情况都是通过Key查询对应的值，假如发送的请求传进来的key是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。</p><p><strong>分析：</strong></p><p>关键在于在Redis查不到key值，这和缓存击穿有根本的区别，区别在于<strong>缓存穿透的情况是传进来的key在Redis中是不存在的</strong>。假如有黑客传进大量的不存在的key，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示，要对调用方保持这种“不信任”的心态。</p><p><img src="https://static.lovebilibili.com/redis_hc_2.png" srcset="/img/loading.gif" alt=""></p><p><strong>解决方案：</strong></p><p>1、<strong>把无效的Key存进Redis中</strong>。如果Redis查不到数据，数据库也查不到，我们把这个Key值保存进Redis，设置value=”null”，当下次再通过这个Key查询时就不需要再查询数据库。这种处理方式肯定是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。</p><p>2、<strong>使用布隆过滤器</strong>。布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。</p><p><img src="https://static.lovebilibili.com/redis_hc_3.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这三个问题在使用Redis的时候是肯定会遇到的，而且是非常致命性的问题，所以在日常开发中一定要注意，每次使用Redis时，都要对其保持严谨的态度。还有一个需要注意的是要做好熔断，一旦出现缓存雪崩，击穿，穿透这种情况，至少还有熔断机制保护数据库不会被打死。</p><p>那么这篇文章就讲到这里了，感谢大家的阅读，希望看完之后能有所收获。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入探索Redis的五种基础数据类型</title>
    <link href="/2021/01/18/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Redis%E7%9A%84%E4%BA%94%E7%A7%8D%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/01/18/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Redis%E7%9A%84%E4%BA%94%E7%A7%8D%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis是一个<strong>开源</strong>的使用C语言编写、支持网络、可<strong>基于内存</strong>亦<strong>可持久化</strong>的日志型、<strong>Key-Value</strong>的NoSQL数据库。</p><p>一般来说，我们都是使用关系型数据库MySQL来存储数据，但是面对着流量高峰，会对MySQL造成巨大的压力，导致数据库性能很差，这时就要使用缓存中间件来降低数据库的压力，这是Redis最常见的使用场景。除了作为缓存使用之外，Redis还有很多使用场景，比如分布式锁，计数，队列等等。</p><p>所以Redis对于程序员来说可以算得上是必修课。</p><h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><p>安装Redis很简单，因为网上教程很多，这里就不再详细讲解，推荐看菜鸟教程：<a href="https://www.runoob.com/redis/redis-install.html" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-install.html</a></p><h1 id="Redis的特点"><a href="#Redis的特点" class="headerlink" title="Redis的特点"></a>Redis的特点</h1><p>要用好Redis，首先要明白它的特点：</p><ul><li><strong>读写速度快</strong>。redis官网测试读写能到10万左右每秒。速度快的原因这里简单说一下，第一是因为<strong>数据存储在内存中</strong>，我们知道机器访问内存的速度是远远大于访问磁盘的，其次是<strong>Redis采用单线程的架构</strong>，避免了上下文的切换和多线程带来的竞争，也就不存在加锁释放锁的操作，减少了CPU的消耗，第三点是<strong>采用了非阻塞IO多路复用机制</strong>。</li><li><strong>数据结构丰富</strong>。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构。这也是这篇文章要讲的。</li><li><strong>支持持久化</strong>。Redis提供了RDB和AOF两种持久化策略，能最大限度地保证Redis服务器宕机重启后数据不会丢失。</li><li><strong>支持高可用</strong>。可以使用主从复制，并且提供哨兵机制，保证服务器的高可用。</li><li><strong>客户端语言多</strong>。因为Redis受到社区和各大公司的广泛认可，所以客户端语言涵盖了所有的主流编程语言，比如Java，C，C++，PHP，NodeJS等等。</li></ul><h1 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h1><p>下面我们就学习Redis的数据结构，也是使用Redis要知道的最基础的知识。</p><p>Redis是一个Key-Value型的内存数据库，它所有的key都是字符串，而value常见的数据类型有五种：string，list，set，zset，hash。</p><p><img src="https://static.lovebilibili.com/redis_kv_01.png" srcset="/img/loading.gif" alt=""></p><p>Redis的这些数据结构，在底层都是使用redisObject来进行表示。redisObject中有三个重要的属性，分别是<strong>type、 encoding 和 ptr</strong>。</p><p><strong>type</strong>表示保存的value的类型。通常有以下几种，也就是常见的五种数据结构：</p><ul><li>字符串 REDIS_STRING</li><li>列表 REDIS_LIST</li><li>集合 REDIS_SET</li><li>有序集合 REDIS_ZSET</li><li>字典 REDIS_HASH</li></ul><p><strong>encoding</strong>表示保存的value的编码，通常有以下几种：</p><pre><code class="c">#define REDIS_ENCODING_RAW 0            // 编码为字符串#define REDIS_ENCODING_INT 1            // 编码为整数#define REDIS_ENCODING_HT 2             // 编码为哈希表#define REDIS_ENCODING_ZIPMAP 3         // 编码为 zipmap#define REDIS_ENCODING_LINKEDLIST 4     // 编码为双端链表#define REDIS_ENCODING_ZIPLIST 5        // 编码为压缩列表#define REDIS_ENCODING_INTSET 6         // 编码为整数集合#define REDIS_ENCODING_SKIPLIST 7       // 编码为跳跃表</code></pre><p><strong>ptr</strong>是一个指针，指向实际保存的value的数据结构。</p><p>这里要特别说明一下的是，数据类型和编码方式是有一定关系的，所以数据类型和编码方式是可以确定底层采用什么数据结构存储数据的。</p><p><img src="https://static.lovebilibili.com/redis_kv_02.png" srcset="/img/loading.gif" alt=""></p><h1 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string(字符串)"></a>string(字符串)</h1><p>这是redis中最常用的数据类型，字符串对象的 encoding 有三种，分别是：<strong>int、raw、embstr</strong>。</p><p>常用的命令有常用命令:  <strong>set、get、decr、incr、mget</strong> 等。</p><p>我们知道Redis是用C语言开发的，但是底层存储不是使用C语言的字符串类型，而是自己开发了一种数据类型SDS进行存储，SDS即<em>Simple Dynamic String</em> ，是一种动态字符串。我们可以在github找到源码。</p><pre><code class="c">struct sdshdr{ int len;/*字符串长度*/ int free;/*未使用的字节长度*/ char buf[];/*保存字符串的字节数组*/}</code></pre><p><img src="https://static.lovebilibili.com/redis_kv_03.png" srcset="/img/loading.gif" alt=""></p><p>SDS与C语言的字符串有什么区别呢？</p><ul><li>C语言获取字符串长度是从头到尾遍历，时间复杂度是O(n)，而SDS有len属性记录字符串长度，时间复杂度为O(1)。</li><li>避免缓冲区溢出。SDS在需要修改时，会先检查空间是否满足大小，如果不满足，则先扩展至所需大小再进行修改操作。</li><li>空间预分配。当SDS需要进行扩展时，Redis会为SDS分配好内存，并且根据特定的算法分配多余的free空间，避免了连续执行字符串添加带来的内存分配的消耗。</li><li>惰性释放。如果需要缩短字符串，不会立即回收多余的内存空间，而是用free记录剩余的空间，以备下次扩展时使用，避免了再次分配内存的消耗。</li><li>二进制安全。c语言在存储字符串时采用N+1的字符串数组，末尾使用’\0’标识字符串的结束，如果我们存储的字符串中间出现’\0’，那就会导致识别出错。而SDS因为记录了字符串的长度len，则没有这个问题。</li></ul><p>字符串类型的应用是非常广泛的，比如可以把对象转成JSON字符串存储到Redis中作为缓存，也可以使用decr、incr命令用于计数器的实现，又或者是用setnx命令为基础实现分布式锁等等。</p><p>需要注意的是：<strong>Redis 规定了字符串的长度不得超过 512 MB。</strong></p><h1 id="hash-字典"><a href="#hash-字典" class="headerlink" title="hash(字典)"></a>hash(字典)</h1><p>哈希对象的编码有两种，分别是：<strong>ziplist、hashtable</strong>。</p><p>当哈希对象保存的键值对数量小于 512，并且所有键值对的长度都小于 64 字节时，使用ziplist(压缩列表)存储；否则使用 hashtable 存储。</p><p>Redis中的hashtable跟Java中的HashMap类似，都是通过”数组+链表”的实现方式解决部分的哈希冲突。直接看源码定义。</p><pre><code class="c">typedf struct dict{    dictType *type;//类型特定函数，包括一些自定义函数，这些函数使得key和value能够存储    void *private;//私有数据    dictht ht[2];//两张hash表     int rehashidx;//rehash索引，字典没有进行rehash时，此值为-1    unsigned long iterators; //正在迭代的迭代器数量}dict;typedef struct dictht{     //哈希表数组     dictEntry **table;     //哈希表大小     unsigned long size;     //哈希表大小掩码，用于计算索引值     //总是等于 size-1     unsigned long sizemask;     //该哈希表已有节点的数量     unsigned long used; }dictht;typedf struct dictEntry{    void *key;//键    union{        void val;        unit64_t u64;        int64_t s64;        double d;    }v;//值    struct dictEntry *next；//指向下一个节点的指针}dictEntry;</code></pre><p>我们再看一个结构图就比较清楚了。</p><p><img src="https://static.lovebilibili.com/redis_kv_04.webp" srcset="/img/loading.gif" alt=""></p><p>下面讲一下扩容和收缩。当哈希表保存的键值太多或者太少时，就会通过rehash来进行相应的扩容和收缩。</p><p><strong>扩容和收缩的过程</strong>：</p><p>1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</p><p>2、重新利用哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</p><p>3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。</p><p>在redis中执行扩容和收缩的规则是：</p><ul><li><p>服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF (持久化)命令，并且负载因子大于等于1。</p></li><li><p>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF (持久化)命令，并且负载因子大于等于5。</p></li></ul><p>负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p><p><strong>渐进式rehash</strong></p><p>什么是渐进式，也就是说扩容和收缩不是一次性，集中式地完成，而是通过多次逐渐地完成的。为什么要采用这种方式呢？如果是几十个键值，那么rehash当然可以瞬间完成，如果是几十万，几百万的键值要一次性进行rehash，势必会导致redis性能严重下降，自然而然地redis开发者就想到采用渐进式rehash。过程如下：</p><p>在rehash时，会使用rehashidx字段保存迁移的进度，rehashidx为0表示迁移开始。</p><p>在迁移过程中ht[0]和ht[1]会同时保存数据，ht[0]指向旧哈希表，ht[1]指向新哈希表，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]的元素迁移到ht[1]中。</p><p>随着字典操作的不断执行，最终会在某个时间节点，ht[0]的所有键值都会被迁移到ht[1]中，rehashidx设置为-1，代表迁移完成。如果没有执行字典操作，redis也会通过定时任务去判断rehash是否完成，没有完成则继续rehash。</p><p>rehash完成后，ht[0]指向的旧表会被释放, 之后会将新表的持有权转交给ht[0], 再重置ht[1]指向NULL。</p><p><strong>渐进式rehash的优缺点</strong>：</p><p>优点是把rehash操作分散到每一个字典操作和定时函数上，避免了一次性集中式rehash带来的服务器压力。</p><p>缺点是在rehash期间需要使用两个hash表，占用内存稍大。</p><p>hash类型的常用命令有：hget、hset、hgetall 等。</p><h1 id="list-链表"><a href="#list-链表" class="headerlink" title="list(链表)"></a>list(链表)</h1><p>列表对象的编码有两种，分别是：ziplist、linkedlist。当列表的长度小于 512，并且所有元素的长度都小于 64 字节时，使用ziplist存储；否则使用 linkedlist 存储。</p><p>Redis中的linkedlist类似于Java中的LinkedList，是一个链表，底层的实现原理也和LinkedList类似。这意味着list的插入和删除操作效率会比较快，时间复杂度是O(1)。我们看源码：</p><pre><code class="c">typedef struct listNode {    struct listNode *prev;    struct listNode *next;    void *value;} listNode;typedef struct listIter {    listNode *next;    int direction;} listIter;typedef struct list {    listNode *head;    listNode *tail;    void *(*dup)(void *ptr);    void (*free)(void *ptr);    int (*match)(void *ptr, void *key);    unsigned long len;} list;</code></pre><p>我们可以看到，listNode就是链表中的节点元素，通过prev和next组成双向链表。</p><p><img src="https://static.lovebilibili.com/redis_kv_05.png" srcset="/img/loading.gif" alt=""></p><p>list则记录了头结点head，尾结点tail，还有链表长度len，match函数用于比较两个节点的值是否相等，操作起来更加方便。</p><p><img src="https://static.lovebilibili.com/redis_kv_06.png" srcset="/img/loading.gif" alt=""></p><p>list类型常用的命令有：lpush、rpush、lpop、rpop、lrange等。</p><h1 id="set-集合"><a href="#set-集合" class="headerlink" title="set(集合)"></a>set(集合)</h1><p>set类型的特点很简单，无序，不重复，跟Java的HashSet类似。它的编码有两种，分别是intset和hashtable。如果value可以转成整数值，并且长度不超过512的话就使用intset存储，否则采用hashtable。</p><p>hashtable在前面讲hash类型时已经讲过，这里的set集合采用的hashtable几乎一样，只是哈希表的value都是NULL。这个不难理解，比如用Java中的HashMap实现一个HashSet，我们只用HashMap的key就是了。</p><p>我们讲一讲intset，先看源码。</p><pre><code class="c">typedef struct intset{    uint32_t encoding;//编码方式    uint32_t length;//集合包含的元素数量    int8_t contents[];//保存元素的数组}intset;</code></pre><p>encoding有三种，分别是INTSET_ENC_INT16、INSET_ENC_INT32、INSET_ENC_INT64，代表着整数值的取值范围。Redis会根据添加进来的元素的大小，选择不同的类型进行存储，可以尽可能地节省内存空间。</p><p>length记录集合有多少个元素，这样获取元素个数的时间复杂度就是O(1)。</p><p>contents，存储数据的数组，数组按照从小到大有序排列，不包含任何重复项。</p><p><img src="https://static.lovebilibili.com/redis_kv_07.png" srcset="/img/loading.gif" alt=""></p><p>这里我们可能会提出疑问，如果一开始存的是INTSET_ENC_INT16(范围在-32,768~32,767)，如果这时添加了一个40000的数，怎么升级为INSET_ENC_INT32呢？</p><p>升级过程是这样的：</p><p>1、根据新元素的类型扩展数组contents的空间。</p><p>2、从尾部将数据插入。</p><p>3、根据新的编码格式重置之前的值，因为这时的contents存在着两种编码的值。从插入的数据的位置，也就是尾部，从后到前将之前的数据按照新的编码格式进行移动和设置。从后到前调整是为了防止数据被覆盖。</p><p>升级的优点在于，根据存储的数据大小选择合适的编码方式，节省了内存。</p><p>缺点在于，升级会消耗系统资源。而且升级是不可逆的，也就是一旦对数组进行升级，编码就会一直保持升级后的状态。</p><p>set数据类型常用的命令有：sadd、spop、smembers、sunion等等。</p><p>Redis为set类型提供了求交集，并集，差集的操作，可以非常方便地实现譬如共同关注、共同爱好、共同好友等功能。</p><h1 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset(有序集合)"></a>zset(有序集合)</h1><p>zset是Redis中比较有特色的数据类型，它和set一样是不可重复的，区别在于多了score值，用来代表排序的权重。也就是当你需要一个有序的，不可重复的集合列表时，就可以考虑使用这种数据类型。</p><p>zset的编码有两种，分别是：ziplist、skiplist。当zset的长度小于 128，并且所有元素的长度都小于 64 字节时，使用ziplist存储；否则使用 skiplist 存储。</p><p>这里要讲一下skiplist，也就是跳跃表。它的底层实现比较复杂，这里简单地提一下。</p><p><img src="https://static.lovebilibili.com/redis_kv_08.png" srcset="/img/loading.gif" alt=""></p><p>跳跃表的数据结构如上图所示，为什么要设计成这样呢？好处在于查询的时候，可以减少时间复杂度，如果是一个链表，我们要插入并且保持有序的话，那就要从头结点开始遍历，遍历到合适的位置然后插入，如果这样性能肯定是不理想的。</p><p>所以问题的关键在于<strong>能不能像使用二分查找一样定位到插入的点</strong>，答案就是使用跳跃表。比如我们要插入38，那么查找的过程就是这样。</p><p>首先从L4层，查询87，需要查询1次。</p><p>然后到L3层，查询到在-&gt;24-&gt;87之间，需要查询2次。</p><p>然后到L2层，查询-&gt;48，需要查询1次。</p><p>然后到L1层，查询-&gt;37-&gt;48，查询2次。确定在37-&gt;48之间是插入点。</p><p>有没有发现经过L4，L3，L2层的查询后已经跳过了很多节点，当到了L1层遍历时已经把范围缩小了很多。这就是跳跃表的优势。这种方式有点类似于二分查找，所以他的时间复杂度为<strong>O(logN)</strong>。</p><p>其实生活中也有这种例子，类似于快递填写的地址是省-&gt;市-&gt;区-&gt;镇-&gt;街，当快递公司在送快递时就根据地址层层缩小范围，最终锁定在一个很小的区域去搜索，提高了效率。</p><p>zet常用的命令有：zadd、zrange、zrem、zcard等。</p><p>zset的特点非常适合应用于开发排行榜的功能，比如三天阅读排行榜，游戏排行榜等等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redis能够受到社区的认可，并且在互联网中如此欢迎，除了速度快之外，很大原因也跟丰富的数据类型有关，而且很多数据类型的底层实现也是会考虑到内存空间的使用，尽可能地节省内存空间。</p><p>其实很多人是知道Redis常用的五种数据类型，但是对于底层的实现，就没有深入去研究，当然我以前也是没有深入的。那么在面试时就没有产生差异化，要从面试中脱颖而出最重要就是要跟普通程序员不一样，这样才能突出自身的价值。所以深入学习Redis的数据结构还是很有用的。</p><p>希望这篇文章能让大家对Redis有更深入的理解，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死磕synchronized关键字底层原理</title>
    <link href="/2021/01/18/%E6%AD%BB%E7%A3%95synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2021/01/18/%E6%AD%BB%E7%A3%95synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为Java程序员，我们都知道在多线程的情况下，为了保证线程安全，经常会使用synchronized和Lock锁。Lock锁之前写过一篇<a href="https://mp.weixin.qq.com/s/FjLl9POXHqI8ca9EQHCCCw" target="_blank" rel="noopener">《不得不学的AQS》</a>，已经详细讲解过Lock锁的底层原理。这次我们讲一下日常开发中常用的关键字synchronized，想要用得好，底层原理必须要搞明白。</p><p>synchronized是JDK自带的一个关键字，在JDK1.5之前是一个重量级锁，所以从性能上考虑大部分人会选择Lock锁，不过毕竟是JDK自带的关键字，所以在JDK1.6后对它进行优化，引入了偏向锁，轻量级锁，自旋锁等概念。</p><h1 id="一、synchronized的使用方式"><a href="#一、synchronized的使用方式" class="headerlink" title="一、synchronized的使用方式"></a>一、synchronized的使用方式</h1><p>在语法上，要使用synchronized关键字，需要把任意一个非null对象作为”锁”对象，也就是需要一个<strong>对象监视器（Object Monitor）</strong>。总的来说有三种用法：</p><h2 id="1-1-作用在实例方法"><a href="#1-1-作用在实例方法" class="headerlink" title="1.1 作用在实例方法"></a>1.1 作用在实例方法</h2><p>修饰实例方法，相当于对当前实例对象this加锁，this作为对象监视器。</p><pre><code class="java">public synchronized void hello(){    System.out.println(&quot;hello world&quot;);}</code></pre><h2 id="1-2-作用在静态方法"><a href="#1-2-作用在静态方法" class="headerlink" title="1.2 作用在静态方法"></a>1.2 作用在静态方法</h2><p>修饰静态方法，相当于对当前类的Class对象加锁，当前类的Class对象作为对象监视器。</p><pre><code class="java">public synchronized static void helloStatic(){    System.out.println(&quot;hello world static&quot;);}</code></pre><h2 id="1-3-修饰代码块"><a href="#1-3-修饰代码块" class="headerlink" title="1.3 修饰代码块"></a>1.3 修饰代码块</h2><p>指定加锁对象，对给定对象加锁，括号括起来的对象就是对象监视器。</p><pre><code class="java">public void test(){    SynchronizedTest test = new SynchronizedTest();            synchronized (test){        System.out.println(&quot;hello world&quot;);    }}</code></pre><h1 id="二、synchronized锁的原理"><a href="#二、synchronized锁的原理" class="headerlink" title="二、synchronized锁的原理"></a>二、synchronized锁的原理</h1><p>在讲原理前，我们先讲一下Java对象的构成。在JVM中，对象在内存中分为三块区域：对象头，实例数据和对齐填充。如图所示：</p><p><img src="https://static.lovebilibili.com/synchronized_01.png" srcset="/img/loading.gif" alt=""></p><p><strong>对象头</strong>：</p><ul><li>Mark Word，用于存储对象自身运行时的数据，如哈希码(Hash Code)，GC分代年龄，锁状态标志，偏向线程ID、偏向时间戳等信息，它会根据对象的状态复用自己的存储空间。它是<strong>实现轻量级锁和偏向锁的关键</strong>。</li><li>类型指针，对象会指向它的类的元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。</li><li>Array length，如果对象是一个数组，还必须记录数组长度的数据。</li></ul><p><strong>实例数据</strong>：</p><ul><li>存放类的属性数据信息，包括父类的属性信息。</li></ul><p><strong>对齐填充</strong>：</p><ul><li>由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</li></ul><h2 id="2-1-同步代码块原理"><a href="#2-1-同步代码块原理" class="headerlink" title="2.1 同步代码块原理"></a>2.1 同步代码块原理</h2><p>为了看底层实现原理，使用<code>javap -v xxx.class</code>命令进行反编译。</p><p><img src="https://static.lovebilibili.com/synchronized_02.png" srcset="/img/loading.gif" alt=""></p><p>这是使用同步代码块被标志的地方就是刚刚提到的对象头，它会关联一个monitor对象，也就是括号括起来的对象。</p><p>1、<strong>monitorenter</strong>，如果当前monitor的进入数为0时，线程就会进入monitor，并且把进入数+1，那么该线程就是monitor的拥有者(owner)。</p><p>2、如果该线程已经是monitor的拥有者，又重新进入，就会把进入数再次+1。也就是可重入的。</p><p>3、<strong>monitorexit</strong>，执行monitorexit的线程必须是monitor的拥有者，指令执行后，monitor的进入数减1，如果减1后进入数为0，则该线程会退出monitor。其他被阻塞的线程就可以尝试去获取monitor的所有权。</p><blockquote><p>monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</p></blockquote><p>总的来说，synchronized的底层原理是通过monitor对象来完成的。</p><h2 id="2-2-同步方法原理"><a href="#2-2-同步方法原理" class="headerlink" title="2.2 同步方法原理"></a>2.2 同步方法原理</h2><p>比如说使用synchronized修饰的实例方法。</p><pre><code class="java">public synchronized void hello(){    System.out.println(&quot;hello world&quot;);}</code></pre><p>同理使用<code>javap -v</code>反编译。</p><p><img src="https://static.lovebilibili.com/synchronized_03.png" srcset="/img/loading.gif" alt=""></p><p>可以看到多了一个标志位<strong>ACC_SYNCHRONIZED</strong>，作用就是一旦执行到这个方法时，就会先判断是否有标志位，如果有这个标志位，就会先尝试获取monitor，获取成功才能执行方法，方法执行完成后再释放monitor。<strong>在方法执行期间，其他线程都无法获取同一个monitor</strong>。归根结底还是对monitor对象的争夺，只是同步方法是一种隐式的方式来实现。</p><h2 id="2-3-Monitor"><a href="#2-3-Monitor" class="headerlink" title="2.3 Monitor"></a>2.3 Monitor</h2><p>上面经常提到monitor，它内置在每一个对象中，任何一个对象都有一个monitor与之关联，synchronized在JVM里的实现就是基于进入和退出monitor来实现的，底层则是通过成对的MonitorEnter和MonitorExit指令来实现，因此每一个Java对象都有成为Monitor的潜质。所以我们可以理解monitor是一个同步工具。</p><h1 id="三、synchronized锁的优化"><a href="#三、synchronized锁的优化" class="headerlink" title="三、synchronized锁的优化"></a>三、synchronized锁的优化</h1><p>前面讲过JDK1.5之前，synchronized是属于重量级锁，重量级需要依赖于底层操作系统的Mutex Lock实现，然后操作系统需要切换用户态和内核态，这种切换的消耗非常大，所以性能相对来说并不好。</p><p>既然我们都知道性能不好，JDK的开发人员肯定也是知道的，于是在JDK1.6后开始对synchronized进行优化，增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略。锁的等级从无锁，偏向锁，轻量级锁，重量级锁逐步升级，并且是单向的，不会出现锁的降级。</p><h2 id="3-1-自适应性自旋锁"><a href="#3-1-自适应性自旋锁" class="headerlink" title="3.1 自适应性自旋锁"></a>3.1 自适应性自旋锁</h2><p>在说自适应自旋锁之前，先讲自旋锁。上面已经讲过，当线程没有获得monitor对象的所有权时，就会进入阻塞，当持有锁的线程释放了锁，当前线程才可以再去竞争锁，但是如果按照这样的规则，就会浪费大量的性能在阻塞和唤醒的切换上，特别是线程占用锁的时间很短的话。</p><p>为了避免阻塞和唤醒的切换，在没有获得锁的时候就不进入阻塞，而是不断地循环检测锁是否被释放，这就是自旋。在占用锁的时间短的情况下，自旋锁表现的性能是很高的。</p><p>但是又有问题，由于线程是一直在循环检测锁的状态，就会占用cpu资源，如果线程占用锁的时间比较长，那么自旋的次数就会变多，占用cpu时间变长导致性能变差，当然我们也可以通过参数<code>-XX:PreBlockSpin</code>设置自旋锁的自旋次数，当自旋一定的次数(时间)后就挂起，但是设置的自旋次数是多少比较合适呢？</p><p>如果设置次数少了或者多了都会导致性能受到影响，而且占用锁的时间在业务高峰期和正常时期也有区别，所以在JDK1.6引入了自适应性自旋锁。</p><p>自适应性自旋锁的意思是，自旋的次数不是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><p>表现是如果此次自旋成功了，很有可能下一次也能成功，于是允许自旋的次数就会更多，反过来说，如果很少有线程能够自旋成功，很有可能下一次也是失败，则自旋次数就更少。这样能最大化利用资源，随着程序运行和性能监控信息的不断完善，虚拟机对锁的状况预测会越来越准确，也就变得越来越智能。</p><h2 id="3-2-锁消除"><a href="#3-2-锁消除" class="headerlink" title="3.2 锁消除"></a>3.2 锁消除</h2><p>锁消除是一种锁的优化策略，这种优化更加彻底，在JVM编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。这种优化策略可以消除没有必要的锁，节省毫无意义的请求锁时间。比如StringBuffer的append()方法，就是使用synchronized进行加锁的。</p><pre><code class="java">public synchronized StringBuffer append(String str) {    toStringCache = null;    super.append(str);    return this;}</code></pre><p>如果在实例方法中StringBuffer作为局部变量使用append()方法，StringBuffer是不可能存在共享资源竞争的，因此会自动将其锁消除。例如：</p><pre><code class="java">public String add(String s1, String s2) {    //sb属于不可能共享的资源,JVM会自动消除内部的锁    StringBuffer sb = new StringBuffer();    sb.append(s1).append(s2);    return sb.toString();}</code></pre><h2 id="3-3-锁粗化"><a href="#3-3-锁粗化" class="headerlink" title="3.3 锁粗化"></a>3.3 锁粗化</h2><p>如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。意思是将多个连续加锁、解锁的操作连接在一起，扩展成为一个范围更大的锁。</p><h2 id="3-4-偏向锁"><a href="#3-4-偏向锁" class="headerlink" title="3.4 偏向锁"></a>3.4 偏向锁</h2><p>偏向锁是JDK1.6引入的一个重要的概念，JDK的开发人员经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。也就是说在很多时候我们是假设有多线程的场景，但是实际上却是单线程的。所以偏向锁是在单线程执行代码块时使用的机制。</p><p>原理是什么呢，我们前面提到锁的争夺实际上是Monitor对象的争夺，还有每个对象都有一个对象头，对象头是由Mark Word和Klass pointer 组成的。一旦有线程持有了这个锁对象，标志位修改为1，就进入<strong>偏向模式</strong>，同时会把这个<strong>线程的ID记录在对象的Mark Word中</strong>，当同一个线程再次进入时，就不再进行同步操作，这样就省去了大量的锁申请的操作，从而提高了性能。</p><p>一旦有多个线程开始竞争锁的话呢？那么偏向锁并不会一下子升级为重量级锁，而是先升级为轻量级锁。</p><h2 id="3-5-轻量级锁"><a href="#3-5-轻量级锁" class="headerlink" title="3.5 轻量级锁"></a>3.5 轻量级锁</h2><p>如果获取偏向锁失败，也就是有多个线程竞争锁的话，就会升级为JDK1.6引入的轻量级锁，Mark Word 的结构也变为轻量级锁的结构。</p><p>执行同步代码块之前，JVM会在线程的栈帧中创建一个锁记录（Lock Record），并将Mark Word拷贝复制到锁记录中。然后尝试通过CAS操作将Mark Word中的锁记录的指针，指向创建的Lock Record。如果成功表示获取锁状态成功，如果失败，则进入自旋获取锁状态。</p><p>自旋锁的原理在上面已经讲过了，如果自旋获取锁也失败了，则升级为重量级锁，也就是把线程阻塞起来，等待唤醒。</p><h2 id="3-6-重量级锁"><a href="#3-6-重量级锁" class="headerlink" title="3.6 重量级锁"></a>3.6 重量级锁</h2><p>重量级锁就是一个悲观锁了，但是其实不是最坏的锁，因为升级到重量级锁，是因为线程占用锁的时间长(自旋获取失败)，锁竞争激烈的场景，在这种情况下，让线程进入阻塞状态，进入阻塞队列，能减少cpu消耗。所以说在不同的场景使用最佳的解决方案才是最好的技术。synchronized在不同的场景会自动选择不同的锁，这样一个升级锁的策略就体现出了这点。</p><h2 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h2><p>偏向锁：适用于单线程执行。</p><p>轻量级锁：适用于锁竞争较不激烈的情况。</p><p>重量级锁：适用于锁竞争激烈的情况。</p><h1 id="四、Lock锁与synchronized的区别"><a href="#四、Lock锁与synchronized的区别" class="headerlink" title="四、Lock锁与synchronized的区别"></a>四、Lock锁与synchronized的区别</h1><p>我们看一下他们的区别：</p><ul><li>synchronized是Java语法的一个关键字，加锁的过程是在JVM底层进行。Lock是一个类，是JDK应用层面的，在JUC包里有丰富的API。</li><li>synchronized在加锁和解锁操作上都是自动完成的，Lock锁需要我们手动加锁和解锁。</li><li>Lock锁有丰富的API能知道线程是否获取锁成功，而synchronized不能。</li><li>synchronized能修饰方法和代码块，Lock锁只能锁住代码块。</li><li>Lock锁有丰富的API，可根据不同的场景，在使用上更加灵活。</li><li>synchronized是非公平锁，而Lock锁既有非公平锁也有公平锁，可以由开发者通过参数控制。</li></ul><p>个人觉得在锁竞争不是很激烈的场景，使用synchronized，语义清晰，实现简单，JDK1.6后引入了偏向锁，轻量级锁等概念后，性能也能保证。而在锁竞争激烈，复杂的场景下，则使用Lock锁会更灵活一点，性能也较稳定。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习synchronized关键字的底层原理不是钻牛角尖，其实是从底层原理上知道了synchronized在什么场景使用会有什么样的效果，我们都知道没有最好的技术，只有最适合的技术，所以在学完之后，希望对大家有所帮助，写出更加高效的代码。所谓不积跬步无以至千里，一步一个脚印，哪怕现在还是菜鸟，总有一天也会成为雄鹰。</p><p>那么这篇文章就写到这里了，感谢大家的阅读，希望看完后能有所收获！</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不得不懂的explain关键字</title>
    <link href="/2021/01/10/%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%87%82%E7%9A%84explain%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/01/10/%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%87%82%E7%9A%84explain%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在MySQL中，我们知道加索引能提高查询效率，这基本上算是常识了。但是有时候，我们加了索引还是觉得SQL查询效率低下，我想看看<strong>有没有使用到索引，扫描了多少行，表的加载顺序</strong>等等，怎么查看呢？其实MySQL自带的SQL分析神器<strong>Explain执行计划</strong>就能完成以上的事情！</p><h1 id="Explain有哪些信息"><a href="#Explain有哪些信息" class="headerlink" title="Explain有哪些信息"></a>Explain有哪些信息</h1><p>先确认一下试验的MySQL版本，这里使用的是<code>5.7.31</code>版本。</p><p><img src="https://static.lovebilibili.com/mysql_explain_01.png" srcset="/img/loading.gif" alt=""></p><p>只需要在SQL语句前加上explain关键字就可以查看执行计划，执行计划包括以下信息：id、select_type、table、partitions、type、possible_keys、key、key_len、ref、rows、filtered、Extra，总共12个字段信息。</p><p><img src="https://static.lovebilibili.com/mysql_explain_02.png" srcset="/img/loading.gif" alt=""></p><p>然后创建三个表：</p><pre><code class="sql">CREATE TABLE `tb_student` (  `id` int(10) NOT NULL AUTO_INCREMENT,  `name` varchar(36) NOT NULL,  PRIMARY KEY (`id`),  KEY `index_name` (`name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;学生表&#39;;CREATE TABLE `tb_class` (  `id` INT(10) primary key not null auto_increment,  `name` VARCHAR(36) NOT NULL,    `stu_id` INT(10) NOT NULL,    `tea_id` INT(10) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;班级表&#39;;CREATE TABLE `tb_teacher` (  `id` INT(10) primary key not null auto_increment,  `name` VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;教师表&#39;;</code></pre><h1 id="Explain执行计划详解"><a href="#Explain执行计划详解" class="headerlink" title="Explain执行计划详解"></a>Explain执行计划详解</h1><p>explain的使用很简单，只需要在SQL语句前加上关键字<code>explain</code>即可，关键是怎么看explain执行后返回的字段信息，这才是重点。</p><h2 id="一、id"><a href="#一、id" class="headerlink" title="一、id"></a>一、id</h2><p>SELECT识别符。这是SELECT的查询序列号。<strong>SQL执行的顺序的标识，SQL从大到小的执行</strong>。id列有以下几个注意点：</p><ul><li>id相同时，执行顺序由上至下。</li><li>id不同时，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。</li></ul><pre><code class="sql">EXPLAIN SELECT * FROM `tb_student` WHERE id IN (SELECT stu_id FROM tb_class WHERE tea_id IN(SELECT id FROM tb_teacher WHERE `name` = &#39;马老师&#39;));</code></pre><p><img src="https://static.lovebilibili.com/mysql_explain_03.png" srcset="/img/loading.gif" alt=""></p><p>根据原则，当id不同时，SQL从大到小执行，id相同则从上到下执行。</p><h2 id="二、select-type"><a href="#二、select-type" class="headerlink" title="二、select_type"></a>二、select_type</h2><p>表示select查询的类型，用于区分各种复杂的查询，例如普通查询，联合查询，子查询等等。</p><h3 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h3><p>表示最简单的查询操作，也就是查询SQL语句中没有子查询、union等操作。</p><h3 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h3><p>当查询语句中包含复杂查询的子部分，表示复杂查询中最外层的 select。</p><h3 id="SUBQUERY"><a href="#SUBQUERY" class="headerlink" title="SUBQUERY"></a>SUBQUERY</h3><p>当 <code>select</code> 或 <code>where</code> 中包含有子查询，该子查询被标记为SUBQUERY。</p><h3 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a>DERIVED</h3><p>在SQL语句中包含在<code>from</code>子句中的子查询。</p><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>表示在union中的第二个和随后的select语句。</p><h3 id="UNION-RESULT"><a href="#UNION-RESULT" class="headerlink" title="UNION RESULT"></a>UNION RESULT</h3><p>代表从<code>union</code>的临时表中读取数据。</p><pre><code class="sql">EXPLAIN SELECT u.`name` FROM ((SELECT s.id,s.`name` FROM `tb_student` s) UNION (SELECT t.id,t.`name` FROM tb_teacher t)) AS u;</code></pre><p><code>&lt;union2,3&gt;</code>代表是id为2和3的select查询的结果进行union操作。</p><p><img src="https://static.lovebilibili.com/mysql_explain_04.png" srcset="/img/loading.gif" alt=""></p><h3 id="MATERIALIZED"><a href="#MATERIALIZED" class="headerlink" title="MATERIALIZED"></a>MATERIALIZED</h3><p><code>MATERIALIZED</code>表示物化子查询，子查询来自视图。</p><h2 id="三、table"><a href="#三、table" class="headerlink" title="三、table"></a>三、table</h2><p>表示输出结果集的表的表名，并不一定是真实存在的表，也有可能是别名，临时表等等。</p><h2 id="四、partitions"><a href="#四、partitions" class="headerlink" title="四、partitions"></a>四、partitions</h2><p>表示SQL语句查询时匹配到的分区信息，对于非分区表值为NULL，当查询的是分区表则会显示分区表命中的分区情况。</p><h2 id="五、type"><a href="#五、type" class="headerlink" title="五、type"></a>五、type</h2><p>需要重点关注的一个字段信息，表示查询使用了哪种类型，在 <code>SQL</code>优化中是一个非常重要的指标，依次从优到差分别是：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong>。</p><h3 id="system和const"><a href="#system和const" class="headerlink" title="system和const"></a>system和const</h3><p><strong>单表中最多有一条匹配行，查询效率最高，所以这个匹配行的其他列的值可以被优化器在当前查询中当作常量来处理</strong>。通常出现在根据主键或者唯一索引进行的查询，system是const的特例，表里只有一条元组匹配时（系统表）为system。</p><p><img src="https://static.lovebilibili.com/mysql_explain_05.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/mysql_explain_06.png" srcset="/img/loading.gif" alt=""></p><h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录，所以这种类型常出现在多表的join查询。</p><p><img src="https://static.lovebilibili.com/mysql_explain_07.png" srcset="/img/loading.gif" alt=""></p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>相比<strong>eq_ref</strong>，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，可能会找到多个符合条件的行。</p><p><img src="https://static.lovebilibili.com/mysql_explain_08.png" srcset="/img/loading.gif" alt=""></p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>使用索引选择行，仅检索给定范围内的行。一般来说是针对一个有索引的字段，给定范围检索数据，通常出现在where语句中使用 <code>bettween...and</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>in</code> 等条件查询 。</p><p><img src="https://static.lovebilibili.com/mysql_explain_09.png" srcset="/img/loading.gif" alt=""></p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>扫描全表索引，通常比ALL要快一些。</p><p><img src="https://static.lovebilibili.com/mysql_explain_10.png" srcset="/img/loading.gif" alt=""></p><h3 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h3><p><strong>全表扫描，MySQL遍历全表来找到匹配行</strong>，性能最差。</p><p><img src="https://static.lovebilibili.com/mysql_explain_11.png" srcset="/img/loading.gif" alt=""></p><h2 id="六、possible-keys"><a href="#六、possible-keys" class="headerlink" title="六、possible_keys"></a>六、possible_keys</h2><p>表示在查询中可能使用到的索引来查找，别列出的索引并不一定是最终查询数据所用到的索引。</p><h2 id="七、key"><a href="#七、key" class="headerlink" title="七、key"></a>七、key</h2><p>跟possible_keys有所区别，key表示查询中实际使用到的索引，若没有使用到索引则显示为NULL。</p><h2 id="八、key-len"><a href="#八、key-len" class="headerlink" title="八、key_len"></a>八、key_len</h2><p>表示查询用到的索引key的长度(字节数)。如果单列索引，那么就会把整个索引长度计算进去，如果是联合索引，不是所有的列都用到，那么就只计算实际用到的列，因此可以<strong>根据key_len来判断联合索引是否生效</strong>。</p><h2 id="九、ref"><a href="#九、ref" class="headerlink" title="九、ref"></a>九、ref</h2><p>显示了哪些列或常量被用于查找索引列上的值。常见的值有：<code>const</code>，<code>func</code>，<code>null</code>，字段名。</p><h2 id="十、rows"><a href="#十、rows" class="headerlink" title="十、rows"></a>十、rows</h2><p>mysql估算要找到我们所需的记录，需要读取的行数。可以通过这个数据很直观的显示 <code>SQL</code> 性能的好坏，一般情况下 <code>rows</code> 值越小越好。</p><h2 id="十一、filtered"><a href="#十一、filtered" class="headerlink" title="十一、filtered"></a>十一、filtered</h2><p>指返回结果的行占需要读到的行(rows列的值)的百分比，一般来说越大越好。</p><h2 id="十二、Extra"><a href="#十二、Extra" class="headerlink" title="十二、Extra"></a>十二、Extra</h2><p>表示额外的信息。此字段能够给出让我们深入理解执行计划进一步的细节信息。</p><h3 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h3><p>说明在select查询中使用了覆盖索引。覆盖索引的好处是一条SQL通过索引就可以返回我们需要的数据。</p><p><img src="https://static.lovebilibili.com/mysql_explain_12.png" srcset="/img/loading.gif" alt=""></p><h3 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h3><p>查询时没使用到索引，然后通过where条件过滤获取到所需的数据。</p><p><img src="https://static.lovebilibili.com/mysql_explain_13.png" srcset="/img/loading.gif" alt=""></p><h3 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="Using temporary"></a>Using temporary</h3><p>表示在查询时，MySQL需要创建一个临时表来保存结果。临时表一般会比较影响性能，应该尽量避免。</p><p><img src="https://static.lovebilibili.com/mysql_explain_14.png" srcset="/img/loading.gif" alt=""></p><p>有时候使用DISTINCT去重时也会产生Using temporary。</p><p><img src="https://static.lovebilibili.com/mysql_explain_15.png" srcset="/img/loading.gif" alt=""></p><h3 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a><strong>Using filesort</strong></h3><p>我们知道索引除了查询中能起作用外，排序也是能起到作用的，所以当SQL中包含 ORDER BY 操作，而且<strong>无法利用索引完成排序操作</strong>的时候，MySQL不得不选择相应的排序算法来实现，这时就会出现<strong>Using filesort</strong>，应该尽量避免使用<strong>Using filesort</strong>。</p><p><img src="https://static.lovebilibili.com/mysql_explain_16.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一般优化SQL语句第一步是要知道这条SQL语句有哪些需要优化的，explain执行计划就相当于一面镜子，能把详细的执行情况给开发者列出来。所以说善用explain执行计划，能解决80%的SQL优化问题。</p><p>explain的信息中，一般我们要关心的是type，看是什么级别，如果是在互联网公司一般需要在range以上的级别，接着关心的是Extra，有没有出现filesort或者using template，一旦出现就要想办法避免，接着再看key使用的是什么索引，还有看filtered筛选比是多少。</p><p>这篇文章就讲到这里了，希望大家看完之后能对SQL优化有更深入的理解，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！    </p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4千字详细讲解JVM中的垃圾回收</title>
    <link href="/2021/01/01/4%E5%8D%83%E5%AD%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3JVM%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2021/01/01/4%E5%8D%83%E5%AD%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3JVM%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/jvm_gc_swdt.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java相对于C/C++语言来说，最明显的特点在于Java引入了自动垃圾回收。垃圾回收(Garbage Collection简称GC)可以使程序员不在需要关心JVM内存管理的问题，专注于写程序本身。平时程序员是很难感知到GC的存在，但是如果<strong>涉及到一些性能调优，线上的问题排查等等，深入地了解GC是必不可少的</strong>。往往通过一些JVM参数的设置能就使系统性能提高不少。</p><h1 id="一、JVM内存区域"><a href="#一、JVM内存区域" class="headerlink" title="一、JVM内存区域"></a>一、JVM内存区域</h1><p>要深入了解GC，首先要明白GC会回收哪些数据，数据位于哪个区域。接着我们看一下JVM的内存区域。</p><p><img src="https://static.lovebilibili.com/jvm_gc_01.png" srcset="/img/loading.gif" alt=""></p><p>从图中可以看出，内存区域分为五个：</p><ul><li>虚拟机栈：线程私有，由一个个栈帧组成，每个栈帧对应着一个调用的方法，保存有方法的局部变量等信息。方法被调用时栈帧入栈，方法结束调用时栈帧出栈。入栈出栈的时机很清楚，所以不需要进行GC。</li><li>本地方法栈：与虚拟机栈非常类似，本地方法栈与虚拟机栈的区别在于，虚拟机栈执行的是Java方法，本地方法栈执行的是本地方法(Native Method)。这块区域也不需要进行GC。</li><li>程序计数器：线程私有的，它的作用可以看做是当前线程所执行的字节码的行号指示器。我们知道JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会被挂起，而另一个线程获取到时间片开始执行。<strong>在JVM中，就是通过程序计数器来记录某个线程的字节码执行位置，当被挂起的线程重新获取到时间片的时候，就知道上次被挂起时执行到哪个位置了</strong>。这块区域也不需要GC。</li><li>方法区：在Java8之前有永久代的概念，在堆中实现，受GC的管理，主要存储类的信息，常量，静态变量，由于永久代有 -XX:MaxPermSize 的上限，所以很容易造成 OOM。在Java8之后，永久代被移除，然后把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。所以Java8以后，方法区也不需要GC。</li><li>堆：堆是Java对象的存储区域，任何new字段分配的<strong>Java对象实例和数组</strong>，都被分配在了堆上。GC主要作用于这个区域，对这两类数据进行回收。</li></ul><h1 id="二、如何判断对象是否可回收"><a href="#二、如何判断对象是否可回收" class="headerlink" title="二、如何判断对象是否可回收"></a>二、如何判断对象是否可回收</h1><p>上面讲了GC主要作用的区域是在堆中，那么又是怎么判断是否可以回收的呢？在GC里面有两种算法来判断，一种是引用计数，对象引用的次数为0就是垃圾，另一种是可达性算法，如果一个对象不在以GC Root根节点为起点的引用链中，则视为垃圾。</p><h2 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h2><p>首先看引用计数法，简单点说对象被引用，就会在此对象的对象头上计数器加一，每当有一个引用失效时计数器的值减一，如果没有引用(引用次数为0)则此对象可回收。但是这种算法很难解决对象之间互相循环引用的问题。</p><h2 id="2-2-可达性算法"><a href="#2-2-可达性算法" class="headerlink" title="2.2 可达性算法"></a>2.2 可达性算法</h2><p>所谓的GC Roots就是一组必须活跃的引用，基本思路就是从一系列的GC Root一直往下搜索，通过GC Root串成的一条线称为引用链，如果有对象不在任何一条以GC Root为起点的引用链中，则此对象就会被GC回收，这就是可达性算法。</p><p><img src="https://static.lovebilibili.com/jvm_gc_02.png" srcset="/img/loading.gif" alt=""></p><p>哪些对象可作为GC Root对象呢：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><h1 id="三、常见的垃圾回收算法"><a href="#三、常见的垃圾回收算法" class="headerlink" title="三、常见的垃圾回收算法"></a>三、常见的垃圾回收算法</h1><p>上面已经讲了如何判断哪些对象时可回收的。那么判断完是否可回收后，GC又是使用什么算法进行回收的呢？这就要讲一讲垃圾回收的几种方式：</p><ul><li>标记清除法</li><li>标记整理法</li><li>复制算法</li><li>分代收集算法</li></ul><h2 id="3-1-标记清除法"><a href="#3-1-标记清除法" class="headerlink" title="3.1 标记清除法"></a>3.1 标记清除法</h2><p>其实很简单，分为<strong>标记</strong>和<strong>清除</strong>两个步骤。第一步根据可达性算法标记被回收的对象，第二步回收被标记的对象。</p><p><img src="https://static.lovebilibili.com/jvm_gc_03.png" srcset="/img/loading.gif" alt=""></p><p>明显这种垃圾回收算法的缺点是很容易产生内存碎片。</p><h2 id="3-2-标记整理法"><a href="#3-2-标记整理法" class="headerlink" title="3.2 标记整理法"></a>3.2 标记整理法</h2><p>前面两个步骤和标记清除算法一样，而不同的是在标记清除算法的基础上多了一步整理的过程。如图所示，整理步骤的时候，将所有存活的对象都往左边移动，然后清理另一端的所有区域，这样就不会产生内存碎片。</p><p><img src="https://static.lovebilibili.com/jvm_gc_04.png" srcset="/img/loading.gif" alt=""></p><p>虽然不会产生内存碎片，但是由于频繁地移动存活的对象，所以效率十分低下。</p><h2 id="3-3-复制算法"><a href="#3-3-复制算法" class="headerlink" title="3.3 复制算法"></a>3.3 复制算法</h2><p>把内存分成两份，分别是A区域和B区域，第一步根据可达性算法把存活的对象标记出来，第二步把存活的对象复制到B区域，第三步把A区域全部清空。这就是复制算法。</p><p><img src="https://static.lovebilibili.com/jvm_gc_05.png" srcset="/img/loading.gif" alt=""></p><p>复制算法不会产生内存碎片，并且不需要频繁移动存活的对象，而缺点就是内存利用不充分，比如一块500M的内存，要分成两份，只能利用到250M。</p><h2 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h2><p>分代搜集算法是<strong>针对对象的不同特性</strong>，而使用适合的算法，这里面并没有实际上的新算法产生。与其说分代收集算法是第四个算法，不如说它是对前三个算法的实际应用。</p><p>首先我们先探讨一下对象的不同特性，内存中的对象其实可以根据生命周期的长短大致分为三种：</p><ul><li>夭折对象(新生代)：朝生夕死的对象，比如方法里的局部变量。</li><li>持久对象(老年代)：存活的比较久但还是要死的对象，比如缓存对象，单例对象等等。</li><li>永久对象(永久代)：对象生成后几乎不灭的对象，例如String池中的对象（享元模式）、加载过的类信息等等。</li></ul><p>上述的对象对应在内存中的区域就是，夭折对象和持久对象在Java堆中，永久对象在方法区。</p><p>分代算法的原理就是根据对象的存货周期不同将堆分为年轻代和老年代。新生代又分为Eden 区，from Survivor 区（S0区），to Survivor 区(S1区)，比例为8:1:1。</p><p><img src="https://static.lovebilibili.com/jvm_gc_06.png" srcset="/img/loading.gif" alt=""></p><p>先看年轻代的GC，年轻代采用的回收算法是复制算法。新建的对象被创建后就会分配在Eden 区，当Eden区将满时，就会触发GC。</p><p><img src="https://static.lovebilibili.com/jvm_gc_07.png" srcset="/img/loading.gif" alt=""></p><p>在这一步GC会把大部分夭折对象回收，根据可达性算法标记出存活的对象，把存活对象复制到S0区，然后清空Eden 区。</p><p><img src="https://static.lovebilibili.com/jvm_gc_08.png" srcset="/img/loading.gif" alt=""></p><p>接着继续到下一次触发GC时，就会把Eden区和S0区的存活对象复制到S1区，然后清空Eden区和S0区。每次垃圾回收后S0和S1区的角色互换。每次GC后，如果对象存活下来则年龄加一。</p><p><img src="https://static.lovebilibili.com/jvm_gc_09.png" srcset="/img/loading.gif" alt=""></p><p>我们知道在年轻代中存活得越久的对象，年龄会越大，如果存活对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代。由于老年代的对象一般不会经常回收，所以采用的算法是标记整理法，老年代的回收次数相对较少，每次回收时间比较长。</p><h1 id="四、Stop-the-world"><a href="#四、Stop-the-world" class="headerlink" title="四、Stop the world"></a>四、Stop the world</h1><p>Java中Stop The World机制简称STW，<strong>执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集器之外），当垃圾回收完成后，再继续运行</strong>，所以尽量减少STW的时间，就是优化JVM的主要目标。</p><h1 id="五、常见的垃圾收集器"><a href="#五、常见的垃圾收集器" class="headerlink" title="五、常见的垃圾收集器"></a>五、常见的垃圾收集器</h1><p>垃圾收集器其实就是上面讲的算法的具体实现，目前没有说哪个垃圾收集器是最好的，只有根据应用的特点选择最合适的，所以说合适的才是最好的。</p><p>常见的垃圾收集器除了G1垃圾收集器外，都是只作用于一个区域，要么年轻代要么老年代，所以一般是配合使用，总共有7种，怎么配合使用，请看下面这张图，有连线的就是可以配合使用的。</p><p><img src="https://static.lovebilibili.com/jvm_gc_10.png" srcset="/img/loading.gif" alt=""></p><h2 id="5-1-Serial收集器"><a href="#5-1-Serial收集器" class="headerlink" title="5.1 Serial收集器"></a>5.1 Serial收集器</h2><p>Serial收集器作用于年轻代，单线程的垃圾收集器，单线程意味着它只会使用一个CPU或者一个线程去完成垃圾回收的工作，当它在垃圾回收时，由于SWT机制，其他工作线程都会被暂时挂起，直到垃圾回收完成。这种垃圾收集器适用于Client模式的应用，在单CPU的环境下，由于没有和其他线程交互的开销，可以专心垃圾回收的工作，能够把单线程的优势发挥到极致，简单高效。通过-XX:+UseSerialGC可以开启这种回收模式。</p><p><img src="https://static.lovebilibili.com/jvm_gc_11.png" srcset="/img/loading.gif" alt=""></p><h2 id="5-2-ParNew收集器"><a href="#5-2-ParNew收集器" class="headerlink" title="5.2 ParNew收集器"></a>5.2 ParNew收集器</h2><p>ParNew 收集器是Serial收集器的多线程版本，作用于年轻代，默认开启的收集线程数和cpu数量一样，运行数量可以通过修改ParallelGCThreads设定。</p><p><img src="https://static.lovebilibili.com/jvm_gc_12.png" srcset="/img/loading.gif" alt=""></p><h2 id="5-3-Parallel-Scavenge收集器"><a href="#5-3-Parallel-Scavenge收集器" class="headerlink" title="5.3 Parallel Scavenge收集器"></a>5.3 Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器也被称为吞吐量优先收集器，作用于年轻代，多线程采用复制算法的垃圾收集器，跟ParNew 收集器有些类似。和ParNew 收集器不同的是，Parallel Scavenge收集器关注的是吞吐量，它提供了两个参数来控制吞吐量，分别是-XX:MaxGCPauseMillis(控制最大的垃圾收集停顿时间)、 -XX:GCTimeRatio(直接设置吞吐量大小)。</p><p>如果设置了-XX:+UseAdaptiveSizePolicy参数，虚拟机就会根据系统的运行情况收集监控信息，动态调整新生代的大小，Eden,Survivor比例等，以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标，这种调节方式称为GC的自适应调节策略。这也是Parallel Scavenge收集器和ParNew 收集器最大的区别。</p><h2 id="5-4-Serial-Old收集器"><a href="#5-4-Serial-Old收集器" class="headerlink" title="5.4 Serial Old收集器"></a>5.4 Serial Old收集器</h2><p>Serial Old 收集器是工作在老年代的单线程垃圾收集器，采用的算法是标记整理算法。在Client模式下可以和Serial收集器配合使用，如果在Server模式的应用，在JDK1.5之前可以和Parallel Scavenge收集器配合使用，另一种使用场景则是CMS垃圾收集器的后备预案，在发生<strong>Concurrent Mode Failure</strong>使用。</p><h2 id="5-5-Parallel-Old收集器"><a href="#5-5-Parallel-Old收集器" class="headerlink" title="5.5 Parallel Old收集器"></a>5.5 Parallel Old收集器</h2><p>Parallel Old 收集器是Parallel Scavenge收集器的老年代版本，多线程收集，采用标记整理算法。下图是Parallel Scavenge收集器和Parallel Old 收集器配合工作的过程图。</p><p><img src="https://static.lovebilibili.com/jvm_gc_13.png" srcset="/img/loading.gif" alt=""></p><h2 id="5-6-CMS收集器"><a href="#5-6-CMS收集器" class="headerlink" title="5.6 CMS收集器"></a>5.6 CMS收集器</h2><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器，采用标记-清除算法。适用于希望系统停顿时间短，给用户更好的体验的场景。</p><p>CMS收集器运行时主要分为四个步骤：</p><ul><li>初始标记：标记GC Roots能直接关联的对象。存在Stop The World。</li><li>并发标记：GC Roots Tracing，可以和用户线程并发执行。</li><li>重新标记：标记期间产生的对象存活的再次判断，修正对这些对象的标记，执行时间相对并发标记短，存在Stop The World。</li><li>并发清除：清除对象,可以和用户线程并发执行。</li></ul><p><img src="https://static.lovebilibili.com/jvm_gc_14.png" srcset="/img/loading.gif" alt=""></p><p>CMS收集器的缺点在于：</p><ul><li>对CPU资源比较敏感。</li><li>无法处理浮动垃圾。可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理时用户线程还在运行，所以清理垃圾同时新的垃圾也会不断产生，这部分垃圾（即浮动垃圾）只能在下一次 GC 时再清理掉。</li><li>采用的是标记清除算法，所以会产生内存碎片。内存碎片会导致大对象无法分配到连续的内存空间，然后会产生Full GC，影响应用的性能。</li></ul><h2 id="5-7-G1收集器"><a href="#5-7-G1收集器" class="headerlink" title="5.7 G1收集器"></a>5.7 G1收集器</h2><p>G1垃圾回收器主要是面向服务端的垃圾回收器，年轻代和老年代都可使用。运作时，整体上采用标记整理算法，局部上看是采用复制算法，两种算法都不会产生内存碎片，所以回收器在回收后能产生连续的内存空间。</p><p>它是专门针对以下场景设计的：</p><ul><li>像CMS收集器一样，能与应用程序线程并发执行。</li><li>整理空闲空间更快。</li><li>需要GC停顿时间更好预测。</li><li>不希望牺牲大量的吞吐性能。</li><li>不需要更大的Java Heap。</li></ul><p>G1垃圾回收器的内存分区不再采用传统的内存分区，将新生代，老年代的物理空间划分取消了。</p><p><img src="https://static.lovebilibili.com/jvm_gc_15.png" srcset="/img/loading.gif" alt=""></p><p>取而代之的是，把堆内存分成若干个Region(区域)，每次收集的时候，只收集其中几个区域，以此来控制垃圾回收产生的STW。G1垃圾回收器和传统的垃圾回收器的最大区别就在于，<strong>弱化了分代概念，引入了分区的思想</strong>。</p><p><img src="https://static.lovebilibili.com/jvm_gc_16.png" srcset="/img/loading.gif" alt=""></p><p>G1中每代的存储地址都不是连续的，而是使用了不连续的大小相同的Region。除此之外G1中还多了一个H，H代表Humongous，用于存储巨大对象(humongous object)，当对象大小大于等于region一半的对象，就直接分配到了老年代，防止了反复拷贝移动。</p><p>G1垃圾回收过程可分为四步：</p><ul><li>初始标记。收集所有GC根（对象的起源指针，根引用），STW，在年轻代完成。</li><li>并发标记。标记存活对象。</li><li>最终标记。是最后一个标记阶段，STW，很短，完成所有标记工作。</li><li>筛选回收。回收没有存活对象的Region并加入可用Region队列。</li></ul><p><img src="https://static.lovebilibili.com/jvm_gc_17.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文的简述了JVM的垃圾回收的理论知识，思路是先搞懂GC作用的区域是在堆中，然后介绍可达性算法的作用是为了标记存活的对象，知道哪些是可回收对象，接着就是使用垃圾回收算法进行回收，然后介绍了常见的几种垃圾回收算法(标记清除，复制算法，标记整理)，最后再介绍常见的几种垃圾回收器。</p><p>对于垃圾回收器的介绍，这里只是简单的描述，并没有深入地讲解，因为每一个垃圾回收器如果展开细述都能讲上半天，所以有兴趣的话，可以自己再去探索一下，个人认为CMS和G1垃圾回收器是比较重要的两种。</p><p>这篇文章就讲到这里了，希望看完之后能对你有所帮助，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>垃圾回收</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring用了哪些设计模式，能讲讲吗</title>
    <link href="/2020/12/27/Spring%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%83%BD%E8%AE%B2%E8%AE%B2%E5%90%97/"/>
    <url>/2020/12/27/Spring%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%83%BD%E8%AE%B2%E8%AE%B2%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/spring_design_mode_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一个优秀的框架肯定离不开各种设计模式的运用，Spring框架也不例外。因为网上很多文章比较散乱，所以想总结一下在Spring中用到的设计模式，希望大家看完之后能对spring有更深层次的理解。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式我们都知道是把创建对象交给工厂，以此来降低类与类之间的耦合。工厂模式在Spring中的应用非常广泛，这里举的例子是ApplicationContext和BeanFactory，这也是Spring的IOC容器的基础。</p><p>首先看BeanFactory，这是最底层的接口。</p><pre><code class="java">public interface BeanFactory {    Object getBean(String name) throws BeansException;    &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException;    Object getBean(String name, Object... args) throws BeansException;    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;    //省略...}</code></pre><p>ApplicationContext则是扩展类，也是一个接口，他的作用是当容器启动时，一次性创建所有的bean。</p><pre><code class="java">public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,MessageSource, ApplicationEventPublisher, ResourcePatternResolver {    @Nullable    String getId();    String getApplicationName();    String getDisplayName();    long getStartupDate();    @Nullable    ApplicationContext getParent();    AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;}</code></pre><p>ApplicationContext有三个实现类，分别是：</p><ul><li>ClassPathXmlApplication：从类路径ClassPath中寻找指定的XML配置文件，找到并装载ApplicationContext的实例化工作。</li><li>FileSystemXMLApplicationContext：从指定的文件系统路径中寻找指定的XML配置文件，找到并装载ApplicationContext的实例化工作。</li><li>XMLWebApplicationContext：从Web系统中的XML文件载入Bean定义的信息，Web应用寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。</li></ul><p>因此这几个类的关系我们清楚了，类图就是这样：</p><p><img src="https://static.lovebilibili.com/ApplicationContext.png" srcset="/img/loading.gif" alt=""></p><p>在哪里初始化呢，这讲起来有些复杂，就不展开细讲，提一下。主要看AbstractApplicationContext类的refresh()方法。</p><pre><code class="java">@Overridepublic void refresh() throws BeansException, IllegalStateException {    synchronized (this.startupShutdownMonitor) {        //省略...        try {            //省略...            //初始化所有的单实例 Bean(没有配置赖加载的)            finishBeanFactoryInitialization(beanFactory);        }catch (BeansException ex) {            //省略...        }finally {            //省略...        }    }}</code></pre><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>在系统中，有很多对象我们都只需要一个，比如线程池、Spring的上下文对象，日志对象等等。单例模式的好处在于<strong>对一些重量级的对象，省略了创建对象花费的时间，减少了系统的开销</strong>，第二点是使用单例<strong>可以减少new操作的次数，减少了GC线程回收内存的压力</strong>。</p><p>实际上，在Spring中的Bean默认的作用域就是<strong>singleton</strong>(单例)的。如何实现的呢？</p><p>主要看DefaultSingletonBeanRegistry的getSingleton()方法：</p><pre><code class="java">public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {    /** 保存单例Objects的缓存集合ConcurrentHashMap，key：beanName --&gt; value：bean实例 */    private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);    public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {        Assert.notNull(beanName, &quot;Bean name must not be null&quot;);        synchronized (this.singletonObjects) {            //检查缓存中是否有实例，如果缓存中有实例，直接返回            Object singletonObject = this.singletonObjects.get(beanName);            if (singletonObject == null) {                //省略...                try {                    //通过singletonFactory获取单例                    singletonObject = singletonFactory.getObject();                    newSingleton = true;                }                //省略...                if (newSingleton) {                    addSingleton(beanName, singletonObject);                }            }            //返回实例            return singletonObject;        }    }    protected void addSingleton(String beanName, Object singletonObject) {        synchronized (this.singletonObjects) {            this.singletonObjects.put(beanName, singletonObject);            this.singletonFactories.remove(beanName);            this.earlySingletonObjects.remove(beanName);            this.registeredSingletons.add(beanName);        }    }}</code></pre><p>从源码中可以看出，是通过ConcurrentHashMap的方式，如果在Map中存在则直接返回，如果不存在则创建，并且put进Map集合中，并且整段逻辑是使用同步代码块包住的，所以是线程安全的。</p><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式，简单来说就是封装好一组策略算法，外部客户端根据不同的条件选择不同的策略算法解决问题。这在很多框架，还有日常开发都会用到的一种设计模式。在Spring中，我这里举的例子是Resource类，这是所有资源访问类所实现的接口。</p><p>针对不同的访问资源的方式，Spring定义了不同的Resource类的实现类。我们看一张类图：</p><p><img src="https://static.lovebilibili.com/Resource.png" srcset="/img/loading.gif" alt=""></p><p>简单介绍一下Resource的实现类：</p><ul><li><strong>UrlResource</strong>：访问网络资源的实现类。</li><li><strong>ServletContextResource</strong>：访问相对于 ServletContext 路径里的资源的实现类。</li><li><strong>ByteArrayResource</strong>：访问字节数组资源的实现类。</li><li><strong>PathResource</strong>：访问文件路径资源的实现类。</li><li><strong>ClassPathResource</strong>：访问类加载路径里资源的实现类。</li></ul><p>写一段伪代码来示范一下Resource类的使用：</p><pre><code class="java">@RequestMapping(value = &quot;/resource&quot;, method = RequestMethod.GET)public String resource(@RequestParam(name = &quot;type&quot;) String type,                       @RequestParam(name = &quot;arg&quot;) String arg) throws Exception {    Resource resource;    //这里可以优化为通过工厂模式，根据type创建Resource的实现类    if (&quot;classpath&quot;.equals(type)) {        //classpath下的资源        resource = new ClassPathResource(arg);    } else if (&quot;file&quot;.equals(type)) {        //本地文件系统的资源        resource = new PathResource(arg);    } else if (&quot;url&quot;.equals(type)) {        //网络资源        resource = new UrlResource(arg);    } else {        return &quot;fail&quot;;    }    InputStream is = resource.getInputStream();    ByteArrayOutputStream os = new ByteArrayOutputStream();    int i;    while ((i = is.read()) != -1) {        os.write(i);    }    String result = new String(os.toByteArray(), StandardCharsets.UTF_8);    is.close();    os.close();    return &quot;type:&quot; + type + &quot;,arg:&quot; + arg + &quot;\r\n&quot; + result;}</code></pre><p>这就是策略模式的思想，通过外部条件使用不同的算法解决问题。其实很简单，因为每个实现类的getInputStream()方法都不一样，我们看ClassPathResource的源码，是通过类加载器加载资源：</p><pre><code class="java">public class ClassPathResource extends AbstractFileResolvingResource {    private final String path;    @Nullable    private ClassLoader classLoader;    @Nullable    private Class&lt;?&gt; clazz;    @Override    public InputStream getInputStream() throws IOException {        InputStream is;        //通过类加载器加载类路径下的资源        if (this.clazz != null) {            is = this.clazz.getResourceAsStream(this.path);        }        else if (this.classLoader != null) {            is = this.classLoader.getResourceAsStream(this.path);        }        else {            is = ClassLoader.getSystemResourceAsStream(this.path);        }        //如果输入流is为null，则报错        if (is == null) {            throw new FileNotFoundException(getDescription() + &quot; cannot be opened because it does not exist&quot;);        }        //返回InputStream        return is;    }}</code></pre><p>再看UrlResource的源码，获取InputStream的实现又是另一种策略。</p><pre><code class="java">public class UrlResource extends AbstractFileResolvingResource {    @Nullable    private final URI uri;    private final URL url;    private final URL cleanedUrl;    @Override    public InputStream getInputStream() throws IOException {        //获取连接        URLConnection con = this.url.openConnection();        ResourceUtils.useCachesIfNecessary(con);        try {            //获取输入流，并返回            return con.getInputStream();        }        catch (IOException ex) {            // Close the HTTP connection (if applicable).            if (con instanceof HttpURLConnection) {                ((HttpURLConnection) con).disconnect();            }            throw ex;        }    }}</code></pre><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>Spring除了IOC(控制反转)之外的另一个核心就是AOP(面向切面编程)。AOP能够将与业务无关的，却被业务模块所共同调用的逻辑(<strong>比如日志，权限控制等等</strong>)封装起来，减少系统重复代码，降低系统之间的耦合，有利于系统的维护和扩展。</p><p>Spring AOP主要是基于动态代理实现的，如果要代理的类，实现了某个接口，则使用JDK动态代理，如果没有实现接口则使用Cglib动态代理。</p><p>我们看DefaultAopProxyFactory的createAopProxy()方法，Spring通过此方法创建动态代理类：</p><pre><code class="java">public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {    @Override    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {            Class&lt;?&gt; targetClass = config.getTargetClass();            if (targetClass == null) {                throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; + &quot;Either an interface or a target is required for proxy creation.&quot;);            }            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {                return new JdkDynamicAopProxy(config);            }            return new ObjenesisCglibAopProxy(config);        }        else {            return new JdkDynamicAopProxy(config);        }    }}</code></pre><p>JDK动态代理和Cglib动态代理的区别：</p><ul><li>JDK动态代理只能对实现了接口的类生成代理，没有实现接口的类不能使用。</li><li>Cglib动态代理即使被代理的类没有实现接口，也可以使用，因为Cglib动态代理是使用继承被代理类的方式进行扩展。</li><li>Cglib动态代理是通过继承的方式，覆盖被代理类的方法来进行代理，所以如果方法是被final修饰的话，就不能进行代理。</li></ul><p>从源码中可以看出，Spring会先判断是否实现了接口，如果实现了接口就使用JDK动态代理，如果没有实现接口则使用Cglib动态代理，也可以通过配置，强制使用Cglib动态代理，配置如下：</p><pre><code class="xml">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></pre><h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>模板模式在Spring中用得太多了，它定义一个算法的骨架，而将一些步骤延迟到子类中。 一般定义一个抽象类为骨架，子类重写抽象类中的模板方法实现算法骨架中特定的步骤。模板模式可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。</p><p>Spring中的事务管理器就运用模板模式的设计，首先看PlatformTransactionManager类。这是最底层的接口，定义提交和回滚的方法。</p><pre><code class="java">public interface PlatformTransactionManager {    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;    void commit(TransactionStatus status) throws TransactionException;    void rollback(TransactionStatus status) throws TransactionException;}</code></pre><p>毫无意外，使用了抽象类作为骨架，接着看AbstractPlatformTransactionManager类。</p><pre><code class="java">@Overridepublic final void commit(TransactionStatus status) throws TransactionException {    //省略...    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;    if (defStatus.isLocalRollbackOnly()) {        //省略...        //调用processRollback()        processRollback(defStatus, false);        return;    }    if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) {        //省略...        //调用processRollback()        processRollback(defStatus, true);        return;    }    //调用processCommit()    processCommit(defStatus);}//这个方法定义了骨架，里面会调用一个doRollback()的模板方法private void processRollback(DefaultTransactionStatus status, boolean unexpected) {    if (status.hasSavepoint()) {        //省略...    }    else if (status.isNewTransaction()) {        //调用doRollback()模板方法        doRollback(status);    }    else {        //省略...    }    //省略了很多代码...}private void processCommit(DefaultTransactionStatus status) throws TransactionException {    //省略...    if (status.hasSavepoint()) {        //省略...    }    else if (status.isNewTransaction()) {        //省略...        //调用doCommit()模板方法        doCommit(status);    }    else if (isFailEarlyOnGlobalRollbackOnly()) {        unexpectedRollback = status.isGlobalRollbackOnly();    }    //省略了很多代码...}//模板方法doRollback()，把重要的步骤延迟到子类去实现protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException;//模板方法doCommit()，把重要的步骤延迟到子类去实现protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException;</code></pre><p>模板方法则由各种事务管理器的实现类去实现，也就是把骨架中重要的doRollback()延迟到子类。一般来说，Spring默认是使用的事务管理器的实现类是DataSourceTransactionManager。</p><pre><code class="java">//通过继承AbstractPlatformTransactionManager抽象类public class DataSourceTransactionManager extends AbstractPlatformTransactionManager        implements ResourceTransactionManager, InitializingBean {    //重写doCommit()方法，实现具体commit的逻辑    @Override    protected void doCommit(DefaultTransactionStatus status) {        DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();        Connection con = txObject.getConnectionHolder().getConnection();        if (status.isDebug()) {            logger.debug(&quot;Committing JDBC transaction on Connection [&quot; + con + &quot;]&quot;);        }        try {            con.commit();        }        catch (SQLException ex) {            throw new TransactionSystemException(&quot;Could not commit JDBC transaction&quot;, ex);        }    }    //重写doRollback()方法，实现具体的rollback的逻辑    @Override    protected void doRollback(DefaultTransactionStatus status) {        DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();        Connection con = txObject.getConnectionHolder().getConnection();        if (status.isDebug()) {            logger.debug(&quot;Rolling back JDBC transaction on Connection [&quot; + con + &quot;]&quot;);        }        try {            con.rollback();        }        catch (SQLException ex) {            throw new TransactionSystemException(&quot;Could not roll back JDBC transaction&quot;, ex);        }    }}</code></pre><p>如果你是用Hibernate框架，Hibernate也有自身的实现，这就体现了设计模式的开闭原则，通过继承或者组合的方式进行扩展，而不是直接修改类的代码。Hibernate的事务管理器则是HibernateTransactionManager。</p><pre><code class="java">public class HibernateTransactionManager extends AbstractPlatformTransactionManager        implements ResourceTransactionManager, BeanFactoryAware, InitializingBean {    //重写doCommit()方法，实现Hibernate的具体commit的逻辑    @Override    protected void doCommit(DefaultTransactionStatus status) {        HibernateTransactionObject txObject = (HibernateTransactionObject) status.getTransaction();        Transaction hibTx = txObject.getSessionHolder().getTransaction();        Assert.state(hibTx != null, &quot;No Hibernate transaction&quot;);        if (status.isDebug()) {            logger.debug(&quot;Committing Hibernate transaction on Session [&quot; +                    txObject.getSessionHolder().getSession() + &quot;]&quot;);        }        try {            hibTx.commit();        }        catch (org.hibernate.TransactionException ex) {            throw new TransactionSystemException(&quot;Could not commit Hibernate transaction&quot;, ex);        }        //省略...    }    //重写doRollback()方法，实现Hibernate的具体rollback的逻辑    @Override    protected void doRollback(DefaultTransactionStatus status) {        HibernateTransactionObject txObject = (HibernateTransactionObject) status.getTransaction();        Transaction hibTx = txObject.getSessionHolder().getTransaction();        Assert.state(hibTx != null, &quot;No Hibernate transaction&quot;);        //省略...        try {            hibTx.rollback();        }        catch (org.hibernate.TransactionException ex) {            throw new TransactionSystemException(&quot;Could not roll back Hibernate transaction&quot;, ex);        }        //省略...        finally {            if (!txObject.isNewSession() &amp;&amp; !this.hibernateManagedSession) {                txObject.getSessionHolder().getSession().clear();            }        }    }}</code></pre><p>其实模板模式在日常开发中也经常用，比如一个方法中，前后代码都一样，只有中间有一部分操作不同，就可以使用模板模式进行优化代码，这可以大大地减少冗余的代码，非常实用。</p><h1 id="适配器模式与责任链模式"><a href="#适配器模式与责任链模式" class="headerlink" title="适配器模式与责任链模式"></a>适配器模式与责任链模式</h1><p>适配器模式是一种结构型设计模式， 它<strong>能使接口不兼容的对象能够相互合作，将一个类的接口，转换成客户期望的另外一个接口</strong>。</p><p>在SpringAOP中有一个很重要的功能就是使用的 Advice（通知） 来增强被代理类的功能，Advice主要有MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice这几种。每个Advice都有对应的拦截器，如下所示：</p><p><img src="https://static.lovebilibili.com/spring_design_mode_01.png" srcset="/img/loading.gif" alt=""></p><p>Spring需要将每个 Advice 都封装成对应的拦截器类型返回给容器，所以<strong>需要使用适配器模式对 Advice 进行转换</strong>。对应的就有三个适配器，我们看个类图：</p><p><img src="https://static.lovebilibili.com/AdvisorAdapter.png" srcset="/img/loading.gif" alt=""></p><p>适配器在Spring中是怎么把通知类和拦截类进行转换的呢，我们先看适配器的接口。定义了两个方法，分别是supportsAdvice()和getInterceptor()。</p><pre><code class="java">public interface AdvisorAdapter {    //判断通知类是否匹配    boolean supportsAdvice(Advice advice);    //传入通知类，返回对应的拦截类    MethodInterceptor getInterceptor(Advisor advisor);}</code></pre><p>其实很简单，可以看出转换的方法就是getInterceptor()，通过supportsAdvice()进行判断。我们看前置通知的适配器的实现类MethodBeforeAdviceAdapter。</p><pre><code class="java">class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {    //判断是否匹配MethodBeforeAdvice通知类    @Override    public boolean supportsAdvice(Advice advice) {        return (advice instanceof MethodBeforeAdvice);    }    //传入MethodBeforeAdvice，转换为MethodBeforeAdviceInterceptor拦截类    @Override    public MethodInterceptor getInterceptor(Advisor advisor) {        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();        return new MethodBeforeAdviceInterceptor(advice);    }}</code></pre><p>getInterceptor()方法中，调用了对应的拦截类的构造器创建对应的拦截器返回，传入通知类advice作为参数。接着我们看拦截器MethodBeforeAdviceInterceptor。</p><pre><code class="java">public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {    //成员变量，通知类    private MethodBeforeAdvice advice;    //定义了有参构造器，外部通过有参构造器创建MethodBeforeAdviceInterceptor    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {        Assert.notNull(advice, &quot;Advice must not be null&quot;);        this.advice = advice;    }    //当调用拦截器的invoke方法时，就调用通知类的before()方法，实现前置通知    @Override    public Object invoke(MethodInvocation mi) throws Throwable {        //调用通知类的before()方法，实现前置通知        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );        return mi.proceed();    }}</code></pre><p>那么在哪里初始化这些适配器呢，我们看DefaultAdvisorAdapterRegistry()。</p><pre><code class="java">public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable {    private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList&lt;&gt;(3);    public DefaultAdvisorAdapterRegistry() {        //初始化适配器，添加到adapters集合，也就是注册        registerAdvisorAdapter(new MethodBeforeAdviceAdapter());        registerAdvisorAdapter(new AfterReturningAdviceAdapter());        registerAdvisorAdapter(new ThrowsAdviceAdapter());    }    @Override    public void registerAdvisorAdapter(AdvisorAdapter adapter) {        this.adapters.add(adapter);    }    //获取所有的拦截器    @Override    public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {        List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;&gt;(3);        Advice advice = advisor.getAdvice();        if (advice instanceof MethodInterceptor) {            interceptors.add((MethodInterceptor) advice);        }        //遍历adapters集合        for (AdvisorAdapter adapter : this.adapters) {            //调用supportsAdvice()方法，判断入参的advisor是否有匹配的适配器            if (adapter.supportsAdvice(advice)) {                //如果匹配，则调用getInterceptor()转换成对应的拦截器，添加到interceptors集合中                interceptors.add(adapter.getInterceptor(advisor));            }        }        if (interceptors.isEmpty()) {            throw new UnknownAdviceTypeException(advisor.getAdvice());        }        //返回拦截器集合        return interceptors.toArray(new MethodInterceptor[0]);    }}</code></pre><p>适配器模式在这里就是把通知类转为拦截类，转为拦截类之后，就添加到拦截器集合中。添加到拦截器集合之后，就用到了责任链模式，在ReflectiveMethodInvocation类被调用，我们看JDK动态代理JdkDynamicAopProxy的invoke()方法。</p><pre><code class="java">@Override@Nullablepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    MethodInvocation invocation;    //这里就是获取拦截器集合，最后就会调用到上文说的getInterceptors()    List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);    if (chain.isEmpty()) {        //省略...    }else {        //创建一个MethodInvocation        invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);        //调用proceed()方法，底层会通过指针遍历拦截器集合，然后实现前置通知等功能        retVal = invocation.proceed();    }    //省略...}</code></pre><p>最后就在ReflectiveMethodInvocation里调用proceed()方法，proceed()方法是一个递归的方法，通过指针控制递归的结束。这是很典型的责任链模式。</p><pre><code class="java">public class ReflectiveMethodInvocation implements ProxyMethodInvocation, Cloneable {    protected final List&lt;?&gt; interceptorsAndDynamicMethodMatchers;    //指针    private int currentInterceptorIndex = -1;    protected ReflectiveMethodInvocation(Object proxy, @Nullable Object target, Method method, @Nullable Object[] arguments, @Nullable Class&lt;?&gt; targetClass, List&lt;Object&gt; interceptorsAndDynamicMethodMatchers) {        //省略...        //拦截器的集合        this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers;    }    @Override    @Nullable    public Object proceed() throws Throwable {        //    We start with an index of -1 and increment early.        if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {            //递归结束            return invokeJoinpoint();        }        //获取拦截器，并且当前的指针+1        Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {            InterceptorAndDynamicMethodMatcher dm =                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;            if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {                return dm.interceptor.invoke(this);            }            else {                //匹配失败，跳过，递归下一个                return proceed();            }        }        else {            //匹配拦截器，强转为拦截器，然后执行invoke()方法，然后就会调用拦截器里的成员变量的before()，afterReturning()等等，实现前置通知，后置通知，异常通知            return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);        }    }}</code></pre><p>这里可能没学过责任链模式的同学会看得有点晕，但是学过责任链模式应该很容易看懂，这其实跟SpringMVC的拦截器的逻辑实现几乎一样的。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式是一种对象行为型模式，当一个对象发生变化时，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。</p><h2 id="事件角色"><a href="#事件角色" class="headerlink" title="事件角色"></a>事件角色</h2><p>在Spring事件驱动模型中，首先有事件角色ApplicationEvent，这是一个抽象类，抽象类下有四个实现类代表四种事件。</p><ul><li>ContextStartedEvent：ApplicationContext启动后触发的事件。</li><li>ContextStoppedEvent：ApplicationContext停止后触发的事件。</li><li>ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件。</li><li>ContextClosedEvent：ApplicationContext关闭后触发的事件。</li></ul><p><img src="https://static.lovebilibili.com/ApplicationEvent.png" srcset="/img/loading.gif" alt=""></p><h2 id="事件发布者"><a href="#事件发布者" class="headerlink" title="事件发布者"></a>事件发布者</h2><p>有了事件之后，需要有个发布者发布事件，发布者对应的类是ApplicationEventPublisher。</p><pre><code class="java">@FunctionalInterfacepublic interface ApplicationEventPublisher {    default void publishEvent(ApplicationEvent event) {        publishEvent((Object) event);    }    void publishEvent(Object event);}</code></pre><p>@FunctionalInterface表示这是一个函数式接口，函数式接口只有一个抽象方法。ApplicationContext类又继承了</p><p>ApplicationEventPublisher类，所以我们可以使用ApplicationContext发布事件。</p><h2 id="事件监听者"><a href="#事件监听者" class="headerlink" title="事件监听者"></a>事件监听者</h2><p>发布事件后需要有事件的监听者，事件监听者通过实现接口ApplicationListener来定义，这是一个函数式接口，并且带有泛型，要求E参数是ApplicationEvent的子类。</p><pre><code class="java">@FunctionalInterfacepublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener {    void onApplicationEvent(E event);}</code></pre><p>下面我们演示一下怎么使用，首先继承抽象类ApplicationEvent定义一个事件角色PayApplicationEvent。</p><pre><code class="java">public class PayApplicationEvent extends ApplicationEvent {    private String message;    public PayApplicationEvent(Object source, String message) {        super(source);        this.message = message;    }    public String getMessage() {        return message;    }}</code></pre><p>接着定义一个PayApplicationEvent事件的监听者PayListener。</p><pre><code class="java">@Componentpublic class PayListener implements ApplicationListener&lt;PayApplicationEvent&gt; {    @Override    public void onApplicationEvent(PayApplicationEvent event) {        String message = event.getMessage();        System.out.println(&quot;监听到PayApplicationEvent事件，消息为：&quot; + message);    }}</code></pre><p>最后我们使用ApplicationContext发布事件。</p><pre><code class="java">@SpringBootApplicationpublic class SpringmvcApplication {    public static void main(String[] args) throws Exception {        ApplicationContext applicationContext = SpringApplication.run(SpringmvcApplication.class, args);        applicationContext.publishEvent(new PayApplicationEvent(applicationContext,&quot;成功支付100元！&quot;));    }}</code></pre><p>启动之后我们可以看到控制台打印：</p><p><img src="https://static.lovebilibili.com/spring_design_mode_02.png" srcset="/img/loading.gif" alt=""></p><h2 id="絮叨"><a href="#絮叨" class="headerlink" title="絮叨"></a>絮叨</h2><p>实际上，Spring中使用到的设计模式在源码中随处可见，并不止我列举的这些，所以Spring的源码非常值得去阅读和学习，受益良多。反过来看，如果不会设计模式，读起源码来也是非常费劲的，所以我建议还是先学会设计模式再去学习源码。</p><p>希望大家看完之后，能对Spring有更深入的了解，那么这篇文章就讲到这里了，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5千字详细讲解JUC中重要的AQS</title>
    <link href="/2020/12/06/5%E5%8D%83%E5%AD%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3JUC%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84AQS/"/>
    <url>/2020/12/06/5%E5%8D%83%E5%AD%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3JUC%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84AQS/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/aqs_swdt.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="一、什么是AQS"><a href="#一、什么是AQS" class="headerlink" title="一、什么是AQS"></a>一、什么是AQS</h1><p>谈到并发编程，不得不说AQS(AbstractQueuedSynchronizer)，这可谓是Doug Lea老爷子的大作之一。AQS即是抽象队列同步器，是用来构建Lock锁和同步组件的基础框架，很多我们熟知的锁和同步组件都是基于AQS构建，比如ReentrantLock、ReentrantReadWriteLock、CountDownLatch、Semaphore。</p><p>实际上AQS是一个抽象类，我们不妨先看一下源码：</p><pre><code class="java">public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {    //头结点    private transient volatile Node head;    //尾节点    private transient volatile Node tail;    //共享状态    private volatile int state;    //内部类，构建链表的Node节点    static final class Node {        volatile Node prev;        volatile Node next;        volatile Thread thread;    }}//AbstractQueuedSynchronizer的父类public abstract class AbstractOwnableSynchronizer implements java.io.Serializable {    //占用锁的线程    private transient Thread exclusiveOwnerThread;}</code></pre><p>由源码可以看出AQS是有以下几个部分组成的：</p><p><img src="https://static.lovebilibili.com/aqs_01.png" srcset="/img/loading.gif" alt=""></p><h2 id="1-1-state共享变量"><a href="#1-1-state共享变量" class="headerlink" title="1.1 state共享变量"></a>1.1 state共享变量</h2><p>AQS中里一个很重要的字段state，表示同步状态，是由<code>volatile</code>修饰的，用于展示当前临界资源的获锁情况。通过getState()，setState()，compareAndSetState()三个方法进行维护。</p><pre><code class="java">private volatile int state;protected final int getState() {    return state;}protected final void setState(int newState) {    state = newState;}//CAS操作protected final boolean compareAndSetState(int expect, int update) {    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);}</code></pre><p>关于state的几个要点：</p><ul><li>使用volatile修饰，保证多线程间的可见性。</li><li>getState()、setState()、compareAndSetState()使用final修饰，限制子类不能对其重写。</li><li>compareAndSetState()采用乐观锁思想的CAS算法，保证原子性操作。</li></ul><h2 id="1-2-CLH队列"><a href="#1-2-CLH队列" class="headerlink" title="1.2 CLH队列"></a>1.2 CLH队列</h2><p>AQS里另一个重要的概念就是CLH队列，它是一个双向链表队列，其内部由head和tail分别记录头结点和尾结点，队列的元素类型是Node。</p><p>简单讲一下这个队列的作用，就是当一个线程获取同步状态(state)失败时，AQS会将此线程以及等待的状态等信息封装成Node加入到队列中，同时阻塞该线程，等待后续的被唤醒。</p><p>队列的元素就是一个个的Node节点，下面讲一下Node节点的组成：</p><pre><code class="java">static final class Node {    //共享模式下的等待标记    static final Node SHARED = new Node();    //独占模式下的等待标记    static final Node EXCLUSIVE = null;    //表示当前节点的线程因为超时或者中断被取消    static final int CANCELLED =  1;    //表示当前节点的后续节点的线程需要运行，也就是通过unpark操作    static final int SIGNAL    = -1;    //表示当前节点在condition队列中    static final int CONDITION = -2;    //共享模式下起作用，表示后续的节点会传播唤醒的操作    static final int PROPAGATE = -3;    //状态，包括上面的四种状态值，初始值为0，一般是节点的初始状态    volatile int waitStatus;    //上一个节点的引用    volatile Node prev;    //下一个节点的引用    volatile Node next;    //保存在当前节点的线程引用    volatile Thread thread;    //condition队列的后续节点    Node nextWaiter;}</code></pre><h2 id="1-3-exclusiveOwnerThread"><a href="#1-3-exclusiveOwnerThread" class="headerlink" title="1.3 exclusiveOwnerThread"></a>1.3 exclusiveOwnerThread</h2><p>AQS通过继承AbstractOwnableSynchronizer类，拥有的属性。表示独占模式下同步器的持有者。</p><h1 id="二、AQS的实现原理"><a href="#二、AQS的实现原理" class="headerlink" title="二、AQS的实现原理"></a>二、AQS的实现原理</h1><p>AQS有两种模式，分别是独占式和共享式。</p><h2 id="2-1-独占式"><a href="#2-1-独占式" class="headerlink" title="2.1 独占式"></a>2.1 独占式</h2><p>同一时刻仅有一个线程持有同步状态，也就是其他线程只有在占有的线程释放后才能竞争，比如<strong>ReentrantLock</strong>。下面从源码切入，梳理独占式的实现思路。</p><p>首先看acquire()方法，这是AQS在独占模式下获取同步状态的方法。</p><pre><code class="java">public final void acquire(int arg) {    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();}</code></pre><p>先讲这个方法的总体思路：</p><ul><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回。</li><li>如果失败则调用addWaiter()方法把当前线程包装成Node(状态为EXCLUSIVE，标记为独占模式)插入到CLH队列末尾。</li><li>然后acquireQueued()方法使线程阻塞在等待队列中获取资源，一直获取到资源后才返回，如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ul><p>我们展开来分析，看tryAcquire()方法，尝试获取资源，成功返回true，失败返回false。</p><pre><code class="java">//直接抛出异常，这是由子类进行实现的方法，体现了模板模式的思想protected boolean tryAcquire(int arg) {    throw new UnsupportedOperationException();}</code></pre><p>为什么没有具体实现呢，其实这是模板模式的思想。这个方法是尝试获取资源，但是获取资源的方式有很多种实现，比如<strong>公平锁有公平锁的获取方式，非公平锁有非公平锁的获取方式</strong>(后面会讲，别急)。所以这里是一个没有具体实现的方法，需要由子类去实现。</p><p>接着看addWaiter()方法，这个方法的作用是把当前线程包装成Node添加到队列中。</p><pre><code class="java">private Node addWaiter(Node mode) {    //把当前线程包装成Node节点    Node node = new Node(Thread.currentThread(), mode);    //获取到尾结点    Node pred = tail;    //判断尾结点是否为null，如果不为空，那就证明队列已经初始化了    if (pred != null) {        //已经初始化了，就直接把Node节点添加到队列的末尾        node.prev = pred;        if (compareAndSetTail(pred, node)) {            pred.next = node;            //返回包含当前线程的节点Node            return node;        }    }    //如果队列没有初始化，那就调用enq()方法    enq(node);    return node;}</code></pre><p>接着我们看enq()方法，就是一个自旋的操作，把传进来的node添加到队列最后，如果队列没有初始化则进行初始化。</p><pre><code class="java">private Node enq(final Node node) {    //自旋操作，也就是死循环，只有加入队列成功才会return    for (;;) {        //把尾结点赋值给t        Node t = tail;        //如果为空，证明没有初始化，进行初始化        if (t == null) { // Must initialize            //创建一个空的Node节点，并且设置为头结点            if (compareAndSetHead(new Node()))                //然后把头结点赋值给尾结点                tail = head;        } else {            //如果是第一次循环为空，就已经创建了一个一个Node，那么第二次循环就不会为空了            //如果尾结点不为空，就把传进来的node节点的前驱节点指向尾结点            node.prev = t;            //cas原子性操作，把传进来的node节点设置为尾结点            if (compareAndSetTail(t, node)) {                //把原来的尾结点的后驱节点指向传进来的node节点                t.next = node;                return t;            }        }    }}</code></pre><p>接着我们再把思路跳回去顶层的方法，看acquireQueued()方法。</p><pre><code class="java">//在队列中的节点node通过acquireQueued()方法获取资源，忽略中断。final boolean acquireQueued(final Node node, int arg) {    boolean failed = true;    try {        boolean interrupted = false;        //自旋的操作，一个死循环        for (;;) {            //获取传进来的node节点的前驱节点，赋值给p            final Node p = node.predecessor();            //如果p是头结点，node节点就是第二个节点，则再次去尝试获取资源            if (p == head &amp;&amp; tryAcquire(arg)) {                //tryAcquire(arg)获取资源成功的话，则把node节点设置为头结点                setHead(node);                //把原来的头结点p的后驱节点设置为null，等待GC垃圾回收                p.next = null; // help GC                failed = false;                return interrupted;            }            //如果p不是头结点，或者tryAcquire()获取资源失败，判断是否可以被park，也就是把线程阻塞起来            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())//&amp;&amp;前面如果返回true，将当前线程阻塞并检查是否被中断                //如果阻塞过程中被中断，则置interrupted标志位为true。                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}</code></pre><p>最后是selfInterrupt()方法，自我中断。</p><pre><code class="java">static void selfInterrupt() {    Thread.currentThread().interrupt();}</code></pre><p>过程记不住没关系，下面画张图来总结一下，其实很简单。</p><p><img src="https://static.lovebilibili.com/aqs_02.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="2-2-共享式"><a href="#2-2-共享式" class="headerlink" title="2.2 共享式"></a>2.2 共享式</h2><p>即共享资源可以被多个线程同时占有，直到共享资源被占用完毕。比如ReadWriteLock和CountdownLatch。下面我们从源码去分析其实现原理。</p><p>首先还是看最顶层的acquireShared()方法。</p><pre><code class="java">public final void acquireShared(int arg) {    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg);}</code></pre><p>这段代码很简单，首先调用tryAcquireShared()方法，tryAcquireShared返回是一个int数值，当返回值大于等于0的时候，说明获得成功获取锁，方法结束，否则返回负数，表示获取同步状态失败，执行doAcquireShared方法。</p><p>tryAcquireShared()方法是一个模板方法由子类去重写，意思是需要如何获取同步资源由实现类去定义，AQS只是一个框架。</p><p>那么就看如果获取资源失败，执行的doAcquireShared()方法。</p><pre><code class="java">private void doAcquireShared(int arg) {    //调用addWaiter()方法，把当前线程包装成Node，标志为共享式，插入到队列中    final Node node = addWaiter(Node.SHARED);    boolean failed = true;    try {        boolean interrupted = false;        for (;;) {            //获取当前节点node的前驱节点            final Node p = node.predecessor();            //前驱节点是否是头结点            if (p == head) {                //如果前驱节点是头结点，则调用tryAcquireShared()获取同步资源                int r = tryAcquireShared(arg);                //r&gt;=0表示获取同步资源成功，只有获取成功，才会执行到return退出for循环                if (r &gt;= 0) {                    //设置node为头结点                    setHeadAndPropagate(node, r);                    p.next = null; // help GC                    if (interrupted)                        selfInterrupt();                    failed = false;                    return;                }            }            //判断是否可以被park，跟独占式的逻辑一样返回true，则进行park操作，阻塞线程            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}</code></pre><p>这段逻辑基本上跟独占式的逻辑差不多，不同的地方在于入队的Node是标志为SHARED共享式的，获取同步资源的方式是tryAcquireShared()方法。</p><h1 id="三、AQS的模板模式"><a href="#三、AQS的模板模式" class="headerlink" title="三、AQS的模板模式"></a>三、AQS的模板模式</h1><p>模板模式在AQS中的应用可谓是一大精髓，在上文中有提到的tryAcquireShared()和tryAcquire()都是很重要的模板方法。一般使用AQS往往都是使用一个内部类继承AQS，然后重写相应的模板方法。</p><p>AQS已经把一些常用的，比如入队，出队，CAS操作等等构建了一个框架，使用者只需要实现获取资源，释放资源的，因为很多锁，还有同步器，其实就是获取资源和释放资源的方式有比较大的区别。</p><p>那么我们看一下模板方法有哪些。</p><h2 id="3-1-tryAcquire"><a href="#3-1-tryAcquire" class="headerlink" title="3.1 tryAcquire()"></a>3.1 tryAcquire()</h2><p>tryAcquire()方法，独占式获取同步资源，返回true表示获取同步资源成功，false表示获取失败。</p><pre><code class="java">protected boolean tryAcquire(int arg) {    throw new UnsupportedOperationException();}</code></pre><h2 id="3-2-tryRelease"><a href="#3-2-tryRelease" class="headerlink" title="3.2 tryRelease()"></a>3.2 tryRelease()</h2><p>tryRelease()方法，独占式使用，tryRelease()的返回值来判断该线程是否已经完成释放资源，子类来决定是否能成功释放锁。</p><pre><code class="java">protected boolean tryRelease(int arg) {    throw new UnsupportedOperationException();}</code></pre><h2 id="3-3-tryAcquireShared"><a href="#3-3-tryAcquireShared" class="headerlink" title="3.3 tryAcquireShared()"></a>3.3 tryAcquireShared()</h2><p>tryAcquireShared()方法，共享式获取同步资源，返回大于等于0表示获取资源成功，返回小于0表示失败。</p><pre><code class="java&#39;">protected int tryAcquireShared(int arg) {    throw new UnsupportedOperationException();}</code></pre><h2 id="3-4-tryReleaseShared"><a href="#3-4-tryReleaseShared" class="headerlink" title="3.4 tryReleaseShared()"></a>3.4 tryReleaseShared()</h2><p>tryReleaseShared()方法，共享式尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p><pre><code class="java">protected boolean tryReleaseShared(int arg) {    throw new UnsupportedOperationException();}</code></pre><h2 id="3-5-isHeldExclusively"><a href="#3-5-isHeldExclusively" class="headerlink" title="3.5 isHeldExclusively()"></a>3.5 isHeldExclusively()</h2><p>isHeldExclusively()方法，该线程是否正在独占资源。只有用到condition才需要去实现它。</p><pre><code class="java">protected boolean isHeldExclusively() {    throw new UnsupportedOperationException();}</code></pre><h1 id="四、认识ReentrantLock"><a href="#四、认识ReentrantLock" class="headerlink" title="四、认识ReentrantLock"></a>四、认识ReentrantLock</h1><p>ReentrantLock是一个很经典的使用AQS的案例，不妨以此为切入点来继续深入。ReentrantLock的特性有很多，首先它是一个悲观锁，其次有两种模式分别是公平锁和非公平锁，最后它是重入锁，也就是能够对共享资源重复加锁。</p><p>AQS通常是使用内部类实现，所以不难想象在ReentrantLock类里有两个内部类，我们看一张类图。</p><p><img src="https://static.lovebilibili.com/aqs_03.png" srcset="/img/loading.gif" alt=""></p><p>FairSync是公平锁的实现，NonfairSync则是非公平锁的实现。通过构造器传入的boolean值进行判断。</p><pre><code class="java">public ReentrantLock(boolean fair) {    //true则使用公平锁，false则使用非公平锁    sync = fair ? new FairSync() : new NonfairSync();}//默认是非公平锁public ReentrantLock() {    sync = new NonfairSync();}</code></pre><p>公平锁是遵循<strong>FIFO</strong>（先进先出）原则的，先到的线程会优先获取资源，后到的线程会进行排队等待，能保证每个线程都能拿到锁，不会存在有线程饿死的情况。</p><p>非公平锁是则不遵守先进先出的原则，会出现有线程插队的情况，不能保证每个线程都能拿到锁，会存在有线程饿死的情况。</p><p>下面我们从源码分析去找出这两种锁的区别。</p><h1 id="五、源码分析ReentrantLock"><a href="#五、源码分析ReentrantLock" class="headerlink" title="五、源码分析ReentrantLock"></a>五、源码分析ReentrantLock</h1><h2 id="5-1-上锁"><a href="#5-1-上锁" class="headerlink" title="5.1 上锁"></a>5.1 上锁</h2><p>ReentrantLock是通过lock()方法上锁，所以看lock()方法。</p><pre><code class="java">public void lock() {    sync.lock();}</code></pre><p>sync就是NonfairSync或者FairSync。</p><pre><code class="java">//这里就是调用AQS的acquire()方法，获取同步资源final void lock() {    acquire(1);}</code></pre><p>acquire()方法前面已经解析过了，主要看FairSync的tryAcquire()方法。</p><pre><code class="java">protected final boolean tryAcquire(int acquires) {    //获取当前线程    final Thread current = Thread.currentThread();    //获取同步状态    int c = getState();    //判断同步状态是否为0    if (c == 0) {        //关键在这里，公平锁会判断是否需要排队        if (!hasQueuedPredecessors() &amp;&amp;            //如果不需要排队，则直接cas操作更新同步状态为1            compareAndSetState(0, acquires)) {            //设置占用锁的线程为当前线程            setExclusiveOwnerThread(current);            //返回true，表示上锁成功            return true;        }    }    //判断当前线程是否是拥有锁的线程，主要是可重入锁的逻辑    else if (current == getExclusiveOwnerThread()) {        //如果是当前线程，则同步状态+1        int nextc = c + acquires;        if (nextc &lt; 0)            throw new Error(&quot;Maximum lock count exceeded&quot;);        //设置同步状态        setState(nextc);        return true;    }    //以上情况都不是，则返回false，表示上锁失败。上锁失败根据AQS的框架设计，会入队排队    return false;}</code></pre><p>如果是非公平锁NonfairSync的tryAcquire()，我们继续分析。</p><pre><code class="java">protected final boolean tryAcquire(int acquires) {    return nonfairTryAcquire(acquires);}//非公平式获取锁final boolean nonfairTryAcquire(int acquires) {    //这段跟公平锁是一样的操作    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) {        //关键在这里，不再判断是否需要排队，而是直接去更新同步状态，通俗点讲就是插队        if (compareAndSetState(0, acquires)) {            //如果获取同步状态成功，则设置占用锁的线程为当前线程            setExclusiveOwnerThread(current);            //返回true表示获取锁成功            return true;        }    }    //以下逻辑跟公平锁的逻辑一样    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0) // overflow            throw new Error(&quot;Maximum lock count exceeded&quot;);        setState(nextc);        return true;    }    return false;}</code></pre><p>其实很明显了，关键的区别就在于尝试获取锁的时候，公平锁会判断是否需要排队再去更新同步状态，非公平锁是直接就更新同步，不判断是否需要排队。</p><p>从性能上来说，公平锁的性能是比非公平锁要差的，因为<strong>公平锁要遵守FIFO(先进先出)的原则，这就会增加了上下文切换与等待线程的状态变换时间</strong>。</p><p>非公平锁的缺点也是很明显的，因为允许插队，这就会存在有线程饿死的情况。</p><h2 id="5-2-解锁"><a href="#5-2-解锁" class="headerlink" title="5.2 解锁"></a>5.2 解锁</h2><p>解锁对应的方法就是unlock()。</p><pre><code class="java">public void unlock() {    //调用AQS中的release()方法    sync.release(1);}//这是AQS框架定义的release()方法public final boolean release(int arg) {    //当前锁是不是没有被线程持有,返回true表示该锁没有被任何线程持有    if (tryRelease(arg)) {        //获取头结点h        Node h = head;        //判断头结点是否为null并且waitStatus不是初始化节点状态，解除线程挂起状态        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    }    return false;}</code></pre><p>关键在于tryRelease()，这就不需要分公平锁和非公平锁的情况，只需要考虑可重入的逻辑。</p><pre><code class="java">protected final boolean tryRelease(int releases) {    //减少可重入的次数    int c = getState() - releases;    //如果当前线程不是持有锁的线程，抛出异常    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    // 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state    if (c == 0) {        //状态为0，表示持有线程被全部释放，设置为true        free = true;        setExclusiveOwnerThread(null);    }    setState(c);    return free;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JUC可谓是学习java的一个难点，而学习AQS其实关键在于并发的思维，因为需要考虑的情况很多，其次需要理解模板模式的思想，这才能理解为什么AQS作为一个框架的作用。ReentrantLock这个类我觉得是理解AQS一个很好的切入点，看懂了之后再去看AQS的其他应用类应该会轻松很多。</p><p>那么这篇文章就讲到这里了，希望看完能有所收获，感谢你的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讲讲并发编程的悲观锁和乐观锁</title>
    <link href="/2020/11/29/%E8%AE%B2%E8%AE%B2%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <url>/2020/11/29/%E8%AE%B2%E8%AE%B2%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/bllock_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>悲观锁是平时开发中经常用到的一种锁，比如<code>ReentrantLock</code>和<code>synchronized</code>等就是这种思想的体现，它总是假设别的线程在拿线程的时候都会修改数据，所以每次拿到数据的时候都会上锁，这样别的线程想拿这个数据就会被阻塞。如图所示：</p><p><img src="https://static.lovebilibili.com/bllock_1.png" srcset="/img/loading.gif" alt=""></p><p><code>synchronized</code>是悲观锁的一种实现，一般我们都会有这样使用：</p><pre><code class="java">private static Object monitor = new Object();public static void main(String[] args) throws Exception {    //锁一段代码块    synchronized (monitor){    }}//锁实例方法，锁对象是this，即该类实例本身public synchronized void doSome(){}//锁静态方法，锁对象是该类，即XXX.classpublic synchronized static void add(){}</code></pre><p>我们以最简单的同步代码块来分析，其实就是将synchronized作用于一个给定的实例对象monitor，即当前实例对象就是锁对象，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有monitor实例对象锁，<strong>如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行synchronized内包裹的代码块</strong>。</p><p>从上面的分析中可以看出，悲观锁是独占和排他的，只要操作资源都会对资源进行加锁。假设<strong>读多写少</strong>的情况下，使用悲观锁的效果就不是很好。这时就引出了接下来要讲的乐观锁。</p><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁，顾名思义它总是假设最好的情况，线程每次去拿数据时都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。如图所示：</p><p><img src="https://static.lovebilibili.com/bllock_2.png" srcset="/img/loading.gif" alt=""></p><p>一般乐观锁在java中是通过无锁编程实现的，最常见的就是CAS算法，比如Java并发包中的原子类的递增操作就是通过CAS算法实现的。</p><p>CAS算法，其实就是Compare And Swap(比较与交换)的意思。目的就是将内存的值更新为需要的值，但是有个条件，内存值必须与期待的原内存值相同。展开来说，我们有三个变量，内存值M，期望的内存值E，更新值U，<strong>只有当M==E时，才会将M更新为U</strong>。</p><p>CAS算法实现的乐观锁在很多地方有应用，比如并发包的原子类AtomicInteger类。在自增的时候就使用到CAS算法。</p><pre><code class="java">public final int getAndIncrement() {    return unsafe.getAndAddInt(this, valueOffset, 1);}//var1 是this指针//var2 是偏移量//var4 是自增量public final int getAndAddInt(Object var1, long var2, int var4) {    int var5;    do {        //获取内存，称之为期待的内存值E        var5 = this.getIntVolatile(var1, var2);        //var5 + var4的结果是更新值U        //这里使用JNI方法，每个线程将自己内存中的内存值M与var5期望值比较，        //如果相同则更新为var5 + var4，返回true跳出循环。        //如果不相同，则把内存值M更新为最新的内存值，然后自旋，直到更新成功为止    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));    //返回更新后的值    return var5;}public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code></pre><p>所以可以看出CAS算法其实是无锁的。好处是在读多写少的情况下，性能是比较好的。那么CAS算法的缺点其实也是很明显的。</p><ul><li><strong>ABA问题</strong>。线程C将内存值A改成了B后，又改成了A，而线程D会认为内存值A没有改变过，这个问题就称为ABA问题。解决办法很简单，在变量前面加上版本号，每次变量更新的时候变量的<strong>版本号都<code>+1</code></strong>，即<code>A-&gt;B-&gt;A</code>就变成了<code>1A-&gt;2B-&gt;3A</code>。</li><li>在写多读少的情况下，也就是频繁更新数据，那么会导致其他线程经常更新失败，那么就会进入自旋，自旋时会<strong>占用CPU资源</strong>。如果资源竞争激烈，多线程自旋的时间长，导致<strong>消耗资源</strong>。</li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在<strong>读多写少的场景</strong>下，更新时很少发生冲突，<strong>使用乐观锁</strong>，减少了上锁和释放锁的开销，可以有效地提升系统的性能。</p><p>相反，在<strong>写多读少的场景</strong>下，如果使用乐观锁会导致更新时经常产生冲突，然后线程会循环重试，这样会增大CPU的消耗。在这种情况下，<strong>建议可以使用悲观锁</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在日常的开发中，悲观锁和乐观锁应该是见得最多，用得最多的锁，比如最常见的<code>synchronized</code>和<code>ReentrantLock</code>是悲观锁，并发包中的原子类和ConcurrentHashMap则用了乐观锁。锁的实现并不复杂，关键是搞懂这两种锁的思想，这样才能在合适的地方使用合适的锁。</p><p>这篇文章就讲到这里了，希望看完后能有所收获，感谢你的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三千字给大伙讲讲线程池</title>
    <link href="/2020/11/29/%E4%B8%89%E5%8D%83%E5%AD%97%E7%BB%99%E5%A4%A7%E4%BC%99%E8%AE%B2%E8%AE%B2%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2020/11/29/%E4%B8%89%E5%8D%83%E5%AD%97%E7%BB%99%E5%A4%A7%E4%BC%99%E8%AE%B2%E8%AE%B2%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/ThreadPool_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在实际开发场景中，我们经常要使用多线程开发应用，比如实现异步操作，或者为了提高程序的效率等等。但是以前我见过有实习生在使用的时候是直接new Runable()，然后start()。没有使用线程池，可能很多初学者对线程池在多线程开发中没有足够的认识，所以我写一篇文章讲讲线程池，希望对大家有所启发。</p><h1 id="一、什么是线程池"><a href="#一、什么是线程池" class="headerlink" title="一、什么是线程池"></a>一、什么是线程池</h1><p>线程池借鉴了”池化”技术的思想，线程池能够对线程的生命周期进行管理，对线程重复利用，并且能够以一种简单的方式将任务的提交与执行相解耦。</p><p>举个例子来说，线程就像是某个公司的客服小姐姐，每天都要接很多客户的电话，如果同时有1000个客户打电话进来咨询，按正常的逻辑，那就需要1000个客服小姐姐，但是在现实中往往需要考虑成本问题，招这么多人费用太多了，于是就可以这样优化，可以招100个人成立一个客服中心，如果同时超过100个人则提示让客户等待，等有空闲的客服小姐姐时就去响应客户。实现效益最大化。这就是一个池化技术在现实生活中类似的例子。</p><h1 id="二、为什么使用线程池"><a href="#二、为什么使用线程池" class="headerlink" title="二、为什么使用线程池"></a>二、为什么使用线程池</h1><p>一种技术的出现，肯定是要解决存在的问题。如果不用线程池，会怎么样呢？很简单，需要时创建线程，线程跑完销毁，如果频繁去做这两个动作，就会造成比较大的资源消耗。所以线程池主要就是解决这个问题。</p><p>因此在《java并发编程的艺术》书中就提到以下几点：</p><ul><li><strong>降低资源消耗</strong>。通过重复使用已创建的线程，降低线程创建和销毁造成的资源消耗。</li><li><strong>提高响应速度</strong>。当有任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。使用线程池可以进行统一的分配，调优和监控。</li></ul><h1 id="三、Executor"><a href="#三、Executor" class="headerlink" title="三、Executor"></a>三、Executor</h1><p>创建线程池主要使用ThreadPoolExecutor这个类，所以我们先看一张类图。</p><p><img src="https://static.lovebilibili.com/Executor.png" srcset="/img/loading.gif" alt=""></p><p>一般来说，遵守面向接口编程的思想，我们都喜欢使用ExecutorService接口接收线程池实例。如下：</p><pre><code class="java">public static void main(String[] args) throws Exception {    //创建线程池    ExecutorService executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10));}</code></pre><p>这里可以看到创建线程池是使用ThreadPoolExecutor构造器来创建。构造器的参数有什么意义呢，继续往下看。</p><h2 id="3-1-七个关键参数"><a href="#3-1-七个关键参数" class="headerlink" title="3.1 七个关键参数"></a>3.1 七个关键参数</h2><pre><code class="java">/*** corePoolSize 核心线程数* maximumPoolSize 最大线程数* keepAliveTime 线程存活时间* unit keepAliveTime的时间单位，有日，小时，分钟，秒等等* workQueue 工作队列* threadFactory 线程工厂，用于创建线程* handler 饱和策略*/public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) {    //省略...}</code></pre><p>那么这7个参数，在线程池工作时，起到什么作用呢？直接看一张图就明白了。</p><p><img src="https://static.lovebilibili.com/ThreadPool.png" srcset="/img/loading.gif" alt=""></p><p>这里有两个参数需要讲解一下，工作队列workQueue和饱和策略handler。</p><p>工作队列的类是BlockingQueue，是一个接口，我们先看看类图，看一下有哪些子类可以使用。</p><p><img src="https://static.lovebilibili.com/BlockingQueue.png" srcset="/img/loading.gif" alt=""></p><p>可以看到有很多实现的子类，功能也各有不同。下面讲几个有代表性的。</p><p><strong>DelayQueue</strong>是无界的队列，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。</p><p><strong>LinkedBlockingDeque</strong>是基于双向链表实现的双向并发阻塞队列，该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作（添加或删除）；并且该阻塞队列是支持线程安全。可以指定队列的容量，如果不指定默认容量大小是<code>Integer.MAX_VALUE</code>。</p><p><strong>ArrayBlockingQueue</strong>是基于数组实现的有界阻塞队列，此队列按先进先出的原则对元素进行排序。新元素插入到队列的尾部，获取元素的操作则从队列的头部进行。</p><p><strong>PriorityBlockingQueue</strong>是带优先级的无界阻塞队列，每次出队都返回优先级最高或者最低的元素(规则可以通过实现Comparable接口自己制定)，内部是使用平衡二叉树实现的，遍历不保证有序。</p><p>饱和策略只要看RejectedExecutionHandler接口，以及其实现子类。</p><p><img src="https://static.lovebilibili.com/RejectedExecutionHandler.png" srcset="/img/loading.gif" alt=""></p><p>饱和策略主要有四种，如果要自定义饱和策略也很简单，实现RejectedExecutionHandler接口，重写rejectedExecution()方法即可。下面介绍JDK里的四种饱和策略。</p><ul><li>AbortPolicy，直接抛出异常，简单粗暴。</li><li>CallerRunsPolicy，在任务被拒绝添加后，会调用当前线程池的所在的线程去执行被拒绝的任务。</li><li>DiscardPolicy，什么都不做，既不抛出异常，也不会执行。</li><li>DiscardOldestPolicy，当任务被拒绝添加时，会抛弃任务队列中最旧的任务(也就是最先加入队列的任务)，再把这个新任务添加进去。</li></ul><h2 id="3-2-Executors"><a href="#3-2-Executors" class="headerlink" title="3.2 Executors"></a>3.2 Executors</h2><p>Executors类提供了四种线程池，根据使用不同的参数去new ThreadPoolExecutor实现。简单介绍一下。</p><p>第一种是<strong>newFixedThreadPool</strong>，这是创建固定大小的线程池，核心线程数和最大线程数都设置相同的值，使用LinkedBlockingQueue作为工作队列，当corePoolSize满了之后就加入到LinkedBlockingQueue队列中。LinkedBlockingQueue默认大小为Integer.MAX_VALUE，所以会有OOM的风险。</p><pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());}</code></pre><p>第二种是<strong>newSingleThreadExecutor</strong>，创建线程数为1的线程池，并且使用了LinkedBlockingQueue，核心线程数和最大线程数都为1，满了就放入队列中，执行完了就从队列取一个。也就是创建了一个具有缓冲队列的单线程的线程池。跟上面的问题一样，队列的容量默认是Integer.MAX_VALUE，也会有OOM的风险。</p><pre><code class="java">public static ExecutorService newSingleThreadExecutor() {    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));}</code></pre><p>第三种是<strong>newCachedThreadPool</strong>，创建可缓冲的线程池，没有大小限制。核心线程数是0，最大线程数是Integer.MAX_VALUE，所以当有新任务时，任务会放入SynchronousQueue队列中，SynchronousQueue只能存放大小为1，所以会立刻新起线程。如果在工作线程在指定时间(60秒)空闲，则会自动终止。</p><pre><code class="java">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;(),                                  threadFactory);}</code></pre><p>第四种是<strong>newScheduledThreadPool</strong>，支持定时及周期性任务执行的线程池。</p><pre><code class="java">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {    return new ScheduledThreadPoolExecutor(corePoolSize);}public ScheduledThreadPoolExecutor(int corePoolSize) {    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue());}</code></pre><h2 id="3-3-使用规范"><a href="#3-3-使用规范" class="headerlink" title="3.3 使用规范"></a>3.3 使用规范</h2><p>在阿里java开发规范中，是<strong>强制</strong>不允许使用Executors创建线程池，我们不妨看看。</p><p><img src="https://static.lovebilibili.com/ThreadPool_1.png" srcset="/img/loading.gif" alt=""></p><p>假如有人头铁不信，那我们写一段代码模拟一下。</p><pre><code class="java">public class ThreadTest {    private static AtomicInteger num = new AtomicInteger();    public static void main(String[] args) throws Exception {        //创建线程池        ExecutorService executor = Executors.newCachedThreadPool();        while (true) {            executor.execute(() -&gt; {                try {                    System.out.println(&quot;线程数：&quot; + num.incrementAndGet());                    Thread.sleep(10000);                } catch (Exception e) {                    e.printStackTrace();                }            });        }    }}</code></pre><p>然后设置JVM的参数<code>-Xms5M -Xmx5M</code>，运行一小段时间，就会看到报错了。</p><p><img src="https://static.lovebilibili.com/ThreadPool_2.png" srcset="/img/loading.gif" alt=""></p><p>第二个问题是线程数的设置，设置多少线程数比较合适呢？</p><p>如果是<strong>cpu密集型</strong>的应用，cpu密集的意思是<strong>执行的任务大部分时间是在做计算和逻辑判断</strong>，这种情况显然不能设置太多的线程数，否则花在线程之间的切换时间就变多，效率就会变得低下。所以一般这种情况设置<strong>线程数为cpu核数+1</strong>即可。</p><p>cpu核数可以通过<code>Runtime</code>获取。</p><pre><code class="java">Runtime.getRuntime().availableProcessors()</code></pre><p>如果是<strong>IO密集型</strong>的应用，IO密集的意思是<strong>执行的任务需要执行大量的IO操作，比如网络IO，磁盘IO</strong>，对CPU的使用率较低，因为在IO操作的特点需要等待，那么就可以把CPU切换到其他线程。所以可以设置<strong>线程数为CPU核数的两倍+1</strong>。</p><h1 id="絮叨"><a href="#絮叨" class="headerlink" title="絮叨"></a>絮叨</h1><p>经过学习之后，我们就要养成使用多线程不能直接new一个Thread，然后start()，要有使用线程池的意识。其次要理解线程池参数的意义，根据实际情况去设置。</p><p>并发编程往往是实际开发中比较容易出问题，希望看完这篇文章能减少一些不必要的错误。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot启动流程是怎样的？</title>
    <link href="/2020/11/15/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/"/>
    <url>/2020/11/15/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/SpringBoot_7.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SpringBoot一开始最让我印象深刻的就是通过一个启动类就能启动应用。在SpringBoot以前，启动应用虽然也不麻烦，但是还是有点繁琐，要打包成war包，又要配置tomcat，tomcat又有一个server.xml文件去配置。</p><p>然而SpringBoot则内置了tomcat，通过启动类启动，配置也集中在一个application.yml中，简直不要太舒服。好奇心驱动，于是我很想搞清楚启动类的启动过程，那么开始吧。</p><h1 id="一、启动类"><a href="#一、启动类" class="headerlink" title="一、启动类"></a>一、启动类</h1><p>首先我们看最常见的启动类写法。</p><pre><code class="java">@SpringBootApplicationpublic class SpringmvcApplication {    public static void main(String[] args) {        SpringApplication.run(SpringmvcApplication.class, args);    }}</code></pre><p>把启动类分解一下，实际上就是两部分：</p><ul><li>@SpringBootApplication注解</li><li>一个main()方法，里面调用SpringApplication.run()方法。</li></ul><h1 id="二、-SpringBootApplication"><a href="#二、-SpringBootApplication" class="headerlink" title="二、@SpringBootApplication"></a>二、@SpringBootApplication</h1><p>首先看@SpringBootApplication注解的源码。</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {}</code></pre><p>很明显，@SpringBootApplication注解由三个注解组合而成，分别是：</p><ul><li>@ComponentScan</li><li>@EnableAutoConfiguration</li><li>@SpringBootConfiguration</li></ul><h2 id="2-1-ComponentScan"><a href="#2-1-ComponentScan" class="headerlink" title="2.1 @ComponentScan"></a>2.1 @ComponentScan</h2><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan {}</code></pre><p>这个注解的作用是<strong>告诉Spring扫描哪个包下面类，加载符合条件的组件</strong>(比如贴有@Component和@Repository等的类)或者bean的定义。</p><p>所以有一个basePackages的属性，如果默认不写，则从声明@ComponentScan所在类的package进行扫描。</p><p>所以<strong>启动类最好定义在Root package下</strong>，因为一般我们在使用@SpringBootApplication时，都不指定basePackages的。</p><h2 id="2-2-EnableAutoConfiguration"><a href="#2-2-EnableAutoConfiguration" class="headerlink" title="2.2 @EnableAutoConfiguration"></a>2.2 @EnableAutoConfiguration</h2><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration {}</code></pre><p>这是一个复合注解，看起来很多注解，实际上关键在@Import注解，它会加载AutoConfigurationImportSelector类，然后就会触发这个类的selectImports()方法。根据返回的String数组(配置类的Class的名称)加载配置类。</p><pre><code class="java">public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {    //返回的String[]数组，是配置类Class的类名    @Override    public String[] selectImports(AnnotationMetadata annotationMetadata) {        if (!isEnabled(annotationMetadata)) {            return NO_IMPORTS;        }        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);        //返回配置类的类名        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());    }}</code></pre><p>我们一直点下去，就可以找到最后的幕后英雄，就是SpringFactoriesLoader类，通过loadSpringFactories()方法加载META-INF/spring.factories中的配置类。</p><p><img src="https://static.lovebilibili.com/SpringBoot_1.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/SpringBoot_2.png" srcset="/img/loading.gif" alt=""></p><p>这里使用了spring.factories文件的方式加载配置类，提供了很好的扩展性。</p><p>所以@EnableAutoConfiguration注解的作用其实就是开启自动配置，自动配置主要则依靠这种加载方式来实现。</p><h2 id="2-3-SpringBootConfiguration"><a href="#2-3-SpringBootConfiguration" class="headerlink" title="2.3 @SpringBootConfiguration"></a>2.3 @SpringBootConfiguration</h2><p><strong>@SpringBootConfiguration继承自@Configuration，二者功能也一致</strong>，标注当前类是配置类，<br>并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。</p><h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h2><p>我们在这里画张图把@SpringBootApplication注解包含的三个注解分别解释一下。</p><p><img src="https://static.lovebilibili.com/SpringBoot_3.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、SpringApplication类"><a href="#三、SpringApplication类" class="headerlink" title="三、SpringApplication类"></a>三、SpringApplication类</h1><p>接下来讲main方法里执行的这句代码，这是SpringApplication类的静态方法run()。</p><pre><code class="java">//启动类的main方法public static void main(String[] args) {    SpringApplication.run(SpringmvcApplication.class, args);}//启动类调的run方法public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) {    //调的是下面的，参数是数组的run方法    return run(new Class&lt;?&gt;[] { primarySource }, args);}//和上面的方法区别在于第一个参数是一个数组public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) {    //实际上new一个SpringApplication实例，调的是一个实例方法run()    return new SpringApplication(primarySources).run(args);}</code></pre><p>通过上面的源码，发现实际上最后调的并不是静态方法，而是实例方法，需要new一个SpringApplication实例，这个构造器还带有一个primarySources的参数。所以我们直接定位到构造器。</p><pre><code class="java">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {    this.resourceLoader = resourceLoader;    //断言primarySources不能为null，如果为null，抛出异常提示    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);    //启动类传入的Class    this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));    //判断当前项目类型，有三种：NONE、SERVLET、REACTIVE    this.webApplicationType = WebApplicationType.deduceFromClasspath();    //设置ApplicationContextInitializer    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));    //设置监听器    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));    //判断主类，初始化入口类    this.mainApplicationClass = deduceMainApplicationClass();}//判断主类private Class&lt;?&gt; deduceMainApplicationClass() {    try {        StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();        for (StackTraceElement stackTraceElement : stackTrace) {            if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) {                return Class.forName(stackTraceElement.getClassName());            }        }    }    catch (ClassNotFoundException ex) {        // Swallow and continue    }    return null;}</code></pre><p>以上就是创建SpringApplication实例做的事情，下面用张图来表示一下。</p><p><img src="https://static.lovebilibili.com/SpringBoot_4.png" srcset="/img/loading.gif" alt=""></p><p>创建了SpringApplication实例之后，就完成了SpringApplication类的初始化工作，这个实例里包括监听器、初始化器，项目应用类型，启动类集合，类加载器。如图所示。</p><p><img src="https://static.lovebilibili.com/SpringBoot_5.png" srcset="/img/loading.gif" alt=""></p><p>得到SpringApplication实例后，接下来就调用实例方法run()。继续看。</p><pre><code class="java">public ConfigurableApplicationContext run(String... args) {    //创建计时器    StopWatch stopWatch = new StopWatch();    //开始计时    stopWatch.start();    //定义上下文对象    ConfigurableApplicationContext context = null;    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();    //Headless模式设置    configureHeadlessProperty();    //加载SpringApplicationRunListeners监听器    SpringApplicationRunListeners listeners = getRunListeners(args);    //发送ApplicationStartingEvent事件    listeners.starting();    try {        //封装ApplicationArguments对象        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);        //配置环境模块        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);        //根据环境信息配置要忽略的bean信息        configureIgnoreBeanInfo(environment);        //打印Banner标志        Banner printedBanner = printBanner(environment);        //创建ApplicationContext应用上下文        context = createApplicationContext();        //加载SpringBootExceptionReporter        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,                                                         new Class[] { ConfigurableApplicationContext.class }, context);        //ApplicationContext基本属性配置        prepareContext(context, environment, listeners, applicationArguments, printedBanner);        //刷新上下文        refreshContext(context);        //刷新后的操作，由子类去扩展        afterRefresh(context, applicationArguments);        //计时结束        stopWatch.stop();        //打印日志        if (this.logStartupInfo) {            new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);        }        //发送ApplicationStartedEvent事件，标志spring容器已经刷新，此时所有的bean实例都已经加载完毕        listeners.started(context);        //查找容器中注册有CommandLineRunner或者ApplicationRunner的bean，遍历并执行run方法        callRunners(context, applicationArguments);    }    catch (Throwable ex) {        //发送ApplicationFailedEvent事件，标志SpringBoot启动失败        handleRunFailure(context, ex, exceptionReporters, listeners);        throw new IllegalStateException(ex);    }    try {        //发送ApplicationReadyEvent事件，标志SpringApplication已经正在运行，即已经成功启动，可以接收服务请求。        listeners.running(context);    }    catch (Throwable ex) {        //报告异常，但是不发送任何事件        handleRunFailure(context, ex, exceptionReporters, null);        throw new IllegalStateException(ex);    }    return context;}</code></pre><p>结合注释和源码，其实很清晰了，为了加深印象，画张图看一下整个流程。</p><p><img src="https://static.lovebilibili.com/SpringBoot_6.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>表面启动类看起来就一个@SpringBootApplication注解，一个run()方法。其实是经过高度封装后的结果。我们可以从这个分析中学到很多东西。比如使用了spring.factories文件来完成自动配置，提高了扩展性。在启动时使用观察者模式，以事件发布的形式通知，降低耦合，易于扩展等等。</p><p>那么SpringBoot的启动类分析就讲到这里了，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手把手教你搭建ELK日志集中分析平台</title>
    <link href="/2020/11/13/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAELK%E6%97%A5%E5%BF%97%E9%9B%86%E4%B8%AD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/"/>
    <url>/2020/11/13/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAELK%E6%97%A5%E5%BF%97%E9%9B%86%E4%B8%AD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/elk_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们都知道，在生产环境中经常会遇到很多异常，报错信息，需要查看日志信息排查错误。现在的系统大多比较复杂，即使是一个服务背后也是一个集群的机器在运行，<strong>如果逐台机器去查看日志显然是很费力的，也不现实</strong>。</p><p>如果能把日志全部收集到一个平台，然后像百度，谷歌一样<strong>通过关键字搜索出相关的日志</strong>，岂不快哉。于是就有了<strong>集中式日志系统</strong>。ELK就是其中一款使用最多的开源产品。</p><h1 id="一、什么是ELK"><a href="#一、什么是ELK" class="headerlink" title="一、什么是ELK"></a>一、什么是ELK</h1><p>ELK其实是Elasticsearch，Logstash 和 Kibana三个产品的首字母缩写，这三款都是开源产品。</p><p><strong>ElasticSearch</strong>(简称ES)，是一个实时的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。</p><p><strong>Logstash</strong>，是一个数据收集引擎，主要用于进行数据收集、解析，并将数据发送给ES。支持的数据源包括本地文件、ElasticSearch、MySQL、Kafka等等。</p><p><strong>Kibana</strong>，为 Elasticsearch 提供了分析和 Web 可视化界面，并生成各种维度表格、图形。</p><p><img src="https://static.lovebilibili.com/elk_2.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、搭建ELK"><a href="#二、搭建ELK" class="headerlink" title="二、搭建ELK"></a>二、搭建ELK</h1><p>环境依赖：CentOS7.5，JDK1.8，ElasticSearch7.9.3，Logstash 7.9.3，Kibana7.9.3。</p><h2 id="2-1-安装ElasticSearch"><a href="#2-1-安装ElasticSearch" class="headerlink" title="2.1 安装ElasticSearch"></a>2.1 安装ElasticSearch</h2><p>首先，到<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">官网</a>下载安装包，然后使用<code>tar -zxvf</code>命令解压。</p><p><img src="https://static.lovebilibili.com/elk_3.png" srcset="/img/loading.gif" alt=""></p><p>找到config目录下的elasticsearch.yml文件，修改配置：</p><pre><code class="yaml">cluster.name: es-applicationnode.name: node-1#对所有IP开放network.host: 0.0.0.0#HTTP端口号http.port: 9200#elasticsearch数据文件存放目录path.data: /usr/elasticsearch-7.9.3/data#elasticsearch日志文件存放目录path.logs: /usr/elasticsearch-7.9.3/logs</code></pre><p>配置完之后，因为ElasticSearch使用非root用户启动，所以创建一个用户。</p><pre><code class="java"># 创建用户useradd yehongzhi# 设置密码passwd yehongzhi# 赋予用户权限chown -R yehongzhi:yehongzhi /usr/elasticsearch-7.9.3/</code></pre><p>然后切换用户，启动：</p><pre><code># 切换用户su yehongzhi# 启动 -d表示后台启动./bin/elasticsearch -d</code></pre><p>使用命令<code>netstat -nltp</code>查看端口号：</p><p><img src="https://static.lovebilibili.com/elk_4.png" srcset="/img/loading.gif" alt=""></p><p>访问<code>http://192.168.0.109:9200/</code>可以看到如下信息，表示安装成功。</p><p><img src="https://static.lovebilibili.com/elk_5.png" srcset="/img/loading.gif" alt=""></p><h2 id="2-2-安装Logstash"><a href="#2-2-安装Logstash" class="headerlink" title="2.2 安装Logstash"></a>2.2 安装Logstash</h2><p>首先在官网下载安装压缩包，然后解压，找到/config目录下的logstash-sample.conf文件，修改配置：</p><pre><code class="yaml">input {  file{    path =&gt; [&#39;/usr/local/user/*.log&#39;]    type =&gt; &#39;user_log&#39;    start_position =&gt; &quot;beginning&quot;  }}output {  elasticsearch {    hosts =&gt; [&quot;http://192.168.0.109:9200&quot;]    index =&gt; &quot;user-%{+YYYY.MM.dd}&quot;  }}</code></pre><p>input表示输入源，output表示输出，还可以配置filter过滤，架构如下：</p><p><img src="https://static.lovebilibili.com/elk_11.png" srcset="/img/loading.gif" alt=""></p><p>配置完之后，要有数据源，也就是日志文件，准备一个user.jar应用程序，然后后台启动，并且输出到日志文件user.log中，命令如下：</p><pre><code class="shell">nohup java -jar user.jar &gt;/usr/local/user/user.log &amp;</code></pre><p>接着再后台启动Logstash，命令如下：</p><pre><code class="shell">nohup ./bin/logstash -f /usr/logstash-7.9.3/config/logstash-sample.conf &amp;</code></pre><p>启动完之后，使用<code>jps</code>命令，可以看到两个进程在运行：</p><p><img src="https://static.lovebilibili.com/elk_8.png" srcset="/img/loading.gif" alt=""></p><h2 id="2-3-安装Kibana"><a href="#2-3-安装Kibana" class="headerlink" title="2.3 安装Kibana"></a>2.3 安装Kibana</h2><p>首先还是到<a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener">官网</a>下载压缩包，然后解压，找到/config目录下的kibana.yml文件，修改配置：</p><pre><code class="yaml">server.port: 5601server.host: &quot;192.168.0.111&quot;elasticsearch.hosts: [&quot;http://192.168.0.109:9200&quot;]</code></pre><p>和elasticSearch一样，不能使用root用户启动，需要创建一个用户：</p><pre><code># 创建用户useradd kibana# 设置密码passwd kibana# 赋予用户权限chown -R kibana:kibana /usr/kibana/</code></pre><p>然后使用命令启动：</p><pre><code>#切换用户su kibana#非后台启动，关闭shell窗口即退出./bin/kibana#后台启动nohup ./bin/kibana &amp;</code></pre><p>启动后在浏览器打开<code>http://192.168.0.111:5601</code>，可以看到kibana的web交互界面：</p><p><img src="https://static.lovebilibili.com/elk_6.png" srcset="/img/loading.gif" alt=""></p><h2 id="2-4-效果展示"><a href="#2-4-效果展示" class="headerlink" title="2.4 效果展示"></a>2.4 效果展示</h2><p>全部启动成功后，整个过程应该是这样，我们看一下：</p><p><img src="https://static.lovebilibili.com/elk_12.png" srcset="/img/loading.gif" alt=""></p><p>浏览器打开<code>http://192.168.0.111:5601</code>，到管理界面，点击“Index Management”可以看到，有一个<code>user-2020.10.31</code>的索引。</p><p><img src="https://static.lovebilibili.com/elk_10.png" srcset="/img/loading.gif" alt=""></p><p>点击<code>Index Patterns</code>菜单栏，然后创建，命名为user-*。</p><p><img src="https://static.lovebilibili.com/elk_9.png" srcset="/img/loading.gif" alt=""></p><p>最后，就可以到Discover栏进行选择，选择user-*的Index Pattern，然后搜索关键字，就找到相关的日志了！</p><p><img src="https://static.lovebilibili.com/elk_7.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、改进优化"><a href="#三、改进优化" class="headerlink" title="三、改进优化"></a>三、改进优化</h1><p>上面只是用到了核心的三个组件简单搭建的ELK，实际上是有缺陷的。如果Logstash需要添加插件，那就全部服务器的Logstash都要添加插件，扩展性差。所以就有了<strong>FileBeat</strong>，占用资源少，只负责采集日志，不做其他的事情，这样就轻量级，把Logstash抽出来，做一些滤处理之类的工作。</p><p><img src="https://static.lovebilibili.com/elk_13.png" srcset="/img/loading.gif" alt=""></p><p>FileBeat也是官方推荐用的日志采集器，首先下载Linux安装压缩包：</p><pre><code>https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.9.3-linux-x86_64.tar.gz</code></pre><p>下载完成后，解压。然后修改filebeat.yml配置文件：</p><pre><code class="yaml">#输入源filebeat.inputs:- type: log  enabled: true  paths:    - /usr/local/user/*.log#输出，Logstash的服务器地址output.logstash:  hosts: [&quot;192.168.0.110:5044&quot;]#输出，如果直接输出到ElasticSearch则填写这个#output.elasticsearch:  #hosts: [&quot;localhost:9200&quot;]  #protocol: &quot;https&quot;</code></pre><p>然后Logstash的配置文件logstash-sample.conf，也要改一下：</p><pre><code>#输入源改成beatsinput {  beats {    port =&gt; 5044    codec =&gt; &quot;json&quot;  }}</code></pre><p>然后启动FileBeat：</p><pre><code class="shell">#后台启动命令nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;</code></pre><p>再启动Logstash：</p><pre><code class="shell">#后台启动命令nohup ./bin/logstash -f /usr/logstash-7.9.3/config/logstash-sample.conf &amp;</code></pre><p>怎么判断启动成功呢，看Logstash应用的/logs目录下的logstash-plain.log日志文件：</p><p><img src="https://static.lovebilibili.com/elk_14.png" srcset="/img/loading.gif" alt=""></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>目前，很多互联网公司都是采用ELK来做日志集中式系统，原因很简单：<strong>开源、插件多、易扩展、支持数据源多、社区活跃、开箱即用</strong>等等。我见过有一个公司在上面的架构中还会加多一个Kafka的集群，主要是基于日志数据量比较大的考虑。但是呢，基本的三大组件ElasticSearch，Logstash，Kibana是不能少的。</p><p>希望这篇文章能帮助大家对ELK有一些初步的认识，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>ELK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从设计模式的角度剖析Mybatis源码</title>
    <link href="/2020/11/13/%E4%BB%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A7%92%E5%BA%A6%E5%89%96%E6%9E%90Mybatis%E6%BA%90%E7%A0%81/"/>
    <url>/2020/11/13/%E4%BB%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A7%92%E5%BA%A6%E5%89%96%E6%9E%90Mybatis%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/mybatis_swdt.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Mybatis是一个比较主流的ORM框架，所以在日常工作中接触得很多。我比较喜欢看优秀框架的源码，因为能写出这种框架的作者肯定有其独特之处。如果能看懂源码的一些巧妙构思，一定是受益匪浅的。</p><p>所谓万事开头难，看源码也要找到切入的点。设计模式无疑是源码分析一个很好的切入点，废话不多说，那么我们就开始吧。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式属于创建型模式。工厂模式的作用是把创建对象的逻辑封装起来，提供一个接口给外部创建对象，降低类与类之间的耦合。</p><p>在Mybatis中，用到工厂模式主要在DataSourceFactory。这是一个负责创建DataSource数据源的工厂。DataSourceFactory是一个接口，有不同的子类实现，根据不同的配置，生成不同的DataSourceFactory实现类。类图如下：</p><p><img src="https://static.lovebilibili.com/mybatis_dataSourceFactory.png" srcset="/img/loading.gif" alt="img"></p><p>接着我们看一下DataSourceFactory的源码：</p><pre><code>public interface DataSourceFactory {  void setProperties(Properties props);  DataSource getDataSource();}</code></pre><p>DataSourceFactory接口定义了两个抽象方法，怎么工作的呢，其实是跟dataSource标签的属性type有关。</p><pre><code>&lt;environment id=&quot;development&quot;&gt;    &lt;transactionManager type=&quot;JDBC&quot;/&gt;    &lt;!-- type属性是关键属性 --&gt;    &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;${dataSource.driver}&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;${dataSource.url}&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;${dataSource.username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${dataSource.password}&quot;/&gt;    &lt;/dataSource&gt;&lt;/environment&gt;</code></pre><p>Mybatis内置的type有三种配置，分别是UNPOOLED，POOLED，JNDI。</p><p><strong>UNPOOLED</strong>，这个数据源的实现只是每次被请求时打开和关闭连接。</p><p><strong>POOLED</strong>，这种数据源的使用“池“的思想，避免了创建新的连接实例时所必需的初始化和认证时间。 </p><p><strong>JNDI</strong>，这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p><p>接着看XMLConfigBuilder的dataSourceElement()方法。</p><pre><code>private DataSourceFactory dataSourceElement(XNode context) throws Exception {    if (context != null) {        //读取配置文件中dataSource标签的属性type        String type = context.getStringAttribute(&quot;type&quot;);        Properties props = context.getChildrenAsProperties();        //根据type属性的值，返回不同的子类，使用接口DataSourceFactory接收，体现了面向接口编程的思想        DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance();        //设置属性值，比如数据库的url，username，password等等        factory.setProperties(props);        //返回factory        return factory;    }    throw new BuilderException(&quot;Environment declaration requires a DataSourceFactory.&quot;);}</code></pre><p>获得DataSourceFactory之后，就通过getDataSource()方法获取数据源，完事了。</p><pre><code>private void environmentsElement(XNode context) throws Exception {    if (context != null) {        if (environment == null) {            environment = context.getStringAttribute(&quot;default&quot;);        }        //这里for循环主要是配置文件可以配置多个数据源        for (XNode child : context.getChildren()) {            String id = child.getStringAttribute(&quot;id&quot;);            if (isSpecifiedEnvironment(id)) {                TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));                DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;));                //dsFactory调动getDataSource()方法，创建dataSource对象                DataSource dataSource = dsFactory.getDataSource();                Environment.Builder environmentBuilder = new Environment.Builder(id)                    .transactionFactory(txFactory)                    .dataSource(dataSource);                configuration.setEnvironment(environmentBuilder.build());            }        }    }}</code></pre><p>Mybatis使用工厂模式来创建DataSourceFactory，可以做到通过配置去使用不同的DataSourceFactory创建DataSource，非常灵活。在Mybatis中使用到工厂模式还有很多地方，比如SqlSessionFactory，这里就不再展开了，有兴趣的可以自己探索一下。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式属于创建型设计模式，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<strong>保证在应用中只有单一对象被创建</strong>。</p><p>Mybatis中用到单例模式的地方有很多，这里举个例子是ErrorContext类。这是一个用于记录该线程的执行环境错误信息，所以是在线程范围内的单例。</p><pre><code>public class ErrorContext {    //使用ThreadLocal保存每个线程中的单例对象    private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;ErrorContext&gt;();    //私有化构造器    private ErrorContext() {    }    //向外提供唯一的接口获取单例对象    public static ErrorContext instance() {        //从LOCAL中取出context对象        ErrorContext context = LOCAL.get();        if (context == null) {            //如果为null，new一个            context = new ErrorContext();            //放入到LOCAL中保存            LOCAL.set(context);        }        //如果不为null，直接返回        return context;    }}</code></pre><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式也是属于创建型模式，主要是在创建一个复杂对象时使用，通过一步一步构造最终的对象，将一个复杂对象的构建与它的表示分离。</p><p>在Mybatis中，使用到建造者模式的地方体现在ParameterMapping类，这是用于参数映射的一个类。</p><pre><code>public class ParameterMapping {  private Configuration configuration;  private String property;  private ParameterMode mode;  private Class&lt;?&gt; javaType = Object.class;  private JdbcType jdbcType;  private Integer numericScale;  private TypeHandler&lt;?&gt; typeHandler;  private String resultMapId;  private String jdbcTypeName;  private String expression;  //私有化构造器  private ParameterMapping() {  }  //通过内部类Builder创建对象  public static class Builder {      //初始化ParameterMapping实例      private ParameterMapping parameterMapping = new ParameterMapping();      //通过构造器初始化ParameterMapping的一些成员变量      public Builder(Configuration configuration, String property, TypeHandler&lt;?&gt; typeHandler) {          parameterMapping.configuration = configuration;          parameterMapping.property = property;          parameterMapping.typeHandler = typeHandler;          parameterMapping.mode = ParameterMode.IN;      }      public Builder(Configuration configuration, String property, Class&lt;?&gt; javaType) {          parameterMapping.configuration = configuration;          parameterMapping.property = property;          parameterMapping.javaType = javaType;          parameterMapping.mode = ParameterMode.IN;      }      //设置parameterMapping的mode      public Builder mode(ParameterMode mode) {          parameterMapping.mode = mode;          return this;      }      //设置parameterMapping的javaType      public Builder javaType(Class&lt;?&gt; javaType) {          parameterMapping.javaType = javaType;          return this;      }      //设置parameterMapping的jdbcType      public Builder jdbcType(JdbcType jdbcType) {          parameterMapping.jdbcType = jdbcType;          return this;      }      //设置parameterMapping的numericScale      public Builder numericScale(Integer numericScale) {          parameterMapping.numericScale = numericScale;          return this;      }      //设置parameterMapping的resultMapId      public Builder resultMapId(String resultMapId) {          parameterMapping.resultMapId = resultMapId;          return this;      }      //设置parameterMapping的typeHandler      public Builder typeHandler(TypeHandler&lt;?&gt; typeHandler) {          parameterMapping.typeHandler = typeHandler;          return this;      }      //设置parameterMapping的jdbcTypeName      public Builder jdbcTypeName(String jdbcTypeName) {          parameterMapping.jdbcTypeName = jdbcTypeName;          return this;      }      //设置parameterMapping的expression      public Builder expression(String expression) {          parameterMapping.expression = expression;          return this;      }      //通过build()方法创建对象，返回      public ParameterMapping build() {          resolveTypeHandler();          validate();          return parameterMapping;      }    }}</code></pre><p>在SqlSourceBuilder类的buildParameterMapping()方法中可以看到建造者模式的实战应用：</p><pre><code>//根据参数content，构建parameterMapping实例private ParameterMapping buildParameterMapping(String content) {    //属性值的Map集合    Map&lt;String, String&gt; propertiesMap = parseParameterMapping(content);    String property = propertiesMap.get(&quot;property&quot;);    Class&lt;?&gt; propertyType;    //省略...    //创建一个ParameterMapping.Builder对象    ParameterMapping.Builder builder = new ParameterMapping.Builder(configuration, property, propertyType);    //省略...    //这里遍历Map集合，把属性值设置到ParameterMapping对象中，并创建    for (Map.Entry&lt;String, String&gt; entry : propertiesMap.entrySet()) {        String name = entry.getKey();        String value = entry.getValue();        if (&quot;javaType&quot;.equals(name)) {            javaType = resolveClass(value);            builder.javaType(javaType);        } else if (&quot;jdbcType&quot;.equals(name)) {            builder.jdbcType(resolveJdbcType(value));        } else if (&quot;mode&quot;.equals(name)) {            builder.mode(resolveParameterMode(value));        } else if (&quot;numericScale&quot;.equals(name)) {            builder.numericScale(Integer.valueOf(value));        } else if (&quot;resultMap&quot;.equals(name)) {            builder.resultMapId(value);        } else if (&quot;typeHandler&quot;.equals(name)) {            typeHandlerAlias = value;        } else if (&quot;jdbcTypeName&quot;.equals(name)) {            builder.jdbcTypeName(value);        } else if (&quot;property&quot;.equals(name)) {            // Do Nothing        } else if (&quot;expression&quot;.equals(name)) {            //抛出异常Expression based parameters are not supported yet        } else {            //抛出异常        }    }    //省略...    //创建ParameterMapping对象，并返回    return builder.build();}</code></pre><h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>模板模式是一种行为型模式，一般用在一些比较通用的方法中，定义一个抽象类，编写一个算法的骨架，将一些步骤延迟到子类。就像是请假条一样，开头和结尾都是写好的模板，中间的请假的原因(内容)由请假人(子类)去补充完整，这样可以提高代码的复用。</p><p>在Mybatis中，模板模式体现在Executor和BaseExecutor这两个类中。首先看张类图：</p><p><img src="https://static.lovebilibili.com/mybatis_executor.png" srcset="/img/loading.gif" alt="img"></p><p>Executor是一个接口，从命名上可以看出是用来执行SQL语句的对象。下面有一个BaseExecutor的抽象类，这就是用来定义模板方法的。再下面有三个实现类，<strong>SimpleExecutor(简单执行器)，ReuseExecutor(重用执行器)，BatchExecutor(批量执行器)</strong>。实现类就是用来填充模板中间的内容的。</p><p>执行器在执行JDBC操作的前后往往有很多需要处理的工作都是相同的，比如查询的时候使用缓存，更新时需要清除缓存等等，所以就很适合使用模板模式。</p><p>接着我们看BaseExecutor抽象类的源码，一看就明白了，其实就定义了一个骨架。</p><pre><code>public abstract class BaseExecutor implements Executor {    //查询操作    private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {        List&lt;E&gt; list;        localCache.putObject(key, EXECUTION_PLACEHOLDER);        //上面的代码是固定的        try {            //这段代码不同的子类有不同的实现，所以是调用抽象方法doQuery()            list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);        //下面的代码也是固定的        } finally {            //清除缓存            localCache.removeObject(key);        }        //添加到缓存中        localCache.putObject(key, list);        if (ms.getStatementType() == StatementType.CALLABLE) {            localOutputParameterCache.putObject(key, parameter);        }        //返回结果        return list;    }    //抽象方法，由子类去实现    protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)        throws SQLException;}</code></pre><p>那么就有疑问了，一开始如果都不设置的话，默认使用哪个子类的实现。很简单，直接跟着源码去顺藤摸瓜，我们就看到了。</p><pre><code>public class Configuration {    //默认是SIMPLE，也就是SimpleExecutor    protected ExecutorType defaultExecutorType = ExecutorType.SIMPLE;}</code></pre><p>其实模板模式很简单就能“认出来”，我的理解就是，<strong>抽象类里定义具(具体的方法)，具体方法再调抽(抽象方法)</strong>。那十有八九就是模板模式了。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式属于结构型模式，代理模式的定义说的很抽象，为<strong>其他对象提供一种代理以控制对这个对象的访问</strong>。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><p>其实代理模式可以简单理解为中介的作用，比如一手房东只关心收租，其他的水电费结算，带人看房这些杂七杂八的东西他不想关心，就交给中介（二手房东），租客要租房就给钱中介，一手房东收钱就找中介，这个中介就是所谓的代理者。</p><p>回到Mybatis框架中，SqlSession类就用到代理模式，SqlSession是操作数据库一个会话对象，我们用户一般通过SqlSession做增删改查，但是如果每次做增删改都开启事务，关闭事务，显然是很麻烦，<strong>所以就可以交给代理类来完成这个工作，如果没有开启事务，由代理类自动开启事务</strong>。</p><p>Mybatis在这里是使用JDK动态代理，所以SqlSession是一个接口。</p><pre><code>public interface SqlSession extends Closeable {    &lt;T&gt; T selectOne(String statement);    &lt;E&gt; List&lt;E&gt; selectList(String statement);    &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter);    &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, String mapKey);    &lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement);    void select(String statement, Object parameter, ResultHandler handler);    int insert(String statement);    int update(String statement);    int delete(String statement);    void commit();    void rollback();    //省略...}</code></pre><p>我们知道动态代理要有一个实现InvocationHandler接口的类，这个类在SqlSessionManager里，是一个内部类，叫做SqlSessionInterceptor，在这个类里做相关的处理。</p><pre><code>private class SqlSessionInterceptor implements InvocationHandler {    public SqlSessionInterceptor() {        // Prevent Synthetic Access    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        //获取SqlSession对象，localSqlSession是一个ThreadLocal，所以是每个线程有自己的sqlSession        final SqlSession sqlSession = SqlSessionManager.this.localSqlSession.get();        //如果不为null        if (sqlSession != null) {            try {                //执行方法，返回结果                  return method.invoke(sqlSession, args);            } catch (Throwable t) {                throw ExceptionUtil.unwrapThrowable(t);            }            //如果sqlsession为null        } else {            //打开session              final SqlSession autoSqlSession = openSession();            try {                //执行Sqlsession的方法，获得结果                  final Object result = method.invoke(autoSqlSession, args);                //commit提交事务                autoSqlSession.commit();                //返回结果                return result;            } catch (Throwable t) {                //rollback回滚事务                autoSqlSession.rollback();                //抛出异常                throw ExceptionUtil.unwrapThrowable(t);            } finally {                //关闭sqlsession                autoSqlSession.close();            }        }    }}</code></pre><p>然后通过构造器去初始化，提供静态方法返回这个SqlSessionManager实例，请看源码。</p><pre><code>//实现了SqlSessionFactory，SqlSession接口public class SqlSessionManager implements SqlSessionFactory, SqlSession {    private final SqlSessionFactory sqlSessionFactory;    //代理类sqlSessionProxy    private final SqlSession sqlSessionProxy;    private SqlSessionManager(SqlSessionFactory sqlSessionFactory) {        this.sqlSessionFactory = sqlSessionFactory;        //初始化代理类        this.sqlSessionProxy = (SqlSession) Proxy.newProxyInstance(            SqlSessionFactory.class.getClassLoader(),            new Class[]{SqlSession.class},            new SqlSessionInterceptor());    }    //提供一个静态方法给外部获取SqlSessionManager类，可以用SqlSession接收    public static SqlSessionManager newInstance(SqlSessionFactory sqlSessionFactory) {        return new SqlSessionManager(sqlSessionFactory);    }    //重写selectOne方法，使用代理类去执行    @Override    public &lt;T&gt; T selectOne(String statement) {        return sqlSessionProxy.&lt;T&gt; selectOne(statement);    }    //重写insert方法，使用代理类去执行    @Override    public int insert(String statement) {        return sqlSessionProxy.insert(statement);    }    //省略...}</code></pre><p>这就是Mybatis使用代理模式的一个例子，其实也不是很复杂，还是能看懂的。</p><p>但是上面这种方式一般很少用，我们一般都是使用Mapper接口的方式，其实Mapper接口的方式也是使用了代理模式，接下来再继续看。直接看MapperProxy类。</p><pre><code>//实现了InvocationHandler接口public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable {    private static final long serialVersionUID = -6424540398559729838L;    private final SqlSession sqlSession;    private final Class&lt;T&gt; mapperInterface;    private final Map&lt;Method, MapperMethod&gt; methodCache;    public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) {        this.sqlSession = sqlSession;        this.mapperInterface = mapperInterface;        this.methodCache = methodCache;    }    //代理类做的什么事情，看这个方法    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        //省略...        //获取mapperMethod对象        final MapperMethod mapperMethod = cachedMapperMethod(method);        //执行方法。根据Mapper.xml配置文件的配置进行执行，返回结果        return mapperMethod.execute(sqlSession, args);    }    private MapperMethod cachedMapperMethod(Method method) {        //从methodCache取出mapperMethod        MapperMethod mapperMethod = methodCache.get(method);        //为null        if (mapperMethod == null) {            //new一个。这里已经把Mapper.xml的一些配置都封装好了            mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());            //然后put进methodCache            methodCache.put(method, mapperMethod);        }        //返回mapperMethod        return mapperMethod;    }}</code></pre><p>mapperMethod的execute()方法的作用就是根据Mapper接口的方法名找到Mapper.xml文件的sql的Id，然后执行相应的操作，返回结果。内部的代码比较长，但是思路就是这样，这里就不展开了。</p><p>所以我们平时用的时候，TbCommodityInfoMapper接口假设是这样定义了一个list()方法。</p><pre><code>public interface TbCommodityInfoMapper {    //查询TbCommodityInfo列表    List&lt;TbCommodityInfo&gt; list();}</code></pre><p>那个在TbCommodityInfoMapper.xml就要对应有一个id为list的配置。</p><pre><code>&lt;!-- 命名空间也要和接口的全限定名一致 --&gt;&lt;mapper namespace=&quot;io.github.yehongzhi.commodity.mapper.TbCommodityInfoMapper&quot;&gt;    &lt;!-- 必须要有一个对应的属性id为list的sql配置 --&gt;    &lt;select id=&quot;list&quot; resultType=&quot;tbCommodityInfo&quot;&gt;        select `id`, `commodity_name`, `commodity_price`, `description`, `number` from tb_commodity_info    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>然后在MapperProxyFactory类，使用工厂模式提供获取代理类。</p><pre><code>public class MapperProxyFactory&lt;T&gt; {    private final Class&lt;T&gt; mapperInterface;    private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;();    //通过构造器初始化mapperInterface    public MapperProxyFactory(Class&lt;T&gt; mapperInterface) {        this.mapperInterface = mapperInterface;    }    @SuppressWarnings(&quot;unchecked&quot;)    protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {        return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);    }    //通过这个方法，获取Mapper接口的代理类    public T newInstance(SqlSession sqlSession) {        final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);        return newInstance(mapperProxy);    }}</code></pre><p>那个这个getMapper的方法就在SqlSession的子类中被调用。</p><pre><code>@Overridepublic &lt;T&gt; T getMapper(Class&lt;T&gt; type) {    return getConfiguration().getMapper(type, this);}</code></pre><p>最终用户就是这样使用，这里是纯Mybatis，没有集成Spring的写法。</p><pre><code>public class Test {    public static void main(String[] args) {        //获取SqlSession对象        SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession();        //再获取Mapper接口的代理类        TbCommodityInfoMapper tbCommodityInfoMapper = sqlSession.getMapper(TbCommodityInfoMapper.class);        //通过代理类去执行相应的方法        List&lt;TbCommodityInfo&gt; commodityInfoList = tbCommodityInfoMapper.list();    }}</code></pre><p>所以代理模式可以说是Mybatis核心的设计模式，用的是非常巧妙。</p><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>装饰器模式属于结构型模式，使用装饰类包装对象，动态地给对象添加一些额外的职责。那么在Mybatis中，哪个地方会使用到装饰器模式呢？</p><p>没错了，就是缓存。Mybatis有一级缓存和二级缓存的功能，一级缓存默认是打开的，范围在SqlSession中生效，二级缓存需要手动配置打开，范围在全局Configuration，在每个namespace中配置。二级缓存的类型有以下几种，请看配置。</p><pre><code>&lt;mapper namespace=&quot;io.github.yehongzhi.commodity.mapper.TbCommodityInfoMapper&quot;&gt;    &lt;!--        eviction:代表的是缓存回收策略，目前MyBatis提供以下策略。        (1) LRU,最近最少使用的，一处最长时间不用的对象        (2) FIFO,先进先出，按对象进入缓存的顺序来移除他们        (3) SOFT,软引用，移除基于垃圾回收器状态和软引用规则的对象        (4) WEAK,弱引用，更积极的移除基于垃圾收集器状态和弱引用规则的对象。这里采用的是LRU，移除最长时间不用的对形象        flushInterval:刷新间隔时间，单位为毫秒，这里配置的是100秒刷新，如果你不配置它，那么当SQL被执行的时候才会去刷新缓存。        size:引用数目，一个正整数，代表缓存最多可以存储多少个对象，不宜设置过大。设置过大会导致内存溢出。这里配置的是1024个对象        readOnly:只读，意味着缓存数据只能读取而不能修改，这样设置的好处是我们可以快速读取缓存，缺点是我们没有办法修改缓存    --&gt;    &lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;100000&quot; readOnly=&quot;true&quot; size=&quot;1024&quot;/&gt;    &lt;select id=&quot;list&quot; resultMap=&quot;base_column&quot;&gt;        select `id`, `commodity_name`, `commodity_price`, `description`, `number` from tb_commodity_info    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>所以这个场景已经很清晰了，也就是在一级缓存的基础上，再添加二级缓存，也就符合装饰器模式的那句话，动态给对象添加职责功能。怎么做呢，我们不妨先看Cache类的类图。</p><p><img src="https://static.lovebilibili.com/mybatis_cache.png" srcset="/img/loading.gif" alt="img"></p><p>先看Cache接口，其实就定义了一些接口方法。</p><pre><code>public interface Cache {    String getId();    void putObject(Object key, Object value);    Object getObject(Object key);    Object removeObject(Object key);    void clear();    int getSize();    ReadWriteLock getReadWriteLock();}</code></pre><p>然后再看PerpetualCache类，这是Cache接口最基本的实现，二级缓存要扩展就在这个类上面再去包装来实现扩展。其实就是一个HashMap，再简单包装一下。</p><pre><code>public class PerpetualCache implements Cache {    private final String id;    //成员变量cache，创建一个HashMap    private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;();    public PerpetualCache(String id) {        this.id = id;    }    @Override    public String getId() {        return id;    }    @Override    public int getSize() {        return cache.size();    }    @Override    public void putObject(Object key, Object value) {        cache.put(key, value);    }    @Override    public Object getObject(Object key) {        return cache.get(key);    }    @Override    public Object removeObject(Object key) {        return cache.remove(key);    }    @Override    public void clear() {        cache.clear();    }    @Override    public ReadWriteLock getReadWriteLock() {        return null;    }    //省略...}</code></pre><p>那么我们再看二级缓存的一个代表性的类LruCache。</p><pre><code>public class LruCache implements Cache {    //一级缓存，保存在这个成员变量中    private final Cache delegate;    //实际上这是一个LinkedHashMap，利用LinkedHashMap的LRU算法实现缓存的LRU    private Map&lt;Object, Object&gt; keyMap;    private Object eldestKey;    //构造器缓存对象，初始化    public LruCache(Cache delegate) {        this.delegate = delegate;        setSize(1024);    }    //初始化keyMap，重写removeEldestEntry方法，实现LUR算法    public void setSize(final int size) {        keyMap = new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) {            private static final long serialVersionUID = 4267176411845948333L;            @Override            protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) {                boolean tooBig = size() &gt; size;                //每次put进来时，eldestKey都是最老的key                if (tooBig) {                    eldestKey = eldest.getKey();                }                return tooBig;            }        };    }    @Override    public void putObject(Object key, Object value) {        //保存进缓存        delegate.putObject(key, value);        //这里就是删除掉不常用的值        cycleKeyList(key);    }    @Override    public Object getObject(Object key) {        keyMap.get(key); //touch        return delegate.getObject(key);    }    private void cycleKeyList(Object key) {        keyMap.put(key, key);        if (eldestKey != null) {            //删除掉Map中最老的key            delegate.removeObject(eldestKey);            eldestKey = null;        }    }}</code></pre><p>关键在于成员变量delegate，这在其他的二级缓存装饰类中都定义了。这个是为了保存PerpetualCache这个基础缓存类的。所以这也就是说二级缓存是在PerpetualCache为基础扩展的。再继续看就更加明白了。</p><p>直接看创建SqlSessionFactory的builder方法，一直追踪下去，就可以找到MapperBuilderAssistant类的useNewCache方法。</p><pre><code>public class MapperBuilderAssistant extends BaseBuilder {    //当前Mapper.xml的命名空间    private String currentNamespace;    public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass,                             Class&lt;? extends Cache&gt; evictionClass,                             Long flushInterval,                             Integer size,                             boolean readWrite,                             boolean blocking,                             Properties props) {        Cache cache = new CacheBuilder(currentNamespace)            //设置基础缓存            .implementation(valueOrDefault(typeClass, PerpetualCache.class))            //添加缓存装饰类            .addDecorator(valueOrDefault(evictionClass, LruCache.class))            .clearInterval(flushInterval)            .size(size)            .readWrite(readWrite)            .blocking(blocking)            .properties(props)            //创建缓存            .build();        //把缓存添加到configuration，所以二级缓存是configuration范围的        configuration.addCache(cache);        currentCache = cache;        return cache;    }}</code></pre><p>再看CacheBuilder的build方法，更加清晰了。</p><pre><code>public class CacheBuilder {    private Class&lt;? extends Cache&gt; implementation;    private final List&lt;Class&lt;? extends Cache&gt;&gt; decorators;    public Cache build() {        setDefaultImplementations();        Cache cache = newBaseCacheInstance(implementation, id);        setCacheProperties(cache);        // issue #352, do not apply decorators to custom caches        if (PerpetualCache.class.equals(cache.getClass())) {            //遍历装饰器类            for (Class&lt;? extends Cache&gt; decorator : decorators) {                //在cache上添加二级缓存                cache = newCacheDecoratorInstance(decorator, cache);                setCacheProperties(cache);            }            cache = setStandardDecorators(cache);        } else if (!LoggingCache.class.isAssignableFrom(cache.getClass())) {            cache = new LoggingCache(cache);        }        //返回缓存        return cache;    }    private void setDefaultImplementations() {        if (implementation == null) {            //如果为空，初始化为PerpetualCache            implementation = PerpetualCache.class;            //如果装饰器类为空，默认用LruCache            if (decorators.isEmpty()) {                decorators.add(LruCache.class);            }        }    }}</code></pre><p>所以我们大概可以想到二级缓存就像千层饼一样，一层一层地包装起来。最后debug模式验证一下。</p><p><img src="https://static.lovebilibili.com/mybatis_mode_1.png" srcset="/img/loading.gif" alt="img"></p><p>在执行查询的时候你就会看到真的是千层饼一样，一层一层的。看CachingExecutor类的query方法。</p><p><img src="https://static.lovebilibili.com/mybatis_mode_2.png" srcset="/img/loading.gif" alt="img"></p><p>最后在调用Cache的putObject方法时就会一层一层从外到内地调用，实现为对象动态扩展功能的装饰器模式。</p><p><img src="https://static.lovebilibili.com/mybatis_mode_3.png" srcset="/img/loading.gif" alt="img"></p><p>装饰器模式在Mybatis中的应用就讲到这里了，有什么不懂的，可以关注公众号<code>java技术爱好者</code>，加我微信提问。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章就介绍了Mybatis中用到的6种设计模式，分别是<strong>工厂模式，单例模式，模板模式，建造者模式，代理模式，还有装饰器模式</strong>。实际上Mybatis除了我讲的这些之外，还有很多我没有提到的，比如组合模式，适配器模式等等，有兴趣自己去研究一下吧。</p><p>因为现在很多面试动不动就问有看过什么框架的源码，实际上看源码是好的，但是不能盲目入手，因为很多框架是运用了大量的设计模式，如果对设计模式没有一定的认识，很容易看不懂，看懵。所以对于还没有设计模式基础的同学，建议先看设计模式，然后再去学习源码，这样才能循序渐进地提升自身实力。</p><p>这篇文章就讲到这里了，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码分析</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是skywalking？看完这篇你就懂了</title>
    <link href="/2020/11/02/%E4%BB%80%E4%B9%88%E6%98%AFskywalking%EF%BC%9F%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/"/>
    <url>/2020/11/02/%E4%BB%80%E4%B9%88%E6%98%AFskywalking%EF%BC%9F%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/skywalking_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong><a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">skywalking</a></strong>又是一个优秀的国产开源框架，2015年由个人吴晟（华为开发者）开源 ， 2017年加入Apache孵化器。</p><p>skywalking是分布式系统的<strong>应用程序性能监视工具</strong>，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。SkyWalking 是<strong>观察性分析平台和应用性能管理系统</strong>。提供<strong>分布式追踪、服务网格遥测分析、度量聚合和可视化一体化</strong>解决方案（官网介绍）。</p><h1 id="一、OpenTracing规范"><a href="#一、OpenTracing规范" class="headerlink" title="一、OpenTracing规范"></a>一、OpenTracing规范</h1><p><strong>OpenTracing是一种分布式系统链路跟踪的设计原则、规范、标准。</strong></p><p>类似JDBC的规范，主要为了提供一套标准的JDBC API。OpenTracing也是一样，是为了统一提供一套链路追踪的标准API，所制定的一种规范。</p><p>OpenTracing通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现。</p><p>类似于JDBC的规范由各个数据库厂商实现一样，OpenTracing规范也是有很多实现的产品，下面介绍一下落地的产品。</p><h2 id="1-1-实现OpenTracing的产品"><a href="#1-1-实现OpenTracing的产品" class="headerlink" title="1.1 实现OpenTracing的产品"></a>1.1 实现OpenTracing的产品</h2><p><strong>Jaeger</strong>：Jaeger是由Uber公司开源发布的，受到Dapper和OpenZipkin启发。后端使用Go语言，前端(用户界面)使用React 。优点是上传采用的是udp传输，效率高速度快。缺点就是丢包，影响了整条调用链，而且不支持告警和JVM监控。</p><p><strong>Zipkin</strong>：SpringCloud官方推荐，可以<strong>与SpringCloud有良好集成</strong>，实现方式是拦截请求，发送(http)数据到zipkin服务。缺点在于<strong>不支持告警，不支持JVM监控，通信方式使用Http请求向Zipkin上报信息，比较耗性能</strong>。</p><p><strong>SkyWalking</strong>：国人(吴晟)开发，支持dubbo，SpringCloud，SpringBoot集成，<strong>代码无侵入，通信方式采用GRPC，性能较好，实现方式是java探针，支持告警，支持JVM监控，支持全局调用统计</strong>等等，功能较完善。缺点是<strong>依赖较多</strong>，需要ElasticSearch，JDK环境，Nacos注册中心等。</p><h2 id="1-2-skywalking的特点"><a href="#1-2-skywalking的特点" class="headerlink" title="1.2 skywalking的特点"></a>1.2 skywalking的特点</h2><p><img src="https://static.lovebilibili.com/skywalking_1.png" srcset="/img/loading.gif" alt=""></p><p>比较重要的特点，我觉得是轻量高效，对代码无侵入性。对于微服务，支持dubbo，SpringBoot，SpringCloud集成。</p><h1 id="二、安装部署"><a href="#二、安装部署" class="headerlink" title="二、安装部署"></a>二、安装部署</h1><p>环境：CentOS 7.5，MySQL 5.7.26，Nacos 1.3.1（注册中心），JDK 1.8，<strong>skywalking 8.1.0</strong>。</p><p>除了skywalking之外，其他需要用到的组件我就不介绍怎么安装了，比较简单。安装skywalking其实很简单，下面一步一步来讲解。</p><p>第一步，下载。在<a href="http://skywalking.apache.org/downloads/" target="_blank" rel="noopener">官网</a>下载即可，选择8.1.0版本，如果要使用ES作为存储仓库，那就要选择es7的版本。</p><p><img src="https://static.lovebilibili.com/skywalking_2.png" srcset="/img/loading.gif" alt=""></p><p>第二步，解压。找到config目录下的application.yml文件，然后修改配置。</p><p><img src="https://static.lovebilibili.com/skywalking_3.png" srcset="/img/loading.gif" alt=""></p><p>需要修改的配置内容如下：</p><pre><code class="yaml">cluster:  selector: ${SW_CLUSTER:nacos}  #单机模式  standalone:  #使用nacos作为注册中心  nacos:    # 注册到nacos的服务名    serviceName: ${SW_SERVICE_NAME:&quot;SkyWalking_OAP_Cluster&quot;}    #nacos服务端的地址    hostPort: ${SW_CLUSTER_NACOS_HOST_PORT:192.168.0.105:8848}    # Nacos Configuration namespace命名空间    namespace: ${SW_CLUSTER_NACOS_NAMESPACE:&quot;public&quot;}core:  selector: ${SW_CORE:default}  default:    #skywalking服务端的REST绑定的IP    restHost: ${SW_CORE_REST_HOST:192.168.0.107}    #skywalking服务端的REST调用的端口    restPort: ${SW_CORE_REST_PORT:12800}    #skywalking服务端GRPC通信绑定的IP    gRPCHost: ${SW_CORE_GRPC_HOST:192.168.0.107}    #skywalking服务端GRPC通信绑定的端口    gRPCPort: ${SW_CORE_GRPC_PORT:11800}storage:  #选择使用mysql  selector: ${SW_STORAGE:mysql}  #默认使用h2，不会持久化，重启skyWalking之前的数据会丢失  h2:    driver: ${SW_STORAGE_H2_DRIVER:org.h2.jdbcx.JdbcDataSource}    url: ${SW_STORAGE_H2_URL:jdbc:h2:mem:skywalking-oap-db}    user: ${SW_STORAGE_H2_USER:sa}    metadataQueryMaxSize: ${SW_STORAGE_H2_QUERY_MAX_SIZE:5000}  #使用mysql作为持久化存储的仓库  mysql:    properties:      #数据库连接地址      jdbcUrl: ${SW_JDBC_URL:&quot;jdbc:mysql://192.168.0.107:3306/swtest&quot;}      #用户名      dataSource.user: ${SW_DATA_SOURCE_USER:yehongzhi}      #密码      dataSource.password: ${SW_DATA_SOURCE_PASSWORD:Yehongzhi520.}</code></pre><p>默认是web管理界面是8080端口，如果要修改端口号，可以修改webapp目录下的webapp.yml。</p><pre><code class="yaml">#web管理界面的端口server:  port: 8080</code></pre><p>第三步，添加mysql数据驱动包。因为在lib目录下是没有mysql数据驱动包的，所以修改完配置启动是会报错，启动失败的。为什么作者不提前在lib目录下放一个数据驱动包呢，还要我们手动去添加。网上貌似没有这个问题的讨论，我的理解是<strong>因为框架不知道你用的是什么版本的mysql数据库，所以不知道放什么版本的数据库驱动包，使用者用的是什么版本的mysql，就自己放对应的数据库驱动包</strong>。</p><p>我这里用的是5.7.26版本的mysql，所以我下载了一个8.0.17的驱动包，添加到/oap-libs目录下。</p><p><img src="https://static.lovebilibili.com/skywalking_4.png" srcset="/img/loading.gif" alt=""></p><p>第三步，启动。在/bin目录上一级，直接使用<code>./bin/startup.sh</code>启动即可。启动之后，可以使用<code>jps</code>命令查看进程，可以看到这两个java程序在运行状态。</p><p><img src="https://static.lovebilibili.com/skywalking_5.png" srcset="/img/loading.gif" alt=""></p><p>打开配置的Nacos控制台，可以看到服务列表注册了名为“SkyWalking_OAP_Cluster”的服务。</p><p><img src="https://static.lovebilibili.com/skywalking_6.png" srcset="/img/loading.gif" alt=""></p><p>可以看到mysql建了很多表。</p><p><img src="https://static.lovebilibili.com/skywalking_7.png" srcset="/img/loading.gif" alt=""></p><p>说明启动成功了，打开配置对应的地址<a href="http://192.168.0.109:8080/，可以看到skywalking的web界面。" target="_blank" rel="noopener">http://192.168.0.109:8080/，可以看到skywalking的web界面。</a></p><p><img src="https://static.lovebilibili.com/skywalking_8.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、整合SpringCloud工程"><a href="#三、整合SpringCloud工程" class="headerlink" title="三、整合SpringCloud工程"></a>三、整合SpringCloud工程</h1><p>整合其实很简单，不需要引入依赖，也不需要添加任何代码，我们只需要在启动jar包时配置参数即可。</p><pre><code>-javaagent:D:\apache-skywalking-apm-bin-es7\agent\skywalking-agent.jar-Dskywalking.agent.service_name=consumer-Dskywalking.collector.backend_service=192.168.0.109:11800#解释一下上面这三个参数的意思#-javaagent:填的是skywalking-agent.jar的本地磁盘的路径#-Dskywalking.agent.service_name：在skywalking上显示的服务名#-Dskywalking.collector.backend_service：skywalking的collector服务的IP及端口</code></pre><p>我们一般用IDEA开发就这样设置即可。</p><p><img src="https://static.lovebilibili.com/skywalking_9.png" srcset="/img/loading.gif" alt=""></p><p>接下来我按照这个配置，启动一个Consumer工程和Provider工程，并且注册到Nacos注册中心。</p><p><img src="https://static.lovebilibili.com/skywalking_10.png" srcset="/img/loading.gif" alt=""></p><p>然后使用Consumer工程的接口调用Provider工程的接口，可以看到调用链的效果。</p><p><img src="https://static.lovebilibili.com/skywalking_11.png" srcset="/img/loading.gif" alt=""></p><p>非常清晰地看到服务之间调用的情况，耗时等等。其他还有很多功能就不一一介绍了，读者可以自己探索一下。</p><h1 id="四、谈谈架构设计"><a href="#四、谈谈架构设计" class="headerlink" title="四、谈谈架构设计"></a>四、谈谈架构设计</h1><p>可能前面还有一些疑问，比如为什么要设置GRPC的端口号，设置存储仓库为mysql，启动之后有两个java进程等等。不妨看看架构，一切问题都明白了。首先看官网的一张架构图。</p><p><img src="https://static.lovebilibili.com/skywalking_15.png" srcset="/img/loading.gif" alt=""></p><p>可以看到主要有四个部分。</p><p><strong>上面的Agent</strong> ：负责从应用中，收集tracing(调用链数据)和metric(指标)，发送给 SkyWalking OAP 服务器。目前支持 SkyWalking、Zikpin、Jaeger 等提供的 Tracing 数据信息。而我们目前采用的是，SkyWalking Agent 收集 SkyWalking Tracing 数据，传递给SkyWalking OAP 服务器。</p><p><strong>中间的SkyWalking OAP</strong>：负责接收 Agent 发送的 Tracing 和Metric的数据信息，然后进行分析(Analysis Core) ，存储到外部存储器( Storage )，最终提供查询( Query )功能。</p><p><strong>左边的SkyWalking UI</strong>：负责提供web控制台，查看链路，查看各种指标，性能等等。</p><p><strong>右边的Storage</strong>：数据存储。目前支持ES、MySQL、H2等多种存储器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章就介绍到这里，这里仅仅只是入门，简单使用Skywalking，实际上里面还有很多功能我没有介绍，有兴趣的同学可以按照上面的教程安装部署，然后自己探索一下。</p><p>在现在微服务架构比较流行的环境下，如果没有一个调用链追踪框架，会导致很难排查线上服务调用的问题。skywalking是目前发展势头最快的技术框架的技术框架，因为对代码是无侵入性的，所以目前很多公司都采用Skywalking。</p><p><img src="https://static.lovebilibili.com/skywalking_14.png" srcset="/img/loading.gif" alt=""></p><p>这篇文章就讲到这里了，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>ELK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三千字Apollo配置中心总结</title>
    <link href="/2020/10/21/%E4%B8%89%E5%8D%83%E5%AD%97Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%80%BB%E7%BB%93/"/>
    <url>/2020/10/21/%E4%B8%89%E5%8D%83%E5%AD%97Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/apollo_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用<strong>不同环境、不同集群</strong>的配置，配置修改后能够<strong>实时推送到应用端，并且具备规范的权限、流程治理</strong>等特性。</p><p>目前Apollo在github有22.6k颗星，在官网登记的使用的公司有451家，算是很流行的配置中心的框架技术。所以接下来跟着我一起学习Apollo配置中心吧。</p><p><img src="https://static.lovebilibili.com/apollo_1.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、为什么使用配置中心"><a href="#二、为什么使用配置中心" class="headerlink" title="二、为什么使用配置中心"></a>二、为什么使用配置中心</h1><p>首先，没有配置中心之前传统的配置都是写在配置文件中，比如各种yml、perproties、xml文件。</p><p>写在各种文件里最大的问题在于<strong>如果需要改配置信息，需要重新部署发布应用才能生效</strong>，这是第一个问题。</p><p>后面为了做到动态读取配置信息，后面有人改进一下把配置信息存储在数据库的一张表，程序读取表中的配置信息，这种方式很多公司都还在使用，因为简单，而且灵活(修改配置只需要执行个SQL语句，不需要重新部署发布)。但是也不是最完美的，因为<strong>缺少了权限控制，没有管理界面进行统一配置，没有历史版本的配置信息，不支持回滚(防止误操作)</strong>。</p><p>实际上配置中心在市面上已经有很多，比如Nacos、Consul、spring-cloud-config、Apollo等等。</p><p>相对其他的，我觉得选择Apollo的原因是，界面比较美观，操作简便，部署简单，依赖较少，开箱即用。</p><h1 id="三、安装部署"><a href="#三、安装部署" class="headerlink" title="三、安装部署"></a>三、安装部署</h1><p>首先要讲一下Apollo部署三个服务apollo-configservice，apollo-adminservice，apollo-portal，后面我讲架构设计时会讲一下这三个服务是用来干嘛的。</p><p>这里部署建议不要用官网的Quick Start，我一开始使用QuickStart的方式，搞了几个钟头搞不定，总是在Eureka上多了一个UNKONWN的服务，然后又无法访问8070的管理界面，心态直接崩溃。上github找了一下，如下：</p><p><img src="https://static.lovebilibili.com/apollo_3.png" srcset="/img/loading.gif" alt=""></p><p>作者在下面的回答是这样的。</p><p><img src="https://static.lovebilibili.com/apollo_4.png" srcset="/img/loading.gif" alt=""></p><p>这个问题发现不止有一个issue(#2931)反映了，但是没有解决，作者建议使用标准部署。</p><p><img src="https://static.lovebilibili.com/apollo_5.png" srcset="/img/loading.gif" alt=""></p><p>所以接下来就讲标准部署，也就是分布式部署，有耐心的同学也可以直接去github看作者写的<a href="https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">分布式部署指南</a>。</p><p>先介绍一下环境依赖，Linux服务器(建议CentOS7)，MySQL(版本要求:5.6.5+)，部署的服务器需要安装JDK环境(java 1.8+)。</p><p>这里有两种安装方式，一种是下载安装包，另一种是通过源码构建。一般如果不需要对Apollo定制开发，直接用安装包部署即可。我这里演示的就是安装包部署的方式。</p><h2 id="3-1-获取安装包"><a href="#3-1-获取安装包" class="headerlink" title="3.1 获取安装包"></a>3.1 获取安装包</h2><p>先到<a href="https://github.com/ctripcorp/apollo/releases" target="_blank" rel="noopener">官网</a>下载安装包。</p><p><img src="https://static.lovebilibili.com/apollo_6.png" srcset="/img/loading.gif" alt=""></p><p>下载后解压，如下：</p><p><img src="https://static.lovebilibili.com/apollo_7.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-2-创建数据库"><a href="#3-2-创建数据库" class="headerlink" title="3.2 创建数据库"></a>3.2 创建数据库</h2><p>使用MySQL数据库(版本要求:5.6.5+)。</p><h3 id="3-2-1-创建ApolloPortalDB数据库"><a href="#3-2-1-创建ApolloPortalDB数据库" class="headerlink" title="3.2.1 创建ApolloPortalDB数据库"></a>3.2.1 创建ApolloPortalDB数据库</h3><p>使用<a href="https://github.com/ctripcorp/apollo/blob/master/scripts/sql/apolloportaldb.sql" target="_blank" rel="noopener">github上面的sql脚本</a>创建ApolloPortalDB数据库，导入相关的表以及数据。</p><p><img src="https://static.lovebilibili.com/apollo_8.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-2-2-创建ApolloConfigDB数据库"><a href="#3-2-2-创建ApolloConfigDB数据库" class="headerlink" title="3.2.2 创建ApolloConfigDB数据库"></a>3.2.2 创建ApolloConfigDB数据库</h3><p>使用<a href="https://github.com/ctripcorp/apollo/blob/master/scripts/sql/apolloportaldb.sql" target="_blank" rel="noopener">github上面的sql脚本</a>创建ApolloConfigDB数据库，导入相关的表以及数据。</p><p><img src="https://static.lovebilibili.com/apollo_9.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-3-修改配置"><a href="#3-3-修改配置" class="headerlink" title="3.3 修改配置"></a>3.3 修改配置</h2><p>需要改一下数据库连接信息，路径在/config下。</p><h3 id="3-3-1-apollo-configservice配置"><a href="#3-3-1-apollo-configservice配置" class="headerlink" title="3.3.1 apollo-configservice配置"></a>3.3.1 apollo-configservice配置</h3><p>修改apollo-configservice的数据库连接信息application-github.properties，如下：</p><pre><code class="properties"># DataSourcespring.datasource.url = jdbc:mysql://192.168.0.107:3306/ApolloConfigDB?characterEncoding=utf8spring.datasource.username = 账号spring.datasource.password = 密码</code></pre><h3 id="3-3-2-apollo-adminservice配置"><a href="#3-3-2-apollo-adminservice配置" class="headerlink" title="3.3.2 apollo-adminservice配置"></a>3.3.2 apollo-adminservice配置</h3><p>修改apollo-adminservice的数据库连接信息application-github.properties，如下：</p><pre><code class="properties"># DataSourcespring.datasource.url = jdbc:mysql://192.168.0.107:3306/ApolloConfigDB?characterEncoding=utf8spring.datasource.username = 账号spring.datasource.password = 密码</code></pre><h3 id="3-3-3-apollo-portal配置"><a href="#3-3-3-apollo-portal配置" class="headerlink" title="3.3.3 apollo-portal配置"></a>3.3.3 apollo-portal配置</h3><p>修改apollo-portal的数据库连接信息application-github.properties，如下：</p><pre><code class="properties"># DataSourcespring.datasource.url = jdbc:mysql://192.168.0.107:3306/ApolloPortalDB?characterEncoding=utf8spring.datasource.username = 账号spring.datasource.password = 密码</code></pre><p>再修改apollo-env.properties配置，这是关于环境配置的，如下：</p><pre><code class="properties">local.meta=http://localhost:8080## 开发环境dev.meta=http://192.168.0.107:8080## 不需要配置的环境参考${lpt_meta}配置fat.meta=${fat_meta}uat.meta=${uat_meta}lpt.meta=${lpt_meta}pro.meta=${pro_meta}</code></pre><h2 id="3-4-部署"><a href="#3-4-部署" class="headerlink" title="3.4 部署"></a>3.4 部署</h2><p>然后把三个文件夹都上传到Linux服务器。</p><p><img src="https://static.lovebilibili.com/apollo_10.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-4-1-部署发布apollo-configservice"><a href="#3-4-1-部署发布apollo-configservice" class="headerlink" title="3.4.1 部署发布apollo-configservice"></a>3.4.1 部署发布apollo-configservice</h3><p>部署发布服务有顺序，首先发布apollo-configservice，直接执行scripts/startup.sh。</p><p><img src="https://static.lovebilibili.com/apollo_11.png" srcset="/img/loading.gif" alt=""></p><p>有可能会出现这个错误(我就出现了)，不用担心，实际上进程还没有结束，还在启动，我们可以到日志记录的文件夹(下图来源于startup.sh脚本)查看日志。</p><p><img src="https://static.lovebilibili.com/apollo_12.png" srcset="/img/loading.gif" alt=""></p><p>启动时间比较长，因为这个服务包括启动Eureka注册中心，需要耐心等待。观察apollo-configservice.log文件，当看到如下信息后，表示启动成功。</p><p><img src="https://static.lovebilibili.com/apollo_13.png" srcset="/img/loading.gif" alt=""></p><p>Eureka注册中心启动成功，可以打开<a href="http://192.168.0.107:8080/查看：" target="_blank" rel="noopener">http://192.168.0.107:8080/查看：</a></p><p><img src="https://static.lovebilibili.com/apollo_14.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-4-2-部署发布apollo-adminservice"><a href="#3-4-2-部署发布apollo-adminservice" class="headerlink" title="3.4.2 部署发布apollo-adminservice"></a>3.4.2 部署发布apollo-adminservice</h3><p>接着发布apollo-adminservice，直接执行scripts/startup.sh。查看日志的方式跟上面一样。启动成功后，可以看到Eureka的服务列表中多了一个服务。</p><p><img src="https://static.lovebilibili.com/apollo_15.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-4-3-部署发布apollo-portal"><a href="#3-4-3-部署发布apollo-portal" class="headerlink" title="3.4.3 部署发布apollo-portal"></a>3.4.3 部署发布apollo-portal</h3><p>接着发布apollo-portal，直接执行scripts/startup.sh。portal是提供Web界面的服务，所以启动成功后，可以打开<a href="http://192.168.0.107:8070/登录web界面，默认账号密码是apollo/admin。" target="_blank" rel="noopener">http://192.168.0.107:8070/登录web界面，默认账号密码是apollo/admin。</a></p><p><img src="https://static.lovebilibili.com/apollo_16.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/apollo_17.png" srcset="/img/loading.gif" alt=""></p><p>到此，安装就完成了！</p><h1 id="四、SpringBoot整合Apollo"><a href="#四、SpringBoot整合Apollo" class="headerlink" title="四、SpringBoot整合Apollo"></a>四、SpringBoot整合Apollo</h1><p>接下来，整一个Demo(相当于java客户端)，使用SpringBoot整合Apollo，实现动态读取配置。</p><h2 id="4-1-Mave依赖"><a href="#4-1-Mave依赖" class="headerlink" title="4.1 Mave依赖"></a>4.1 Mave依赖</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt;    &lt;artifactId&gt;apollo-client&lt;/artifactId&gt;    &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="4-2-AppId"><a href="#4-2-AppId" class="headerlink" title="4.2 AppId"></a>4.2 AppId</h2><p>在classpath路径下，创建/META-INF/app.properties文件。如下：</p><pre><code class="properties"># 应用的唯一标识，后面创建工程需要用到app.id=apollo-demo</code></pre><h2 id="4-3-Apollo-Meta-Server"><a href="#4-3-Apollo-Meta-Server" class="headerlink" title="4.3 Apollo Meta Server"></a>4.3 Apollo Meta Server</h2><p>其实就是配置Apollo服务器的地址。官网提供的方式有很多，我这里选其中一种比较简单的方式。在classpath路径下创建apollo-env.properties文件，配置如下：</p><pre><code class="properties">dev.meta=http://192.168.0.107:8080# fat.meta=http://apollo.fat.xxx.com# uat.meta=http://apollo.uat.xxx.com# pro.meta=http://apollo.xxx.com</code></pre><h2 id="4-4-Environment"><a href="#4-4-Environment" class="headerlink" title="4.4 Environment"></a>4.4 Environment</h2><p>其实是配置环境，因为上面可以配置四种环境，这里配置具体选择哪个环境。这里介绍两种方式：</p><p>第一种通过Java System Property。</p><p><img src="https://static.lovebilibili.com/apollo_18.png" srcset="/img/loading.gif" alt=""></p><p>第二种通过配置文件。</p><p><img src="https://static.lovebilibili.com/apollo_19.png" srcset="/img/loading.gif" alt=""></p><p>到相对应的路径下创建server.properties，配置如下：</p><pre><code class="properties">env=DEV</code></pre><h2 id="4-5-EnableApolloConfig"><a href="#4-5-EnableApolloConfig" class="headerlink" title="4.5 @EnableApolloConfig"></a>4.5 @EnableApolloConfig</h2><p>在启动类上加上注解@EnableApolloConfig。</p><pre><code class="java">@SpringBootApplication//开启apollo配置@EnableApolloConfigpublic class ApolloDemoApplication {    public static void main(String[] args) {        SpringApplication.run(ApolloDemoApplication.class, args);    }}</code></pre><h2 id="4-6-测试类"><a href="#4-6-测试类" class="headerlink" title="4.6 测试类"></a>4.6 测试类</h2><p>这样就完成了，接下来再创建一个Controller进行测试一下。</p><pre><code class="java">@RestControllerpublic class ApolloController {    //冒号后面的是默认值    @Value(&quot;${configValue:default}&quot;)    private String configValue;    @RequestMapping(&quot;/apollo/getConfig&quot;)    public String getConfig() {        return configValue;    }}</code></pre><h2 id="4-7-管理界面创建对应的配置"><a href="#4-7-管理界面创建对应的配置" class="headerlink" title="4.7 管理界面创建对应的配置"></a>4.7 管理界面创建对应的配置</h2><p>第一步，创建项目。</p><p><img src="https://static.lovebilibili.com/apollo_21.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/apollo_20.png" srcset="/img/loading.gif" alt=""></p><p>第二步，创建配置。</p><p><img src="https://static.lovebilibili.com/apollo_22.png" srcset="/img/loading.gif" alt=""></p><p>第三步，发布。</p><p><img src="https://static.lovebilibili.com/apollo_23.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-8-测试"><a href="#4-8-测试" class="headerlink" title="4.8 测试"></a>4.8 测试</h2><p>启动项目apollo-demo，然后请求路径<a href="http://localhost:8888/apollo/getConfig，可以看到：" target="_blank" rel="noopener">http://localhost:8888/apollo/getConfig，可以看到：</a></p><p><img src="https://static.lovebilibili.com/apollo_24.png" srcset="/img/loading.gif" alt=""></p><p>控制台可以看到推送配置信息的日志：</p><p><img src="https://static.lovebilibili.com/apollo_25.png" srcset="/img/loading.gif" alt=""></p><h1 id="五、架构设计"><a href="#五、架构设计" class="headerlink" title="五、架构设计"></a>五、架构设计</h1><p>讲完了安装和SpringBoot整合的demo后，我们是时候探究一下原理，为什么要有三个服务，又是如何做到配置信息发布后，客户端实时获取到最新的配置的。继续往下看。</p><p>首先看一张官网的架构设计图。</p><h2 id="5-1-基础模型"><a href="#5-1-基础模型" class="headerlink" title="5.1 基础模型"></a>5.1 基础模型</h2><p>作者在官网上有个基础模型的架构图，忽略掉很多细节后实际上非常简单：</p><p><img src="https://static.lovebilibili.com/apollo_26.png" srcset="/img/loading.gif" alt=""></p><ol><li>用户在配置中心对配置进行修改并发布。</li><li>配置中心通知Apollo客户端有配置更新。</li><li>Apollo客户端从配置中心拉取最新的配置、更新本地配置并通知到应用。</li></ol><h2 id="5-2-架构模块"><a href="#5-2-架构模块" class="headerlink" title="5.2 架构模块"></a>5.2 架构模块</h2><p>如果我们把Apollo配置中心服务端展开的话，架构图如下：</p><p><img src="https://static.lovebilibili.com/apollo_27.png" srcset="/img/loading.gif" alt=""></p><p>看到这里，整个架构看起来就比较清晰了。接下来从上往下简单介绍一下：</p><p><strong>Portal服务</strong>：提供Web界面供用户管理配置，通过MetaServer获取AdminService服务列表（IP+Port），通过IP+Port访问AdminService服务。</p><p><strong>Client</strong>：实际上就是我们创建的SpringBoot项目，引入ApolloClient的maven依赖，为应用提供配置获取、实时更新等功能。</p><p><strong>Meta Server</strong>：从Eureka获取Config Service和Admin Service的服务信息，相当于是一个Eureka Client。主要是为了封装服务发现的细节，对Portal和Client而言，永远通过一个Http接口获取Admin Service和Config Service的服务信息，而不需要关心背后实际的服务注册和发现组件。Meta Server只是一个逻辑角色，在部署时和Config Service是在一个JVM进程中的，所以IP、端口和Config Service一致。</p><p><strong>Eureka</strong>：注册中心。Config Service和Admin Service会向Eureka注册服务。为了简单起见，目前Eureka在部署时和Config Service是在一个JVM进程中的。</p><p><strong>Config Service</strong>：提供配置获取接口。提供配置更新推送接口(基于Http long polling)。服务对象为Apollo客户端(Client)。</p><p><strong>Admin Service</strong>：提供配置管理接口。提供配置发布、修改等接口。服务对象为Portal。</p><h2 id="5-3-配置发布后的实时推送设计"><a href="#5-3-配置发布后的实时推送设计" class="headerlink" title="5.3 配置发布后的实时推送设计"></a>5.3 配置发布后的实时推送设计</h2><p>上面讲完各个角色的用途，那这些角色是怎么配合一起工作的呢，我们来看一张图：</p><p><img src="https://static.lovebilibili.com/apollo_28.png" srcset="/img/loading.gif" alt=""></p><p>上图简要描述了配置发布的大致过程：</p><ol><li>用户在Portal操作配置发布。</li><li>Portal调用Admin Service的接口操作发布。</li><li>Admin Service发布配置后，发送ReleaseMessage给各个Config Service。</li><li>Config Service收到ReleaseMessage后，通知对应的客户端(Client)。</li></ol><p>关键点在于AdminService发送ReleaseMessage给ConfigService，这一步是如何异步发送的呢，一般异步发送我们很容易想到消息队列，但是实际上我们在安装部署时并没有使用到消息队列。</p><p>答案在于：</p><ul><li>Admin Service在配置发布后会往ReleaseMessage表插入一条消息记录，消息内容就是配置发布的AppId+Cluster+Namespace。</li><li>然后Config Service有一个线程会每秒扫描一次ReleaseMessage表，看看是否有新的消息记录。</li><li>Config Service如果发现有新的消息记录，那么就会通知到所有的消息监听器，监听器得到配置发布的AppId+Cluster+Namespace后，会通知对应的客户端。</li></ul><p><img src="https://static.lovebilibili.com/apollo_29.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>在实现上，考虑到Apollo的实际使用场景，以及为了尽可能减少外部依赖，我们没有采用外部的消息中间件，而是通过数据库实现了一个简单的消息队列。—-来自官网</p></blockquote><h2 id="5-4-高可用"><a href="#5-4-高可用" class="headerlink" title="5.4 高可用"></a>5.4 高可用</h2><p>Apollo为了实现高可用，服务端使用了Eureka作为注册中心，这一点在官网也有谈到。</p><p><img src="https://static.lovebilibili.com/apollo_30.png" srcset="/img/loading.gif" alt=""></p><p>除此之外，客户端也做了高可用的一些架构设计，比如本地文件缓存。</p><p><img src="https://static.lovebilibili.com/apollo_31.png" srcset="/img/loading.gif" alt=""></p><p>这个缓存文件默认就放在C:\opt\data\apollo-demo\config-cache路径下：</p><p><img src="https://static.lovebilibili.com/apollo_32.png" srcset="/img/loading.gif" alt=""></p><p>这个文件的作用是，在遇到服务不可用，或网络不通的时候，依然能从本地恢复配置。</p><h1 id="六、絮叨"><a href="#六、絮叨" class="headerlink" title="六、絮叨"></a>六、絮叨</h1><p>这篇文章就讲到这里。其实Apollo配置中心算是一个比较容易上手，架构相对比较清晰的开源项目。目前很多互联网公司都在推行微服务架构，在使用微服务的架构时，配置信息就会成倍数增加，因为配置实际上代表的是“控制”，很多时候程序的运行是靠配置去决定行为的，而且要能实时生效的，所以就必须要有个配置中心。</p><p>有些公司体量大一些会自己公司开发一套配置中心，其实实现起来也不是特别难，我上一间公司就自己实现，使用MQ消息队列+数据库，再自己简单地搭了一个增删改查、刷新配置的web页面，就完成了一个配置中心。</p><p>但是我觉得如果有现成的开源的会更加舒服，不用自己造轮子耗费时间，精力，而且选一些像Apollo这种比较大众主流的技术框架，学习成本也比较低，网上有很多资料。</p><p>那么Apollo配置中心就讲到这里了，上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>分布式</tag>
      
      <tag>配置中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3千字详细讲解OpenFeign的使用姿势</title>
    <link href="/2020/10/13/3%E5%8D%83%E5%AD%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3OpenFeign%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <url>/2020/10/13/3%E5%8D%83%E5%AD%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3OpenFeign%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/fegin_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前在SpringCloud技术栈中，调用服务用得最多的就是OpenFeign，所以这篇文章讲一下OpenFeign，希望对大家有所帮助。</p><h1 id="一、构建工程"><a href="#一、构建工程" class="headerlink" title="一、构建工程"></a>一、构建工程</h1><p>使用Nacos作为注册中心，不会搭建Nacos的话，可以参考上一篇注册中心的文章。</p><p>首先父工程parent引入依赖。</p><pre><code class="xml">&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Finchley.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;            &lt;version&gt;0.2.2.RELEASE&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-openfeign&lt;/artifactId&gt;            &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;&lt;!-- SpringCloud nacos服务发现的依赖 --&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;        &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;        &lt;version&gt;1.2.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>搭建提供者provider工程和消费者consumer工程。</p><p>provider工程继承父工程的pom文件，编写启动类如下：</p><pre><code class="java">@SpringBootApplication@EnableDiscoveryClient//注册中心public class ProviderApplication {    public static void main(String[] args) throws Exception {        SpringApplication.run(ProviderApplication.class, args);    }}</code></pre><p>provider工程的配置文件如下：</p><pre><code class="yaml">server:  port: 8080spring:  application:    name: provider  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8848        service: ${spring.application.name}</code></pre><p>提供接口，Controller如下：</p><pre><code class="java">@RestControllerpublic class ProviderController {    @RequestMapping(&quot;/provider/list&quot;)    public List&lt;String&gt; list() {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;java技术爱好者&quot;);        list.add(&quot;SpringCloud&quot;);        list.add(&quot;没有人比我更懂了&quot;);        return list;    }}</code></pre><p>消费者consumer工程也继承parent的pom文件，加上Feign依赖：</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;!-- 版本在parent的pom文件中指定了 --&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>编写启动类，如下：</p><pre><code class="java">@SpringBootApplication@EnableDiscoveryClient//开启feign接口扫描，指定扫描的包@EnableFeignClients(basePackages = {&quot;com.yehongzhi.springcloud&quot;})public class ConsumerApplication {    public static void main(String[] args) throws Exception {        SpringApplication.run(ConsumerApplication.class, args);    }}</code></pre><p>环境搭建完成后，接下来讲两种实现使用方式。</p><h1 id="二、声明式"><a href="#二、声明式" class="headerlink" title="二、声明式"></a>二、声明式</h1><p>这种很简单，消费者consumer工程增加一个ProviderClient接口。</p><pre><code class="java">@FeignClient(name = &quot;provider&quot;)//会扫描指定包下，标记FeignClient注解的接口//会根据服务名，从注册中心找到对应的IP地址public interface ProviderClient {    //这里跟提供者接口的URL一致    @RequestMapping(&quot;/provider/list&quot;)    String list();}</code></pre><p>然后再用消费者工程的ConsumerController接口来测试。</p><pre><code class="java">@RestControllerpublic class ConsumerController {    //引入Feign客户端    @Resource    private ProviderClient providerClient;    @RequestMapping(&quot;/consumer/callProvider&quot;)    public String callProvider() {        //使用Feign客户端调用其他服务的接口        return providerClient.list();    }}</code></pre><p>最后我们启动提供者工程，消费者工程，注册中心，测试。</p><p><img src="https://static.lovebilibili.com/fegin_1.png" srcset="/img/loading.gif" alt=""></p><p>然后调用消费者的ConsumerController接口。</p><p><img src="https://static.lovebilibili.com/fegin_2.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、继承式"><a href="#三、继承式" class="headerlink" title="三、继承式"></a>三、继承式</h1><p>细心的同学可能发现，其实声明式会写多一次提供者接口的定义，也就是有重复的代码，既然有重复的定义，那我们就可以抽取出来，所以就有了继承式。</p><p>第一步，创建一个普通的Maven项目api工程，把接口定义在api中。</p><p><img src="https://static.lovebilibili.com/fegin_3.png" srcset="/img/loading.gif" alt=""></p><p>第二步，服务提供者工程的ProviderController实现Provider接口。</p><pre><code class="java">@RestControllerpublic class ProviderController implements ProviderApi {    public String list() {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;java技术爱好者&quot;);        list.add(&quot;SpringCloud&quot;);        list.add(&quot;没有人比我更懂了&quot;);        return list.toString();    }}</code></pre><p>第三步，消费者工程的ProviderClient无需定义，只需要继承ProviderApi，然后加上@FeignClient即可。</p><pre><code class="java">@FeignClient(name = &quot;provider&quot;)public interface ProviderClient extends ProviderApi {}</code></pre><p>其他不用变了，最后启动服务提供者，消费者，注册中心测试一下。</p><p><img src="https://static.lovebilibili.com/fegin_4.png" srcset="/img/loading.gif" alt=""></p><p>测试成功！上面继承式的好处就在于，只需要在api工程定义一次接口，服务提供者去实现具体的逻辑，消费者则继承接口贴个注解即可，非常方便快捷。</p><p>缺点就在于如果有人动了api的接口，则会导致很多服务消费者、提供者出现报错，耦合性比较强。api工程相当于一个公共的工程，消费者和服务者都会依赖此工程，所以一般要求不能随便删api上面的接口。</p><h1 id="四、Feign的相关配置"><a href="#四、Feign的相关配置" class="headerlink" title="四、Feign的相关配置"></a>四、Feign的相关配置</h1><p>下面讲一下Feign的一些常用的相关配置。</p><h2 id="4-1-请求超时设置"><a href="#4-1-请求超时设置" class="headerlink" title="4.1 请求超时设置"></a>4.1 请求超时设置</h2><p>Feign底层其实还是使用Ribbon，默认是1秒。所以超过1秒就报错。</p><p>接下来试验一下。我在服务提供者的接口加上一段休眠1.5秒的代码，然后用消费者去消费。</p><pre><code class="java">@RestControllerpublic class ProviderController implements ProviderApi {    public String list() {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;java技术爱好者&quot;);        list.add(&quot;SpringCloud&quot;);        list.add(&quot;没有人比我更懂了&quot;);        try {            //休眠1.5秒            Thread.sleep(1500);        } catch (Exception e) {            e.printStackTrace();        }        return list.toString();    }}</code></pre><p>消费者调用后，由于超过1秒，可以看到控制台报错。</p><p><img src="https://static.lovebilibili.com/fegin_5.png" srcset="/img/loading.gif" alt=""></p><p>如果想调整超时时间，可以在消费者这边，加上配置：</p><pre><code class="yaml">ribbon:  ReadTimeout:  5000 #请求时间5秒  ConnectTimeout: 5000 #连接时间5秒</code></pre><p>为了显示出效果，我们在消费者的代码里加上耗时计算：</p><pre><code class="java">@RestControllerpublic class ConsumerController {    @Resource    private ProviderClient providerClient;    @RequestMapping(&quot;/consumer/callProvider&quot;)    public String callProvider() throws Exception {        long star = System.currentTimeMillis();        String list = providerClient.list();        long end = System.currentTimeMillis();        return &quot;响应结果：&quot; + list + &quot;,耗时：&quot; + (end - star) / 1000 + &quot;秒&quot;;    }}</code></pre><p>最后启动测试，可以看到，超过1秒也能请求成功。</p><p><img src="https://static.lovebilibili.com/fegin_6.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-日志打印功能"><a href="#4-2-日志打印功能" class="headerlink" title="4.2 日志打印功能"></a>4.2 日志打印功能</h2><p>首先需要配置Feign的打印日志的级别。</p><pre><code class="java">@Configurationpublic class FeignConfig {    /**     * NONE：默认的，不显示任何日志     * BASIC：仅记录请求方法、URL、响应状态码及执行时间     * HEADERS：出了BASIC中定义的信息之外，还有请求和响应的头信息     * FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元素     */    @Bean    public Logger.Level feginLoggerLevel() {        return Logger.Level.FULL;    }}</code></pre><p>第二步，需要设置打印的Feign接口。Feign为每个客户端创建一个logger。默认情况下，logger的名称是Feigh接口的完整类名。需要注意的是，<strong>Feign的日志打印只会对DEBUG级别做出响应</strong>。</p><pre><code class="yaml">#与server同级logging:  level:    com.yehongzhi.springcloud.consumer.feign.ProviderClient: debug</code></pre><p>设置完成后，控制台可以看到详细的请求信息。<br><img src="https://static.lovebilibili.com/fegin_7.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-3-Feign实现熔断"><a href="#4-3-Feign实现熔断" class="headerlink" title="4.3 Feign实现熔断"></a>4.3 Feign实现熔断</h2><p>openFeign实际上是已经引入了hystrix的相关jar包，所以可以直接使用，设置超时时间，超时后调用FallBack方法，实现熔断机制。</p><p>首先在消费者工程添加Maven依赖。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>第二步，在配置中开启熔断机制，添加超时时间。</p><pre><code class="yaml">#默认是不支持的，所以这里要开启，设置为truefeign:  hystrix:    enabled: truehystrix:  command:    default:      execution:        isolation:          thread:            timeoutInMilliseconds: 3000</code></pre><p>第三步，编写FallBack类。</p><pre><code class="java">//ProviderClient是贴了@FeignClient注解的接口@Componentpublic class ProviderClientFallBack implements ProviderClient {    @Override    public String list() {        return Arrays.asList(&quot;调用fallBack接口&quot;, &quot;返回未知结果&quot;).toString();    }}</code></pre><p>第四步，在对应的Feign接口添加fallback属性。</p><pre><code class="java">//fallback属性，填写刚刚编写的FallBack回调类@Component@FeignClient(name = &quot;provider&quot;, fallback = ProviderClientFallBack.class)public interface ProviderClient extends ProviderApi {}</code></pre><p>最后可以测试一下，超过设置的3秒，则会熔断，调用FallBack方法返回。</p><p><img src="https://static.lovebilibili.com/fegin_8.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-4-设置负载均衡"><a href="#4-4-设置负载均衡" class="headerlink" title="4.4 设置负载均衡"></a>4.4 设置负载均衡</h2><p>前面说过OpenFeign底层是使用Ribbon，Ribbon是负责做负载均衡的组件。所以是可以通过配置设置负载均衡的策略。</p><p>默认的是轮询策略。如果要换成其他策略，比如随机，怎么换呢。</p><p>很简单，改一下配置即可：</p><pre><code class="yaml">#服务名称provider:  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #配置规则 随机#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #配置规则 轮询#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RetryRule #配置规则 重试#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule #配置规则 响应时间权重#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.BestAvailableRule #配置规则 最空闲连接策略</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>OpenFeign把RestTemplete，Ribbon，Hystrix糅合在了一起，在使用时就可以更加方便，优雅地完成整个服务的暴露，调用等。避免做一些重复的复制粘贴接口URL，或者重复定义接口等。还是非常值得去学习的。</p><p>以前我在的公司搭建的SpringCloud微服务就没有使用Feign，架构师自己写了一个AOP代理类进行服务调用，超时时间5秒写死在代码里，当时有个微服务接口要上传文件，总是超时，又改不了超时时间，一超时就调熔断方法返回服务请求超时，导致非常痛苦。</p><p>如果当时使用Feign，插拔式，可配置的方式，也许就没那么麻烦了。</p><p>那么feign就讲到这里了，上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/example" target="_blank" rel="noopener">https://github.com/yehongzhi/example</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>OpenFeign</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3千字带你搞懂XXL-JOB任务调度平台</title>
    <link href="/2020/10/13/3%E5%8D%83%E5%AD%97%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82XXL-JOB%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0/"/>
    <url>/2020/10/13/3%E5%8D%83%E5%AD%97%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82XXL-JOB%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/xxljob_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在平时的业务场景中，经常有一些场景需要使用定时任务，比如：</p><ul><li>时间驱动的场景：某个时间点发送优惠券，发送短信等等。</li><li>批量处理数据：批量统计上个月的账单，统计上个月销售数据等等。</li><li>固定频率的场景：每隔5分钟需要执行一次。</li></ul><p>所以定时任务在平时开发中并不少见，而且对于现在快速消费的时代，每天都需要发送各种推送，消息都需要依赖定时任务去完成，应用非常广泛。</p><h1 id="二、为什么需要任务调度平台"><a href="#二、为什么需要任务调度平台" class="headerlink" title="二、为什么需要任务调度平台"></a>二、为什么需要任务调度平台</h1><p>在Java中，传统的定时任务实现方案，比如Timer，Quartz等都或多或少存在一些问题：</p><ul><li>不支持集群、不支持统计、没有管理平台、没有失败报警、没有监控等等</li></ul><p>而且在现在分布式的架构中，有一些场景需要分布式任务调度：</p><ul><li>同一个服务多个实例的任务存在互斥时，需要统一的调度。</li><li>任务调度需要支持高可用、监控、故障告警。</li><li>需要统一管理和追踪各个服务节点任务调度的结果，需要记录保存任务属性信息等。</li></ul><p>显然传统的定时任务已经不满足现在的分布式架构，所以需要一个分布式任务调度平台，目前比较主流的是elasticjob和xxl-job。</p><p>elasticjob由当当网开源，目前github有6.5k的Star，使用的公司在官网登记有76家。</p><p><img src="https://static.lovebilibili.com/xxljob_1.png" srcset="/img/loading.gif" alt=""></p><p>跟xxl-job不同的是，<strong>elasticjob是采用zookeeper实现分布式协调</strong>，实现任务高可用以及分片。</p><p><img src="https://static.lovebilibili.com/xxljob_3.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、为什么选择XXL-JOB"><a href="#三、为什么选择XXL-JOB" class="headerlink" title="三、为什么选择XXL-JOB"></a>三、为什么选择XXL-JOB</h1><p>实际上更多公司选择xxl-job，目前<strong>xxl-job的github上有15.7k个star，登记公司有348个</strong>。毫无疑问elasticjob和xxl-job都是非常优秀的技术框架，接下来我们进一步对比讨论，探索一下为什么更多公司会选择xxl-job。</p><p>首先先介绍一下xxl-job，这是出自大众点评许雪里(xxl就是作者名字的拼音首字母)的开源项目，官网上介绍这是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。跟elasticjob不同，xxl-job环境依赖于mysql，不用ZooKeeper，这也是最大的不同。</p><p>elasticjob的初衷是为了面对高并发复杂的业务，即使是在业务量大，服务器多的时候也能做好任务调度，尽可能的利用服务器的资源。使用ZooKeeper使其具有高可用、一致性的，而且还具有良好的扩展性。官网上写<strong>elasticjob是无中心化的，通过ZooKeeper的选举机制选举出主服务器，如果主服务器挂了，会重新选举新的主服务器。因此elasticjob具有良好的扩展性和可用性，但是使用和运维有一定的复杂</strong>。</p><p><img src="https://static.lovebilibili.com/xxljob_4.png" srcset="/img/loading.gif" alt=""></p><p>xxl-job则相反，是通过一个中心式的调度平台，调度多个执行器执行任务，调度中心通过DB锁保证集群分布式调度的一致性，这样扩展执行器会增大DB的压力，但是如果实际上这里数据库只是负责任务的调度执行。但是如果没有大量的执行器的话和任务的情况，是不会造成数据库压力的。实际上大部分公司任务数，执行器并不多(虽然面试经常会问一些高并发的问题)。</p><p>相对来说，xxl-job中心式的调度平台<strong>轻量级，开箱即用，操作简易，上手快，与SpringBoot有非常好的集成</strong>，而且监控界面就集成在调度中心，界面又简洁，对于<strong>企业维护起来成本不高，还有失败的邮件告警</strong>等等。这就使很多企业选择xxl-job做调度平台。</p><h1 id="四、安装"><a href="#四、安装" class="headerlink" title="四、安装"></a>四、安装</h1><h2 id="4-1-拉取源码"><a href="#4-1-拉取源码" class="headerlink" title="4.1 拉取源码"></a>4.1 拉取源码</h2><p>搭建xxl-job很简单，有docker拉取镜像部署和源码编译两种方式，docker部署的方式比较简单，我就讲源码编译的方式。首先到github拉取xxl-job源码到本地。</p><p><img src="https://static.lovebilibili.com/xxljob_5.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-导入IDEA"><a href="#4-2-导入IDEA" class="headerlink" title="4.2 导入IDEA"></a>4.2 导入IDEA</h2><p>拉取源码下来后，可以看到项目结构，如下：</p><p><img src="https://static.lovebilibili.com/xxljob_6.png" srcset="/img/loading.gif" alt=""></p><p>导入到IDEA，配置一下Maven，下载相关的jar包，稍等一下后，就可以看到这样的项目：</p><p><img src="https://static.lovebilibili.com/xxljob_7.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-3-初始化数据库"><a href="#4-3-初始化数据库" class="headerlink" title="4.3 初始化数据库"></a>4.3 初始化数据库</h2><p>前面讲过xxl-job需要依赖mysql，所以需要初始化数据库，在xxl-job\doc\db路径下找到tables_xxl_job.sql文件。在mysql上运行sql文件。</p><p><img src="https://static.lovebilibili.com/xxljob_8.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-4-配置文件"><a href="#4-4-配置文件" class="headerlink" title="4.4 配置文件"></a>4.4 配置文件</h2><p>接着就改一下配置文件，在admin项目下找到application.properties文件。</p><pre><code class="properties">### 调度中心JDBC链接spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=spring.datasource.driver-class-name=com.mysql.jdbc.Driver### 报警邮箱spring.mail.host=smtp.qq.comspring.mail.port=25spring.mail.username=xxx@qq.comspring.mail.password=xxxspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory### 调度中心通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 调度中心国际化配置 [必填]： 默认为 &quot;zh_CN&quot;/中文简体, 可选范围为 &quot;zh_CN&quot;/中文简体, &quot;zh_TC&quot;/中文繁体 and &quot;en&quot;/英文；xxl.job.i18n=zh_CN## 调度线程池最大线程配置【必填】xxl.job.triggerpool.fast.max=200xxl.job.triggerpool.slow.max=100### 调度中心日志表数据保存天数 [必填]：过期日志自动清理；限制大于等于7时生效，否则, 如-1，关闭自动清理功能；xxl.job.logretentiondays=10</code></pre><h2 id="4-5-编译运行"><a href="#4-5-编译运行" class="headerlink" title="4.5 编译运行"></a>4.5 编译运行</h2><p>简单一点直接跑admin项目的main方法启动也行。</p><p><img src="https://static.lovebilibili.com/xxljob_9.png" srcset="/img/loading.gif" alt=""></p><p>如果部署在服务器呢，那我们需要打包成jar包，在IDEA利用Maven插件打包。</p><p><img src="https://static.lovebilibili.com/xxljob_10.png" srcset="/img/loading.gif" alt=""></p><p>然后在xxl-job\xxl-job-admin\target路径下，找到jar包。</p><p><img src="https://static.lovebilibili.com/xxljob_11.png" srcset="/img/loading.gif" alt=""></p><p>然后就得到jar包了，使用java -jar命令就可以启动了。</p><p><img src="https://static.lovebilibili.com/xxljob_12.png" srcset="/img/loading.gif" alt=""></p><p>到这里就已经完成了！打开浏览器，输入<a href="http://localhost:8080/xxl-job-admin进入管理页面。默认账号/密码：admin/123456。" target="_blank" rel="noopener">http://localhost:8080/xxl-job-admin进入管理页面。默认账号/密码：admin/123456。</a></p><p><img src="https://static.lovebilibili.com/xxljob_13.png" srcset="/img/loading.gif" alt=""></p><h1 id="五、永远的HelloWord"><a href="#五、永远的HelloWord" class="headerlink" title="五、永远的HelloWord"></a>五、永远的HelloWord</h1><p>部署了调度中心之后，需要往调度中心注册执行器，添加调度任务。接下来就参考xxl-job写一个简单的例子。</p><p>首先创建一个SpringBoot项目，名字叫”xxljob-demo”，添加依赖。</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;&lt;!-- 官网的demo是2.2.1，中央maven仓库还没有，所以就用2.2.0 --&gt;        &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;        &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;        &lt;version&gt;2.2.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>接着修改application.properties。</p><pre><code class="properties"># web portserver.port=8081# log configlogging.config=classpath:logback.xmlspring.application.name=xxljob-demo### 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin### 执行器通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册xxl.job.executor.appname=xxl-job-demo### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。xxl.job.executor.address=### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；xxl.job.executor.ip=### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；xxl.job.executor.port=9999### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；xxl.job.executor.logretentiondays=10</code></pre><p>接着写一个配置类XxlJobConfig。</p><pre><code class="java">@Configurationpublic class XxlJobConfig {    private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);    @Value(&quot;${xxl.job.admin.addresses}&quot;)    private String adminAddresses;    @Value(&quot;${xxl.job.accessToken}&quot;)    private String accessToken;    @Value(&quot;${xxl.job.executor.appname}&quot;)    private String appname;    @Value(&quot;${xxl.job.executor.address}&quot;)    private String address;    @Value(&quot;${xxl.job.executor.ip}&quot;)    private String ip;    @Value(&quot;${xxl.job.executor.port}&quot;)    private int port;    @Value(&quot;${xxl.job.executor.logpath}&quot;)    private String logPath;    @Value(&quot;${xxl.job.executor.logretentiondays}&quot;)    private int logRetentionDays;    @Bean    public XxlJobSpringExecutor xxlJobExecutor() {        logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;);        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);        xxlJobSpringExecutor.setAppname(appname);        xxlJobSpringExecutor.setAddress(address);        xxlJobSpringExecutor.setIp(ip);        xxlJobSpringExecutor.setPort(port);        xxlJobSpringExecutor.setAccessToken(accessToken);        xxlJobSpringExecutor.setLogPath(logPath);        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);        return xxlJobSpringExecutor;    }}</code></pre><p>接着编写一个任务类XxlJobDemoHandler，使用Bean模式。</p><pre><code class="java">@Componentpublic class XxlJobDemoHandler {    /**     * Bean模式，一个方法为一个任务     * 1、在Spring Bean实例中，开发Job方法，方式格式要求为 &quot;public ReturnT&lt;String&gt; execute(String param)&quot;     * 2、为Job方法添加注解 &quot;@XxlJob(value=&quot;自定义jobhandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)&quot;，注解value值对应的是调度中心新建任务的JobHandler属性的值。     * 3、执行日志：需要通过 &quot;XxlJobLogger.log&quot; 打印执行日志；     */    @XxlJob(&quot;demoJobHandler&quot;)    public ReturnT&lt;String&gt; demoJobHandler(String param) throws Exception {        XxlJobLogger.log(&quot;java, Hello World~~~&quot;);        XxlJobLogger.log(&quot;param:&quot; + param);        return ReturnT.SUCCESS;    }}</code></pre><p>在resources目录下，添加logback.xml文件。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;false&quot; scan=&quot;true&quot; scanPeriod=&quot;1 seconds&quot;&gt;    &lt;contextName&gt;logback&lt;/contextName&gt;    &lt;property name=&quot;log.path&quot; value=&quot;/data/applogs/xxl-job/xxl-job-executor-sample-springboot.log&quot;/&gt;    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;file&gt;${log.path}&lt;/file&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;${log.path}.%d{yyyy-MM-dd}.zip&lt;/fileNamePattern&gt;        &lt;/rollingPolicy&gt;        &lt;encoder&gt;            &lt;pattern&gt;%date %level [%thread] %logger{36} [%file : %line] %msg%n            &lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=&quot;info&quot;&gt;        &lt;appender-ref ref=&quot;console&quot;/&gt;        &lt;appender-ref ref=&quot;file&quot;/&gt;    &lt;/root&gt;&lt;/configuration&gt;</code></pre><p>写完之后启动服务，然后可以打开管理界面，找到执行器管理，添加执行器。</p><p><img src="https://static.lovebilibili.com/xxljob_14.png" srcset="/img/loading.gif" alt=""></p><p>接着到任务管理，添加任务。</p><p><img src="https://static.lovebilibili.com/xxljob_15.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/xxljob_16.png" srcset="/img/loading.gif" alt=""></p><p>最后我们可以到任务管理去测试一下，运行demoJobHandler。</p><p><img src="https://static.lovebilibili.com/xxljob_17.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/xxljob_18.png" srcset="/img/loading.gif" alt=""></p><p>点击保存后，会立即执行。点击查看日志，可以看到任务执行的历史日志记录。</p><p><img src="https://static.lovebilibili.com/xxljob_19.png" srcset="/img/loading.gif" alt=""></p><p>打开刚刚执行的执行日志，我们可以看到，运行成功。</p><p><img src="https://static.lovebilibili.com/xxljob_20.png" srcset="/img/loading.gif" alt=""></p><p>这就是简单的Demo演示，非常简单，上手也快。</p><h1 id="六、谈谈架构设计"><a href="#六、谈谈架构设计" class="headerlink" title="六、谈谈架构设计"></a>六、谈谈架构设计</h1><p>下面简单地说一下xxl-job的架构，我们先看官网提供的一张架构图来分析。</p><p><img src="https://static.lovebilibili.com/xxljob_21.png" srcset="/img/loading.gif" alt=""></p><p>从架构图可以看出，分别有调度中心和执行器两大组成部分</p><ul><li>调度中心。负责<strong>管理调度信息</strong>，按照调度配置发出调度请求，自身不承担业务代码。支持可视化界面，可以在调度中心对任务进行新增，更新，删除，会实时生效。支持监控调度结果，查看执行日志，查看调度任务统计报表，任务失败告警等等。</li><li>执行器。负责接收调度请求，执行调度任务的业务逻辑。执行器启动后需要注册到调度中心。接收调度中心的发出的执行请求，终止请求，日志请求等等。</li></ul><p>接下来我们看一下xxl-job的工作原理。</p><p><img src="https://static.lovebilibili.com/xxljob_22.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>任务执行器根据配置的调度中心的地址，自动注册到调度中心。</p></li><li><p>达到任务触发条件，调度中心下发任务。</p></li><li><p>执行器基于线程池执行任务，并把执行结果放入内存队列中、把执行日志写入日志文件中。</p></li><li><p>执行器的回调线程消费内存队列中的执行结果，主动上报给调度中心。</p></li><li><p>当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情。</p></li></ul><h1 id="絮叨"><a href="#絮叨" class="headerlink" title="絮叨"></a>絮叨</h1><p>看完以上的内容，基本算入门了。实际上，xxl-job还有很多功能，要深入学习，还需要到<a href="https://www.xuxueli.com/" target="_blank" rel="noopener">官网</a>去研究探索。最好就是自己在本地搭建一个xxl-job来玩玩，动手实践是学得最快的学习方式。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>分布式</tag>
      
      <tag>任务调度平台</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务之注册中心</title>
    <link href="/2020/09/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <url>/2020/09/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/zczx_swdt.png" srcset="/img/loading.gif" alt=""></p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>伴随着Eurka2.0版本已停止维护，开始要考虑使用微服务新一代的开源的注册中心替代Eureka。</p><p><img src="https://static.lovebilibili.com/zczx_27.png" srcset="/img/loading.gif" alt=""></p><p>目前据我了解，Consul和Nacos是比较流行的两种替代方案。这篇文章就介绍一下这两种注册中心在微服务中的简单使用，希望对读者有所帮助。</p><a id="more"></a><h1 id="二、注册中心的作用"><a href="#二、注册中心的作用" class="headerlink" title="二、注册中心的作用"></a>二、注册中心的作用</h1><p>注册中心在微服务的架构中相当于一个“服务的通讯录”。当一个服务启动时，需要向注册中心注册服务，注册中心保存了所有服务的服务名称和服务地址的映射关系。当服务A想调用服务D时，则从注册中心获取服务D的服务地址，然后调用。</p><p>我画张图给大家描述会更清楚一点，大概如下：</p><p><img src="https://static.lovebilibili.com/zczx_1.png" srcset="/img/loading.gif" alt=""></p><p>可能会有人问，为什么不直接通过服务地址调用服务D呢，还要从注册中心去获取服务D的服务地址。因为一个服务背后是不止一台机器的，比如服务D可能在实际生产中是由三台机器支持的，对外只暴露一个服务名称，这样可以避免写死服务的IP地址在代码中(写在配置文件里)，在服务扩展时就非常方便了。</p><p>除了<strong>服务注册</strong>之外，注册中心还提供<strong>服务订阅</strong>，当有新的服务注册时，注册中心会实时推送到各个服务。</p><p>还有<strong>服务健康监测</strong>，可以在管理界面看到注册中心中的服务的状态。</p><h1 id="三、Consul"><a href="#三、Consul" class="headerlink" title="三、Consul"></a>三、Consul</h1><p>由Go语言开发，支持多数据中心分布式高可用的服务发布和服务注册，采用ralt算法保证服务的一致性，且支持健康检查。</p><h2 id="3-1-安装-win10版"><a href="#3-1-安装-win10版" class="headerlink" title="3.1 安装(win10版)"></a>3.1 安装(win10版)</h2><p>第一步，上官网下载安装包。</p><p><img src="https://static.lovebilibili.com/zczx_2.png" srcset="/img/loading.gif" alt=""></p><p>第二步，解压zip包，并配置环境变量。</p><p><img src="https://static.lovebilibili.com/zczx_3.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/zczx_4.png" srcset="/img/loading.gif" alt=""></p><p>第三步，唱跳rap篮球键ctrl+R，cmd，输入命令<code>consul</code>：</p><p><img src="https://static.lovebilibili.com/zczx_5.png" srcset="/img/loading.gif" alt=""></p><p>这就安装成功了，超简单！输入consul -version验证一下，会显示版本号：</p><p><img src="https://static.lovebilibili.com/zczx_7.png" srcset="/img/loading.gif" alt=""></p><p>第四步，启动。输入命令<code>consul.exe agent -dev</code>本地启动：</p><p><img src="https://static.lovebilibili.com/zczx_8.png" srcset="/img/loading.gif" alt=""></p><p>第五步，在浏览器中输入<code>http://localhost:8500</code>打开管理界面。</p><p><img src="https://static.lovebilibili.com/zczx_9.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-2-服务注册"><a href="#3-2-服务注册" class="headerlink" title="3.2 服务注册"></a>3.2 服务注册</h2><p>接下来就需要创建两个服务，分别是订单(order)和用户(user)，注册到consul。下面我就演示其中一个user服务。</p><p>首先创建一个SpringBoot工程，Maven配置如下：</p><pre><code class="xml">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;io.github.yehongzhi&lt;/groupId&gt;&lt;artifactId&gt;user&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;&lt;!-- 健康监测的包 --&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;&lt;!-- spring-cloud-consul服务治理的jar包 --&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Finchley.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre><p>然后yml配置文件如下：</p><pre><code class="yaml">server:  port: 8601spring:  application:    name: user  cloud:    consul:      port: 8500      host: 127.0.0.1      discovery:        service-name: user        instance-id: ${spring.application.name}:${spring.cloud.consul.host}:${server.port}        health-check-path: /actuator/health        health-check-interval: 10s        prefer-ip-address: true        heartbeat:          enabled: true</code></pre><p>在启动类加上开启服务注册的注解：</p><pre><code class="java">@SpringBootApplication@EnableDiscoveryClientpublic class UserApplication {    public static void main(String[] args) {        SpringApplication.run(UserApplication.class, args);    }}</code></pre><p>最后启动项目即可，我这里启动两个user，端口号分别是8601，8602：</p><p><img src="https://static.lovebilibili.com/zczx_10.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-3-服务调用"><a href="#3-3-服务调用" class="headerlink" title="3.3 服务调用"></a>3.3 服务调用</h2><p>再创建一个订单项目(order)，和user配置类似，注册服务到consul中。</p><p><img src="https://static.lovebilibili.com/zczx_11.png" srcset="/img/loading.gif" alt=""></p><p>下面演示一下用order服务调用user服务，首先定义user的接口：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/user&quot;)public class UserController {    @RequestMapping(&quot;/list&quot;)    public Map&lt;String, Object&gt; list() throws Exception {        Map&lt;String, Object&gt; userMap = new HashMap&lt;&gt;();        userMap.put(&quot;1号佳丽&quot;, &quot;李嘉欣&quot;);        userMap.put(&quot;2号佳丽&quot;, &quot;袁咏仪&quot;);        userMap.put(&quot;3号佳丽&quot;, &quot;张敏&quot;);        userMap.put(&quot;4号佳丽&quot;, &quot;张曼玉&quot;);        return userMap;    }}</code></pre><p>接着在order服务调用user服务，使用RestTemplate的方式：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/order&quot;)public class OrderController {    @Resource    private LoadBalancerClient loadBalancerClient;    @RequestMapping(&quot;/callUser&quot;)    public String list() throws Exception {        //从注册中心中获取user服务实例，包括服务的IP，端口号等信息        ServiceInstance instance = loadBalancerClient.choose(&quot;user&quot;);        //调用user服务        String userList = new RestTemplate().getForObject(instance.getUri().toString() + &quot;/mall/user/list&quot;, String.class);        return &quot;调用&quot; + instance.getServiceId() + &quot;服务，端口号：&quot; + instance.getPort() + &quot;,返回结果：&quot; + userList;    }}</code></pre><p>启动两个user服务，一个order服务，调用order的接口，可以看到结果：</p><p><img src="https://static.lovebilibili.com/zczx_12.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/zczx_13.png" srcset="/img/loading.gif" alt=""></p><p>负载均衡<strong>默认是轮询访问</strong>，所以交替调用8601和8602的user服务。</p><p>consul的简单入门就讲到这里了，除了<strong>服务治理</strong>之外，consul还可以用于做配置中心，读者有兴趣可以自己探索一下。<strong>我这里用的是dev模式，相当于单机模式，仅用于学习，实际生产的话肯定是集群模式</strong>，后面如果有时间我再专门写一篇演示一下consul集群的搭建。</p><p>下面讲另一款注册中心，阿里出品的Nacos。</p><h1 id="四、Nacos"><a href="#四、Nacos" class="headerlink" title="四、Nacos"></a>四、Nacos</h1><p>以下介绍来源于官网：</p><p>Nacos 致力于帮助您<strong>发现、配置和管理微服务</strong>。Nacos 提供了一组简单易用的特性集，帮助您快速实现<strong>动态服务发现、服务配置、服务元数据及流量管理</strong>。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><p>总结就是，Nacos提供三种功能：服务发现及管理、动态配置服务、动态DNS服务。</p><p>我这里主要讲服务发现，也就是作为<strong>注册中心</strong>的功能。</p><h2 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h2><p>首先<a href="https://github.com/alibaba/nacos/releases/tag/1.3.1" target="_blank" rel="noopener">下载</a>安装包，目前稳定版是1.3.1，推荐在Linux或者Mac系统上使用，我懒得开虚拟机，所以我就直接在win系统安装。</p><p><img src="https://static.lovebilibili.com/zczx_14.png" srcset="/img/loading.gif" alt=""></p><p>我这里仅用于学习，使用单机模式，官网上介绍，双击startup.cmd文件启动即可。</p><p><img src="https://static.lovebilibili.com/zczx_15.png" srcset="/img/loading.gif" alt=""></p><p>实际上，会报错。</p><p><img src="https://static.lovebilibili.com/zczx_17.png" srcset="/img/loading.gif" alt=""></p><p>这个错误，我发现github上有人提出来，再后面加个参数就可以了。</p><p><img src="https://static.lovebilibili.com/zczx_18.png" srcset="/img/loading.gif" alt=""></p><p>但是又有人说后面的版本已经优化了，没有这个错误。反正如果遇到的话，就加个参数启动吧。完整命令是<code>startup.cmd -m standalone</code>。</p><p>如果不想在启动命令后面加参数，可以配置mysql(版本要求：5.6.5+)，初始化mysql数据库，数据库初始化文件：nacos-mysql.sql。</p><p><img src="https://static.lovebilibili.com/zczx_26.png" srcset="/img/loading.gif" alt=""></p><p>修改conf/application.properties文件配置：</p><pre><code class="properties">db.num=1db.url.0=jdbc:mysql://数据库地址:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTCdb.user=账号db.password=密码</code></pre><p>启动成功，命令行窗口可以看到以下提示：</p><p><img src="https://static.lovebilibili.com/zczx_19.png" srcset="/img/loading.gif" alt=""></p><p>启动成功后，可以在浏览器打开<code>http://localhost:8848/nacos/</code>，进入管理界面。账号密码默认都是nacos。</p><p><img src="https://static.lovebilibili.com/zczx_20.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/zczx_21.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-服务注册"><a href="#4-2-服务注册" class="headerlink" title="4.2 服务注册"></a>4.2 服务注册</h2><p>接下来还是一样，创建两个服务注册到nacos，为了跟前面的区分，项目名后缀加上”nacos”。首先添加maven配置，如下：</p><pre><code class="java">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Finchley.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;            &lt;version&gt;0.2.2.RELEASE&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt;    &lt;dependency&gt;&lt;!-- SpringWeb依赖 --&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;&lt;!-- SpringCloud nacos服务发现的依赖 --&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>启动类加上注解@EnableDiscoveryClient。</p><pre><code class="java">@SpringBootApplication@EnableDiscoveryClientpublic class UsernacosApplication {    public static void main(String[] args) {        SpringApplication.run(UsernacosApplication.class, args);    }}</code></pre><p>配置文件application.properties文件加上配置。</p><pre><code class="properties">server.port=8070spring.application.name=usernacosspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848</code></pre><p>创建一个UserController接口，提供给其他微服务调用。</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/userNacos&quot;)public class UserController {    @RequestMapping(&quot;/list&quot;)    public Map&lt;String, Object&gt; list() {        Map&lt;String, Object&gt; userMap = new HashMap&lt;&gt;();        userMap.put(&quot;周杰伦&quot;, &quot;爱在西元前&quot;);        userMap.put(&quot;张学友&quot;, &quot;只想一生跟你走&quot;);        userMap.put(&quot;刘德华&quot;, &quot;忘情水&quot;);        userMap.put(&quot;陈奕迅&quot;, &quot;K歌之王&quot;);        userMap.put(&quot;卫兰&quot;, &quot;就算世界没有童话&quot;);        return userMap;    }}</code></pre><p>运行启动类的main方法，可以看到注册中心多了一个usernacos服务。</p><p><img src="https://static.lovebilibili.com/zczx_22.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-3-服务调用"><a href="#4-3-服务调用" class="headerlink" title="4.3 服务调用"></a>4.3 服务调用</h2><p>相同的配置和方法，再创建一个ordernacos服务，作为消费者。</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/orderNacos&quot;)public class OrderController {    @Resource    private LoadBalancerClient loadBalancerClient;    @RequestMapping(&quot;/callUser&quot;)    public String callUser() {        ServiceInstance instance = loadBalancerClient.choose(&quot;usernacos&quot;);        String url = instance.getUri().toString() + &quot;/mall/userNacos/list&quot;;        RestTemplate restTemplate = new RestTemplate();        //调用usernacos服务        String result = restTemplate.getForObject(url, String.class);        return &quot;调用&quot; + instance.getServiceId() + &quot;服务，端口号：&quot; + instance.getPort() + &quot;,返回结果：&quot; + result;    }}</code></pre><p>启动2个usernacos服务，1个ordernacos服务。</p><p><img src="https://static.lovebilibili.com/zczx_23.png" srcset="/img/loading.gif" alt=""></p><p>测试接口<code>http://localhost:8170/mall/orderNacos/callUser</code>，order能顺利调用user，默认负载均衡策略也是轮询机制。</p><p><img src="https://static.lovebilibili.com/zczx_24.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/zczx_25.png" srcset="/img/loading.gif" alt=""></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>国内用的比较多的是Nacos，我觉得原因有几点：</p><ul><li>因为阿里目前用的就是Nacos，经历过双十一，各种秒杀活动等高并发场景的验证。</li><li>文档比较齐全，关键有中文文档，对于国内很多英文水平不是很好的开发者看起来真的很爽。</li><li>很多从阿里出来的程序员，把阿里的技术带到了各个中小型互联网公司，一般技术选型肯定选自己熟悉的嘛。</li><li>管理界面有中(英)文版本，易于操作。</li><li>还有社区比较活跃，很多问题可以在网上找到解决方案。</li></ul><p>这篇文章主要介绍了SpringCloud微服务关于注册中心的两种流行的实现方案，接下来还会继续介绍其他关于微服务的组件，敬请期待。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>微服务</tag>
      
      <tag>注册中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官问我什么是JMM</title>
    <link href="/2020/09/20/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91%E4%BB%80%E4%B9%88%E6%98%AFJMM/"/>
    <url>/2020/09/20/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91%E4%BB%80%E4%B9%88%E6%98%AFJMM/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/JMM_9.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="面试官：讲讲什么是JMM"><a href="#面试官：讲讲什么是JMM" class="headerlink" title="面试官：讲讲什么是JMM"></a>面试官：讲讲什么是JMM</h1><p>你要是整这个我可就不困了。</p><p><img src="https://static.lovebilibili.com/nishuozhegejiubukunle.jpg" srcset="/img/loading.gif" alt=""></p><p>JMM就是Java内存模型(java memory model)。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以<strong>java内存模型(JMM)屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。</strong></p><p>Java内存模型规定<strong>所有的变量都存储在主内存</strong>中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，<strong>线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行</strong>。<strong>线程不能直接读写主内存中的变量</strong>。</p><p>不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。</p><p>如果听起来抽象的话，我可以画张图给你看看，会直观一点：</p><p><img src="https://static.lovebilibili.com/JMM_1.png" srcset="/img/loading.gif" alt=""></p><p>每个线程的工作内存都是独立的，线程操作数据只能在工作内存中进行，然后刷回到主存。这是 Java 内存模型定义的线程基本工作方式。</p><p>温馨提醒一下，这里有些人会把Java内存模型误解为<strong>Java内存结构</strong>，然后答到堆，栈，GC垃圾回收，最后和面试官想问的问题相差甚远。<strong>实际上一般问到Java内存模型都是想问多线程，Java并发相关的问题</strong>。</p><h1 id="面试官：那JMM定义了什么"><a href="#面试官：那JMM定义了什么" class="headerlink" title="面试官：那JMM定义了什么"></a>面试官：那JMM定义了什么</h1><p>这个简单，整个Java内存模型实际上是围绕着三个特征建立起来的。分别是：原子性，可见性，有序性。这三个特征可谓是整个Java并发的基础。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性指的是一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰。</p><p><strong>面试官拿笔写了段代码，下面这几句代码能保证原子性吗</strong>？</p><pre><code class="java">int i = 2;int j = i;i++;i = i + 1;</code></pre><p>第一句是基本类型赋值操作，必定是原子性操作。</p><p>第二句先读取i的值，再赋值到j，两步操作，不能保证原子性。</p><p>第三和第四句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</p><p>JMM只能保证基本的原子性，如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改了。Java是利用volatile关键字来提供可见性的。 当变量被volatile修饰时，这个变量被修改后会立刻刷新到主内存，当其它线程需要读取该变量时，会去主内存中读取新值。而普通变量则不能保证这一点。</p><p>除了volatile关键字之外，final和synchronized也能实现可见性。</p><p>synchronized的原理是，在执行完，进入unlock之前，必须将共享变量同步到主内存中。</p><p>final修饰的字段，一旦初始化完成，如果没有对象逸出（指对象为初始化完成就可以被别的线程使用），那么对于其他线程都是可见的。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>在Java中，可以使用synchronized或者volatile保证多线程之间操作的有序性。实现原理有些区别：</p><p>volatile关键字是使用内存屏障达到禁止指令重排序，以保证有序性。</p><p>synchronized的原理是，一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized包住的代码块在多线程之间是串行执行的。</p><h1 id="面试官：给我讲一下八种内存交互操作吧"><a href="#面试官：给我讲一下八种内存交互操作吧" class="headerlink" title="面试官：给我讲一下八种内存交互操作吧"></a>面试官：给我讲一下八种内存交互操作吧</h1><p>好的，面试官，内存交互操作有8种，我画张图给你看吧：</p><p><img src="https://static.lovebilibili.com/JMM_2.png" srcset="/img/loading.gif" alt=""></p><ul><li>lock(锁定)，作用于<strong>主内存</strong>中的变量，把变量标识为线程独占的状态。</li><li>read(读取)，作用于<strong>主内存</strong>的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li><li>load(加载)，作用于<strong>工作内存</strong>的变量，把read操作主存的变量放入到工作内存的变量副本中。</li><li>use(使用)，作用于<strong>工作内存</strong>的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)，作用于<strong>工作内存</strong>的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li><li>store(存储)，作用于<strong>工作内存</strong>的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li><li>write(写入)：作用于<strong>主内存</strong>中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ul><p>我再补充一下JMM对8种内存交互操作制定的规则吧：</p><ul><li>不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。</li><li>不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。</li><li>不允许线程将没有assign的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。</li><li>一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。</li></ul><h1 id="面试官：讲一下volatile关键字吧"><a href="#面试官：讲一下volatile关键字吧" class="headerlink" title="面试官：讲一下volatile关键字吧"></a>面试官：讲一下volatile关键字吧</h1><p>内心：这可以重头戏呀，可不能出岔子~</p><p>很多并发编程都使用了volatile关键字，主要的作用包括两点：</p><ol><li><strong>保证线程间变量的可见性。</strong></li><li><strong>禁止CPU进行指令重排序。</strong></li></ol><h2 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h2><p>volatile修饰的变量，当一个线程改变了该变量的值，其他线程是立即可见的。普通变量则需要重新读取才能获得最新值。</p><p>volatile保证可见性的流程大概就是这个一个过程：</p><p><img src="https://static.lovebilibili.com/JMM_3.png" srcset="/img/loading.gif" alt=""></p><h2 id="volatile一定能保证线程安全吗"><a href="#volatile一定能保证线程安全吗" class="headerlink" title="volatile一定能保证线程安全吗"></a>volatile一定能保证线程安全吗</h2><p>先说结论吧，volatile不能一定能保证线程安全。</p><p>怎么证明呢，我们看下面一段代码的运行结果就知道了：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 **/public class VolatileTest extends Thread {    private static volatile int count = 0;    public static void main(String[] args) throws Exception {        Vector&lt;Thread&gt; threads = new Vector&lt;&gt;();        for (int i = 0; i &lt; 100; i++) {            VolatileTest thread = new VolatileTest();            threads.add(thread);            thread.start();        }        //等待子线程全部完成        for (Thread thread : threads) {            thread.join();        }        //输出结果，正确结果应该是1000，实际却是984        System.out.println(count);//984    }    @Override    public void run() {        for (int i = 0; i &lt; 10; i++) {            try {                //休眠500毫秒                Thread.sleep(500);            } catch (Exception e) {                e.printStackTrace();            }            count++;        }    }}</code></pre><p>为什么volatile不能保证线程安全？</p><p>很简单呀，可见性不能保证操作的原子性，前面说过了count++不是原子性操作，会当做三步，先读取count的值，然后+1，最后赋值回去count变量。需要保证线程安全的话，需要使用synchronized关键字或者lock锁，给count++这段代码上锁：</p><pre><code class="java">private static synchronized void add() {    count++;}</code></pre><h2 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h2><p>首先要讲一下as-if-serial语义，不管怎么重排序，（单线程）程序的执行结果不能被改变。</p><p>为了使指令更加符合CPU的执行特性，最大限度的发挥机器的性能，提高程序的执行效率，只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做<strong>指令的重排序</strong>。</p><p>重排序的种类分为三种，分别是：编译器重排序，指令级并行的重排序，内存系统重排序。整个过程如下所示：</p><p><img src="https://static.lovebilibili.com/JMM_5.png" srcset="/img/loading.gif" alt=""></p><p>指令重排序在单线程是没有问题的，不会影响执行结果，而且还提高了性能。但是在多线程的环境下就不能保证一定不会影响执行结果了。</p><p><strong>所以在多线程环境下，就需要禁止指令重排序</strong>。</p><p>volatile关键字禁止指令重排序有两层意思：</p><ul><li><p>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行。</p></li><li><p>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p></li></ul><p>下面举个例子：</p><pre><code class="java">private static int a;//非volatile修饰变量private static int b;//非volatile修饰变量private static volatile int k;//volatile修饰变量private void hello() {    a = 1;  //语句1    b = 2;  //语句2    k = 3;  //语句3    a = 4;  //语句4    b = 5;  //语句5    //以下省略...}</code></pre><p>变量a，b是非volatile修饰的变量，k则使用volatile修饰。所以语句3不能放在语句1、2前，也不能放在语句4、5后。但是语句1、2的顺序是不能保证的，同理，语句4、5也不能保证顺序。</p><p>并且，执行到语句3的时候，语句1，2是肯定执行完毕的，而且语句1,2的执行结果对于语句3,4,5是可见的。</p><h2 id="volatile禁止指令重排序的原理是什么"><a href="#volatile禁止指令重排序的原理是什么" class="headerlink" title="volatile禁止指令重排序的原理是什么"></a>volatile禁止指令重排序的原理是什么</h2><p>首先要讲一下内存屏障，内存屏障可以分为以下几类：</p><ul><li><p>LoadLoad  屏障：对于这样的语句Load1，LoadLoad，Load2。在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p></li><li><p>StoreStore屏障：对于这样的语句Store1， StoreStore， Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p></li><li><p>LoadStore 屏障：对于这样的语句Load1， LoadStore，Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p></li><li><p>StoreLoad 屏障：对于这样的语句Store1， StoreLoad，Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</p></li></ul><p>在每个volatile读操作后插入LoadLoad屏障，在读操作后插入LoadStore屏障。</p><p><img src="https://static.lovebilibili.com/JMM_6.png" srcset="/img/loading.gif" alt=""></p><p>在每个volatile写操作的前面插入一个StoreStore屏障，后面插入一个SotreLoad屏障。</p><p><img src="https://static.lovebilibili.com/JMM_8.png" srcset="/img/loading.gif" alt=""></p><p>大概的原理就是这样。</p><p>面试官：讲得还不错，基本上都讲到了，时间也不早了，今天的面试就到这吧，回去等通知吧~</p><p>啊？就这？</p><img src="https://static.lovebilibili.com/jiuzhe.jpg" srcset="/img/loading.gif" style="zoom:25%;" /><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要学习并发编程，java内存模型是第一站了。原子性，有序性，可见性这三大特征几乎贯穿了并发编程，可谓是基础知识。对于后面要深入学习起到铺垫作用。</p><p>在这篇文章中，如果面试的话，重点是Java内存模型(JMM)的工作方式，三大特征，还有volatile关键字。为什么喜欢问volatile关键字呢，因为<strong>volatile关键字可以扯出很多东西，比如可见性，有序性，还有内存屏障等等</strong>。可以一针见血地看出面试者的技术水平，毕竟面试官也想高效地筛选出符合要求的人才嘛。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八种经典排序算法总结</title>
    <link href="/2020/09/11/%E5%85%AB%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/11/%E5%85%AB%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/sort_swdt.png" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算法和数据结构是一个程序员的内功，所以经常在一些笔试中都会要求手写一些简单的排序算法，以此考验面试者的编程水平。下面我就简单介绍八种常见的排序算法，一起学习一下。</p><a id="more"></a><h1 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h1><p>思路：</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素就是最大的数；</li><li>排除最大的数，接着下一轮继续相同的操作，确定第二大的数…</li><li>重复步骤1-3，直到排序完成。</li></ul><p>动画演示：</p><p><img src="https://static.lovebilibili.com/BubbleSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name BubbleSort * @date 2020-09-05 21:38 **/public class BubbleSort extends BaseSort {    public static void main(String[] args) {        BubbleSort sort = new BubbleSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        for (int i = 0; i &lt; nums.length - 1; i++) {            for (int j = 0; j &lt; nums.length - i - 1; j++) {                if (nums[j] &gt; nums[j + 1]) {                    int temp = nums[j];                    nums[j] = nums[j + 1];                    nums[j + 1] = temp;                }            }        }    }}//10万个数的数组，耗时：21554毫秒</code></pre><p>平均时间复杂度：<strong>O(n²)</strong></p><p>空间复杂度：<strong>O(1)</strong></p><p>算法稳定性：稳定</p><h1 id="二、插入排序"><a href="#二、插入排序" class="headerlink" title="二、插入排序"></a>二、插入排序</h1><p>思路：</p><ol><li><p>从第一个元素开始，该元素可以认为已经被排序；</p></li><li><p>取出下一个元素，在前面已排序的元素序列中，从后向前扫描；</p></li><li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置；</p></li><li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p></li><li><p>将新元素插入到该位置后；</p></li><li><p>重复步骤2~5。</p></li></ol><p>动画演示：</p><p><img src="https://static.lovebilibili.com/InsertionSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name InsertSort * @date 2020-09-05 22:34 **/public class InsertSort extends BaseSort {    public static void main(String[] args) {        BaseSort sort = new InsertSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        for (int i = 0; i &lt; nums.length - 1; i++) {            //当前值            int curr = nums[i + 1];            //上一个数的指针            int preIndex = i;            //在数组中找到一个比当前遍历的数小的第一个数            while (preIndex &gt;= 0 &amp;&amp; curr &lt; nums[preIndex]) {                //把比当前遍历的数大的数字往后移动                nums[preIndex + 1] = nums[preIndex];                //需要插入的数的下标往前移动                preIndex--;            }            //插入到这个数的后面            nums[preIndex + 1] = curr;        }    }}//10万个数的数组，耗时：2051毫秒</code></pre><p>平均时间复杂度：<strong>O(n²)</strong></p><p>空间复杂度：<strong>O(1)</strong></p><p>算法稳定性：稳定</p><h1 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h1><p>思路：</p><p>第一轮，找到最小的元素，和数组第一个数交换位置。</p><p>第二轮，找到第二小的元素，和数组第二个数交换位置…</p><p>直到最后一个元素，排序完成。</p><p>动画演示：</p><p><img src="https://static.lovebilibili.com/SelectionSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name SelectSort * @date 2020-09-06 22:27 **/public class SelectSort extends BaseSort {    public static void main(String[] args) {        SelectSort sort = new SelectSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        for (int i = 0; i &lt; nums.length; i++) {            int minIndex = i;            for (int j = i + 1; j &lt; nums.length; j++) {                if (nums[j] &lt; nums[minIndex]) {                    minIndex = j;                }            }            if (minIndex != i) {                int temp = nums[i];                nums[minIndex] = temp;                nums[i] = nums[minIndex];            }        }    }}//10万个数的数组，耗时：8492毫秒</code></pre><p>算法复杂度：<strong>O(n²)</strong><br>算法空间复杂度：<strong>O(1)</strong><br>算法稳定性：不稳定</p><h1 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h1><p>思路：</p><p>把数组分割成若干(h)个小组(一般数组长度length/2)，然后对每一个小组分别进行插入排序。每一轮分割的数组的个数逐步缩小，h/2-&gt;h/4-&gt;h/8，并且进行排序，保证有序。当h=1时，则数组排序完成。</p><p>动画演示：</p><p><img src="https://static.lovebilibili.com/ShellSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name SelectSort * @date 2020-09-06 22:27 **/public class ShellSort extends BaseSort {    public static void main(String[] args) {        ShellSort sort = new ShellSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        int length = nums.length;        int temp;        //步长        int gap = length / 2;        while (gap &gt; 0) {            for (int i = gap; i &lt; length; i++) {                temp = nums[i];                int preIndex = i - gap;                while (preIndex &gt;= 0 &amp;&amp; nums[preIndex] &gt; temp) {                    nums[preIndex + gap] = nums[preIndex];                    preIndex -= gap;                }                nums[preIndex + gap] = temp;            }            gap /= 2;        }    }}//10万个数的数组，耗时：261毫秒</code></pre><p>算法复杂度：<strong>O(nlog2n)</strong><br>算法空间复杂度：<strong>O(1)</strong><br>算法稳定性：稳定</p><h1 id="五、快速排序"><a href="#五、快速排序" class="headerlink" title="五、快速排序"></a>五、快速排序</h1><p>快排，面试最喜欢问的排序算法。这是运用分治法的一种排序算法。</p><p>思路：</p><ol><li>从数组中选一个数做为基准值，一般选第一个数，或者最后一个数。</li><li>采用双指针(头尾两端)遍历，从左往右找到比基准值大的第一个数，从右往左找到比基准值小的第一个数，交换两数位置，直到头尾指针相等或头指针大于尾指针，把基准值与头指针的数交换。这样一轮之后，左边的数就比基准值小，右边的数就比基准值大。</li><li>对左边的数列，重复上面1，2步骤。对右边重复1，2步骤。</li><li>左右两边数列递归结束后，排序完成。</li></ol><p>动画演示：</p><p><img src="https://static.lovebilibili.com/QuickSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name SelectSort * @date 2020-09-06 22:27 **/public class QuickSort extends BaseSort {    public static void main(String[] args) {        QuickSort sort = new QuickSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        quickSort(nums, 0, nums.length - 1);    }    private void quickSort(int[] nums, int star, int end) {        if (star &gt; end) {            return;        }        int i = star;        int j = end;        int key = nums[star];        while (i &lt; j) {            while (i &lt; j &amp;&amp; nums[j] &gt; key) {                j--;            }            while (i &lt; j &amp;&amp; nums[i] &lt;= key) {                i++;            }            if (i &lt; j) {                int temp = nums[i];                nums[i] = nums[j];                nums[j] = temp;            }        }        nums[star] = nums[i];        nums[i] = key;        quickSort(nums, star, i - 1);        quickSort(nums, i + 1, end);    }}//10万个数的数组，耗时：50毫秒</code></pre><p>算法复杂度：<strong>O(nlogn)</strong><br>算法空间复杂度：<strong>O(1)</strong><br>算法稳定性：不稳定</p><h1 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h1><p>归并排序是采用分治法的典型应用，而且是一种稳定的排序方式，不过需要使用到额外的空间。</p><p>思路：</p><ol><li>把数组不断划分成子序列，划成长度只有2或者1的子序列。</li><li>然后利用临时数组，对子序列进行排序，合并，再把临时数组的值复制回原数组。</li><li>反复操作1~2步骤，直到排序完成。</li></ol><p>归并排序的优点在于最好情况和最坏的情况的时间复杂度都是O(nlogn)，所以是比较稳定的排序方式。</p><p>动画演示：</p><p><img src="https://static.lovebilibili.com/MergeSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name MergeSort * @date 2020-09-08 23:30 **/public class MergeSort extends BaseSort {    public static void main(String[] args) {        MergeSort sort = new MergeSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        //归并排序        mergeSort(0, nums.length - 1, nums, new int[nums.length]);    }    private void mergeSort(int star, int end, int[] nums, int[] temp) {        //递归终止条件        if (star &gt;= end) {            return;        }        int mid = star + (end - star) / 2;        //左边进行归并排序        mergeSort(star, mid, nums, temp);        //右边进行归并排序        mergeSort(mid + 1, end, nums, temp);        //合并左右        merge(star, end, mid, nums, temp);    }    private void merge(int star, int end, int mid, int[] nums, int[] temp) {        int index = 0;        int i = star;        int j = mid + 1;        while (i &lt;= mid &amp;&amp; j &lt;= end) {            if (nums[i] &gt; nums[j]) {                temp[index++] = nums[j++];            } else {                temp[index++] = nums[i++];            }        }        while (i &lt;= mid) {            temp[index++] = nums[i++];        }        while (j &lt;= end) {            temp[index++] = nums[j++];        }        //把临时数组中已排序的数复制到nums数组中        if (index &gt;= 0) System.arraycopy(temp, 0, nums, star, index);    }}//10万个数的数组，耗时：26毫秒</code></pre><p>算法复杂度：<strong>O(nlogn)</strong><br>算法空间复杂度：<strong>O(n)</strong><br>算法稳定性：稳定</p><h1 id="七、堆排序"><a href="#七、堆排序" class="headerlink" title="七、堆排序"></a>七、堆排序</h1><p>大顶堆概念：每个节点的值都大于或者等于它的左右子节点的值，所以顶点的数就是最大值。</p><p><img src="https://static.lovebilibili.com/heap_big.png" srcset="/img/loading.gif" alt=""></p><p>思路：</p><ol><li>对原数组构建成大顶堆。</li><li>交换头尾值，尾指针索引减一，固定最大值。</li><li>重新构建大顶堆。</li><li>重复步骤2~3，直到最后一个元素，排序完成。</li></ol><p>构建大顶堆的思路，可以看代码注释。</p><p>动画演示：</p><p><img src="https://static.lovebilibili.com/HeapSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name HeapSort * @date 2020-09-08 23:34 **/public class HeapSort extends BaseSort {    public static void main(String[] args) {        HeapSort sort = new HeapSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        heapSort(nums);    }    private void heapSort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        //构建大根堆        createTopHeap(nums);        int size = nums.length;        while (size &gt; 1) {            //大根堆的交换头尾值，固定最大值在末尾            swap(nums, 0, size - 1);            //末尾的索引值往左减1            size--;            //重新构建大根堆            updateHeap(nums, size);        }    }    private void createTopHeap(int[] nums) {        for (int i = 0; i &lt; nums.length; i++) {            //当前插入的索引            int currIndex = i;            //父节点的索引            int parentIndex = (currIndex - 1) / 2;            //如果当前遍历的值比父节点大的话，就交换值。然后继续往上层比较            while (nums[currIndex] &gt; nums[parentIndex]) {                //交换当前遍历的值与父节点的值                swap(nums, currIndex, parentIndex);                //把父节点的索引指向当前遍历的索引                currIndex = parentIndex;                //往上计算父节点索引                parentIndex = (currIndex - 1) / 2;            }        }    }    private void updateHeap(int[] nums, int size) {        int index = 0;        //左节点索引        int left = 2 * index + 1;        //右节点索引        int right = 2 * index + 2;        while (left &lt; size) {            //最大值的索引            int largestIndex;            //如果右节点大于左节点，则最大值索引指向右子节点索引            if (right &lt; size &amp;&amp; nums[left] &lt; nums[right]) {                largestIndex = right;            } else {                largestIndex = left;            }            //如果父节点大于最大值，则把父节点索引指向最大值索引            if (nums[index] &gt; nums[largestIndex]) {                largestIndex = index;            }            //如果父节点索引指向最大值索引，证明已经是大根堆，退出循环            if (largestIndex == index) {                break;            }            //如果不是大根堆，则交换父节点的值            swap(nums, largestIndex, index);            //把最大值的索引变成父节点索引            index = largestIndex;            //重新计算左节点索引            left = 2 * index + 1;            //重新计算右节点索引            right = 2 * index + 2;        }    }    private void swap(int[] nums, int i, int j) {        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    }}//10万个数的数组，耗时：38毫秒</code></pre><p>算法复杂度：<strong>O(nlogn)</strong><br>算法空间复杂度：<strong>O(1)</strong><br>算法稳定性：不稳定</p><h1 id="八、桶排序"><a href="#八、桶排序" class="headerlink" title="八、桶排序"></a>八、桶排序</h1><p>思路：</p><ol><li>找出最大值，最小值。</li><li>根据数组的长度，创建出若干个桶。</li><li>遍历数组的元素，根据元素的值放入到对应的桶中。</li><li>对每个桶的元素进行排序(可使用快排，插入排序等)。</li><li>按顺序合并每个桶的元素，排序完成。</li></ol><p>对于数组中的元素分布均匀的情况，排序效率较高。相反的，如果分布不均匀，则会导致大部分的数落入到同一个桶中，使效率降低。</p><p>动画演示(来源于五分钟学算法，侵删)：</p><p><img src="https://static.lovebilibili.com/BucketSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name BucketSort * @date 2020-09-08 23:37 **/public class BucketSort extends BaseSort {    public static void main(String[] args) {        BucketSort sort = new BucketSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        bucketSort(nums);    }    public void bucketSort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        //找出最大值，最小值        int max = Integer.MIN_VALUE;        int min = Integer.MAX_VALUE;        for (int num : nums) {            min = Math.min(min, num);            max = Math.max(max, num);        }        int length = nums.length;        //桶的数量        int bucketCount = (max - min) / length + 1;        int[][] bucketArrays = new int[bucketCount][];        //遍历数组，放入桶内        for (int i = 0; i &lt; length; i++) {            //找到桶的下标            int index = (nums[i] - min) / length;            //添加到指定下标的桶里，并且使用插入排序排序            bucketArrays[index] = insertSortArrays(bucketArrays[index], nums[i]);        }        int k = 0;        //合并全部桶的        for (int[] bucketArray : bucketArrays) {            if (bucketArray == null || bucketArray.length == 0) {                continue;            }            for (int i : bucketArray) {                //把值放回到nums数组中                nums[k++] = i;            }        }    }    //每个桶使用插入排序进行排序    private int[] insertSortArrays(int[] arr, int num) {        if (arr == null || arr.length == 0) {            return new int[]{num};        }        //创建一个temp数组，长度是arr数组的长度+1        int[] temp = new int[arr.length + 1];        //把传进来的arr数组，复制到temp数组        for (int i = 0; i &lt; arr.length; i++) {            temp[i] = arr[i];        }        //找到一个位置，插入，形成新的有序的数组        int i;        for (i = temp.length - 2; i &gt;= 0 &amp;&amp; temp[i] &gt; num; i--) {            temp[i + 1] = temp[i];        }        //插入需要添加的值        temp[i + 1] = num;        //返回        return temp;    }}//10万个数的数组，耗时：8750毫秒</code></pre><p>算法复杂度：<strong>O(M+N)</strong></p><p>算法空间复杂度：<strong>O(M+N)</strong></p><p>算法稳定性：稳定(取决于桶内的排序算法，这里使用的是插入排序所以是稳定的)。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://static.lovebilibili.com/sort_zongjie.png" srcset="/img/loading.gif" alt=""></p><p>动画演示来源于算法学习网站：<a href="https://visualgo.net" target="_blank" rel="noopener">https://visualgo.net</a></p><p>讲完这些排序算法后，可能有人会问学这些排序算法有什么用呢，难道就为了应付笔试面试？平时开发也没用得上这些。</p><p>我觉得我们应该换个角度来看，比如高中时我们学物理，化学，数学，那么多公式定理，现在也没怎么用得上，但是高中课本为什么要教这些呢？</p><p>我的理解是：第一，普及一些常识性的问题。第二，锻炼思维，提高解决问题的能力。第三，为了区分人才。</p><p>回到学排序算法有什么用的问题上，实际上也一样。这些最基本的排序算法就是一些常识性的问题，作为开发者应该了解掌握。同时也锻炼了编程思维，其中包含有双指针，分治，递归等等的思想。最后在面试中体现出来的就是人才的划分，懂得这些基本的排序算法当然要比不懂的人要更有竞争力。</p><p>建议大家看完之后，能找时间动手写一下，加深理解。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从JVM讲到类加载机制，很简单的</title>
    <link href="/2020/09/04/%E4%BB%8EJVM%E8%AE%B2%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%BE%88%E7%AE%80%E5%8D%95%E7%9A%84/"/>
    <url>/2020/09/04/%E4%BB%8EJVM%E8%AE%B2%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%BE%88%E7%AE%80%E5%8D%95%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/jvm_siweidaotu.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录到Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="一、JVM介绍"><a href="#一、JVM介绍" class="headerlink" title="一、JVM介绍"></a>一、JVM介绍</h1><p>在介绍JVM之前，先看一下.java文件从编码到执行的过程：</p><p><img src="https://static.lovebilibili.com/jvm_02.png" srcset="/img/loading.gif" alt=""></p><p>整个过程是，x.java文件需要编译成x.class文件，通过类加载器加载到内存中，然后通过解释器或者即时编译器进行解释和编译，最后交给执行引擎执行，执行引擎操作OS硬件。</p><p>从<strong>类加载器到执行引擎这块内容就是JVM</strong>。</p><a id="more"></a><p><strong>JVM是一个跨语言的平台</strong>。从上面的图中可以看到，实际上JVM上运行的不是.java文件，而是.class文件。这就引出一个观点，JVM是一个跨语言的平台，他不仅仅能跑java程序，只要这种编程语言能编译成JVM可识别的.class文件都可以在上面运行。</p><p>所以除了java以外，能在JVM上运行的语言有很多，比如JRuby、Groovy、Scala、Kotlin等等。</p><p>从本质上讲JVM就是一台通过软件虚拟的计算机，它有它自身的指令集，有它自身的操作系统。</p><p>所以Oracle给JVM定了一套JVM规范，Oracle公司也给出了他的实现。基本上是目前最多人使用的java虚拟机实现，叫做Hotspot。使用java -version可以查看：</p><p><img src="https://static.lovebilibili.com/jvm_03.png" srcset="/img/loading.gif" alt=""></p><p>一些体量较大，有一定规模的公司，也会开发自己的JVM虚拟机，比如淘宝的TaobaoVM、IBM公司的J9-IBM、微软的MicrosoftVM等等。</p><h1 id="二、JDK、JRE、JVM"><a href="#二、JDK、JRE、JVM" class="headerlink" title="二、JDK、JRE、JVM"></a>二、JDK、JRE、JVM</h1><p><img src="https://static.lovebilibili.com/jvm_04.png" srcset="/img/loading.gif" alt=""></p><p>JVM应该很清楚了，是运行.class文件的虚拟机。JRE则是运行时环境，包括JVM和java核心类库，没有核心的类库是跑不起来的。</p><p><img src="https://static.lovebilibili.com/jvm_05.png" srcset="/img/loading.gif" alt=""></p><p>JDK则包括JRE和一些开发使用的工具集。</p><p>所以总的关系是<strong>JDK &gt; JRE &gt; JVM</strong>。</p><h1 id="三、Class加载过程"><a href="#三、Class加载过程" class="headerlink" title="三、Class加载过程"></a>三、Class加载过程</h1><p>类加载是JVM工作的一个很重要的过程，我们知道.class是存在在硬盘上的一个文件，如何加载到内存工作的呢，面试中也经常问这个问题。所以你要和其他程序员拉开差距，体现差异化，这个问题要搞懂。</p><p>类加载的过程实际上分为三大步：<strong>Loading(加载)、Linking(连接)、Initlalizing(初始化)</strong>。</p><p>其中第二步Linking又分为三小步：<strong>Verification(验证)、Preparation(准备)、Resolution(解析)</strong>。</p><p><img src="https://static.lovebilibili.com/jvm_06.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-1-Loading"><a href="#3-1-Loading" class="headerlink" title="3.1 Loading"></a>3.1 Loading</h2><p>Loading是<strong>把.class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据，在堆中生成一个java.lang.Class类对象代表这个类，作为方法区这些类型数据的访问入口</strong>。</p><h2 id="3-2-Linking"><a href="#3-2-Linking" class="headerlink" title="3.2 Linking"></a>3.2 Linking</h2><p>Linking简单来说，就是把原始的类定义的信息合并到JVM运行状态之中。分为三小步进行。</p><h3 id="3-2-1-Verification"><a href="#3-2-1-Verification" class="headerlink" title="3.2.1 Verification"></a>3.2.1 Verification</h3><p>验证加载的类信息是否符合class文件的标准，防止恶意信息或者不符合规范的字节信息。是JVM虚拟机运行安全的重要保障。</p><h3 id="3-2-2-Preparation"><a href="#3-2-2-Preparation" class="headerlink" title="3.2.2 Preparation"></a>3.2.2 Preparation</h3><p>创建类或者接口中的<strong>静态变量</strong>，并初始化<strong>静态变量赋默认值</strong>。赋默认值不是赋初始值，比如static int i = 5，这一步只是把i赋值为0，而不是赋值为5。赋值为5是在后面的步骤。</p><h3 id="3-2-3-Resolution"><a href="#3-2-3-Resolution" class="headerlink" title="3.2.3 Resolution"></a>3.2.3 Resolution</h3><p>把class文件常量池里面用到的符号引用转换成直接内存地址，直接可以访问到的内容。</p><h2 id="3-3-Initlalizing"><a href="#3-3-Initlalizing" class="headerlink" title="3.3 Initlalizing"></a>3.3 Initlalizing</h2><p>这一步真正去执行类初始化clinit()(类构造器)的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态代码块内(static{})的逻辑。当初始化一个类时，发现父类还没有进行过初始化，则先初始化父类。虚拟机会保证一个类的clinit()方法在多线程环境中被正确加锁和同步。</p><h1 id="四、类加载器"><a href="#四、类加载器" class="headerlink" title="四、类加载器"></a>四、类加载器</h1><p>上面就是类加载的整个过程。而最后一步Initlalizing是通过类加载器加载类。类加载器这里我单独讲一下，因为这是一个重点。</p><p>Java中的类加载器由上到下分为：</p><ul><li>Bootstrap ClassLoader（启动类加载器）</li><li>ExtClassLoader（扩展类加载器）</li><li>AppClassLoader（应用程序类加载器）</li></ul><p>从类图，可以看到<strong>ExtClassLoader和AppClassLoader都是ClassLoader的子类</strong>。</p><p><img src="https://static.lovebilibili.com/jvm_07.png" srcset="/img/loading.gif" alt=""></p><p>所以如果要自定义一个类加载器，可以继承ClassLoader抽象类，重写里面的方法。重写什么方法后面再讲。</p><h1 id="五、双亲委派机制"><a href="#五、双亲委派机制" class="headerlink" title="五、双亲委派机制"></a>五、双亲委派机制</h1><p>讲完类加载器，这些类加载器是怎么工作的呢。对于双亲委派机制可能多多少少有听过，没听过也没关系，我正要讲。</p><p>上面说过有Bootstrap，ExtClassLoader，AppClassLoader三个类加载器。工作机制如下：</p><p><img src="https://static.lovebilibili.com/jvm_08.png" srcset="/img/loading.gif" alt=""></p><p>加载类的逻辑是怎么样的呢，核心代码是可以在JDK源码中找到的，在抽象类ClassLoader类的loadClass()，有兴趣可以源码看看：</p><pre><code class="java">protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {    synchronized (getClassLoadingLock(name)) {        // First, check if the class has already been loaded        Class&lt;?&gt; c = findLoadedClass(name);        if (c == null) {            long t0 = System.nanoTime();            try {                if (parent != null) {                    //如果上层有类加载器，递归向上，往上层的类加载器寻找                    c = parent.loadClass(name, false);                } else {                    c = findBootstrapClassOrNull(name);                }            } catch (ClassNotFoundException e) {                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader            }            //如果上层的都找不到相应的class            if (c == null) {                // If still not found, then invoke findClass in order                // to find the class.                long t1 = System.nanoTime();                //自己去加载                c = findClass(name);                // this is the defining class loader; record the stats                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            }        }        if (resolve) {            resolveClass(c);        }        return c;    }}</code></pre><p>其实整个逻辑已经很清晰了，为了更好理解，我这里画张图给给大家，更好理解一点：</p><p><img src="https://static.lovebilibili.com/jvm_09.png" srcset="/img/loading.gif" alt=""></p><p>看到这里，应该都清楚了双亲委派机制的流程了。<strong>重点来了，为什么要使用双亲委派机制呢？</strong></p><p>如果面试官问这个问题，一定要答出关键字：<strong>安全性</strong>。</p><p>反证法来辩证。假设不采用双亲委派机制，那我可以自定义一个类加载器，然后我写一个java.lang.String类用自定义的类加载器加载进去，原来java本身又有一个java.lang.String类，那么类的唯一性就没法保证，就不就给虚拟机的安全带来的隐患了吗。<strong>所以要保证一个类只能由同一个类加载器加载，才能保证系统类的的安全</strong>。</p><h1 id="六、自定义类加载器"><a href="#六、自定义类加载器" class="headerlink" title="六、自定义类加载器"></a>六、自定义类加载器</h1><p>自定义类加载器，上面讲过可以有样学样，自定义一个类继承ClassLoader抽象类。重写哪个方法呢？loadClass()方法是加载类的方法，重写这个不就行了？</p><p>如果重写loadClass()那证明有思考过，但是不太对，因为重写loadClass()会破坏了双亲委派机制的逻辑。应该重写loadClass()方法里的findClass()方法。</p><p>findClass()方法才是自定义类加载器加载类的方法。</p><p><img src="https://static.lovebilibili.com/jvm_10.png" srcset="/img/loading.gif" alt=""></p><p>那findClass()方法源码是怎么样的呢？</p><p><img src="https://static.lovebilibili.com/jvm_11.png" srcset="/img/loading.gif" alt=""></p><p>明显这个方法是给子类重写用的，权限修饰符也是protected，如果不重写，那就会抛出找不到类的异常。如果学过设计模式的同学，应该看得出来这里用了<strong>模板模式</strong>的设计模式。所以我们自定义类加载器重写此方法即可。开始动手！</p><p>创建CustomerClassLoader类，继承ClassLoader抽象类的findClass()方法。</p><pre><code class="java">public class CustomerClassLoader extends ClassLoader {    //class文件在磁盘中的路径    private String path;    //通过构造器初始化class文件的路径    public CustomerClassLoader(String path) {        this.path = path;    }    /**     * 加载类     *     * @param name 类的全路径     * @return Class&lt;?&gt;     * @author Ye hongzhi     */    @Override    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {        Class clazz = null;        //获取class文件，转成字节码数组        byte[] data = getData();        if (data != null) {            //将class的字节码数组转换成Class类的实例            clazz = defineClass(name, data, 0, data.length);        }        //返回Class对象        return clazz;    }    private byte[] getData() {        File file = new File(path);        if (file.exists()) {            try (FileInputStream in = new FileInputStream(file);                 ByteArrayOutputStream out = new ByteArrayOutputStream();) {                byte[] buffer = new byte[1024];                int size;                while ((size = in.read(buffer)) != -1) {                    out.write(buffer, 0, size);                }                return out.toByteArray();            } catch (IOException e) {                e.printStackTrace();                return null;            }        } else {            return null;        }    }}</code></pre><p>这样就完成了，接下来测试一下，定义一个Hello类。</p><pre><code class="java">public class Hello {    public void say() {        System.out.println(&quot;hello.......java&quot;);    }}</code></pre><p>使用javac命令编译成class文件，如下图：</p><p><img src="https://static.lovebilibili.com/jvm_12.png" srcset="/img/loading.gif" alt=""></p><p>最后写个main方法运行测试一把：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        String path = &quot;D:\\mall\\core\\src\\main\\java\\io\\github\\yehongzhi\\classloader\\Hello.class&quot;;        CustomerClassLoader classLoader = new CustomerClassLoader(path);        Class&lt;?&gt; clazz = classLoader.findClass(&quot;io.github.yehongzhi.classloader.Hello&quot;);        System.out.println(&quot;使用类加载器：&quot; + clazz.getClassLoader());        Method method = clazz.getDeclaredMethod(&quot;say&quot;);        Object obj = clazz.newInstance();        method.invoke(obj);    }}</code></pre><p>运行结果：</p><p><img src="https://static.lovebilibili.com/jvm_13.png" srcset="/img/loading.gif" alt=""></p><h1 id="七、破坏双亲委派机制"><a href="#七、破坏双亲委派机制" class="headerlink" title="七、破坏双亲委派机制"></a>七、破坏双亲委派机制</h1><p>看到这里，你肯定会很疑惑。上面不是才讲过双亲委派机制为了保证系统的安全性吗，为什么又要破坏双亲委派机制呢？</p><p>重温一下双亲委派机制，应该还记得，就是底层的类加载器一直委托上层的类加载器，如果上层的已经加载了，就无需加载，上层的类加载器没有加载则自己加载。这就<strong>突出了双亲委派机制的一个缺陷，就是只能子的类加载器委托父的类加载器，不能反过来用父的类加载器委托子的类加载器</strong>。</p><p>那你会问，什么情况会出现父的类加载器委托子的类加载器呢？</p><p>还真有这个场景，就是加载JDBC的数据库驱动。在JDK中有一个所有 JDBC 驱动程序需要实现的接口Java.sql.Driver。而Driver接口的实现类则是由各大数据库厂商提供。那问题就出现了，<strong>DriverManager(JDK的rt.jar包中)要加载各个实现了Driver接口的实现类，然后进行统一管理，但是DriverManager是由Bootstrap类加载器加载的，只能加载JAVA_HOME下lib目录下的文件(可以看回上面双亲委派机制的第一张图)，但是实现类是服务商提供的，由AppClassLoader加载，这就需要Bootstrap(上层类加载器)委托AppClassLoader(下层类加载器)，也就破坏了双亲委派机制</strong>。这只是其中一种场景，破坏双亲委派机制的例子还有很多。</p><p>那么怎么实现破坏双亲委派机制呢？</p><ul><li>最简单就是自定义类加载器，前面讲过为了不破坏双亲委派机制重写findClass()方法，所以如果我要破坏双亲委派机制，那就重写loadClass()方法，直接把双亲委派机制的逻辑给改了。在JDK1.2后不提倡重写此方法。所以提供下面这种方式。</li><li>使用线程上下文件类加载器(Thread Context ClassLoader)。<strong>这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是AppClassLoader类加载器</strong>。</li></ul><p><img src="https://static.lovebilibili.com/jvm_14.png" srcset="/img/loading.gif" alt=""></p><p>那么刚刚说的JDBC又是采用什么方式破坏双亲委派机制的呢？</p><p>当然是采用上下文文件类加载器，还有使用了SPI机制，下面一步一步分解。</p><p>第一步，Bootstrap加载DriverManager类，在DriverManager类的静态代码块调用初始化方法。</p><pre><code class="java">public class DriverManager {    static {        loadInitialDrivers();        println(&quot;JDBC DriverManager initialized&quot;);    }}</code></pre><p>第二步，加载Driver接口的所有实现类，得到Driver实现类的集合，获取一个迭代器。</p><p><img src="https://static.lovebilibili.com/jvm_15.png" srcset="/img/loading.gif" alt=""></p><p>第三步，看ServiceLoader.load()方法。</p><p><img src="https://static.lovebilibili.com/jvm_16.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/jvm_17.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/jvm_18.png" srcset="/img/loading.gif" alt=""></p><p>第四步，看迭代器driversIterator。</p><p><img src="https://static.lovebilibili.com/jvm_19.png" srcset="/img/loading.gif" alt=""></p><p>接着一直找下去，就会看到一个很神奇的地方。</p><p><img src="https://static.lovebilibili.com/jvm_21.png" srcset="/img/loading.gif" alt=""></p><p>而这个常量值PREFIX则是：</p><pre><code class="java">private static final String PREFIX = &quot;META-INF/services/&quot;;</code></pre><p>所以我们可以在mysql驱动包中找到这个文件：</p><p><img src="https://static.lovebilibili.com/jvm_22.png" srcset="/img/loading.gif" alt=""></p><p>通过文件名找接口的实现类，这是java的SPI机制。到此为止，破案了大人！</p><p>作为暖男的我，就画张图，总结一下整个过程吧：</p><p><img src="https://static.lovebilibili.com/jvm_23.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章主要介绍了JVM，然后讲到JVM的类加载机制的三大步骤，接着讲自定义类加载器以及双亲委派机制。最后再深入探讨了为什么要使用双亲委派机制，又为什么要破坏双亲委派机制的问题。可能讲得有点长，不过我相信应该都看懂了，因为我讲得比较通俗，而且图文并茂。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5千字的SpringMVC总结，你值得拥有</title>
    <link href="/2020/08/30/5%E5%8D%83%E5%AD%97%E7%9A%84SpringMVC%E6%80%BB%E7%BB%93%EF%BC%8C%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89/"/>
    <url>/2020/08/30/5%E5%8D%83%E5%AD%97%E7%9A%84SpringMVC%E6%80%BB%E7%BB%93%EF%BC%8C%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/springmvc_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>微信公众号已开启：【<strong>java技术爱好者</strong>】，还没关注的记得关注哦~</p><p><strong>文章已收录到我的Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SpringMVC再熟悉不过的框架了，因为现在最火的SpringBoot的内置MVC框架就是SpringMVC。我写这篇文章的动机是想通过回顾总结一下，重新认识SpringMVC，所谓温故而知新嘛。</p><p>为了了解SpringMVC，先看一个流程示意图：</p><p><img src="https://static.lovebilibili.com/springmvc_1.png" srcset="/img/loading.gif" alt=""></p><p>从流程图中，我们可以看到：</p><ul><li>接收前端传过来Request请求。</li><li>根据映射路径找到对应的处理器处理请求，处理完成之后返回ModelAndView。</li><li>进行视图解析，视图渲染，返回响应结果。</li></ul><p>总结就是：<strong>参数接收，定义映射路径，页面跳转，返回响应结果</strong>。</p><p>当然这只是最基本的核心功能，除此之外还可以<strong>定义拦截器，全局异常处理，文件上传下载</strong>等等。</p><h1 id="一、搭建项目"><a href="#一、搭建项目" class="headerlink" title="一、搭建项目"></a>一、搭建项目</h1><p>在以前的老项目中，因为还没有SpringBoot，没有自动配置，所以需要使用<strong>web.xml</strong>文件去定义一个DispatcherServlet。现在互联网应用基本上都使用SpringBoot，所以我就直接使用SpringBoot进行演示。很简单，引入依赖即可：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h1 id="二、定义Controller"><a href="#二、定义Controller" class="headerlink" title="二、定义Controller"></a>二、定义Controller</h1><p>使用SpringMVC定义Controller处理器，总共有五种方式。</p><h2 id="2-1-实现Controller接口"><a href="#2-1-实现Controller接口" class="headerlink" title="2.1 实现Controller接口"></a>2.1 实现Controller接口</h2><p>早期的SpringMVC是通过这种方式定义：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name DemoController * @date 2020-08-25 22:28 **/@org.springframework.stereotype.Controller(&quot;/demo/controller&quot;)public class DemoController implements Controller {    @Override    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {        //业务处理        return null;    }}</code></pre><h2 id="2-2-实现HttpRequestHandler接口"><a href="#2-2-实现HttpRequestHandler接口" class="headerlink" title="2.2 实现HttpRequestHandler接口"></a>2.2 实现HttpRequestHandler接口</h2><p>跟第一种方式差不多，也是通过实现接口的方式：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name HttpDemoController * @date 2020-08-25 22:45 **/@Controller(&quot;/http/controller&quot;)public class HttpDemoController implements HttpRequestHandler{    @Override    public void handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException {        //业务处理    }}</code></pre><h2 id="2-3-实现Servlet接口"><a href="#2-3-实现Servlet接口" class="headerlink" title="2.3 实现Servlet接口"></a>2.3 实现Servlet接口</h2><p>这种方式已经不推荐使用了，不过从这里可以看出<strong>SpringMVC的底层使用的还是Servlet</strong>。</p><pre><code class="java">@Controller(&quot;/servlet/controller&quot;)public class ServletDemoController implements Servlet {    //以下是Servlet生命周期方法    @Override    public void init(ServletConfig servletConfig) throws ServletException {    }    @Override    public ServletConfig getServletConfig() {        return null;    }    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {    }    @Override    public String getServletInfo() {        return null;    }    @Override    public void destroy() {    }}</code></pre><p>因为不推荐使用这种方式，所以默认是不加载这种适配器的，需要加上：</p><pre><code class="java">@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter {    @Bean    public SimpleServletHandlerAdapter simpleServletHandlerAdapter() {        return new SimpleServletHandlerAdapter();    }}</code></pre><h2 id="2-4-使用-RequestMapping"><a href="#2-4-使用-RequestMapping" class="headerlink" title="2.4 使用@RequestMapping"></a>2.4 使用@RequestMapping</h2><p>这种方式是最常用的，因为上面那些方式定义需要使用一个类定义一个路径，就会导致产生很多类。使用注解就相对轻量级一些。</p><pre><code class="java">@Controller@RequestMapping(&quot;/requestMapping/controller&quot;)public class RequestMappingController {    @RequestMapping(&quot;/demo&quot;)    public String demo() {        return &quot;HelloWord&quot;;    }}</code></pre><h3 id="2-4-1-支持Restful风格"><a href="#2-4-1-支持Restful风格" class="headerlink" title="2.4.1 支持Restful风格"></a>2.4.1 支持Restful风格</h3><p>而且支持<strong>Restful风格</strong>，使用<strong>method</strong>属性定义对资源的操作方式：</p><pre><code class="java">    @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.GET)    public String get() {        //查询        return &quot;get&quot;;    }    @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.POST)    public String post() {        //创建        return &quot;post&quot;;    }    @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.PUT)    public String put() {        //更新        return &quot;put&quot;;    }    @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.DELETE)    public String del() {        //删除        return &quot;post&quot;;    }</code></pre><h3 id="2-4-2-支持Ant风格"><a href="#2-4-2-支持Ant风格" class="headerlink" title="2.4.2 支持Ant风格"></a>2.4.2 支持Ant风格</h3><pre><code class="java">    //匹配 /antA 或者 /antB 等URL    @RequestMapping(&quot;/ant?&quot;)    public String ant() {        return &quot;ant&quot;;    }    //匹配 /ant/a/create 或者 /ant/b/create 等URL    @RequestMapping(&quot;/ant/*/create&quot;)    public String antCreate() {        return &quot;antCreate&quot;;    }    //匹配 /ant/create 或者 /ant/a/b/create 等URL    @RequestMapping(&quot;/ant/**/create&quot;)    public String antAllCreate() {        return &quot;antAllCreate&quot;;    }</code></pre><h2 id="2-5-使用HandlerFunction"><a href="#2-5-使用HandlerFunction" class="headerlink" title="2.5 使用HandlerFunction"></a>2.5 使用HandlerFunction</h2><p>最后一种是使用HandlerFunction函数式接口，这是<code>Spring5.0</code>后引入的方式，主要用于做响应式接口的开发，也就是Webflux的开发。</p><p>有兴趣的可以网上搜索相关资料学习，这个讲起来可能要很大篇幅，这里就不赘述了。</p><h1 id="三、接收参数"><a href="#三、接收参数" class="headerlink" title="三、接收参数"></a>三、接收参数</h1><p>定义完Controller之后，需要接收前端传入的参数，怎么接收呢。</p><h2 id="3-1-接收普通参数"><a href="#3-1-接收普通参数" class="headerlink" title="3.1 接收普通参数"></a>3.1 接收普通参数</h2><p>在@RequestMapping映射方法上写上接收参数名即可：</p><pre><code class="java">@RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.POST)public String post(Integer id, String name, int money) {    System.out.println(&quot;id:&quot; + id + &quot;,name:&quot; + name + &quot;,money:&quot; + money);    return &quot;post&quot;;}</code></pre><p><img src="https://static.lovebilibili.com/springmvc_2.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-2-RequestParam参数名绑定"><a href="#3-2-RequestParam参数名绑定" class="headerlink" title="3.2 @RequestParam参数名绑定"></a>3.2 @RequestParam参数名绑定</h2><p>如果不想使用形参名称作为参数名称，可以使用@RequestParam进行参数名称绑定：</p><pre><code class="java">    /**     * value: 参数名     * required: 是否request中必须包含此参数，默认是true。     * defaultValue: 默认参数值     */    @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.GET)    public String get(@RequestParam(value = &quot;userId&quot;, required = false, defaultValue = &quot;0&quot;) String id) {        System.out.println(&quot;id:&quot; + id);        return &quot;get&quot;;    }</code></pre><p><img src="https://static.lovebilibili.com/springmvc_3.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-3-PathVariable路径参数"><a href="#3-3-PathVariable路径参数" class="headerlink" title="3.3 @PathVariable路径参数"></a>3.3 @PathVariable路径参数</h2><p>通过@PathVariable将URL中的占位符{xxx}参数映射到操作方法的入参。演示代码如下：</p><pre><code class="java">@RequestMapping(value = &quot;/restful/{id}&quot;, method = RequestMethod.GET)public String search(@PathVariable(&quot;id&quot;) String id) {    System.out.println(&quot;id:&quot; + id);    return &quot;search&quot;;}</code></pre><p><img src="https://static.lovebilibili.com/springmvc_4.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-4-RequestHeader绑定请求头属性"><a href="#3-4-RequestHeader绑定请求头属性" class="headerlink" title="3.4 @RequestHeader绑定请求头属性"></a>3.4 @RequestHeader绑定请求头属性</h2><p>获取请求头的信息怎么获取呢？</p><p><img src="https://static.lovebilibili.com/springmvc_5.png" srcset="/img/loading.gif" alt=""></p><p>使用@RequestHeader注解，用法和@RequestParam类似：</p><pre><code class="java">    @RequestMapping(&quot;/head&quot;)    public String head(@RequestHeader(&quot;Accept-Language&quot;) String acceptLanguage) {        return acceptLanguage;    }</code></pre><p><img src="https://static.lovebilibili.com/springmvc_6.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-5-CookieValue绑定请求的Cookie值"><a href="#3-5-CookieValue绑定请求的Cookie值" class="headerlink" title="3.5 @CookieValue绑定请求的Cookie值"></a>3.5 @CookieValue绑定请求的Cookie值</h2><p>获取Request中Cookie的值：</p><pre><code class="java">    @RequestMapping(&quot;/cookie&quot;)    public String cookie(@CookieValue(&quot;_ga&quot;) String _ga) {        return _ga;    }</code></pre><p><img src="https://static.lovebilibili.com/springmvc_7.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-6-绑定请求参数到POJO对象"><a href="#3-6-绑定请求参数到POJO对象" class="headerlink" title="3.6 绑定请求参数到POJO对象"></a>3.6 绑定请求参数到POJO对象</h2><p>定义了一个User实体类：</p><pre><code class="java">public class User {    private String id;    private String name;    private Integer age;    //getter、setter方法}</code></pre><p>定义一个@RequestMapping操作方法：</p><pre><code class="java">    @RequestMapping(&quot;/body&quot;)    public String body(User user) {        return user.toString();    }</code></pre><p>只要请求参数与属性名相同自动填充到user对象中：</p><p><img src="https://static.lovebilibili.com/springmvc_8.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_9.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-6-1-支持级联属性"><a href="#3-6-1-支持级联属性" class="headerlink" title="3.6.1 支持级联属性"></a>3.6.1 支持级联属性</h3><p>现在多了一个Address类存储地址信息：</p><pre><code class="java">public class Address {    private String id;    private String name;    //getter、setter方法}</code></pre><p>在User中加上address属性：</p><pre><code class="java">public class User {    private String id;    private String name;    private Integer age;    private Address address;    //getter、setter方法}</code></pre><p>传参时只要传入address.name、address.id即会自动填充：</p><p><img src="https://static.lovebilibili.com/springmvc_11.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_10.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-6-2-InitBinder解决接收多对象时属性名冲突"><a href="#3-6-2-InitBinder解决接收多对象时属性名冲突" class="headerlink" title="3.6.2 @InitBinder解决接收多对象时属性名冲突"></a>3.6.2 @InitBinder解决接收多对象时属性名冲突</h3><p>如果有两个POJO对象拥有相同的属性名，不就产生冲突了吗？比如刚刚的user和address，其中他们都有id和name这两个属性，如果同时接收，就会冲突：</p><pre><code class="java">    //user和address都有id和name这两个属性        @RequestMapping(value = &quot;/twoBody&quot;, method = RequestMethod.POST)    public String twoBody(User user, Address address) {        return user.toString() + &quot;,&quot; + address.toString();    }</code></pre><p>这时就可以使用@InitBinder绑定参数名称：</p><pre><code class="java">    @InitBinder(&quot;user&quot;)    public void initBindUser(WebDataBinder webDataBinder) {        webDataBinder.setFieldDefaultPrefix(&quot;u.&quot;);    }    @InitBinder(&quot;address&quot;)    public void initBindAddress(WebDataBinder webDataBinder) {        webDataBinder.setFieldDefaultPrefix(&quot;addr.&quot;);    }</code></pre><p><img src="https://static.lovebilibili.com/springmvc_12.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_13.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-6-3-Requestbody自动解析JSON字符串封装到对象"><a href="#3-6-3-Requestbody自动解析JSON字符串封装到对象" class="headerlink" title="3.6.3 @Requestbody自动解析JSON字符串封装到对象"></a>3.6.3 @Requestbody自动解析JSON字符串封装到对象</h3><p>前端传入一个json字符串，自动转换成pojo对象，演示代码：</p><pre><code class="java">    @RequestMapping(value = &quot;/requestBody&quot;, method = RequestMethod.POST)    public String requestBody(@RequestBody User user) {        return user.toString();    }</code></pre><p>注意的是，要使用<strong>POST请求，发送端的Content-Type设置为application/json，数据是json字符串</strong>：</p><p><img src="https://static.lovebilibili.com/springmvc_14.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_15.png" srcset="/img/loading.gif" alt=""></p><p>甚至有一些人喜欢用一个Map接收：</p><p><img src="https://static.lovebilibili.com/springmvc_16.png" srcset="/img/loading.gif" alt=""></p><p>但是<strong>千万不要用Map接收，否则会造成代码很难维护</strong>，后面的老哥估计看不懂你这个Map里面有什么数据，所以最好还是定义一个POJO对象。</p><h1 id="四、参数类型转换"><a href="#四、参数类型转换" class="headerlink" title="四、参数类型转换"></a>四、参数类型转换</h1><p>实际上，SpringMVC框架本身就内置了很多类型转换器，比如你传入字符串的数字，接收的入参定为int，long类型，都会自动帮你转换。</p><p>就在包<strong>org.springframework.core.convert.converter</strong>下，如图所示：</p><p><img src="https://static.lovebilibili.com/springmvc_17.png" srcset="/img/loading.gif" alt=""></p><p>有的时候如果内置的类型转换器不足够满足业务需求呢，怎么扩展呢，很简单，看我操作。什么是Java技术爱好者(战术后仰)。</p><p>首先有样学样，内置的转换器实现Converter接口，我也实现：</p><pre><code class="java">public class StringToDateConverter implements Converter&lt;String, Date&gt; {    @Override    public Date convert(String source) {        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        try {            //String转换成Date类型            return sdf.parse(source);        } catch (Exception e) {            //类型转换错误            e.printStackTrace();        }        return null;    }}</code></pre><p>接着把转换器注册到Spring容器中：</p><pre><code class="java">@Configurationpublic class ConverterConfig extends WebMvcConfigurationSupport {    @Override    protected void addFormatters(FormatterRegistry registry) {        //添加类型转换器        registry.addConverter(new StringToDateConverter());    }}</code></pre><p>接着看测试，所有的日期字符串，都自动被转换成Date类型了，非常方便：</p><p><img src="https://static.lovebilibili.com/springmvc_19.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_18.png" srcset="/img/loading.gif" alt=""></p><h1 id="五、页面跳转"><a href="#五、页面跳转" class="headerlink" title="五、页面跳转"></a>五、页面跳转</h1><p>在前后端未分离之前，页面跳转的工作都是由后端控制，采用JSP进行展示数据。虽然现在互联网项目几乎不会再使用JSP，但是我觉得还是需要学习一下，因为有些旧项目还是会用JSP，或者需要重构。</p><p>如果你在RequestMapping方法中直接返回一个字符串是不会跳转到指定的JSP页面的，需要做一些配置。</p><p>第一步，加入解析jsp的Maven配置。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;    &lt;version&gt;7.0.59&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>第二步，添加视图解析器。</p><pre><code class="java">@Configurationpublic class WebAppConfig extends WebMvcConfigurerAdapter {    @Bean    public InternalResourceViewResolver viewResolver() {        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();        viewResolver.setPrefix(&quot;/&quot;);        viewResolver.setSuffix(&quot;.jsp&quot;);        viewResolver.setViewClass(JstlView.class);        return viewResolver;    }}</code></pre><p>第三步，设置IDEA的配置。</p><p><img src="https://static.lovebilibili.com/springmvc_21.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_20.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_22.png" srcset="/img/loading.gif" alt=""></p><p>第四步，创建jsp页面。</p><p><img src="https://static.lovebilibili.com/springmvc_23.png" srcset="/img/loading.gif" alt=""></p><p>第五步，创建Controller控制器。</p><pre><code class="java">@Controller@RequestMapping(&quot;/view&quot;)public class ViewController {    @RequestMapping(&quot;/hello&quot;)    public String hello() throws Exception {        return &quot;hello&quot;;    }}</code></pre><p>这样就完成了，启动项目，访问/view/hello就看到了：</p><p><img src="https://static.lovebilibili.com/springmvc_25.png" srcset="/img/loading.gif" alt=""></p><p>就是这么简单，对吧</p><h1 id="六、-ResponseBody"><a href="#六、-ResponseBody" class="headerlink" title="六、@ResponseBody"></a>六、@ResponseBody</h1><p>如果采用前后端分离，页面跳转不需要后端控制了，后端只需要返回json即可，怎么返回呢？</p><p>使用@ResponseBody注解即可，这个注解会把对象自动转成json数据返回。</p><p>@ResponseBody注解可以放在类或者方法上，源码如下：</p><pre><code class="java">//用在类、方法上@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ResponseBody {}</code></pre><p>演示一下：</p><pre><code class="java">@RequestMapping(&quot;/userList&quot;)@ResponseBodypublic List&lt;User&gt; userList() throws Exception {    List&lt;User&gt; list = new ArrayList&lt;&gt;();    list.add(new User(&quot;1&quot;,&quot;姚大秋&quot;,18));    list.add(new User(&quot;2&quot;,&quot;李星星&quot;,18));    list.add(new User(&quot;3&quot;,&quot;冬敏&quot;,18));    return list;}</code></pre><p>测试一下/view/userList：</p><p><img src="https://static.lovebilibili.com/springmvc_26.png" srcset="/img/loading.gif" alt=""></p><h1 id="七、-ModelAttribute"><a href="#七、-ModelAttribute" class="headerlink" title="七、@ModelAttribute"></a>七、@ModelAttribute</h1><p>@ModelAttribute用法比较多，下面一一讲解。</p><h2 id="7-1-用在无返回值的方法上"><a href="#7-1-用在无返回值的方法上" class="headerlink" title="7.1 用在无返回值的方法上"></a>7.1 用在无返回值的方法上</h2><p>在Controller类中，在执行所有的RequestMapping方法前都会先执行@ModelAttribute注解的方法。</p><pre><code class="java">@Controller@RequestMapping(&quot;/modelAttribute&quot;)public class ModelAttributeController {    //先执行这个方法    @ModelAttribute    public void modelAttribute(Model model){        //在request域中放入数据        model.addAttribute(&quot;userName&quot;,&quot;公众号：java技术爱好者&quot;);    }    @RequestMapping(&quot;/index&quot;)    public String index(){        //跳转到inex.jsp页面        return &quot;index&quot;;    }}</code></pre><p>index.jsp页面如下：</p><pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 获取到userName属性值 --&gt;&lt;h1&gt;${userName}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>相当于一个Controller的拦截器一样，在执行RequestMapping方法前先执行@ModelAttribute注解的方法。所以要慎用。</p><p>启动项目，访问/modelAttribute/index可以看到：</p><p><img src="https://static.lovebilibili.com/springmvc_27.png" srcset="/img/loading.gif" alt=""></p><p>即使在index()方法中没有放入userName属性值，jsp页面也能获取到，因为在执行index()方法之前的modelAttribute()方法已经放入了。</p><h2 id="7-2-放在有返回值的方法上"><a href="#7-2-放在有返回值的方法上" class="headerlink" title="7.2 放在有返回值的方法上"></a>7.2 放在有返回值的方法上</h2><p>其实调用顺序是一样，也是在RequestMapping方法前执行，不同的在于，方法的返回值直接帮你放入到Request域中。</p><pre><code class="java">//放在有参数的方法上@ModelAttributepublic User userAttribute() {    //相当于model.addAttribute(&quot;user&quot;,new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18));    return new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18);}@RequestMapping(&quot;/user&quot;)public String user() {    return &quot;user&quot;;}</code></pre><p>创建一个user.jsp:</p><pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;ID:${user.id}&lt;/h1&gt;&lt;h1&gt;名称:${user.name}&lt;/h1&gt;&lt;h1&gt;年龄:${user.age}岁&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>测试一下：</p><p><img src="https://static.lovebilibili.com/springmvc_28.png" srcset="/img/loading.gif" alt=""></p><p>放入Request域中的属性值默认是类名的首字母小写驼峰写法，如果你想自定义呢？很简单，可以这样写：</p><pre><code class="java">//自定义属性名为&quot;u&quot;@ModelAttribute(&quot;u&quot;)public User userAttribute() {    return new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18);}/**JSP就要改成这样写：&lt;h1&gt;ID:${u.id}&lt;/h1&gt;&lt;h1&gt;名称:${u.name}&lt;/h1&gt;&lt;h1&gt;年龄:${u.age}岁&lt;/h1&gt;*/</code></pre><h2 id="7-3-放在RequestMapping方法上"><a href="#7-3-放在RequestMapping方法上" class="headerlink" title="7.3 放在RequestMapping方法上"></a>7.3 放在RequestMapping方法上</h2><pre><code class="java">@Controller@RequestMapping(&quot;/modelAttribute&quot;)public class ModelAttributeController {    @RequestMapping(&quot;/jojo&quot;)    @ModelAttribute(&quot;attributeName&quot;)    public String jojo() {        return &quot;JOJO！我不做人了！&quot;;    }}</code></pre><p>这种情况下RequestMapping方法的返回的值就不是JSP视图了。而是把返回值放入Request域中的属性值，属性名为attributeName。视图则是RequestMapping注解上的URL，所以创建一个对应的JSP页面：</p><p><img src="https://static.lovebilibili.com/springmvc_29.png" srcset="/img/loading.gif" alt=""></p><pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;${attributeName}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>测试一下：</p><p><img src="https://static.lovebilibili.com/springmvc_30.png" srcset="/img/loading.gif" alt=""></p><h2 id="7-4-放在方法入参上"><a href="#7-4-放在方法入参上" class="headerlink" title="7.4 放在方法入参上"></a>7.4 放在方法入参上</h2><p>放在入参上，意思是从前面的Model中提取出对应的属性值，当做入参传入方法中使用。如下所示：</p><pre><code class="java">@ModelAttribute(&quot;u&quot;)public User userAttribute() {    return new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18);}@RequestMapping(&quot;/java&quot;)public String user1(@ModelAttribute(&quot;u&quot;) User user) {    //拿到@ModelAttribute(&quot;u&quot;)方法返回的值，打印出来    System.out.println(&quot;user:&quot; + user);    return &quot;java&quot;;}</code></pre><p>测试一下：</p><p><img src="https://static.lovebilibili.com/springmvc_31.png" srcset="/img/loading.gif" alt=""></p><h1 id="八、拦截器"><a href="#八、拦截器" class="headerlink" title="八、拦截器"></a>八、拦截器</h1><p>拦截器算重点内容了，很多时候都要用拦截器，比如登录校验，权限校验等等。SpringMVC怎么添加拦截器呢？</p><p>很简单，实现HandlerInterceptor接口，接口有三个方法需要重写。</p><ul><li>preHandle()：在业务处理器处理请求之前被调用。预处理。</li><li>postHandle()：在业务处理器处理请求执行完成后，生成视图之前执行。后处理。</li><li>afterCompletion()：在DispatcherServlet完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）；</li></ul><p>自定义的拦截器，实现的接口HandlerInterceptor：</p><pre><code class="java">public class DemoInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //预处理，返回true则继续执行。如果需要登录校验，校验不通过返回false即可，通过则返回true。        System.out.println(&quot;执行preHandle()方法&quot;);        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        //后处理        System.out.println(&quot;执行postHandle()方法&quot;);    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        //在DispatcherServlet完全处理完请求后被调用        System.out.println(&quot;执行afterCompletion()方法&quot;);    }}</code></pre><p>然后把拦截器添加到Spring容器中：</p><pre><code class="java">@Configurationpublic class ConverterConfig extends WebMvcConfigurationSupport {    @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(new DemoInterceptor()).addPathPatterns(&quot;/**&quot;);    }}</code></pre><p>/**代表所有路径，测试一下：</p><p><img src="https://static.lovebilibili.com/springmvc_32.png" srcset="/img/loading.gif" alt=""></p><h1 id="九、全局异常处理"><a href="#九、全局异常处理" class="headerlink" title="九、全局异常处理"></a>九、全局异常处理</h1><p>SpringMVC本身就对一些异常进行了全局处理，所以有内置的异常处理器，在哪里呢？</p><p>看<code>HandlerExceptionResolver</code>接口的类图就知道了：</p><p><img src="https://static.lovebilibili.com/HandlerExceptionResolver.png" srcset="/img/loading.gif" alt=""></p><p>从类图可以看出有四种异常处理器：</p><ul><li><code>DefaultHandlerExceptionResolver</code>，默认的异常处理器。根据各个不同类型的异常，返回不同的异常视图。</li><li><code>SimpleMappingExceptionResolver</code>，简单映射异常处理器。通过配置异常类和view的关系来解析异常。</li><li><code>ResponseStatusExceptionResolver</code>，状态码异常处理器。解析带有<code>@ResponseStatus</code>注释类型的异常。</li><li><code>ExceptionHandlerExceptionResolver</code>，注解形式的异常处理器。对<code>@ExceptionHandler</code>注解的方法进行异常解析。</li></ul><p>第一个默认的异常处理器是内置的异常处理器，对一些常见的异常处理，一般来说不用管它。后面的三个才是需要注意的，是用来扩展的。</p><h2 id="9-1-SimpleMappingExceptionResolver"><a href="#9-1-SimpleMappingExceptionResolver" class="headerlink" title="9.1 SimpleMappingExceptionResolver"></a>9.1 SimpleMappingExceptionResolver</h2><p>翻译过来就是简单映射异常处理器。用途是，我们可以<strong>指定某种异常，当抛出这种异常之后跳转到指定的页面</strong>。请看演示。</p><p>第一步，添加spring-config.xml文件，放在resources目录下，文件名见文知意即可：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;        &lt;!-- 定义默认的异常处理页面 --&gt;        &lt;property name=&quot;defaultErrorView&quot; value=&quot;err&quot;/&gt;        &lt;!-- 定义异常处理页面用来获取异常信息的属性名，默认名为exception --&gt;        &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;        &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常也页名作为值 --&gt;        &lt;property name=&quot;exceptionMappings&quot;&gt;            &lt;props&gt;                &lt;!-- 异常，err表示err.jsp页面 --&gt;                &lt;prop key=&quot;java.lang.Exception&quot;&gt;err&lt;/prop&gt;                &lt;!-- 可配置多个prop --&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>第二步，在启动类加载xml文件：</p><pre><code class="java">@SpringBootApplication@ImportResource(&quot;classpath:spring-config.xml&quot;)public class SpringmvcApplication {    public static void main(String[] args) {        SpringApplication.run(SpringmvcApplication.class, args);    }}</code></pre><p>第三步，在webapp目录下创建一个err.jsp页面：</p><pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;异常页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;出现异常，这是一张500页面&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%=ex.getMessage()%&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这样就完成了，写一个接口测试一下：</p><pre><code class="java">@Controller@RequestMapping(&quot;/exception&quot;)public class ExceptionController {    @RequestMapping(&quot;/index&quot;)    public String index(String msg) throws Exception {        if (&quot;null&quot;.equals(msg)) {            //抛出空指针异常            throw new NullPointerException();        }        return &quot;index&quot;;    }}</code></pre><p>效果如下：</p><p><img src="https://static.lovebilibili.com/springmvc_33.png" srcset="/img/loading.gif" alt=""></p><p>这种异常处理器，在现在前后端分离的项目中几乎已经看不到了。</p><h2 id="9-2-ResponseStatusExceptionResolver"><a href="#9-2-ResponseStatusExceptionResolver" class="headerlink" title="9.2 ResponseStatusExceptionResolver"></a>9.2 ResponseStatusExceptionResolver</h2><p>这种异常处理器主要用于处理带有<code>@ResponseStatus</code>注释的异常。请看演示代码：</p><p>自定义一个异常类，并且使用<code>@ResponseStatus</code>注解修饰：</p><pre><code class="java">//HttpStatus枚举有所有的状态码，这里返回一个400的响应码@ResponseStatus(value = HttpStatus.BAD_REQUEST)public class DefinedException extends Exception{}</code></pre><p>写一个Controller接口进行测试：</p><pre><code class="java">@RequestMapping(&quot;/defined&quot;)public String defined(String msg) throws Exception {    if (&quot;defined&quot;.equals(msg)) {        throw new DefinedException();    }    return &quot;index&quot;;}</code></pre><p>启动项目，测试一下，效果如下：</p><p><img src="https://static.lovebilibili.com/springmvc_34.png" srcset="/img/loading.gif" alt=""></p><h2 id="9-3-ExceptionHandlerExceptionResolver"><a href="#9-3-ExceptionHandlerExceptionResolver" class="headerlink" title="9.3 ExceptionHandlerExceptionResolver"></a>9.3 ExceptionHandlerExceptionResolver</h2><p>注解形式的异常处理器，这是用得最多的。使用起来非常简单方便。</p><p>第一步，定义自定义异常BaseException：</p><pre><code class="java">public class BaseException extends Exception {    public BaseException(String message) {        super(message);    }}</code></pre><p>第二步，定义一个错误提示实体类ErrorInfo：</p><pre><code class="java">public class ErrorInfo {    public static final Integer OK = 0;    public static final Integer ERROR = -1;    private Integer code;    private String message;    private String url;    //getter、setter}</code></pre><p>第三步，定义全局异常处理类GlobalExceptionHandler：</p><pre><code class="java">//这里使用了RestControllerAdvice，是@ResponseBody和@ControllerAdvice的结合//会把实体类转成JSON格式的提示返回，符合前后端分离的架构@RestControllerAdvicepublic class GlobalExceptionHandler {    //这里自定义了一个BaseException，当抛出BaseException异常就会被此方法处理    @ExceptionHandler(BaseException.class)    public ErrorInfo errorHandler(HttpServletRequest req, BaseException e) throws Exception {        ErrorInfo r = new ErrorInfo();        r.setMessage(e.getMessage());        r.setCode(ErrorInfo.ERROR);        r.setUrl(req.getRequestURL().toString());        return r;    }}</code></pre><p>完成之后，写一个测试接口：</p><pre><code class="java">@RequestMapping(&quot;/base&quot;)public String base(String msg) throws Exception {    if (&quot;base&quot;.equals(msg)) {        throw new BaseException(&quot;测试抛出BaseException异常，欧耶！&quot;);    }    return &quot;index&quot;;}</code></pre><p>启动项目，测试：</p><p><img src="https://static.lovebilibili.com/springmvc_35.png" srcset="/img/loading.gif" alt=""></p><h1 id="絮叨"><a href="#絮叨" class="headerlink" title="絮叨"></a>絮叨</h1><p>SpringMVC的功能实际上肯定还不止我写的这些，不过学会上面这些之后，基本上已经可以应对日常的工作了。</p><p>如果要再深入一些，最好是看看SpringMVC源码，我之前写过三篇，<strong>责任链模式与SpringMVC拦截器，适配器模式与SpringMVC，全局异常处理源码分析</strong>。有兴趣可以关注公众号看看我的历史文章。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL主从复制读写分离，能讲一下吗</title>
    <link href="/2020/08/30/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%8C%E8%83%BD%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%90%97/"/>
    <url>/2020/08/30/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%8C%E8%83%BD%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/mysql_zxfz_wedt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>微信公众号已开启：【<strong>java技术爱好者</strong>】，还没关注的记得关注哦~</p><p><strong>文章已收录到我的Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很多项目，特别是互联网项目，在使用MySQL时都会采用主从复制、读写分离的架构。</p><p>为什么要采用主从复制读写分离的架构？如何实现？有什么缺点？让我们带着这些问题开始这段学习之旅吧！</p><h1 id="为什么使用主从复制、读写分离"><a href="#为什么使用主从复制、读写分离" class="headerlink" title="为什么使用主从复制、读写分离"></a>为什么使用主从复制、读写分离</h1><p>主从复制、读写分离一般是一起使用的。目的很简单，就是<strong>为了提高数据库的并发性能</strong>。你想，假设是单机，读写都在一台MySQL上面完成，性能肯定不高。如果有三台MySQL，一台mater只负责写操作，两台salve只负责读操作，性能不就能大大提高了吗？</p><p>所以<strong>主从复制、读写分离就是为了数据库能支持更大的并发</strong>。</p><p>随着业务量的扩展、如果是单机部署的MySQL，会导致I/O频率过高。采用<strong>主从复制、读写分离可以提高数据库的可用性</strong>。</p><h1 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h1><p>①当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。</p><p>②salve从库连接master主库，Master有多少个slave就会创建多少个binlog dump线程。</p><p>③当Master节点的binlog发生变化时，binlog dump 线程会通知所有的salve节点，并将相应的binlog内容推送给slave节点。</p><p>④I/O线程接收到 binlog 内容后，将内容写入到本地的 relay-log。</p><p>⑤SQL线程读取I/O线程写入的relay-log，并且根据 relay-log 的内容对从数据库做对应的操作。</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_1.png" srcset="/img/loading.gif" alt=""></p><h1 id="如何实现主从复制"><a href="#如何实现主从复制" class="headerlink" title="如何实现主从复制"></a>如何实现主从复制</h1><p>我这里用三台虚拟机(Linux)演示，IP分别是104(Master)，106(Slave)，107(Slave)。</p><p>预期的效果是一主二从，如下图所示：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_2.png" srcset="/img/loading.gif" alt=""></p><h2 id="Master配置"><a href="#Master配置" class="headerlink" title="Master配置"></a>Master配置</h2><p>使用命令行进入mysql：</p><pre><code class="java">mysql -u root -p</code></pre><p>接着输入root用户的密码(密码忘记的话就网上查一下重置密码吧~)，然后创建用户：</p><pre><code class="java">//192.168.0.106是slave从机的IPGRANT REPLICATION SLAVE ON *.* to &#39;root&#39;@&#39;192.168.0.106&#39; identified by &#39;Java@1234&#39;;//192.168.0.107是slave从机的IPGRANT REPLICATION SLAVE ON *.* to &#39;root&#39;@&#39;192.168.0.107&#39; identified by &#39;Java@1234&#39;;//刷新系统权限表的配置FLUSH PRIVILEGES;</code></pre><p>创建的这两个用户在配置slave从机时要用到。</p><p>接下来在找到mysql的配置文件/etc/my.cnf，增加以下配置：</p><pre><code class="properties"># 开启binloglog-bin=mysql-binserver-id=104# 需要同步的数据库，如果不配置则同步全部数据库binlog-do-db=test_db# binlog日志保留的天数，清除超过10天的日志# 防止日志文件过大，导致磁盘空间不足expire-logs-days=10 </code></pre><p>配置完成后，重启mysql：</p><pre><code class="java">service mysql restart</code></pre><p>可以通过命令行<code>show master status\G;</code>查看当前binlog日志的信息(后面有用)：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_3.png" srcset="/img/loading.gif" alt=""></p><h2 id="Slave配置"><a href="#Slave配置" class="headerlink" title="Slave配置"></a>Slave配置</h2><p>Slave配置相对简单一点。从机肯定也是一台MySQL服务器，所以和Master一样，找到/etc/my.cnf配置文件，增加以下配置：</p><pre><code class="properties"># 不要和其他mysql服务id重复即可server-id=106</code></pre><p>接着使用命令行登录到mysql服务器：</p><pre><code class="java">mysql -u root -p</code></pre><p>然后输入密码登录进去。</p><p>进入到mysql后，再输入以下命令：</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.0.104&#39;,//主机IPMASTER_USER=&#39;root&#39;,//之前创建的用户账号MASTER_PASSWORD=&#39;Java@1234&#39;,//之前创建的用户密码MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;,//master主机的binlog日志名称MASTER_LOG_POS=862,//binlog日志偏移量master_port=3306;//端口</code></pre><p>还没完，设置完之后需要启动：</p><pre><code class="java"># 启动slave服务start slave;</code></pre><p>启动完之后怎么校验是否启动成功呢？使用以下命令：</p><pre><code class="java">show slave status\G;</code></pre><p>可以看到如下信息（摘取部分关键信息）：</p><pre><code>*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.104                  Master_User: root                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000001          Read_Master_Log_Pos: 619               Relay_Log_File: mysqld-relay-bin.000001                Relay_Log_Pos: 782        Relay_Master_Log_File: mysql-bin.000001 //binlog日志文件名称             Slave_IO_Running: Yes //Slave_IO线程、SQL线程都在运行            Slave_SQL_Running: Yes             Master_Server_Id: 104 //master主机的服务id                  Master_UUID: 0ab6b3a6-e21d-11ea-aaa3-080027f8d623             Master_Info_File: /var/lib/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it           Master_Retry_Count: 86400                Auto_Position: 0</code></pre><p>另一台slave从机配置一样，不再赘述。</p><h2 id="测试主从复制"><a href="#测试主从复制" class="headerlink" title="测试主从复制"></a>测试主从复制</h2><p>在master主机执行sql：</p><pre><code class="sql">CREATE TABLE `tb_commodity_info` (  `id` varchar(32) NOT NULL,  `commodity_name` varchar(512) DEFAULT NULL COMMENT &#39;商品名称&#39;,  `commodity_price` varchar(36) DEFAULT &#39;0&#39; COMMENT &#39;商品价格&#39;,  `number` int(10) DEFAULT &#39;0&#39; COMMENT &#39;商品数量&#39;,  `description` varchar(2048) DEFAULT &#39;&#39; COMMENT &#39;商品描述&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;商品信息表&#39;;</code></pre><p>接着我们可以看到两台slave从机同步也创建了商品信息表：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_5.png" srcset="/img/loading.gif" alt=""></p><p>主从复制就完成了！java技术爱好者有点东西哦~</p><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>主从复制完成后，我们还需要实现读写分离，master负责写入数据，两台slave负责读取数据。怎么实现呢？</p><p>实现的方式有很多，以前我公司是采用AOP的方式，通过方法名判断，方法名中有get、select、query开头的则连接slave，其他的则连接master数据库。</p><p>但是通过AOP的方式实现起来代码有点繁琐，有没有什么现成的框架呢，答案是有的。</p><p>Apache ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 JDBC、Proxy两部分组成。</p><p>ShardingSphere-JDBC定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p><p>读写分离就可以使用ShardingSphere-JDBC实现。</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_6.png" srcset="/img/loading.gif" alt=""></p><p>下面演示一下SpringBoot+Mybatis+Mybatis-plus+druid+ShardingSphere-JDBC代码实现。</p><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>版本说明：</p><pre><code class="java">SpringBoot：2.0.1.RELEASEdruid：1.1.22mybatis-spring-boot-starter:1.3.2mybatis-plus-boot-starter：3.0.7sharding-jdbc-spring-boot-starter:4.1.1</code></pre><p>添加sharding-jdbc的maven配置：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;4.1.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后在application.yml添加配置：</p><pre><code class="yaml"># 这是使用druid连接池的配置，其他的连接池配置可能有所不同spring:  shardingsphere:    datasource:      names: master,slave0,slave1      master:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.jdbc.Driver        url: jdbc:mysql://192.168.0.108:3306/test_db?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT        username: yehongzhi        password: YHZ@1234      slave0:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.jdbc.Driver        url: jdbc:mysql://192.168.0.109:3306/test_db?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT        username: yehongzhi        password: YHZ@1234      slave1:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.jdbc.Driver        url: jdbc:mysql://192.168.0.110:3306/test_db?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT        username: yehongzhi        password: YHZ@1234    props:      sql.show: true    masterslave:      load-balance-algorithm-type: round_robin    sharding:      master-slave-rules:        master:          master-data-source-name: master          slave-data-source-names: slave0,slave1</code></pre><p>sharding.master-slave-rules是标明主库和从库，一定不要写错，否则写入数据到从库，就会导致无法同步。</p><p>load-balance-algorithm-type是路由策略，round_robin表示轮询策略。</p><p>启动项目，可以看到以下信息，代表配置成功：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_8.png" srcset="/img/loading.gif" alt=""></p><p>编写Controller接口：</p><pre><code class="java">    /**     * 添加商品     *     * @param commodityName  商品名称     * @param commodityPrice 商品价格     * @param description    商品价格     * @param number         商品数量     * @return boolean 是否添加成功     * @author java技术爱好者     */    @PostMapping(&quot;/insert&quot;)    public boolean insertCommodityInfo(@RequestParam(name = &quot;commodityName&quot;) String commodityName,                                       @RequestParam(name = &quot;commodityPrice&quot;) String commodityPrice,                                       @RequestParam(name = &quot;description&quot;) String description,                                       @RequestParam(name = &quot;number&quot;) Integer number) throws Exception {        return commodityInfoService.insertCommodityInfo(commodityName, commodityPrice, description, number);    }</code></pre><p>准备就绪，开始测试！</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开POSTMAN，添加商品：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_9.png" srcset="/img/loading.gif" alt=""></p><p>控制台可以看到如下信息：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_11.png" srcset="/img/loading.gif" alt=""></p><p>查询数据的话则通过slave进行：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_12.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/mysql_zcfz_13.png" srcset="/img/loading.gif" alt=""></p><p>就是这么简单！</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>尽管主从复制、读写分离能很大程度保证MySQL服务的高可用和提高整体性能，但是问题也不少：</p><ul><li><strong>从机是通过binlog日志从master同步数据的，如果在网络延迟的情况，从机就会出现数据延迟。那么就有可能出现master写入数据后，slave读取数据不一定能马上读出来</strong>。</li></ul><p>可能有人会问，有没有事务问题呢？</p><p>实际上这个框架已经想到了，我们看回之前的那个截图，有一句话是这样的：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_14.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>微信公众号已开启：【java技术爱好者】，没关注的同学记得关注哦~</p><p>我是java技术爱好者，罗定的java精英，人称 【罗ja英】</p><p>坚持原创，持续输出兼具广度和深度的技术文章。</p></blockquote><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Canal+Kafka实现MySQL与Redis数据同步</title>
    <link href="/2020/08/16/Canal-Kafka%E5%AE%9E%E7%8E%B0MySQL%E4%B8%8ERedis%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
    <url>/2020/08/16/Canal-Kafka%E5%AE%9E%E7%8E%B0MySQL%E4%B8%8ERedis%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/canal_jinjie_37.png" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很多业务情况下，我们都会在系统中加入redis缓存做查询优化。</p><p>如果数据库数据发生更新，这时候就需要在业务代码中写一段同步更新redis的代码。</p><p>这种<strong>数据同步的代码跟业务代码糅合在一起会不太优雅</strong>，能不能把这些数据同步的代码抽出来形成一个独立的模块呢，答案是可以的。</p><h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p>canal是一个伪装成slave订阅mysql的binlog，实现数据同步的中间件。上一篇文章<a href="https://juejin.im/post/6859278867635388430" target="_blank" rel="noopener">《canal入门》</a></p><p>我已经介绍了最简单的使用方法，也就是tcp模式。</p><p>实际上canal是支持直接发送到MQ的，<strong>目前最新版是支持主流的三种MQ：Kafka、RocketMQ、RabbitMQ</strong>。而canal的RabbitMQ模式目前是有一定的bug，所以一般使用Kafka或者RocketMQ。</p><p><img src="https://static.lovebilibili.com/canal_jinjie_25.png" srcset="/img/loading.gif" alt=""></p><p>本文使用Kafka，实现Redis与MySQL的数据同步。架构图如下：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_26.png" srcset="/img/loading.gif" alt=""></p><p>通过架构图，我们很清晰就知道要用到的组件：MySQL、Canal、Kafka、ZooKeeper、Redis。</p><p>下面演示Kafka的搭建，MySQL搭建大家应该都会，ZooKeeper、Redis这些网上也有很多资料参考。</p><h1 id="搭建Kafka"><a href="#搭建Kafka" class="headerlink" title="搭建Kafka"></a>搭建Kafka</h1><p>首先在<a href="https://github.com/apache/kafka" target="_blank" rel="noopener">官网</a>下载安装包：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_21.png" srcset="/img/loading.gif" alt=""></p><p>解压，打开/config/server.properties配置文件，修改日志目录：</p><pre><code class="properties">log.dirs=./logs</code></pre><p>首先启动ZooKeeper，我用的是3.6.1版本：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_27.png" srcset="/img/loading.gif" alt=""></p><p>接着再启动Kafka，在Kafka的bin目录下打开cmd，输入命令：</p><pre><code class="java">kafka-server-start.bat ../../config/server.properties</code></pre><p>我们可以看到ZooKeeper上注册了Kafka相关的配置信息：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_28.png" srcset="/img/loading.gif" alt=""></p><p>然后需要创建一个队列，用于接收canal传送过来的数据，使用命令：</p><pre><code class="java">kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic canaltopic</code></pre><p>创建的队列名是<code>canaltopic</code>。</p><p><img src="https://static.lovebilibili.com/canal_jinjie_29.png" srcset="/img/loading.gif" alt=""></p><h1 id="配置Cannal-Server"><a href="#配置Cannal-Server" class="headerlink" title="配置Cannal Server"></a>配置Cannal Server</h1><p>canal<a href="https://github.com/alibaba/canal/releases" target="_blank" rel="noopener">官网</a>下载相关安装包：</p><p><img src="https://static.lovebilibili.com/pic/canal_download.png" srcset="/img/loading.gif" alt=""></p><p>找到canal.deployer-1.1.4/conf目录下的canal.properties配置文件：</p><pre><code class="properties"># tcp, kafka, RocketMQ 这里选择kafka模式canal.serverMode = kafka# 解析器的线程数，打开此配置，不打开则会出现阻塞或者不进行解析的情况canal.instance.parser.parallelThreadSize = 16# 配置MQ的服务地址，这里配置的是kafka对应的地址和端口canal.mq.servers = 127.0.0.1:9092# 配置instance，在conf目录下要有example同名的目录，可以配置多个canal.destinations = example</code></pre><p>然后配置instance，找到/conf/example/instance.properties配置文件：</p><pre><code class="properties">## mysql serverId , v1.0.26+ will autoGen(自动生成，不需配置)# canal.instance.mysql.slaveId=0# position infocanal.instance.master.address=127.0.0.1:3306# 在Mysql执行 SHOW MASTER STATUS;查看当前数据库的binlogcanal.instance.master.journal.name=mysql-bin.000006canal.instance.master.position=4596# 账号密码canal.instance.dbUsername=canalcanal.instance.dbPassword=Canal@****canal.instance.connectionCharset = UTF-8#MQ队列名称canal.mq.topic=canaltopic#单队列模式的分区下标canal.mq.partition=0</code></pre><p>配置完成后，就可以启动canal了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>这时可以打开kafka的消费者窗口，测试一下kafka是否收到消息。</p><p>使用命令进行监听消费：</p><pre><code class="java">kafka-console-consumer.bat --bootstrap-server 127.0.0.1:9092 --from-beginning --topic canaltopic</code></pre><p><strong>有个小坑</strong>。我这里使用的是win10系统的cmd命令行，win10系统默认的编码是GBK，而Canal Server是UTF-8的编码，所以控制台会出现乱码：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_30.png" srcset="/img/loading.gif" alt=""></p><p>怎么解决呢？</p><p>在cmd命令行执行前切换到UTF-8编码即可，使用命令行：chcp 65001</p><p>然后再执行打开kafka消费端的命令，就不乱码了：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_31.png" srcset="/img/loading.gif" alt=""></p><p>接下来就是启动Redis，把数据同步到Redis就完事了。</p><h1 id="封装Redis客户端"><a href="#封装Redis客户端" class="headerlink" title="封装Redis客户端"></a>封装Redis客户端</h1><p>环境搭建完成后，我们可以写代码了。</p><p>首先引入Kafka和Redis的maven依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>在application.yml文件增加以下配置：</p><pre><code class="yaml">spring:    redis:    host: 127.0.0.1    port: 6379    database: 0    password: 123456</code></pre><p>封装一个操作Redis的工具类：</p><pre><code class="java">@Componentpublic class RedisClient {    /**     * 获取redis模版     */    @Resource    private StringRedisTemplate stringRedisTemplate;    /**     * 设置redis的key-value     */    public void setString(String key, String value) {        setString(key, value, null);    }    /**     * 设置redis的key-value，带过期时间     */    public void setString(String key, String value, Long timeOut) {        stringRedisTemplate.opsForValue().set(key, value);        if (timeOut != null) {            stringRedisTemplate.expire(key, timeOut, TimeUnit.SECONDS);        }    }    /**     * 获取redis中key对应的值     */    public String getString(String key) {        return stringRedisTemplate.opsForValue().get(key);    }    /**     * 删除redis中key对应的值     */    public Boolean deleteKey(String key) {        return stringRedisTemplate.delete(key);    }}</code></pre><h1 id="创建MQ消费者进行同步"><a href="#创建MQ消费者进行同步" class="headerlink" title="创建MQ消费者进行同步"></a>创建MQ消费者进行同步</h1><p>在application.yml配置文件加上kafka的配置信息：</p><pre><code class="yaml">spring:  kafka:      # Kafka服务地址    bootstrap-servers: 127.0.0.1:9092    consumer:      # 指定一个默认的组名      group-id: consumer-group1      #序列化反序列化      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer    producer:      key-serializer: org.apache.kafka.common.serialization.StringDeserializer      value-serializer: org.apache.kafka.common.serialization.StringDeserializer      # 批量抓取      batch-size: 65536      # 缓存容量      buffer-memory: 524288</code></pre><p>根据上面Kafka消费命令那里，我们知道了json数据的结构，可以创建一个CanalBean对象进行接收：</p><pre><code class="java">public class CanalBean {    //数据    private List&lt;TbCommodityInfo&gt; data;    //数据库名称    private String database;    private long es;    //递增，从1开始    private int id;    //是否是DDL语句    private boolean isDdl;    //表结构的字段类型    private MysqlType mysqlType;    //UPDATE语句，旧数据    private String old;    //主键名称    private List&lt;String&gt; pkNames;    //sql语句    private String sql;    private SqlType sqlType;    //表名    private String table;    private long ts;    //(新增)INSERT、(更新)UPDATE、(删除)DELETE、(删除表)ERASE等等    private String type;    //getter、setter方法}</code></pre><pre><code class="java">public class MysqlType {    private String id;    private String commodity_name;    private String commodity_price;    private String number;    private String description;    //getter、setter方法}</code></pre><pre><code class="java">public class SqlType {    private int id;    private int commodity_name;    private int commodity_price;    private int number;    private int description;}</code></pre><p>最后就可以创建一个消费者CanalConsumer进行消费：</p><pre><code class="java">@Componentpublic class CanalConsumer {    //日志记录    private static Logger log = LoggerFactory.getLogger(CanalConsumer.class);    //redis操作工具类    @Resource    private RedisClient redisClient;    //监听的队列名称为：canaltopic    @KafkaListener(topics = &quot;canaltopic&quot;)    public void receive(ConsumerRecord&lt;?, ?&gt; consumer) {        String value = (String) consumer.value();        log.info(&quot;topic名称:{},key:{},分区位置:{},下标:{},value:{}&quot;, consumer.topic(), consumer.key(),consumer.partition(), consumer.offset(), value);        //转换为javaBean        CanalBean canalBean = JSONObject.parseObject(value, CanalBean.class);        //获取是否是DDL语句        boolean isDdl = canalBean.getIsDdl();        //获取类型        String type = canalBean.getType();        //不是DDL语句        if (!isDdl) {            List&lt;TbCommodityInfo&gt; tbCommodityInfos = canalBean.getData();            //过期时间            long TIME_OUT = 600L;            if (&quot;INSERT&quot;.equals(type)) {                //新增语句                for (TbCommodityInfo tbCommodityInfo : tbCommodityInfos) {                    String id = tbCommodityInfo.getId();                    //新增到redis中,过期时间是10分钟                    redisClient.setString(id, JSONObject.toJSONString(tbCommodityInfo), TIME_OUT);                }            } else if (&quot;UPDATE&quot;.equals(type)) {                //更新语句                for (TbCommodityInfo tbCommodityInfo : tbCommodityInfos) {                    String id = tbCommodityInfo.getId();                    //更新到redis中,过期时间是10分钟                    redisClient.setString(id, JSONObject.toJSONString(tbCommodityInfo), TIME_OUT);                }            } else {                //删除语句                for (TbCommodityInfo tbCommodityInfo : tbCommodityInfos) {                    String id = tbCommodityInfo.getId();                    //从redis中删除                    redisClient.deleteKey(id);                }            }        }    }}</code></pre><h1 id="测试MySQL与Redis同步"><a href="#测试MySQL与Redis同步" class="headerlink" title="测试MySQL与Redis同步"></a>测试MySQL与Redis同步</h1><p>mysql对应的表结构如下：</p><pre><code class="sql">CREATE TABLE `tb_commodity_info` (  `id` varchar(32) NOT NULL,  `commodity_name` varchar(512) DEFAULT NULL COMMENT &#39;商品名称&#39;,  `commodity_price` varchar(36) DEFAULT &#39;0&#39; COMMENT &#39;商品价格&#39;,  `number` int(10) DEFAULT &#39;0&#39; COMMENT &#39;商品数量&#39;,  `description` varchar(2048) DEFAULT &#39;&#39; COMMENT &#39;商品描述&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;商品信息表&#39;;</code></pre><p>首先在MySQL创建表。然后启动项目，接着新增一条数据：</p><pre><code class="sql">INSERT INTO `canaldb`.`tb_commodity_info` (`id`, `commodity_name`, `commodity_price`, `number`, `description`) VALUES (&#39;3e71a81fd80711eaaed600163e046cc3&#39;, &#39;叉烧包&#39;, &#39;3.99&#39;, &#39;3&#39;, &#39;又大又香的叉烧包，老人小孩都喜欢&#39;);</code></pre><p>tb_commodity_info表查到新增的数据：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_32.png" srcset="/img/loading.gif" alt=""></p><p>Redis也查到了对应的数据，证明同步成功！</p><p><img src="https://static.lovebilibili.com/canal_jinjie_33.png" srcset="/img/loading.gif" alt=""></p><p>如果更新呢？试一下Update语句：</p><pre><code class="sql">UPDATE `canaldb`.`tb_commodity_info` SET `commodity_name`=&#39;青菜包&#39;,`description`=&#39;很便宜的青菜包呀，不买也开看看了喂&#39; WHERE `id`=&#39;3e71a81fd80711eaaed600163e046cc3&#39;;</code></pre><p><img src="https://static.lovebilibili.com/canal_jinjie_34.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/canal_jinjie_35.png" srcset="/img/loading.gif" alt=""></p><p>没有问题！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么你会说，canal就没有什么缺点吗？</p><p>肯定是有的：</p><ol><li>canal只能同步增量数据。</li><li>不是实时同步，是准实时同步。</li><li>存在一些bug，不过社区活跃度较高，对于提出的bug能及时修复。</li><li>MQ顺序性问题。我这里把官网的回答列出来，大家参考一下。</li></ol><p><img src="https://static.lovebilibili.com/canal_jinjie_36.png" srcset="/img/loading.gif" alt=""></p><p>尽管有一些缺点，毕竟没有一样技术或者产品是完美的，最重要是合适。</p><p>我们公司在同步MySQL数据到Elastic Search也是采用Canal+RocketMQ的方式。</p><p>参考资料：<a href="https://github.com/alibaba/canal/" target="_blank" rel="noopener">canal官网</a></p><h2 id="絮叨"><a href="#絮叨" class="headerlink" title="絮叨"></a>絮叨</h2><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>如果你觉得这篇文章对你有用，点个赞吧</strong>~</p><p><strong>你的点赞是我创作的最大动力</strong>~</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>canal</tag>
      
      <tag>kafka</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超详细canal入门</title>
    <link href="/2020/08/08/%E8%B6%85%E8%AF%A6%E7%BB%86canal%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/08/%E8%B6%85%E8%AF%A6%E7%BB%86canal%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/pic/canal_processon.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>本文章已收录到个人博客网站(我爱B站)：me.lovebilibili.com</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都知道一个系统最重要的是数据，数据是保存在数据库里。但是很多时候不单止要保存在数据库中，还要同步保存到Elastic Search、HBase、Redis等等。</p><p>这时我注意到阿里开源的框架<strong>Canal</strong>，他可以很方便地<strong>同步数据库的增量数据到其他的存储应用</strong>。所以在这里总结一下，分享给各位读者参考~</p><a id="more"></a><h1 id="一、什么是canal"><a href="#一、什么是canal" class="headerlink" title="一、什么是canal"></a>一、什么是canal</h1><p>我们先看官网的介绍</p><blockquote><p>canal，译意为水道/管道/沟渠，主要用途是基于 <strong>MySQL 数据库增量日志解析</strong>，提供<strong>增量数据订阅和消费</strong>。</p></blockquote><p>这句介绍有几个关键字：<strong>增量日志，增量数据订阅和消费</strong>。</p><p>这里我们可以简单地把canal理解为一个用来<strong>同步增量数据的一个工具</strong>。</p><p>接下来我们看一张官网提供的示意图：</p><p><img src="https://static.lovebilibili.com/pic/canal_syt.png" srcset="/img/loading.gif" alt=""></p><p>canal的工作原理就是<strong>把自己伪装成MySQL slave，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议，MySQL mater收到canal发送过来的dump请求，开始推送binary log给canal，然后canal解析binary log，再发送到存储目的地</strong>，比如MySQL，Kafka，Elastic Search等等。</p><h1 id="二、canal能做什么"><a href="#二、canal能做什么" class="headerlink" title="二、canal能做什么"></a>二、canal能做什么</h1><p>以下参考<a href="https://github.com/alibaba/canal" target="_blank" rel="noopener">canal官网</a>。</p><p>与其问canal能做什么，不如说数据同步有什么作用。</p><p>但是canal的数据同步<strong>不是全量的，而是增量</strong>。基于binary log增量订阅和消费，canal可以做：</p><ul><li>数据库镜像</li><li>数据库实时备份</li><li>索引构建和实时维护</li><li>业务cache(缓存)刷新</li><li>带业务逻辑的增量数据处理</li></ul><h1 id="三、如何搭建canal"><a href="#三、如何搭建canal" class="headerlink" title="三、如何搭建canal"></a>三、如何搭建canal</h1><h2 id="3-1-首先有一个MySQL服务器"><a href="#3-1-首先有一个MySQL服务器" class="headerlink" title="3.1 首先有一个MySQL服务器"></a>3.1 首先有一个MySQL服务器</h2><p>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x</p><p>我的Linux服务器安装的MySQL服务器是5.7版本。</p><p>MySQL的安装这里就不演示了，比较简单，网上也有很多教程。</p><p>然后在MySQL中需要创建一个用户，并授权：</p><pre><code class="sql">-- 使用命令登录：mysql -u root -p-- 创建用户 用户名：canal 密码：Canal@123456create user &#39;canal&#39;@&#39;%&#39; identified by &#39;Canal@123456&#39;;-- 授权 *.*表示所有库grant SELECT, REPLICATION SLAVE, REPLICATION CLIENT on *.* to &#39;canal&#39;@&#39;%&#39; identified by &#39;Canal@123456&#39;;</code></pre><p>下一步在MySQL配置文件my.cnf设置如下信息：</p><pre><code class="yml">[mysqld]# 打开binloglog-bin=mysql-bin# 选择ROW(行)模式binlog-format=ROW# 配置MySQL replaction需要定义，不要和canal的slaveId重复server_id=1</code></pre><p>改了配置文件之后，重启MySQL，使用命令查看是否打开binlog模式：</p><p><img src="https://static.lovebilibili.com/pic/canal_1.png" srcset="/img/loading.gif" alt=""></p><p>查看binlog日志文件列表：</p><p><img src="https://static.lovebilibili.com/pic/canal_2.png" srcset="/img/loading.gif" alt=""></p><p>查看当前正在写入的binlog文件：</p><p><img src="https://static.lovebilibili.com/pic/canal_3.png" srcset="/img/loading.gif" alt=""></p><p>MySQL服务器这边就搞定了，很简单。</p><h2 id="3-2-安装canal"><a href="#3-2-安装canal" class="headerlink" title="3.2 安装canal"></a>3.2 安装canal</h2><p>去官网下载页面进行下载：<a href="https://github.com/alibaba/canal/releases" target="_blank" rel="noopener">https://github.com/alibaba/canal/releases</a></p><p>我这里下载的是1.1.4的版本：<br><img src="https://static.lovebilibili.com/pic/canal_download.png" srcset="/img/loading.gif" alt=""></p><p>解压<strong>canal.deployer-1.1.4.tar.gz</strong>，我们可以看到里面有四个文件夹：</p><p><img src="https://static.lovebilibili.com/pic/tar_one.png" srcset="/img/loading.gif" alt=""></p><p>接着打开配置文件conf/example/instance.properties，配置信息如下：</p><pre><code class="properties">## mysql serverId , v1.0.26+ will autoGen## v1.0.26版本后会自动生成slaveId，所以可以不用配置# canal.instance.mysql.slaveId=0# 数据库地址canal.instance.master.address=127.0.0.1:3306# binlog日志名称canal.instance.master.journal.name=mysql-bin.000001# mysql主库链接时起始的binlog偏移量canal.instance.master.position=154# mysql主库链接时起始的binlog的时间戳canal.instance.master.timestamp=canal.instance.master.gtid=# username/password# 在MySQL服务器授权的账号密码canal.instance.dbUsername=canalcanal.instance.dbPassword=Canal@123456# 字符集canal.instance.connectionCharset = UTF-8# enable druid Decrypt database passwordcanal.instance.enableDruid=false# table regex .*\\..*表示监听所有表 也可以写具体的表名，用，隔开canal.instance.filter.regex=.*\\..*# mysql 数据解析表的黑名单，多个表用，隔开canal.instance.filter.black.regex=</code></pre><p>我这里用的是win10系统，所以在bin目录下找到startup.bat启动：</p><p>启动就报错，坑呀：</p><p><img src="https://static.lovebilibili.com/pic/canal_4.png" srcset="/img/loading.gif" alt=""></p><p>要修改一下启动的脚本startup.bat：</p><p><img src="https://static.lovebilibili.com/pic/canal_5.png" srcset="/img/loading.gif" alt=""></p><p>然后再启动脚本：</p><p><img src="https://static.lovebilibili.com/pic/canal_6.png" srcset="/img/loading.gif" alt=""></p><p>这就启动成功了。</p><h1 id="Java客户端操作"><a href="#Java客户端操作" class="headerlink" title="Java客户端操作"></a>Java客户端操作</h1><p>首先引入maven依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt;    &lt;artifactId&gt;canal.client&lt;/artifactId&gt;    &lt;version&gt;1.1.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后创建一个canal项目，使用SpringBoot构建，如图所示：</p><p><img src="https://static.lovebilibili.com/pic/canal_8.png" srcset="/img/loading.gif" alt=""></p><p>在CannalClient类使用Spring Bean的生命周期函数afterPropertiesSet()：</p><pre><code class="java">@Componentpublic class CannalClient implements InitializingBean {    private final static int BATCH_SIZE = 1000;    @Override    public void afterPropertiesSet() throws Exception {        // 创建链接        CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(&quot;127.0.0.1&quot;, 11111), &quot;example&quot;, &quot;&quot;, &quot;&quot;);        try {            //打开连接            connector.connect();            //订阅数据库表,全部表            connector.subscribe(&quot;.*\\..*&quot;);            //回滚到未进行ack的地方，下次fetch的时候，可以从最后一个没有ack的地方开始拿            connector.rollback();            while (true) {                // 获取指定数量的数据                Message message = connector.getWithoutAck(BATCH_SIZE);                //获取批量ID                long batchId = message.getId();                //获取批量的数量                int size = message.getEntries().size();                //如果没有数据                if (batchId == -1 || size == 0) {                    try {                        //线程休眠2秒                        Thread.sleep(2000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                } else {                    //如果有数据,处理数据                    printEntry(message.getEntries());                }                //进行 batch id 的确认。确认之后，小于等于此 batchId 的 Message 都会被确认。                connector.ack(batchId);            }        } catch (Exception e) {            e.printStackTrace();        } finally {            connector.disconnect();        }    }    /**     * 打印canal server解析binlog获得的实体类信息     */    private static void printEntry(List&lt;Entry&gt; entrys) {        for (Entry entry : entrys) {            if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) {                //开启/关闭事务的实体类型，跳过                continue;            }            //RowChange对象，包含了一行数据变化的所有特征            //比如isDdl 是否是ddl变更操作 sql 具体的ddl sql beforeColumns afterColumns 变更前后的数据字段等等            RowChange rowChage;            try {                rowChage = RowChange.parseFrom(entry.getStoreValue());            } catch (Exception e) {                throw new RuntimeException(&quot;ERROR ## parser of eromanga-event has an error , data:&quot; + entry.toString(), e);            }            //获取操作类型：insert/update/delete类型            EventType eventType = rowChage.getEventType();            //打印Header信息            System.out.println(String.format(&quot;================》; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;,                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),                    eventType));            //判断是否是DDL语句            if (rowChage.getIsDdl()) {                System.out.println(&quot;================》;isDdl: true,sql:&quot; + rowChage.getSql());            }            //获取RowChange对象里的每一行数据，打印出来            for (RowData rowData : rowChage.getRowDatasList()) {                //如果是删除语句                if (eventType == EventType.DELETE) {                    printColumn(rowData.getBeforeColumnsList());                    //如果是新增语句                } else if (eventType == EventType.INSERT) {                    printColumn(rowData.getAfterColumnsList());                    //如果是更新的语句                } else {                    //变更前的数据                    System.out.println(&quot;-------&gt;; before&quot;);                    printColumn(rowData.getBeforeColumnsList());                    //变更后的数据                    System.out.println(&quot;-------&gt;; after&quot;);                    printColumn(rowData.getAfterColumnsList());                }            }        }    }    private static void printColumn(List&lt;Column&gt; columns) {        for (Column column : columns) {            System.out.println(column.getName() + &quot; : &quot; + column.getValue() + &quot;    update=&quot; + column.getUpdated());        }    }}</code></pre><p>以上就完成了Java客户端的代码。这里不做具体的处理，仅仅是打印，先有个直观的感受。</p><p>最后我们开始测试，首先启动MySQL、Canal Server，还有刚刚写的Spring Boot项目。然后创建表：</p><pre><code class="sql">CREATE TABLE `tb_commodity_info` (  `id` varchar(32) NOT NULL,  `commodity_name` varchar(512) DEFAULT NULL COMMENT &#39;商品名称&#39;,  `commodity_price` varchar(36) DEFAULT &#39;0&#39; COMMENT &#39;商品价格&#39;,  `number` int(10) DEFAULT &#39;0&#39; COMMENT &#39;商品数量&#39;,  `description` varchar(2048) DEFAULT &#39;&#39; COMMENT &#39;商品描述&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;商品信息表&#39;;</code></pre><p>然后我们在控制台就可以看到如下信息：</p><p><img src="https://static.lovebilibili.com/pic/canal_10.png" srcset="/img/loading.gif" alt=""></p><p>如果新增一条数据到表中：</p><pre><code class="sql">INSERT INTO tb_commodity_info VALUES(&#39;3e71a81fd80711eaaed600163e046cc3&#39;,&#39;叉烧包&#39;,&#39;3.99&#39;,3,&#39;又大又香的叉烧包，老人小孩都喜欢&#39;);</code></pre><p>控制台可以看到如下信息：</p><p><img src="https://static.lovebilibili.com/pic/canal_11.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>canal的好处在于<strong>对业务代码没有侵入</strong>，因为是<strong>基于监听binlog日志去进行同步数据的</strong>。实时性也能做到准实时，其实是很多企业一种比较常见的数据同步的方案。</p><p>通过上面的学习之后，我们应该都明白canal是什么，它的原理，还有用法。实际上这仅仅只是入门，因为实际项目中我们不是这样玩的…</p><p>实际项目我们是<strong>配置MQ模式，配合RocketMQ或者Kafka，canal会把数据发送到MQ的topic中，然后通过消息队列的消费者进行处理</strong>。</p><p><img src="https://static.lovebilibili.com/pic/canal_12.png" srcset="/img/loading.gif" alt=""></p><p>Canal的部署也是支持集群的，需要配合ZooKeeper进行集群管理。</p><p>Canal还有一个简单的Web管理界面。</p><p>下一篇就讲一下<strong>集群部署Canal，配合使用Kafka，同步数据到Redis</strong>。</p><p>参考资料：<a href="https://github.com/alibaba/canal" target="_blank" rel="noopener">Canal官网</a></p><h2 id="絮叨"><a href="#絮叨" class="headerlink" title="絮叨"></a>絮叨</h2><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>如果你觉得这篇文章对你有用，点个赞吧</strong>~</p><p><strong>你的点赞是我创作的最大动力</strong>~</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzMwLzE3MzA1Y2MwOGE3ZWQ1ZDc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>canal</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ如何防止消息丢失</title>
    <link href="/2020/08/08/RabbitMQ%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"/>
    <url>/2020/08/08/RabbitMQ%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://img-blog.csdnimg.cn/20200802232920896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="一、分析数据丢失的原因"><a href="#一、分析数据丢失的原因" class="headerlink" title="一、分析数据丢失的原因"></a>一、分析数据丢失的原因</h1><p>分析RabbitMQ消息丢失的情况，不妨先看看一条消息从生产者发送到消费者消费的过程：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1Yzc2OTVkMDE5MjE?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>可以看出，一条消息整个过程要经历两次的网络传输：<strong>从生产者发送到RabbitMQ服务器，从RabbitMQ服务器发送到消费者</strong>。</p><a id="more"></a><p><strong>在消费者未消费前存储在队列(Queue)中</strong>。</p><p>所以可以知道，有三个场景下是会发生消息丢失的：</p><ul><li>存储在队列中，如果队列没有对消息持久化，RabbitMQ服务器宕机重启会丢失数据。</li><li>生产者发送消息到RabbitMQ服务器过程中，RabbitMQ服务器如果宕机停止服务，消息会丢失。</li><li>消费者从RabbitMQ服务器获取队列中存储的数据消费，但是消费者程序出错或者宕机而没有正确消费，导致数据丢失。</li></ul><p>针对以上三种场景，RabbitMQ提供了三种解决的方式，分别是消息持久化，confirm机制，ACK事务机制。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1ZDVhNjQ1YzNkNDc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><h1 id="二、消息持久化"><a href="#二、消息持久化" class="headerlink" title="二、消息持久化"></a>二、消息持久化</h1><p>RabbitMQ是支持消息持久化的，消息持久化需要设置：Exchange为持久化和Queue持久化，这样当消息发送到RabbitMQ服务器时，消息就会持久化。</p><p>首先看Exchange交换机的类图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1ZjY3MTUyNmVkMmQ?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>看这个类图其实是要说明上一篇文章介绍的四种交换机都是AbstractExchange抽象类的子类，所以根据java的特性，<strong>创建子类的实例会先调用父类的构造器</strong>，父类也就是AbstractExchange的构造器是怎么样的呢？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1ZjhjMGQ1YzhlNTE?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>从上面的注释可以看到<strong>durable参数表示是否持久化。默认是持久化(true)</strong>。创建持久化的Exchange可以这样写：</p><pre><code class="java">    @Bean    public DirectExchange rabbitmqDemoDirectExchange() {        //Direct交换机        return new DirectExchange(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, true, false);    }</code></pre><p>接着是Queue队列，我们先看看Queue的构造器是怎么样的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC9lNTA3ZmU0OTExNWE0MTk5YTFhNjg2ZDIwNWM5OWRlY350cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>也是通过durable参数设置是否持久化，默认是true。所以创建时可以不指定：</p><pre><code class="java">    @Bean    public Queue fanoutExchangeQueueA() {        //只需要指定名称，默认是持久化的        return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A);    }</code></pre><p>这就完成了消息持久化的设置，接下来启动项目，发送几条消息，我们可以看到：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC8zNWFmZjJkNmE0YzU0YjFjYmQ4ODk1NTM2NTExOTAwYn50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""><br>怎么证明是已经持久化了呢，实际上可以找到对应的文件：<br><img src="https://img-blog.csdnimg.cn/20200801205656332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>找到对应磁盘中的目录：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC80NmU1NDIxNTYwM2U0MmIyODI4ODlhYTQxYTVhNjFiOH50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""><br><strong>消息持久化可以防止消息在RabbitMQ Server中不会因为宕机重启而丢失</strong>。</p><h1 id="三、消息确认机制"><a href="#三、消息确认机制" class="headerlink" title="三、消息确认机制"></a>三、消息确认机制</h1><h2 id="3-1-confirm机制"><a href="#3-1-confirm机制" class="headerlink" title="3.1 confirm机制"></a>3.1 confirm机制</h2><p><strong>在生产者发送到RabbitMQ Server时有可能因为网络问题导致投递失败，从而丢失数据</strong>。我们可以使用confirm模式防止数据丢失。工作流程是怎么样的呢，看以下图解：<br><img src="https://img-blog.csdnimg.cn/20200801210244345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>从上图中可以看到是通过两个回调函数<strong>confirm()、returnedMessage()</strong>进行通知。</p><p>一条消息从生产者发送到RabbitMQ，首先会发送到Exchange，对应回调函数<strong>confirm()</strong>。第二步从Exchange路由分配到Queue中，对应回调函数则是<strong>returnedMessage()</strong>。</p><p>代码怎么实现呢，请看演示：</p><p>首先在<strong>application.yml</strong>配置文件中加上如下配置：</p><pre><code class="yml">spring:  rabbitmq:    publisher-confirms: true#    publisher-returns: true    template:      mandatory: true# publisher-confirms：设置为true时。当消息投递到Exchange后，会回调confirm()方法进行通知生产者# publisher-returns：设置为true时。当消息匹配到Queue并且失败时，会通过回调returnedMessage()方法返回消息# spring.rabbitmq.template.mandatory: 设置为true时。指定消息在没有被队列接收时会通过回调returnedMessage()方法退回。</code></pre><p>有个小细节，<strong>publisher-returns和mandatory如果都设置的话，优先级是以mandatory优先</strong>。可以看源码：<br><img src="https://img-blog.csdnimg.cn/20200801212504531.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>接着我们需要定义回调方法：</p><pre><code class="java">@Componentpublic class RabbitmqConfirmCallback implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnCallback {    private Logger logger = LoggerFactory.getLogger(RabbitmqConfirmCallback.class);    /**     * 监听消息是否到达Exchange     *     * @param correlationData 包含消息的唯一标识的对象     * @param ack             true 标识 ack，false 标识 nack     * @param cause           nack 投递失败的原因     */    @Override    public void confirm(CorrelationData correlationData, boolean ack, String cause) {        if (ack) {            logger.info(&quot;消息投递成功~消息Id：{}&quot;, correlationData.getId());        } else {            logger.error(&quot;消息投递失败，Id：{}，错误提示：{}&quot;, correlationData.getId(), cause);        }    }    @Override    public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {        logger.info(&quot;消息没有路由到队列，获得返回的消息&quot;);        Map map = byteToObject(message.getBody(), Map.class);        logger.info(&quot;message body: {}&quot;, map == null ? &quot;&quot; : map.toString());        logger.info(&quot;replyCode: {}&quot;, replyCode);        logger.info(&quot;replyText: {}&quot;, replyText);        logger.info(&quot;exchange: {}&quot;, exchange);        logger.info(&quot;routingKey: {}&quot;, exchange);        logger.info(&quot;------------&gt; end &lt;------------&quot;);    }    @SuppressWarnings(&quot;unchecked&quot;)    private &lt;T&gt; T byteToObject(byte[] bytes, Class&lt;T&gt; clazz) {        T t;        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);             ObjectInputStream ois = new ObjectInputStream(bis)) {            t = (T) ois.readObject();        } catch (Exception e) {            e.printStackTrace();            return null;        }        return t;    }}</code></pre><p>我这里就简单地打印回调方法返回的消息，在实际项目中，可以把返回的消息存储到日志表中，使用定时任务进行进一步的处理。</p><p>我这里是使用<strong>RabbitTemplate</strong>进行发送，所以在Service层的RabbitTemplate需要设置一下：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    @Resource    private RabbitmqConfirmCallback rabbitmqConfirmCallback;    @Resource    private RabbitTemplate rabbitTemplate;    @PostConstruct    public void init() {        //指定 ConfirmCallback        rabbitTemplate.setConfirmCallback(rabbitmqConfirmCallback);        //指定 ReturnCallback        rabbitTemplate.setReturnCallback(rabbitmqConfirmCallback);    }    @Override    public String sendMsg(String msg) throws Exception {        Map&lt;String, Object&gt; message = getMessage(msg);        try {            CorrelationData correlationData = (CorrelationData) message.remove(&quot;correlationData&quot;);            rabbitTemplate.convertAndSend(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING, message, correlationData);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }    private Map&lt;String, Object&gt; getMessage(String msg) {        String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32);        CorrelationData correlationData = new CorrelationData(msgId);        String sendTime = sdf.format(new Date());        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msgId&quot;, msgId);        map.put(&quot;sendTime&quot;, sendTime);        map.put(&quot;msg&quot;, msg);        map.put(&quot;correlationData&quot;, correlationData);        return map;    }}</code></pre><p>大功告成！接下来我们进行测试，发送一条消息，我们可以控制台：<br><img src="https://img-blog.csdnimg.cn/20200801214001880.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>假设发送一条信息没有路由匹配到队列，可以看到如下信息：<br><img src="https://img-blog.csdnimg.cn/20200801214142468.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这就是confirm模式。它的作用是<strong>为了保障生产者投递消息到RabbitMQ不会出现消息丢失</strong>。</p><h2 id="3-2-事务机制-ACK"><a href="#3-2-事务机制-ACK" class="headerlink" title="3.2 事务机制(ACK)"></a>3.2 事务机制(ACK)</h2><p>最开始的那张图已经讲过，<strong>消费者从队列中获取到消息后，会直接确认签收，假设消费者宕机或者程序出现异常，数据没有正常消费，这种情况就会出现数据丢失</strong>。</p><p>所以关键在于把自动签收改成手动签收，正常消费则返回确认签收，如果出现异常，则返回拒绝签收重回队列。<br><img src="https://img-blog.csdnimg.cn/20200801215323179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码怎么实现呢，请看演示：</p><p>首先在消费者的<strong>application.yml</strong>文件中设置事务提交为<strong>manual</strong>手动模式：</p><pre><code class="yml">spring:  rabbitmq:    listener:      simple:        acknowledge-mode: manual # 手动ack模式        concurrency: 1 # 最少消费者数量        max-concurrency: 10 # 最大消费者数量</code></pre><p>然后编写消费者的监听器：</p><pre><code class="java">@Componentpublic class RabbitDemoConsumer {    enum Action {        //处理成功        SUCCESS,        //可以重试的错误，消息重回队列        RETRY,        //无需重试的错误，拒绝消息，并从队列中删除        REJECT    }    @RabbitHandler    @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC))    public void process(String msg, Message message, Channel channel) {        long tag = message.getMessageProperties().getDeliveryTag();        Action action = Action.SUCCESS;        try {            System.out.println(&quot;消费者RabbitDemoConsumer从RabbitMQ服务端消费消息：&quot; + msg);            if (&quot;bad&quot;.equals(msg)) {                throw new IllegalArgumentException(&quot;测试：抛出可重回队列的异常&quot;);            }            if (&quot;error&quot;.equals(msg)) {                throw new Exception(&quot;测试：抛出无需重回队列的异常&quot;);            }        } catch (IllegalArgumentException e1) {            e1.printStackTrace();            //根据异常的类型判断，设置action是可重试的，还是无需重试的            action = Action.RETRY;        } catch (Exception e2) {            //打印异常            e2.printStackTrace();            //根据异常的类型判断，设置action是可重试的，还是无需重试的            action = Action.REJECT;        } finally {            try {                if (action == Action.SUCCESS) {                    //multiple 表示是否批量处理。true表示批量ack处理小于tag的所有消息。false则处理当前消息                    channel.basicAck(tag, false);                } else if (action == Action.RETRY) {                    //Nack，拒绝策略，消息重回队列                    channel.basicNack(tag, false, true);                } else {                    //Nack，拒绝策略，并且从队列中删除                    channel.basicNack(tag, false, false);                }                channel.close();            } catch (Exception e) {                e.printStackTrace();            }        }    }}</code></pre><p>解释一下上面的代码，如果没有异常，则手动确认回复RabbitMQ服务端basicAck(消费成功)。</p><p>如果抛出某些可以重回队列的异常，我们就回复basicNack并且设置重回队列。</p><p>如果是抛出不可重回队列的异常，就回复basicNack并且设置从RabbitMQ的队列中删除。</p><p>接下来进行测试，发送一条普通的消息”hello”：<br><img src="https://img-blog.csdnimg.cn/20200802215129880.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>解释一下ack返回的三个方法的意思。</p><p>①成功确认</p><pre><code class="java">void basicAck(long deliveryTag, boolean multiple) throws IOException;</code></pre><p>消费者成功处理后调用此方法对消息进行确认。</p><ul><li>deliveryTag：该消息的index</li><li>multiple：是否批量.。true：将一次性ack所有小于deliveryTag的消息。</li></ul><p>②失败确认</p><pre><code class="java">void basicNack(long deliveryTag, boolean multiple, boolean requeue) throws IOException;</code></pre><ul><li>deliveryTag：该消息的index。</li><li>multiple：是否批量。true：将一次性拒绝所有小于deliveryTag的消息。</li><li>requeue：被拒绝的是否重新入队列。</li></ul><p>③失败确认</p><pre><code class="java">void basicReject(long deliveryTag, boolean requeue) throws IOException;</code></pre><ul><li>deliveryTag:该消息的index。</li><li>requeue：被拒绝的是否重新入队列。</li></ul><p>basicNack()和basicReject()的区别在于：<strong>basicNack()可以批量拒绝，basicReject()一次只能拒接一条消息</strong>。</p><h1 id="四、遇到的坑"><a href="#四、遇到的坑" class="headerlink" title="四、遇到的坑"></a>四、遇到的坑</h1><h2 id="4-1-启用nack机制后，导致的死循环"><a href="#4-1-启用nack机制后，导致的死循环" class="headerlink" title="4.1 启用nack机制后，导致的死循环"></a>4.1 启用nack机制后，导致的死循环</h2><p>上面的代码我故意写了一个bug。测试发送一条”bad”，然后会抛出重回队列的异常。这就有个问题：重回队列后消费者又消费，消费抛出异常又重回队列，就造成了死循环。<br><img src="https://img-blog.csdnimg.cn/20200802215521688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>那怎么避免这种情况呢？</p><p>既然nack会造成死循环的话，我提供的一个思路是<strong>不使用basicNack()，把抛出异常的消息落库到一张表中，记录抛出的异常，消息体，消息Id。通过定时任务去处理</strong>。</p><p>如果你有什么好的解决方案，也可以留言讨论~</p><h2 id="4-2-double-ack"><a href="#4-2-double-ack" class="headerlink" title="4.2 double ack"></a>4.2 double ack</h2><p>有的时候比较粗心，不小心开启了自动Ack模式，又手动回复了Ack。那就会报这个错误：</p><pre><code class="java">消费者RabbitDemoConsumer从RabbitMQ服务端消费消息：java技术爱好者2020-08-02 22:52:42.148 ERROR 4880 --- [ 127.0.0.1:5672] o.s.a.r.c.CachingConnectionFactory       : Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - unknown delivery tag 1, class-id=60, method-id=80)2020-08-02 22:52:43.102  INFO 4880 --- [cTaskExecutor-1] o.s.a.r.l.SimpleMessageListenerContainer : Restarting Consumer@f4a3a8d: tags=[{amq.ctag-8MJeQ7el_PNbVJxGOOw7Rw=rabbitmq.demo.topic}], channel=Cached Rabbit Channel: AMQChannel(amqp://guest@127.0.0.1:5672/,5), conn: Proxy@782a1679 Shared Rabbit Connection: SimpleConnection@67c5b175 [delegate=amqp://guest@127.0.0.1:5672/, localPort= 56938], acknowledgeMode=AUTO local queue size=0</code></pre><p>出现这个错误，可以检查一下yml文件是否添加了以下配置：</p><pre><code class="yml">spring:  rabbitmq:    listener:      simple:        acknowledge-mode: manual        concurrency: 1        max-concurrency: 10</code></pre><p>如果上面这个配置已经添加了，还是报错，<strong>有可能你使用@Configuration配置了SimpleRabbitListenerContainerFactory，根据SpringBoot的特性，代码优于配置，代码的配置覆盖了yml的配置，并且忘记设置手动manual模式</strong>：</p><pre><code class="java">@Bean    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) {        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();        factory.setConnectionFactory(connectionFactory);        //设置手动ack模式        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);        return factory;    }</code></pre><p>如果你还是有报错，那可能是写错地方了，写在生产者的项目了。以上的配置应该配置在消费者的项目。因为ack模式是针对消费者而言的。我就是写错了，写在生产者，折腾了几个小时，泪目~</p><h2 id="4-3-性能问题"><a href="#4-3-性能问题" class="headerlink" title="4.3 性能问题"></a>4.3 性能问题</h2><p>其实手动ACK相对于自动ACK肯定是会慢很多，我在网上查了一些资料，性能相差大概有10倍。所以一般在实际应用中不太建议开手动ACK模式。不过也不是绝对不可以开，具体情况具体分析，看并发量，还有数据的重要性等等。</p><p>所以<strong>在实际项目中还需要权衡一下并发量和数据的重要性，再决定具体的方案</strong>。</p><h2 id="4-4-启用手动ack模式，如果没有及时回复，会造成队列异常"><a href="#4-4-启用手动ack模式，如果没有及时回复，会造成队列异常" class="headerlink" title="4.4 启用手动ack模式，如果没有及时回复，会造成队列异常"></a>4.4 启用手动ack模式，如果没有及时回复，会造成队列异常</h2><p>如果开启了手动ACK模式，但是由于代码有bug的原因，没有回复RabbitMQ服务端，那么这条消息就会放到Unacked状态的消息堆里，只有等到消费者的连接断开才会转到Ready消息。如果消费者一直没有断开连接，那Unacked的消息就会越来越多，占用内存就越来越大，最后就会出现异常。</p><p>这个问题，我没法用我的电脑演示，我的电脑太卡了。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>通过上面的学习后，总结了RabbitMQ防止数据丢失有三种方式：</p><ul><li>消息持久化</li><li>生产者消息确认机制(confirm模式)</li><li>消费者消息确认模式(ack模式)</li></ul><p>上面所有例子的代码都上传github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>如果你觉得这篇文章对你有用，点个赞吧</strong>~</p><p><strong>你的点赞是我创作的最大动力</strong>~</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzMwLzE3MzA1Y2MwOGE3ZWQ1ZDc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ入门</title>
    <link href="/2020/08/08/RabbitMQ%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/08/RabbitMQ%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/26/17389a94030dbf28?w=729&h=515&f=png&s=44034" srcset="/img/loading.gif" alt=""></p><h1 id="一、什么是消息队列"><a href="#一、什么是消息队列" class="headerlink" title="一、什么是消息队列"></a>一、什么是消息队列</h1><p><strong>消息</strong>指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。</p><p><strong>“消息队列(Message Queue)”是在消息的传输过程中保存消息的容器</strong>。在消息队列中，通常有生产者和消费者两个角色。生产者只负责发送数据到消息队列，谁从消息队列中取出数据处理，他不管。消费者只负责从消息队列中取出数据处理，他不管这是谁发送的数据。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/1736753c4753c6f9?w=436&h=93&f=png&s=8826" srcset="/img/loading.gif" alt=""></p><h1 id="二、为什么使用消息队列"><a href="#二、为什么使用消息队列" class="headerlink" title="二、为什么使用消息队列"></a>二、为什么使用消息队列</h1><p>主要有三个作用：</p><ul><li><strong>解耦</strong>。如图所示。假设有系统B、C、D都需要系统A的数据，于是系统A调用三个方法发送数据到B、C、D。这时，系统D不需要了，那就需要在系统A把相关的代码删掉。假设这时有个新的系统E需要数据，这时系统A又要增加调用系统E的代码。为了降低这种强耦合，就可以使用MQ，<strong>系统A只需要把数据发送到MQ，其他系统如果需要数据，则从MQ中获取即可</strong>。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/173678c7a81cc1c0?w=589&h=254&f=png&s=20463" srcset="/img/loading.gif" alt=""></p><ul><li>异步。如图所示。一个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是800ms。<strong>如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能</strong>。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用MQ。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/17367945a8c4df73?w=570&h=264&f=png&s=13623" srcset="/img/loading.gif" alt=""></p><ul><li>削峰。如图所示。这其实是MQ一个很重要的应用。假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。<strong>如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃</strong>。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/17367a9d902cca4f?w=759&h=335&f=png&s=34834" srcset="/img/loading.gif" alt=""></p><h1 id="三、RabbitMQ的特点"><a href="#三、RabbitMQ的特点" class="headerlink" title="三、RabbitMQ的特点"></a>三、RabbitMQ的特点</h1><p>RabbitMQ是一款使用Erlang语言开发的，实现AMQP(高级消息队列协议)的开源消息中间件。首先要知道一些RabbitMQ的特点，<a href="https://www.rabbitmq.com" target="_blank" rel="noopener">官网</a>可查：</p><ul><li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li><li>灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li><li>支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li><li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li><li>可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li><li>插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li></ul><h1 id="四、RabbitMQ初の体验"><a href="#四、RabbitMQ初の体验" class="headerlink" title="四、RabbitMQ初の体验"></a>四、RabbitMQ初の体验</h1><h2 id="4-1-安装RabbitMQ-Win10系统"><a href="#4-1-安装RabbitMQ-Win10系统" class="headerlink" title="4.1 安装RabbitMQ (Win10系统)"></a>4.1 安装RabbitMQ (Win10系统)</h2><p>由于只是学习需要，所以安装在win10系统，就懒得开虚拟机。如果用Linux系统安装的话，我建议用Docker拉一个RabbitMQ的镜像下来，这样会方便一点。</p><h3 id="4-1-1-安装erLang语言，配置环境变量"><a href="#4-1-1-安装erLang语言，配置环境变量" class="headerlink" title="4.1.1 安装erLang语言，配置环境变量"></a>4.1.1 安装erLang语言，配置环境变量</h3><p>首先到erlang<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">官网</a>下载win10版安装包。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b11e8ce24fc?w=610&h=383&f=png&s=42809" srcset="/img/loading.gif" alt=""></p><p>下载完之后，就得到这个东西：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b35ca09e258?w=120&h=152&f=png&s=3625" srcset="/img/loading.gif" alt=""></p><p>接着双击安装，一直点next(下一步)就行了，安装完之后，配置环境变量。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b5796ccda18?w=648&h=176&f=png&s=12500" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b63e3dd7f73?w=591&h=312&f=png&s=28042" srcset="/img/loading.gif" alt=""></p><p>使用cmd命令，输入 erl -version 验证：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371bac494381d6?w=475&h=50&f=png&s=2778" srcset="/img/loading.gif" alt=""></p><h3 id="4-1-2-安装RabbitMQ服务端"><a href="#4-1-2-安装RabbitMQ服务端" class="headerlink" title="4.1.2 安装RabbitMQ服务端"></a>4.1.2 安装RabbitMQ服务端</h3><p>在RabbitMQ的<a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.3" target="_blank" rel="noopener">gitHub项目</a>中，下载window版本的服务端安装包。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371bf868e203f4?w=394&h=169&f=png&s=19585" srcset="/img/loading.gif" alt=""></p><p>下载后，就得到这个东西：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371c1d6501ab40?w=117&h=153&f=png&s=3533" srcset="/img/loading.gif" alt=""></p><p>接着到双击安装，一直点下一步安装即可，安装完成后，找到安装目录：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371c5bccf4f9d5?w=618&h=280&f=png&s=40338" srcset="/img/loading.gif" alt=""></p><p>在此目录下打开cmd命令，输入rabbitmq-plugins enable rabbitmq_management命令安装管理页面的插件：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371c7989899657?w=718&h=161&f=png&s=11588" srcset="/img/loading.gif" alt=""></p><p>然后双击rabbitmq-server.bat启动脚本，然后打开服务管理可以看到RabbitMQ正在运行：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371ca5f47fce8b?w=1176&h=332&f=png&s=95743" srcset="/img/loading.gif" alt=""></p><p>这时，打开浏览器输入<code>http://localhost:15672</code>，账号密码默认是：guest/guest</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371cb642afc306?w=379&h=170&f=png&s=8715" srcset="/img/loading.gif" alt=""></p><p>到这一步，安装就大功告成了！</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371cc62006368a?w=1296&h=506&f=png&s=65917" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-永远的Hello-Word"><a href="#4-2-永远的Hello-Word" class="headerlink" title="4.2 永远的Hello Word"></a>4.2 永远的Hello Word</h2><p>服务端搭建好了之后肯定要用客户端去操作，接下来就用Java做一个简单的HelloWord演示。</p><p>因为我用的是SpringBoot，所以在<strong>生产者这边</strong>加入对应的starter依赖即可：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>一般需要创建一个公共项目common，共享一些配置，比如队列主题，交换机名称，路由匹配键名称等等。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376a8962ac345e?w=1187&h=422&f=png&s=87972" srcset="/img/loading.gif" alt=""></p><p>首先在application.yml文件加上RabbitMQ的配置信息：</p><pre><code class="yml">spring:    rabbitmq:        host: 127.0.0.1        port: 5672        username: guest        password: guest</code></pre><p>然后在生产者这边，加上common包的maven依赖，然后创建一个Direct交换机以及队列的配置类：</p><pre><code class="java">@Configurationpublic class DirectRabbitConfig {    @Bean    public Queue rabbitmqDemoDirectQueue() {        /**         * 1、name:    队列名称         * 2、durable: 是否持久化         * 3、exclusive: 是否独享、排外的。如果设置为true，定义为排他队列。则只有创建者可以使用此队列。也就是private私有的。         * 4、autoDelete: 是否自动删除。也就是临时队列。当最后一个消费者断开连接后，会自动删除。         * */        return new Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC, true, false, false);    }    @Bean    public DirectExchange rabbitmqDemoDirectExchange() {        //Direct交换机        return new DirectExchange(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, true, false);    }    @Bean    public Binding bindDirect() {        //链式写法，绑定交换机和队列，并设置匹配键        return BindingBuilder                //绑定队列                .bind(rabbitmqDemoDirectQueue())                //到交换机                .to(rabbitmqDemoDirectExchange())                //并设置匹配键                .with(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING);    }}</code></pre><p>然后再创建一个发送消息的Service类：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    //日期格式化    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    @Resource    private RabbitTemplate rabbitTemplate;    @Override    public String sendMsg(String msg) throws Exception {        try {            String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32);            String sendTime = sdf.format(new Date());            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();            map.put(&quot;msgId&quot;, msgId);            map.put(&quot;sendTime&quot;, sendTime);            map.put(&quot;msg&quot;, msg);            rabbitTemplate.convertAndSend(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING, map);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }}</code></pre><p>然后根据业务放在需要用的地方，比如定时任务，或者接口。我这里就简单一点使用Controller层进行发送：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    @Resource    private RabbitMQService rabbitMQService;    /**     * 发送消息     * @author java技术爱好者     */    @PostMapping(&quot;/sendMsg&quot;)    public String sendMsg(@RequestParam(name = &quot;msg&quot;) String msg) throws Exception {        return rabbitMQService.sendMsg(msg);    }}</code></pre><p>生产者写完之后，就写消费者端的代码，消费者很简单。maven依赖，yml文件配置和生产者一样。只需要创建一个类，@RabbitListener注解写上监听队列的名称，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376b4781b8bd8a?w=1198&h=380&f=png&s=66605" srcset="/img/loading.gif" alt=""></p><p><strong>这里有个小坑</strong>，一开始RabbitMQ服务器里还没有创建队列：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bcd4d88602d?w=628&h=287&f=png&s=18084" srcset="/img/loading.gif" alt=""></p><p>这时如果启动消费者，会报错：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bd6f8340df0?w=1241&h=128&f=png&s=34738" srcset="/img/loading.gif" alt=""></p><p>要先启动生产者，发送一条消息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bef5bc1dec1?w=934&h=241&f=png&s=21574" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376c019fa7c8bb?w=778&h=273&f=png&s=27026" srcset="/img/loading.gif" alt=""></p><p>最后再启动消费者，进行消费：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376c132059ba20?w=1164&h=264&f=png&s=95439" srcset="/img/loading.gif" alt=""></p><p>这时候就会持续监听队列的消息，只要生产者发送一条消息到MQ，消费者就消费一条。我这里尝试发送4条：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376c3ca37adf87?w=1139&h=111&f=png&s=36994" srcset="/img/loading.gif" alt=""></p><p>由于队列不存在，启动消费者报错的这个问题。最好的方法是生产者和消费者都尝试创建队列，怎么写呢，有很多方式，我这里用一个相对简单一点的：</p><p>生产者的配置类加点东西：</p><pre><code class="java">//实现BeanPostProcessor类，使用Bean的生命周期函数@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    //这是创建交换机和队列用的rabbitAdmin对象    @Resource    private RabbitAdmin rabbitAdmin;    //初始化rabbitAdmin对象    @Bean    public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory) {        RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory);        // 只有设置为 true，spring 才会加载 RabbitAdmin 这个类        rabbitAdmin.setAutoStartup(true);        return rabbitAdmin;    }    //实例化bean后，也就是Bean的后置处理器    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        //创建交换机        rabbitAdmin.declareExchange(rabbitmqDemoDirectExchange());        //创建队列        rabbitAdmin.declareQueue(rabbitmqDemoDirectQueue());        return null;    }}</code></pre><p>这样启动生产者就会自动创建交换机和队列，不用等到发送消息才创建。</p><p>消费者需要加一点代码：</p><pre><code class="java">@Component//使用queuesToDeclare属性，如果不存在则会创建队列@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC))public class RabbitDemoConsumer {    //...省略}</code></pre><p>这样，无论生产者还是消费者先启动都不会出现问题了~</p><blockquote><p>代码地址：<a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><h1 id="五、RabbitMQ中的组成部分"><a href="#五、RabbitMQ中的组成部分" class="headerlink" title="五、RabbitMQ中的组成部分"></a>五、RabbitMQ中的组成部分</h1><p>从上面的HelloWord例子中，我们大概也能体验到一些，就是RabbitMQ的组成，它是有这几部分：</p><ul><li>Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。</li><li>Exchange：消息队列交换机。<strong>按一定的规则将消息路由转发到某个队列</strong>。</li><li>Queue：消息队列，存储消息的队列。</li><li>Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。</li><li>Consumer：消息消费者。消费队列中存储的消息。</li></ul><p>这些组成部分是如何协同工作的呢，大概的流程如下，请看下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/1737728b72852d77?w=620&h=344&f=png&s=18810" srcset="/img/loading.gif" alt=""></p><ul><li>消息生产者连接到RabbitMQ Broker，创建connection，开启channel。</li><li>生产者声明交换机类型、名称、是否持久化等。</li><li>生产者发送消息，并指定消息是否持久化等属性和routing key。</li><li>exchange收到消息之后，<strong>根据routing key路由到跟当前交换机绑定的相匹配的队列</strong>里面。</li><li>消费者监听接收到消息之后开始业务处理。</li></ul><h1 id="六、Exchange的四种类型以及用法"><a href="#六、Exchange的四种类型以及用法" class="headerlink" title="六、Exchange的四种类型以及用法"></a>六、Exchange的四种类型以及用法</h1><p>从上面的工作流程可以看出，实际上有个关键的组件Exchange，因为<strong>消息发送到RabbitMQ后首先要经过Exchange路由才能找到对应的Queue</strong>。</p><p>实际上Exchange类型有四种，根据不同的类型工作的方式也有所不同。在HelloWord例子中，我们就使用了比较简单的<strong>Direct Exchange</strong>，翻译就是直连交换机。其余三种分别是：<strong>Fanout exchange、Topic exchange、Headers exchange</strong>。</p><h2 id="6-1-Direct-Exchange"><a href="#6-1-Direct-Exchange" class="headerlink" title="6.1 Direct Exchange"></a>6.1 Direct Exchange</h2><p>见文知意，直连交换机意思是此交换机需要绑定一个队列，要求<strong>该消息与一个特定的路由键完全匹配</strong>。简单点说就是一对一的，点对点的发送。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/173773fe45569885?w=468&h=267&f=png&s=65093" srcset="/img/loading.gif" alt=""></p><p>完整的代码就是上面的HelloWord的例子，不再重复代码。</p><h2 id="6-2-Fanout-exchange"><a href="#6-2-Fanout-exchange" class="headerlink" title="6.2 Fanout exchange"></a>6.2 Fanout exchange</h2><p>这种类型的交换机需要将队列绑定到交换机上。<strong>一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上</strong>。很像子网广播，每台子网内的主机都获得了一份复制的消息。简单点说就是发布订阅。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/173774203ee5afd3?w=465&h=299&f=png&s=79778" srcset="/img/loading.gif" alt=""></p><p>代码怎么写呢，演示一下：</p><p>首先要先配置交换机和队列的名称：</p><pre><code class="java">public class RabbitMQConfig {    /**     * RabbitMQ的FANOUT_EXCHANG交换机类型的队列 A 的名称     */    public static final String FANOUT_EXCHANGE_QUEUE_TOPIC_A = &quot;fanout.A&quot;;    /**     * RabbitMQ的FANOUT_EXCHANG交换机类型的队列 B 的名称     */    public static final String FANOUT_EXCHANGE_QUEUE_TOPIC_B = &quot;fanout.B&quot;;    /**     * RabbitMQ的FANOUT_EXCHANG交换机类型的名称     */    public static final String FANOUT_EXCHANGE_DEMO_NAME = &quot;fanout.exchange.demo.name&quot;;}</code></pre><p>再配置FanoutExchange类型的交换机和A、B两个队列，并且绑定。这种类型不需要配置routing key：</p><pre><code class="java">@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    @Resource    private RabbitAdmin rabbitAdmin;    @Bean    public Queue fanoutExchangeQueueA() {        //队列A        return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A, true, false, false);    }    @Bean    public Queue fanoutExchangeQueueB() {        //队列B        return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_B, true, false, false);    }    @Bean    public FanoutExchange rabbitmqDemoFanoutExchange() {        //创建FanoutExchange类型交换机        return new FanoutExchange(RabbitMQConfig.FANOUT_EXCHANGE_DEMO_NAME, true, false);    }    @Bean    public Binding bindFanoutA() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(fanoutExchangeQueueA()).to(rabbitmqDemoFanoutExchange());    }    @Bean    public Binding bindFanoutB() {        //队列B绑定到FanoutExchange交换机        return BindingBuilder.bind(fanoutExchangeQueueB()).to(rabbitmqDemoFanoutExchange());    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        //启动项目即创建交换机和队列        rabbitAdmin.declareExchange(rabbitmqDemoFanoutExchange());        rabbitAdmin.declareQueue(fanoutExchangeQueueB());        rabbitAdmin.declareQueue(fanoutExchangeQueueA());        return null;    }}</code></pre><p>创建service发布消息的方法：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    @Resource    private RabbitTemplate rabbitTemplate;    //发布消息    @Override    public String sendMsgByFanoutExchange(String msg) throws Exception {        Map&lt;String, Object&gt; message = getMessage(msg);        try {            rabbitTemplate.convertAndSend(RabbitMQConfig.FANOUT_EXCHANGE_DEMO_NAME, &quot;&quot;, message);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }    //组装消息体    private Map&lt;String, Object&gt; getMessage(String msg) {        String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32);        String sendTime = sdf.format(new Date());        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msgId&quot;, msgId);        map.put(&quot;sendTime&quot;, sendTime);        map.put(&quot;msg&quot;, msg);        return map;    }}</code></pre><p>Controller接口：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    /**     * 发布消息     *     * @author java技术爱好者     */    @PostMapping(&quot;/publish&quot;)    public String publish(@RequestParam(name = &quot;msg&quot;) String msg) throws Exception {        return rabbitMQService.sendMsgByFanoutExchange(msg);    }}</code></pre><p>接着在消费者项目这边，创建两个队列的监听类，监听队列进行消费：</p><pre><code class="java">@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A))public class FanoutExchangeConsumerA {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列A收到消息：&quot; + map.toString());    }}</code></pre><pre><code class="java">@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_B))public class FanoutExchangeConsumerB {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列B收到消息：&quot; + map.toString());    }}</code></pre><p>然后启动生产者和消费者两个项目，可以看到管理界面创建了一个FanoutExchange交换机和两个队列，并且绑定了：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737c7793f971244?w=647&h=367&f=png&s=27283" srcset="/img/loading.gif" alt=""></p><p>使用POSTMAN进行发送消息，测试：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737c7829f71b8f2?w=944&h=276&f=png&s=22267" srcset="/img/loading.gif" alt=""></p><p>然后可以看到控制台，两个队列同时都收到了相同的消息，形成了发布订阅的效果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737c794ca2a0106?w=961&h=95&f=png&s=32829" srcset="/img/loading.gif" alt=""></p><h2 id="6-3-Topic-Exchange"><a href="#6-3-Topic-Exchange" class="headerlink" title="6.3 Topic Exchange"></a>6.3 Topic Exchange</h2><p>直接翻译的话叫做主题交换机，如果从用法上面翻译可能叫通配符交换机会更加贴切。这种交换机是使用通配符去匹配，路由到对应的队列。通配符有两种：”*” 、 “#”。需要注意的是通配符前面必须要加上”.”符号。</p><p><code>*</code> 符号：有且只匹配一个词。比如 <code>a.*</code>可以匹配到”a.b”、”a.c”，但是匹配不了”a.b.c”。</p><p><code>#</code> 符号：匹配一个或多个词。比如”rabbit.#”既可以匹配到”rabbit.a.b”、”rabbit.a”，也可以匹配到”rabbit.a.b.c”。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737cc2e35abb0c2?w=787&h=472&f=png&s=44593" srcset="/img/loading.gif" alt=""></p><p>废话不多说，代码演示一下：</p><p>依然是配置TopicExchange名称和三个队列的名称：</p><pre><code class="java">    /**     * RabbitMQ的TOPIC_EXCHANGE交换机名称     */    public static final String TOPIC_EXCHANGE_DEMO_NAME = &quot;topic.exchange.demo.name&quot;;    /**     * RabbitMQ的TOPIC_EXCHANGE交换机的队列A的名称     */    public static final String TOPIC_EXCHANGE_QUEUE_A = &quot;topic.queue.a&quot;;    /**     * RabbitMQ的TOPIC_EXCHANGE交换机的队列B的名称     */    public static final String TOPIC_EXCHANGE_QUEUE_B = &quot;topic.queue.b&quot;;    /**     * RabbitMQ的TOPIC_EXCHANGE交换机的队列C的名称     */    public static final String TOPIC_EXCHANGE_QUEUE_C = &quot;topic.queue.c&quot;;</code></pre><p>然后还是老配方，配置交换机和队列，然后绑定，创建：</p><pre><code class="java">@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    //省略...    @Bean    public TopicExchange rabbitmqDemoTopicExchange() {        //配置TopicExchange交换机        return new TopicExchange(RabbitMQConfig.TOPIC_EXCHANGE_DEMO_NAME, true, false);    }    @Bean    public Queue topicExchangeQueueA() {        //创建队列1        return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A, true, false, false);    }    @Bean    public Queue topicExchangeQueueB() {        //创建队列2        return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B, true, false, false);    }    @Bean    public Queue topicExchangeQueueC() {        //创建队列3        return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C, true, false, false);    }    @Bean    public Binding bindTopicA() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(topicExchangeQueueB())                .to(rabbitmqDemoTopicExchange())                .with(&quot;a.*&quot;);    }    @Bean    public Binding bindTopicB() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(topicExchangeQueueC())                .to(rabbitmqDemoTopicExchange())                .with(&quot;a.*&quot;);    }    @Bean    public Binding bindTopicC() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(topicExchangeQueueA())                .to(rabbitmqDemoTopicExchange())                .with(&quot;rabbit.#&quot;);    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        rabbitAdmin.declareExchange(rabbitmqDemoTopicExchange());        rabbitAdmin.declareQueue(topicExchangeQueueA());        rabbitAdmin.declareQueue(topicExchangeQueueB());        rabbitAdmin.declareQueue(topicExchangeQueueC());        return null;    }}</code></pre><p>然后写一个发送消息的service方法：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    @Override    public String sendMsgByTopicExchange(String msg, String routingKey) throws Exception {        Map&lt;String, Object&gt; message = getMessage(msg);        try {            //发送消息            rabbitTemplate.convertAndSend(RabbitMQConfig.TOPIC_EXCHANGE_DEMO_NAME, routingKey, message);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }}</code></pre><p>写一个Controller接口：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    @Resource    private RabbitMQService rabbitMQService;    /**     * 通配符交换机发送消息     *     * @author java技术爱好者     */    @PostMapping(&quot;/topicSend&quot;)    public String topicSend(@RequestParam(name = &quot;msg&quot;) String msg, @RequestParam(name = &quot;routingKey&quot;) String routingKey) throws Exception {        return rabbitMQService.sendMsgByTopicExchange(msg, routingKey);    }}</code></pre><p>生产者这边写完，就写消费端，消费端比较简单，写三个监听类：</p><pre><code class="java">@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A))public class TopicExchangeConsumerA {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A + &quot;]收到消息：&quot; + map.toString());    }}@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B))public class TopicExchangeConsumerB {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B+ &quot;]收到消息：&quot; + map.toString());    }}@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C))public class TopicExchangeConsumerC {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C + &quot;]收到消息：&quot; + map.toString());    }}</code></pre><p>大功告成，然后启动项目开始调试。启动成功后可以看到队列和路由键绑定的关系：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17380fc32fda0fa2?w=518&h=379&f=png&s=26158" srcset="/img/loading.gif" alt=""></p><p>通过POSTMAN进行测试，测试一下 rabbit.# 的路由键是否能够匹配成功：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17380fd5053e38bc?w=934&h=253&f=png&s=23565" srcset="/img/loading.gif" alt=""></p><p>测试成功，队列A消费到消息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17380fe5e090ae23?w=1104&h=46&f=png&s=14452" srcset="/img/loading.gif" alt=""></p><p>接着测试 a.* 路由键，发送 routingKey = a.b ：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17381008ddcc1a5b?w=937&h=233&f=png&s=21310" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/173810049898ae69?w=948&h=51&f=png&s=12864" srcset="/img/loading.gif" alt=""></p><p>比较常用的就是以上三种：直连(DirectExchange)，发布订阅(FanoutExchange)，通配符(TopicExchange)。熟练运用这三种交换机类型，基本上可以解决大部分的业务场景。</p><p>实际上稍微思考一下，可以发现通配符(TopicExchange)这种模式其实是可以达到直连(DirectExchange)和发布订阅(FanoutExchange)这两种的效果的。</p><p>FanoutExchange不需要绑定routingKey，所以性能相对TopicExchange会好一点。</p><h2 id="6-4-Headers-Exchange"><a href="#6-4-Headers-Exchange" class="headerlink" title="6.4 Headers Exchange"></a>6.4 Headers Exchange</h2><p>这种交换机用的相对没这么多。<strong>它跟上面三种有点区别，它的路由不是用routingKey进行路由匹配，而是在匹配请求头中所带的键值进行路由</strong>。如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/1738499671e1955e?w=828&h=252&f=png&s=34357" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/173849a014d576e5?w=799&h=252&f=png&s=34238" srcset="/img/loading.gif" alt=""></p><p>创建队列需要设置绑定的头部信息，有两种模式：<strong>全部匹配和部分匹配</strong>。如上图所示，交换机会根据生产者发送过来的头部信息携带的键值去匹配队列绑定的键值，路由到对应的队列。代码怎么实现呢，往下看演示代码：</p><p>首先还是需要定义交换机名称，队列名称：</p><pre><code class="java">    /**     * HEADERS_EXCHANGE交换机名称     */    public static final String HEADERS_EXCHANGE_DEMO_NAME = &quot;headers.exchange.demo.name&quot;;    /**     * RabbitMQ的HEADERS_EXCHANGE交换机的队列A的名称     */    public static final String HEADERS_EXCHANGE_QUEUE_A = &quot;headers.queue.a&quot;;    /**     * RabbitMQ的HEADERS_EXCHANGE交换机的队列B的名称     */    public static final String HEADERS_EXCHANGE_QUEUE_B = &quot;headers.queue.b&quot;;</code></pre><p>然后设置交换机，队列，进行绑定：</p><pre><code class="java">@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    @Bean    public Queue headersQueueA() {        return new Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A, true, false, false);    }    @Bean    public Queue headersQueueB() {        return new Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B, true, false, false);    }    @Bean    public HeadersExchange rabbitmqDemoHeadersExchange() {        return new HeadersExchange(RabbitMQConfig.HEADERS_EXCHANGE_DEMO_NAME, true, false);    }    @Bean    public Binding bindHeadersA() {        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;key_one&quot;, &quot;java&quot;);        map.put(&quot;key_two&quot;, &quot;rabbit&quot;);        //全匹配        return BindingBuilder.bind(headersQueueA())                .to(rabbitmqDemoHeadersExchange())                .whereAll(map).match();    }    @Bean    public Binding bindHeadersB() {        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;headers_A&quot;, &quot;coke&quot;);        map.put(&quot;headers_B&quot;, &quot;sky&quot;);        //部分匹配        return BindingBuilder.bind(headersQueueB())                .to(rabbitmqDemoHeadersExchange())                .whereAny(map).match();    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        rabbitAdmin.declareExchange(rabbitmqDemoHeadersExchange());        rabbitAdmin.declareQueue(headersQueueA());        rabbitAdmin.declareQueue(headersQueueB());        return null;    }}</code></pre><p>再写一个Service方法发送消息:</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    @Resource    private RabbitTemplate rabbitTemplate;    @Override    public String sendMsgByHeadersExchange(String msg, Map&lt;String, Object&gt; map) throws Exception {        try {            MessageProperties messageProperties = new MessageProperties();            //消息持久化            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);            messageProperties.setContentType(&quot;UTF-8&quot;);            //添加消息            messageProperties.getHeaders().putAll(map);            Message message = new Message(msg.getBytes(), messageProperties);            rabbitTemplate.convertAndSend(RabbitMQConfig.HEADERS_EXCHANGE_DEMO_NAME, null, message);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }}</code></pre><p>再写一个Controller接口：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    @Resource    private RabbitMQService rabbitMQService;    @PostMapping(&quot;/headersSend&quot;)    @SuppressWarnings(&quot;unchecked&quot;)    public String headersSend(@RequestParam(name = &quot;msg&quot;) String msg,                              @RequestParam(name = &quot;json&quot;) String json) throws Exception {        ObjectMapper mapper = new ObjectMapper();        Map&lt;String, Object&gt; map = mapper.readValue(json, Map.class);        return rabbitMQService.sendMsgByHeadersExchange(msg, map);    }}</code></pre><p>生产者这边写完了，再写两个队列的监听类进行消费：</p><pre><code class="java">@Componentpublic class HeadersExchangeConsumerA {    @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A))    public void process(Message message) throws Exception {        MessageProperties messageProperties = message.getMessageProperties();        String contentType = messageProperties.getContentType();        System.out.println(&quot;队列[&quot; + RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A + &quot;]收到消息：&quot; + new String(message.getBody(), contentType));    }}@Componentpublic class HeadersExchangeConsumerB {    @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B))    public void process(Message message) throws Exception {        MessageProperties messageProperties = message.getMessageProperties();        String contentType = messageProperties.getContentType();        System.out.println(&quot;队列[&quot; + RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B + &quot;]收到消息：&quot; + new String(message.getBody(), contentType));    }}</code></pre><p>大功告成~启动项目，打开管理界面，我们可以看到交换机绑定队列的信息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a470aa42de3?w=570&h=364&f=png&s=31572" srcset="/img/loading.gif" alt=""></p><p>跟上面示意图一样~证明没有问题，一切尽在掌握之中。使用POSTMAN发送，测试全匹配的队列A：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a81c6f1551f?w=939&h=264&f=png&s=24756" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a87b820f9f3?w=471&h=63&f=png&s=6969" srcset="/img/loading.gif" alt=""></p><p>再测试部分匹配的队列B：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a9b2293c0e2?w=930&h=258&f=png&s=23945" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a9f8bbab549?w=472&h=76&f=png&s=7341" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章就先写到这里了。回顾一下学了哪些：</p><ul><li>什么是消息队列？为什么使用消息队列？</li><li>RabbitMQ的特点、组成部分、工作流程</li><li>安装RabbitMQ，以及完成一个HelloWord小案例</li><li>RabbitMQ交换机的四种类型的特点，以及使用方法</li></ul><p>实际上RabbitMQ还有事务机制和负载均衡这些还没讲，因为篇幅实在有点长了，差不多5千字了。所以放在下期讲吧，尽请期待一下。</p><p>上面所有例子的代码都上传github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>如果你觉得这篇文章对你有用，点个赞吧</strong>~</p><p><strong>你的点赞是我创作的最大动力</strong>~</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZooKeeper入门</title>
    <link href="/2020/07/26/ZooKeeper%E5%85%A5%E9%97%A8/"/>
    <url>/2020/07/26/ZooKeeper%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/12/17343787ae8f3533?w=538&h=629&f=png&s=42414" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很多时候，我们都可以在各种框架应用中看到ZooKeeper的身影，比如Kafka中间件，Dubbo框架，Hadoop等等。为什么到处都看到ZooKeeper？</p><h1 id="一、什么是ZooKeeper"><a href="#一、什么是ZooKeeper" class="headerlink" title="一、什么是ZooKeeper"></a>一、什么是ZooKeeper</h1><p><strong>ZooKeeper是一个分布式服务协调框架</strong>，提供了分布式数据一致性的解决方案，基于ZooKeeper的<strong>数据结构，Watcher，选举机制</strong>等特点，可以<strong>实现数据的发布/订阅，软负载均衡，命名服务，统一配置管理，分布式锁，集群管理</strong>等等。</p><h1 id="二、为什么使用ZooKeeper"><a href="#二、为什么使用ZooKeeper" class="headerlink" title="二、为什么使用ZooKeeper"></a>二、为什么使用ZooKeeper</h1><p>ZooKeeper能保证：</p><ul><li>更新请求顺序进行。来自同一个client的更新请求按其发送顺序依次执行</li><li>数据更新原子性。一次数据更新要么成功，要么失败</li><li><strong>全局唯一数据视图</strong>。client无论连接到哪个server，数据视图都是一致的</li><li><strong>实时性</strong>。在一定时间范围内，client读到的数据是最新的</li></ul><h1 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h1><p>ZooKeeper的数据结构和Unix文件系统很类似，总体上可以看做是一棵树，每一个节点称之为一个ZNode，每一个ZNode<strong>默认能存储1M的数据</strong>。每一个ZNode可<strong>通过唯一的路径标识</strong>。如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/9/173343f042cc21bf?w=450&h=317&f=png&s=19615" srcset="/img/loading.gif" alt=""></p><p>创建ZNode时，可以指定以下四种类型，包括：</p><ul><li><strong>PERSISTENT，持久性ZNode</strong>。创建后，即使客户端与服务端断开连接也不会删除，只有客户端主动删除才会消失。</li><li><strong>PERSISTENT_SEQUENTIAL，持久性顺序编号ZNode</strong>。和持久性节点一样不会因为断开连接后而删除，并且ZNode的编号会自动增加。</li><li><strong>EPHEMERAL，临时性ZNode</strong>。客户端与服务端断开连接，该ZNode会被删除。</li><li><strong>EPEMERAL_SEQUENTIAL，临时性顺序编号ZNode</strong>。和临时性节点一样，断开连接会被删除，并且ZNode的编号会自动增加。</li></ul><h1 id="四、监听通知机制"><a href="#四、监听通知机制" class="headerlink" title="四、监听通知机制"></a>四、监听通知机制</h1><p>Watcher是基于<strong>观察者模式</strong>实现的一种机制。如果我们需要实现当某个ZNode节点发生变化时收到通知，就可以使用Watcher监听器。</p><p><strong>客户端通过设置监视点（watcher）向 ZooKeeper 注册需要接收通知的 znode，在 znode 发生变化时 ZooKeeper 就会向客户端发送消息</strong>。</p><p><strong>这种通知机制是一次性的</strong>。一旦watcher被触发，ZooKeeper就会从相应的存储中删除。如果需要不断监听ZNode的变化，可以在收到通知后再设置新的watcher注册到ZooKeeper。</p><p>监视点的类型有很多，如<strong>监控ZNode数据变化、监控ZNode子节点变化、监控ZNode 创建或删除</strong>。</p><h1 id="五、选举机制"><a href="#五、选举机制" class="headerlink" title="五、选举机制"></a>五、选举机制</h1><p>ZooKeeper是一个高可用的应用框架，因为ZooKeeper是支持集群的。ZooKeeper在集群状态下，配置文件是不会指定Master和Slave，而是在ZooKeeper服务器初始化时就在内部进行选举，产生一台做为Leader，多台做为Follower，并且遵守半数可用原则。</p><p>由于遵守半数可用原则，所以5台服务器和6台服务器，实际上最大允许宕机数量都是3台，所以为了节约成本，<strong>集群的服务器数量一般设置为奇数</strong>。</p><p>如果在运行时，<strong>如果长时间无法和Leader保持连接的话，则会再次进行选举，产生新的Leader，以保证服务的可用</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339067a2c6c061?w=600&h=185&f=png&s=87756" srcset="/img/loading.gif" alt=""></p><h1 id="六、初の体验"><a href="#六、初の体验" class="headerlink" title="六、初の体验"></a>六、初の体验</h1><p>首先在<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">官网</a>下载ZooKeeper，我这里用的是3.3.6版本。</p><p>然后解压，复制一下/conf目录下的zoo_sample.cfg文件，重命名为zoo.cfg。</p><p>修改zoo.cfg中dataDir的值，并创建对应的目录：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339300106f99c6?w=515&h=245&f=png&s=18915" srcset="/img/loading.gif" alt=""></p><p>最后到/bin目录下启动，我用的是window系统，所以启动zkServer.cmd，双击即可：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/1733937df5bee4e3?w=663&h=180&f=png&s=28318" srcset="/img/loading.gif" alt=""></p><p>启动成功的话就可以看到这个对话框：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339369078c2cc2?w=961&h=407&f=png&s=51377" srcset="/img/loading.gif" alt=""></p><p>可视化界面的话，我推荐使用<code>ZooInspector</code>，操作比较简便：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/173393a9befbac48?w=767&h=156&f=png&s=10149" srcset="/img/loading.gif" alt=""></p><h2 id="6-1-使用java连接ZooKeeper"><a href="#6-1-使用java连接ZooKeeper" class="headerlink" title="6.1 使用java连接ZooKeeper"></a>6.1 使用java连接ZooKeeper</h2><p>首先引入Maven依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>接着我们写一个Main方法，进行操作：</p><pre><code class="java">    //连接地址及端口号    private static final String SERVER_HOST = &quot;127.0.0.1:2181&quot;;    //会话超时时间    private static final int SESSION_TIME_OUT = 2000;    public static void main(String[] args) throws Exception {        //参数一：服务端地址及端口号        //参数二：超时时间        //参数三：监听器        ZooKeeper zooKeeper = new ZooKeeper(SERVER_HOST, SESSION_TIME_OUT, new Watcher() {            @Override            public void process(WatchedEvent watchedEvent) {                //获取事件的状态                Event.KeeperState state = watchedEvent.getState();                //判断是否是连接事件                if (Event.KeeperState.SyncConnected == state) {                    Event.EventType type = watchedEvent.getType();                    if (Event.EventType.None == type) {                        System.out.println(&quot;zk客户端已连接...&quot;);                    }                }            }        });        zooKeeper.create(&quot;/java&quot;, &quot;Hello World&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        System.out.println(&quot;新增ZNode成功&quot;);        zooKeeper.close();    }</code></pre><p>创建一个持久性ZNode，路径是/java，值为”Hello World”：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339630f8746e96?w=443&h=168&f=png&s=10357" srcset="/img/loading.gif" alt=""></p><h1 id="七、API概述"><a href="#七、API概述" class="headerlink" title="七、API概述"></a>七、API概述</h1><h2 id="7-1-创建"><a href="#7-1-创建" class="headerlink" title="7.1 创建"></a>7.1 创建</h2><pre><code class="java">public String create(final String path, byte data[], List&lt;ACL&gt; acl, CreateMode createMode)</code></pre><p>参数解释：</p><ul><li>path ZNode路径</li><li>data ZNode存储的数据</li><li>acl ACL权限控制</li><li>createMode ZNode类型</li></ul><p>ACL权限控制，有三个是ZooKeeper定义的常用权限，在ZooDefs.Ids类中：</p><pre><code class="java">/** * This is a completely open ACL. * 完全开放的ACL，任何连接的客户端都可以操作该属性znode */public final ArrayList&lt;ACL&gt; OPEN_ACL_UNSAFE = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.ALL, ANYONE_ID_UNSAFE)));/** * This ACL gives the creators authentication id&#39;s all permissions. * 只有创建者才有ACL权限 */public final ArrayList&lt;ACL&gt; CREATOR_ALL_ACL = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.ALL, AUTH_IDS)));/** * This ACL gives the world the ability to read. * 只能读取ACL */public final ArrayList&lt;ACL&gt; READ_ACL_UNSAFE = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.READ, ANYONE_ID_UNSAFE)));</code></pre><p>createMode就是前面讲过的四种ZNode类型：</p><pre><code class="java">public enum CreateMode {    /**     * 持久性ZNode     */    PERSISTENT (0, false, false),    /**     * 持久性自动增加顺序号ZNode     */    PERSISTENT_SEQUENTIAL (2, false, true),    /**     * 临时性ZNode     */    EPHEMERAL (1, true, false),    /**     * 临时性自动增加顺序号ZNode     */    EPHEMERAL_SEQUENTIAL (3, true, true);}</code></pre><h2 id="7-2-查询"><a href="#7-2-查询" class="headerlink" title="7.2 查询"></a>7.2 查询</h2><pre><code class="java">//同步获取节点数据public byte[] getData(String path, boolean watch, Stat stat){    ...}//异步获取节点数据public void getData(final String path, Watcher watcher, DataCallback cb, Object ctx){    ...}</code></pre><p>同步getData()方法中的stat参数是用于接收返回的节点描述信息：</p><pre><code class="java">public byte[] getData(final String path, Watcher watcher, Stat stat){    //省略...    GetDataResponse response = new GetDataResponse();    //发送请求到ZooKeeper服务器，获取到response    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (stat != null) {        //把response的Stat赋值到传入的stat中        DataTree.copyStat(response.getStat(), stat);    }}</code></pre><p>使用同步getData()获取数据：</p><pre><code class="java">    //数据的描述信息，包括版本号，ACL权限，子节点信息等等    Stat stat = new Stat();    //返回结果是byte[]数据，getData()方法底层会把描述信息复制到stat对象中    byte[] bytes = zooKeeper.getData(&quot;/java&quot;, false, stat);    //打印结果    System.out.println(&quot;ZNode的数据data:&quot; + new String(bytes));//Hello World    System.out.println(&quot;获取到dataVersion版本号:&quot; + stat.getVersion());//默认数据版本号是0</code></pre><h2 id="7-3-更新"><a href="#7-3-更新" class="headerlink" title="7.3 更新"></a>7.3 更新</h2><pre><code class="java">public Stat setData(final String path, byte data[], int version){    ...}</code></pre><p>值得注意的是第三个参数version，<strong>使用CAS机制，这是为了防止多个客户端同时更新节点数据，所以需要在更新时传入版本号，每次更新都会使版本号+1</strong>，如果服务端接收到版本号，对比发现不一致的话，则会抛出异常。</p><p>所以，在更新前需要先查询获取到版本号，否则你不知道当前版本号是多少，就没法更新：</p><pre><code class="java">    //获取节点描述信息    Stat stat = new Stat();    zooKeeper.getData(&quot;/java&quot;, false, stat);    System.out.println(&quot;更新ZNode数据...&quot;);    //更新操作，传入路径，更新值，版本号三个参数,返回结果是新的描述信息    Stat setData = zooKeeper.setData(&quot;/java&quot;, &quot;fly!!!&quot;.getBytes(), stat.getVersion());    System.out.println(&quot;更新后的版本号为：&quot; + setData.getVersion());//更新后的版本号为：1</code></pre><p>更新后，版本号增加了：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733999126b62716?w=440&h=320&f=png&s=19876" srcset="/img/loading.gif" alt=""></p><p>如果传入的版本参数是”-1”，就是告诉zookeeper服务器，客户端需要基于数据的最新版本进行更新操作。但是-1并不是一个合法的版本号，而是一个标识符。</p><h2 id="7-4-删除"><a href="#7-4-删除" class="headerlink" title="7.4 删除"></a>7.4 删除</h2><pre><code class="java">public void delete(final String path, int version){    ...}</code></pre><ul><li>path 删除节点的路径</li><li>version 版本号</li></ul><p>这里也需要传入版本号，调用getData()方法即可获取到版本号，很简单：</p><pre><code class="java">Stat stat = new Stat();zooKeeper.getData(&quot;/java&quot;, false, stat);//删除ZNodezooKeeper.delete(&quot;/java&quot;, stat.getVersion());</code></pre><h2 id="7-5-watcher机制"><a href="#7-5-watcher机制" class="headerlink" title="7.5 watcher机制"></a>7.5 watcher机制</h2><p>在上面第三点提到，ZooKeeper是可以使用通知监听机制，当ZNode发生变化会收到通知消息，进行处理。基于watcher机制，ZooKeeper能玩出很多花样。怎么使用？</p><p>ZooKeeper的通知监听机制，总的来说可以分为三个过程：</p><p>①客户端注册 Watcher<br>②服务器处理 Watcher<br>③客户端回调 Watcher客户端。</p><p>注册 watcher 有 4 种方法，new ZooKeeper()、getData()、exists()、getChildren()。下面演示一下使用exists()方法注册watcher：</p><p>首先<strong>需要实现Watcher接口</strong>，新建一个监听器：</p><pre><code class="java">public class MyWatcher implements Watcher {    @Override    public void process(WatchedEvent event) {        //获取事件类型        Event.EventType eventType = event.getType();        //通知状态        Event.KeeperState eventState = event.getState();        //节点路径        String eventPath = event.getPath();        System.out.println(&quot;监听到的事件类型:&quot; + eventType.name());        System.out.println(&quot;监听到的通知状态:&quot; + eventState.name());        System.out.println(&quot;监听到的ZNode路径:&quot; + eventPath);    }}</code></pre><p>然后调用exists()方法，注册监听器：</p><pre><code class="java">zooKeeper.exists(&quot;/java&quot;, new MyWatcher());//对ZNode进行更新数据的操作，触发监听器zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), -1);</code></pre><p>然后在控制台就可以看到打印的信息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733cd85f8b2bb10?w=682&h=200&f=png&s=48245" srcset="/img/loading.gif" alt=""></p><p>这里我们可以看到<strong>Event.EventType对象就是事件类型</strong>，我们可以对事件类型进行判断，再配合<strong>Event.KeeperState通知状态</strong>，做相关的业务处理，事件类型有哪些？</p><p>打开EventType、KeeperState的源码查看：</p><pre><code class="java">//事件类型是一个枚举public enum EventType {    None (-1),//无    NodeCreated (1),//Watcher监听的数据节点被创建    NodeDeleted (2),//Watcher监听的数据节点被删除    NodeDataChanged (3),//Watcher监听的数据节点内容发生变更    NodeChildrenChanged (4);//Watcher监听的数据节点的子节点列表发生变更}//通知状态也是一个枚举public enum KeeperState {    Unknown (-1),//属性过期    Disconnected (0),//客户端与服务端断开连接    NoSyncConnected (1),//属性过期    SyncConnected (3),//客户端与服务端正常连接    AuthFailed (4),//身份认证失败    ConnectedReadOnly (5),//返回这个状态给客户端，客户端只能处理读请求    SaslAuthenticated(6),//服务器采用SASL做校验时    Expired (-112);//会话session失效}</code></pre><h3 id="7-5-1-watcher的特性"><a href="#7-5-1-watcher的特性" class="headerlink" title="7.5.1 watcher的特性"></a>7.5.1 watcher的特性</h3><ul><li>一次性。一旦watcher被触发，ZK都会从相应的存储中移除。</li></ul><pre><code class="java">    zooKeeper.exists(&quot;/java&quot;, new Watcher() {        @Override        public void process(WatchedEvent event) {            System.out.println(&quot;我是exists()方法的监听器&quot;);        }    });    //对ZNode进行更新数据的操作，触发监听器    zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), -1);    //企图第二次触发监听器    zooKeeper.setData(&quot;/java&quot;, &quot;spring&quot;.getBytes(), -1);</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733cfc7501b447c?w=476&h=149&f=png&s=27289" srcset="/img/loading.gif" alt=""></p><ul><li>串行执行。客户端Watcher回调的过程是一个串行同步的过程，这是为了保证顺序。<pre><code class="java">  zooKeeper.exists(&quot;/java&quot;, new Watcher() {      @Override      public void process(WatchedEvent event) {          System.out.println(&quot;我是exists()方法的监听器&quot;);      }  });  Stat stat = new Stat();  zooKeeper.getData(&quot;/java&quot;, new Watcher() {      @Override      public void process(WatchedEvent event) {          System.out.println(&quot;我是getData()方法的监听器&quot;);      }  }, stat);  //对ZNode进行更新数据的操作，触发监听器  zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), stat.getVersion());</code></pre>打印结果，说明先调用exists()方法的监听器，再调用getData()方法的监听器。因为exists()方法先注册了。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733cf5f77df73f1?w=541&h=140&f=png&s=27151" srcset="/img/loading.gif" alt=""></p><ul><li>轻量级。WatchedEvent是ZK整个Watcher通知机制的最小通知单元。WatchedEvent包含三部分：<strong>通知状态，事件类型，节点路径</strong>。Watcher通知仅仅告诉客户端发生了什么事情，而不会说明事件的具体内容。</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>我记得B站的UP主李永乐说过，<strong>只有你让更多的人生活变得更美好时，自己的生活才能变得更美好。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733d114535c1c80?w=631&h=127&f=png&s=23550" srcset="/img/loading.gif" alt=""></p><p>这句话也是我今年开始写技术分享的一个动力源泉，希望这篇文章对你有用~</p><p>著名的飞行家<strong>马老师</strong>说过：<strong>回城是收费的，而点赞是免费的~</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从秒杀聊到ZooKeeper分布式锁</title>
    <link href="/2020/07/26/%E4%BB%8E%E7%A7%92%E6%9D%80%E8%81%8A%E5%88%B0ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2020/07/26/%E4%BB%8E%E7%A7%92%E6%9D%80%E8%81%8A%E5%88%B0ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/17365f514c2871a0?w=846&h=397&f=png&s=36190" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过<a href="https://juejin.im/post/5f05e96c5188252e5e22d8f4" target="_blank" rel="noopener">《ZooKeeper入门》</a>后，我们学会了ZooKeeper的基本用法。</p><p>实际上ZooKeeper的应用是非常广泛的，实现分布式锁只是其中一种。接下来我们就ZooKeeper实现分布式锁解决<strong>秒杀超卖问题</strong>进行展开。</p><h1 id="一、什么是秒杀超卖问题"><a href="#一、什么是秒杀超卖问题" class="headerlink" title="一、什么是秒杀超卖问题"></a>一、什么是秒杀超卖问题</h1><p>秒杀活动应该都不陌生，不用过多解释。</p><p>不难想象，在这种”秒杀”的场景中，实际上会出现多个用户争抢”资源”的情况，<strong>也就是多个线程同时并发，这种情况是很容易出现数据不准确，也就是超卖问题</strong>。</p><h2 id="1-1-项目演示"><a href="#1-1-项目演示" class="headerlink" title="1.1 项目演示"></a>1.1 项目演示</h2><p>下面使用程序演示，我使用了<strong>SpringBoot2.0、Mybatis、Mybatis-Plus、SpringMVC</strong>搭建了一个简单的项目，github地址：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p>创建一个商品信息表：</p><pre><code class="sql">CREATE TABLE `tb_commodity_info` (  `id` varchar(32) NOT NULL,  `commodity_name` varchar(512) DEFAULT NULL COMMENT &#39;商品名称&#39;,  `commodity_price` varchar(36) DEFAULT &#39;0&#39; COMMENT &#39;商品价格&#39;,  `number` int(10) DEFAULT &#39;0&#39; COMMENT &#39;商品数量&#39;,  `description` varchar(2048) DEFAULT &#39;&#39; COMMENT &#39;商品描述&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;商品信息表&#39;;</code></pre><p>添加一个商品[<strong>叉烧包</strong>]进去：<br><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e32e530bc75a?w=770&h=45&f=png&s=6596" srcset="/img/loading.gif" alt=""></p><p>核心的代码逻辑是这样的：</p><pre><code class="java">    @Override    public boolean purchaseCommodityInfo(String commodityId, Integer number) throws Exception {        //1.先查询数据库中商品的数量        TbCommodityInfo commodityInfo = commodityInfoMapper.selectById(commodityId);        //2.判断商品数量是否大于0，或者购买的数量大于库存        Integer count = commodityInfo.getNumber();        if (count &lt;= 0 || number &gt; count) {            //商品数量小于或者等于0，或者购买的数量大于库存，则返回false            return false;        }        //3.如果库存数量大于0，并且购买的数量小于或者等于库存。则更新商品数量        count -= number;        commodityInfo.setNumber(count);        boolean bool = commodityInfoMapper.updateById(commodityInfo) == 1;        if (bool) {            //如果更新成功，则打印购买商品成功            System.out.println(&quot;购买商品[ &quot; + commodityInfo.getCommodityName() + &quot; ]成功,数量为：&quot; + number);        }        return bool;    }</code></pre><p>逻辑示意图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e422a298bdef?w=719&h=411&f=png&s=35372" srcset="/img/loading.gif" alt=""></p><p>上面这个逻辑，如果单线程请求的话是没有问题的。</p><p>但是多线程的话就出现问题了。现在我就创建多个线程，通过HttpClient进行请求，看会发生什么：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //请求地址        String url = &quot;http://localhost:8080/mall/commodity/purchase&quot;;        //请求参数，商品ID，数量        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;);        map.put(&quot;number&quot;, &quot;1&quot;);        //创建10个线程通过HttpClient进行发送请求，测试        for (int i = 0; i &lt; 10; i++) {            //这个线程的逻辑仅仅是发送请求            CommodityThread commodityThread = new CommodityThread(url, map);            commodityThread.start();        }    }</code></pre><p>说明一下，叉烧包的数量是100，这里有10个线程同时去购买，假设都购买成功的话，库存数量应该是90。</p><p>实际上，10个线程的确都购买成功了：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e52bcd8c8410?w=348&h=182&f=png&s=10183" srcset="/img/loading.gif" alt=""></p><p>但是数据库的商品库存，却不准确：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e5372723db05?w=777&h=47&f=png&s=7006" srcset="/img/loading.gif" alt=""></p><h1 id="二、尝试使用本地锁"><a href="#二、尝试使用本地锁" class="headerlink" title="二、尝试使用本地锁"></a>二、尝试使用本地锁</h1><p>上面的场景，大概流程如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/16/173576192aaa3672?w=827&h=458&f=png&s=71783" srcset="/img/loading.gif" alt=""></p><p>可以看出问题的<strong>关键在于两个线程”同时”去查询剩余的库存，然后更新库存导致的</strong>。要解决这个问题，其实<strong>只要保证多个线程在这段逻辑是顺序执行即可，也就是加锁</strong>。</p><p>本地锁JDK提供有两种：synchronized和Lock锁。</p><p>两种方式都可以，我这里为了简便，使用synchronized：</p><pre><code class="java">    //使用synchronized修饰方法    @Override    public synchronized boolean purchaseCommodityInfo(String commodityId, Integer number) throws Exception {        //省略...    }</code></pre><p>然后再测试刚刚多线程并发抢购的情况，看看结果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352d90c1ca872c?w=779&h=50&f=png&s=6771" srcset="/img/loading.gif" alt=""></p><p>问题得到解决！！！</p><p>你以为事情就这样结束了吗，看了看进度条，发现事情并不简单。</p><p>我们知道在实际项目中，往往不会只部署一台服务器，所以不妨我们启动两台服务器，端口号分别是8080、8081，模拟实际项目的场景：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352e08465b09fb?w=592&h=391&f=png&s=38702" srcset="/img/loading.gif" alt=""></p><p>写一个交替请求的测试脚本，模拟多台服务器分别处理请求，用户秒杀抢购的场景：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //请求地址        String url = &quot;http://localhost:%s/mall/commodity/purchase&quot;;        //请求参数，商品ID，数量        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;);        map.put(&quot;number&quot;, &quot;1&quot;);        //创建10个线程通过HttpClient进行发送请求，测试        for (int i = 0; i &lt; 10; i++) {            //8080、8081交替请求，每个服务器处理5个请求            String port = &quot;808&quot; + (i % 2);            CommodityThread commodityThread = new CommodityThread(String.format(url, port), map);            commodityThread.start();        }    }</code></pre><p>首先看购买的情况，肯定都是购买成功的:</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352ecdc9af8253?w=615&h=302&f=png&s=36798" srcset="/img/loading.gif" alt=""></p><p>关键是库存数量是否正确：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352edee5171303?w=786&h=50&f=png&s=7086" srcset="/img/loading.gif" alt=""></p><p>有10个请求购买成功，库存应该是90才对，这里库存是95。事实证明<strong>本地锁是不能解决多台服务器秒杀抢购出现超卖的问题</strong>。</p><p>为什么会这样呢，请看示意图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352fc7c52787c9?w=650&h=458&f=png&s=63889" srcset="/img/loading.gif" alt=""></p><p>其实和多线程问题是差不多的原因，<strong>多个服务器去查询数据库，获取到相同的库存，然后更新库存，导致数据不正确</strong>。要保证库存的数量正确，<strong>关键在于多台服务器要保证只能一台服务器在执行这段逻辑</strong>，也就是要加分布式锁。</p><p>这也体现出分布式锁的作用，就是要保证多台服务器只能有一台服务器执行。</p><p>分布式锁有三种实现方式，分别是redis、ZooKeeper、数据库(比如mysql)。</p><h1 id="三、使用ZooKeeper实现分布式锁"><a href="#三、使用ZooKeeper实现分布式锁" class="headerlink" title="三、使用ZooKeeper实现分布式锁"></a>三、使用ZooKeeper实现分布式锁</h1><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h2><p>实际上是利用ZooKeeper的临时顺序节点的特性实现分布式锁。怎么实现呢？</p><p>假设现在有一个客户端A，需要加锁，那么就在”/Lock”路径下创建一个临时顺序节点。然后获取”/Lock”下的节点列表，判断自己的序号是否是最小的，如果是最小的序号，则加锁成功！</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17353229075ad04f?w=698&h=276&f=png&s=23589" srcset="/img/loading.gif" alt=""></p><p>现在又有另一个客户端，客户端B需要加锁，那么也是在”/Lock”路径下创建临时顺序节点。依然获取”/Lock”下的节点列表，判断自己的节点序号是否最小的。发现不是最小的，加锁失败，接着对自己的上一个节点进行监听。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/173532ccde8ed6b4?w=736&h=328&f=png&s=29464" srcset="/img/loading.gif" alt=""></p><p>怎么释放锁呢，其实就是把临时节点删除。假设客户端A释放锁，把节点01删除了。那就会触发节点02的监听事件，客户端就再次获取节点列表，然后判断自己是否是最小的序号，如果是最小序号则加锁。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/16/1735337578204cc5?w=788&h=314&f=png&s=33283" srcset="/img/loading.gif" alt=""></p><p>如果多个客户端其实也是一样，一上来就会创建一个临时节点，然后开始判断自己是否是最小的序号，如果不是就监听上一个节点，形成一种排队的机制。也就形成了锁的效果，保证了多台服务器只有一台执行。</p><p><strong>假设其中有一个客户端宕机了，根据临时节点的特点，ZooKeeper会自动删除对应的临时节点</strong>，相当于自动释放了锁。</p><h2 id="3-2-手写代码实现分布式锁"><a href="#3-2-手写代码实现分布式锁" class="headerlink" title="3.2 手写代码实现分布式锁"></a>3.2 手写代码实现分布式锁</h2><p>首先加入Maven依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.101tec&lt;/groupId&gt;    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;    &lt;version&gt;0.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>接着按照上面分析的思路敲代码，创建ZkLock类：</p><pre><code class="java">public class ZkLock implements Lock {    //计数器，用于加锁失败时，阻塞    private static CountDownLatch cdl = new CountDownLatch(1);    //ZooKeeper服务器的IP端口    private static final String IP_PORT = &quot;127.0.0.1:2181&quot;;    //锁的根路径    private static final String ROOT_NODE = &quot;/Lock&quot;;    //上一个节点的路径    private volatile String beforePath;    //当前上锁的节点路径    private volatile String currPath;    //创建ZooKeeper客户端    private ZkClient zkClient = new ZkClient(IP_PORT);    public ZkLock() {        //判断是否存在根节点        if (!zkClient.exists(ROOT_NODE)) {            //不存在则创建            zkClient.createPersistent(ROOT_NODE);        }    }    //加锁    public void lock() {        if (tryLock()) {            System.out.println(&quot;加锁成功！！&quot;);        } else {            // 尝试加锁失败，进入等待 监听            waitForLock();            // 再次尝试加锁            lock();        }    }    //尝试加锁    public synchronized boolean tryLock() {        // 第一次就进来创建自己的临时节点        if (StringUtils.isBlank(currPath)) {            currPath = zkClient.createEphemeralSequential(ROOT_NODE + &quot;/&quot;, &quot;lock&quot;);        }        // 对节点排序        List&lt;String&gt; children = zkClient.getChildren(ROOT_NODE);        Collections.sort(children);        // 当前的是最小节点就返回加锁成功        if (currPath.equals(ROOT_NODE + &quot;/&quot; + children.get(0))) {            return true;        } else {            // 不是最小节点 就找到自己的前一个 依次类推 释放也是一样            int beforePathIndex = Collections.binarySearch(children, currPath.substring(ROOT_NODE.length() + 1)) - 1;            beforePath = ROOT_NODE + &quot;/&quot; + children.get(beforePathIndex);            //返回加锁失败            return false;        }    }    //解锁    public void unlock() {        //删除节点并关闭客户端        zkClient.delete(currPath);        zkClient.close();    }    //等待上锁，加锁失败进入阻塞，监听上一个节点    private void waitForLock() {        IZkDataListener listener = new IZkDataListener() {            //监听节点更新事件            public void handleDataChange(String s, Object o) throws Exception {            }            //监听节点被删除事件            public void handleDataDeleted(String s) throws Exception {                //解除阻塞                cdl.countDown();            }        };        // 监听上一个节点        this.zkClient.subscribeDataChanges(beforePath, listener);        //判断上一个节点是否存在        if (zkClient.exists(beforePath)) {            //上一个节点存在            try {                System.out.println(&quot;加锁失败 等待&quot;);                //加锁失败，阻塞等待                cdl.await();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        // 释放监听        zkClient.unsubscribeDataChanges(beforePath, listener);    }    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {        return false;    }    public void lockInterruptibly() throws InterruptedException {    }    public Condition newCondition() {        return null;    }}</code></pre><p>在Controller层加上锁：</p><pre><code class="java">    @PostMapping(&quot;/purchase&quot;)    public boolean purchaseCommodityInfo(@RequestParam(name = &quot;commodityId&quot;) String commodityId, @RequestParam(name = &quot;number&quot;) Integer number) throws Exception {        boolean bool;        //获取ZooKeeper分布式锁        ZkLock zkLock = new ZkLock();        try {            //上锁            zkLock.lock();            //调用秒杀抢购的service方法            bool = commodityInfoService.purchaseCommodityInfo(commodityId, number);        } catch (Exception e) {            e.printStackTrace();            bool = false;        } finally {            //解锁            zkLock.unlock();        }        return bool;    }</code></pre><p>测试，依然起两台服务器，8080、8081。然后跑测试脚本：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //请求地址        String url = &quot;http://localhost:%s/mall/commodity/purchase&quot;;        //请求参数，商品ID，数量        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;);        map.put(&quot;number&quot;, &quot;1&quot;);        //创建10个线程通过HttpClient进行发送请求，测试        for (int i = 0; i &lt; 10; i++) {            //8080、8081交替请求            String port = &quot;808&quot; + (i % 2);            CommodityThread commodityThread = new CommodityThread(String.format(url, port), map);            commodityThread.start();        }    }</code></pre><p>结果正确：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/173623e9dd3cc00b?w=776&h=47&f=png&s=7044" srcset="/img/loading.gif" alt=""></p><h2 id="3-3-造好的轮子"><a href="#3-3-造好的轮子" class="headerlink" title="3.3 造好的轮子"></a>3.3 造好的轮子</h2><p>Curator是Apache开源的一个操作ZooKeeper的框架。其中就有实现ZooKeeper分布式锁的功能。</p><p>当然分布式锁的实现只是这个框架的其中一个很小的部分，除此之外还有很多用途，大家可以到<a href="http://curator.apache.org/" target="_blank" rel="noopener">官网</a>去学习。</p><p>首先添加Maven依赖：</p><pre><code class="java">    &lt;dependency&gt;        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;        &lt;version&gt;4.3.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;        &lt;version&gt;4.3.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>还是一样在需要加锁的地方进行加锁：</p><pre><code class="java">    @PostMapping(&quot;/purchase&quot;)    public boolean purchaseCommodityInfo(@RequestParam(name = &quot;commodityId&quot;) String commodityId,                                         @RequestParam(name = &quot;number&quot;) Integer number) throws Exception {        boolean bool = false;        //设置重试策略        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;127.0.0.1:2181&quot;, retryPolicy);        // 启动客户端        client.start();        InterProcessMutex mutex = new InterProcessMutex(client, &quot;/locks&quot;);        try {            //加锁            if (mutex.acquire(3, TimeUnit.SECONDS)) {                //调用抢购秒杀service方法                bool = commodityInfoService.purchaseCommodityInfo(commodityId, number);            }        } catch (Exception e) {            e.printStackTrace();        } finally {            //解锁            mutex.release();            client.close();        }        return bool;    }</code></pre><h1 id="四、遇到的坑"><a href="#四、遇到的坑" class="headerlink" title="四、遇到的坑"></a>四、遇到的坑</h1><p>我尝试用原生的ZooKeeper写分布式锁，有点炸裂。遇到不少坑，最终放弃了，用zkclient的API。可能我太菜了不太会用。</p><p>下面我分享我遇到的一些问题，希望你们在遇到同类型的异常时能迅速定位问题。</p><h2 id="4-1-Session-expired"><a href="#4-1-Session-expired" class="headerlink" title="4.1 Session expired"></a>4.1 Session expired</h2><p>这个错误是使用原生ZooKeeper的API出现的错误。主要是我在进入debug模式进行调试出现的。</p><p>因为原生的ZooKeeper需要设定一个会话超时时间，一般debug模式我们都会卡在一个地方去调试，肯定就超出了设置的会话时间~</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/1736258e60ae7778?w=742&h=434&f=png&s=58282" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-KeeperErrorCode-ConnectionLoss"><a href="#4-2-KeeperErrorCode-ConnectionLoss" class="headerlink" title="4.2 KeeperErrorCode = ConnectionLoss"></a>4.2 KeeperErrorCode = ConnectionLoss</h2><p>这个也是原生ZooKeeper的API的错误，怎么出现的呢？</p><p>主要是创建的ZooKeeper客户端连接服务器时是异步的，由于连接需要时间，还没连接成功，代码已经开始执行create()或者exists()，然后就报这个错误。</p><p>解决方法：使用CountDownLatch计数器阻塞，连接成功后再停止阻塞，然后执行create()或者exists()等操作。</p><h2 id="4-3-并发查询更新出现数据不一致"><a href="#4-3-并发查询更新出现数据不一致" class="headerlink" title="4.3 并发查询更新出现数据不一致"></a>4.3 并发查询更新出现数据不一致</h2><p>这个错误真的太炸裂了~</p><p>一开始我是把分布式锁加在service层，然后以为搞定了。接着启动8080、8081进行并发测试。10个线程都是购买成功，结果居然是不正确！</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/173627032c88e91b?w=876&h=184&f=png&s=26788" srcset="/img/loading.gif" alt=""></p><p>第一反应觉得自己实现的代码有问题，于是换成curator框架实现的分布式锁，开源框架应该没问题了吧。没想到还是不行~</p><p>既然不是锁本身的问题，是不是事务问题。<strong>上一个事务更新库存的操作还没提交，然后下一个请求就进来查询。于是我就把加锁的范围放大一点，放在Controller层</strong>。居然成功了！</p><p>你可能已经注意到，我在上面的例子就是把分布式锁加在Controller层，其实我不太喜欢在Controller层写太多代码。</p><p>也许有更加优雅的方式，可惜本人能力不足，如果你有更好的实现方式，可以分享一下~</p><p>补充：下面评论有位大佬说，在原来的方法外再包裹一层，亲测是可以的。这应该是事务的问题。</p><p>上面放在Controller层可以成功是不是因为Controller层没有事务，原来写在service我是写了一个@Transactional注解在类上，所以整个类里面的都有事务，所以解锁后还没提交事务去更新数据库，然后下一个请求进来就查到了没更新的数据。</p><p>为了优雅一点，就把@Transactional注解放在抢购的service方法上<br><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736c9d98626282d?w=863&h=230&f=png&s=49347" srcset="/img/loading.gif" alt=""></p><p>然后再包裹一个没有事务的方法，用于上锁。<br><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736c993c04ea9e5?w=873&h=378&f=png&s=62335" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736c9a2d2881ae3?w=846&h=248&f=png&s=44367" srcset="/img/loading.gif" alt=""></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>最后，我们回顾总结一下吧：</p><ul><li>首先我们模拟单机多线程的秒杀场景，单机的话可以使用本地锁解决问题。</li><li>接着模拟多服务器多线程的场景，思路是使用ZooKeeper实现分布式锁解决。</li><li>图解ZooKeeper实现分布式锁的原理。</li><li>然后动手写代码，实现分布式锁。</li><li>最后总结遇到的坑。</li></ul><p><strong>希望这篇文章对你有用</strong></p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty进阶之粘包和拆包</title>
    <link href="/2020/07/08/Netty%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/"/>
    <url>/2020/07/08/Netty%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17329e0e4be94869?w=895&h=340&f=png&s=33550" srcset="/img/loading.gif" alt=""></p><h1 id="一、什么是粘包和拆包"><a href="#一、什么是粘包和拆包" class="headerlink" title="一、什么是粘包和拆包"></a>一、什么是粘包和拆包</h1><p>TCP是一种<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。(来自百度百科)</p><p>发送端为了将多个发给接收端的数据包，更有效地发送到接收端，会使用<strong>Nagle算法</strong>。Nagle算法会<strong>将多次时间间隔较小且数据量小的数据合并成一个大的数据块</strong>进行发送。虽然这样的确提高了效率，但是<strong>因为面向流通信，数据是无消息保护边界的</strong>，就会<strong>导致接收端难以分辨出完整的数据包</strong>了。</p><p>所谓的粘包和拆包问题，就是因为TCP消息无保护边界导致的。</p><a id="more"></a><h2 id="1-1-图解粘包和拆包"><a href="#1-1-图解粘包和拆包" class="headerlink" title="1.1 图解粘包和拆包"></a>1.1 图解粘包和拆包</h2><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e5cfafa34ed7?w=774&h=456&f=png&s=36343" srcset="/img/loading.gif" alt=""><br>正常发送消息是三次发送三个数据包，这种情况没有问题。</p><p>粘包，则是其中有多个数据包合并成一个数据包进行发送，也就是上图的第二种情况。</p><p>拆包，则是其中一个数据包被拆成了多段，发送的数据包只包含了一个完整数据包的一部分。也就是上图的第三种情况。</p><h2 id="1-2-程序演示"><a href="#1-2-程序演示" class="headerlink" title="1.2 程序演示"></a>1.2 程序演示</h2><p>首先准备客户端负责发送消息，连续发送5次消息，代码如下：</p><pre><code class="java">    for (int i = 1; i &lt;= 5; i++) {        ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + &quot; &quot;, Charset.forName(&quot;utf-8&quot;));        ctx.writeAndFlush(byteBuf);    }</code></pre><p>然后服务端作为接收方，接收并且打印结果：</p><pre><code class="java">//count变量，用于计数private int count = 0;@Overrideprotected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {    byte[] bytes = new byte[msg.readableBytes()];    //把ByteBuf的数据读到bytes数组中    msg.readBytes(bytes);    String message = new String(bytes, Charset.forName(&quot;utf-8&quot;));    System.out.println(&quot;服务器接收到数据：&quot; + message);    //打印接收的次数    System.out.println(&quot;接收到的数据量是：&quot; + (++this.count));}</code></pre><p>启动服务端，再启动两个客户端发送消息,服务端的控制台可以看到这样：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f27303054a8f?w=719&h=199&f=png&s=28205" srcset="/img/loading.gif" alt=""></p><p>粘包的问题其实是随机的，所以每次结果都不太一样。</p><h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>总体思路可以分为三种：</p><ul><li>在数据的末尾添加特殊的符号标识数据包的边界。通常会加\n\r、\t或者其他的符号。</li><li>在数据的头部声明数据的长度，按长度获取数据。</li><li>规定报文的长度，不足则补空位。读取时按规定好的长度来读取。</li></ul><h2 id="2-1-使用LineBasedFrameDecoder"><a href="#2-1-使用LineBasedFrameDecoder" class="headerlink" title="2.1 使用LineBasedFrameDecoder"></a>2.1 使用LineBasedFrameDecoder</h2><p>这是Netty内置的一个解码器，对应的编码器是LineEncoder。</p><p>原理是上面讲的第一种思路，在数据末尾加上特殊符号以标识边界。默认是使用换行符\n。</p><p>用法很简单，发送方加上编码器：</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //添加编码器，使用默认的符号\n，字符集是UTF-8        ch.pipeline().addLast(new LineEncoder(LineSeparator.DEFAULT, CharsetUtil.UTF_8));        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>接收方加上解码器：</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //解码器需要设置数据的最大长度，我这里设置成1024        ch.pipeline().addLast(new LineBasedFrameDecoder(1024));        //给pipeline管道设置业务处理器        ch.pipeline().addLast(new TcpServerHandler());    }</code></pre><p>然后在发送方，发送消息时在末尾加上标识符：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 5; i++) {            //在末尾加上默认的标识符\n            ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + StringUtil.LINE_FEED, Charset.forName(&quot;utf-8&quot;));            ctx.writeAndFlush(byteBuf);        }    }</code></pre><p>于是我们再次启动服务端和客户端，在服务端的控制台可以看到：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f4a496a5469d?w=505&h=231&f=png&s=42918" srcset="/img/loading.gif" alt=""><br>粘包、拆包的问题就轻松得到解决。</p><p>注意点：<strong>数据末尾一定是分隔符，分隔符后面不要再加上数据</strong>，否则会当做下一条数据的开始部分。下面是错误演示：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 5; i++) {            //在分隔符后面加上一段字符串            ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + StringUtil.LINE_FEED + &quot;[我是分隔符后面的字符串]&quot;, Charset.forName(&quot;utf-8&quot;));            ctx.writeAndFlush(byteBuf);        }    }</code></pre><p>服务端的控制台就会看到这样的打印信息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f7fca99184e9?w=446&h=208&f=png&s=24270" srcset="/img/loading.gif" alt=""></p><h2 id="2-2-使用自定义长度帧解码器"><a href="#2-2-使用自定义长度帧解码器" class="headerlink" title="2.2 使用自定义长度帧解码器"></a>2.2 使用自定义长度帧解码器</h2><p>使用这个解码器解决粘包问题的原理是上面讲的第二种，在数据的头部声明数据的长度，按长度获取数据。这个解码器构造器需要定义5个参数，相对较为复杂一点，先看参数的解释：</p><ul><li>maxFrameLength  发送数据包的最大长度</li><li>lengthFieldOffset  长度域的偏移量。长度域位于整个数据包字节数组中的开始下标。</li><li>lengthFieldLength  长度域的字节数长度。长度域的字节数长度。</li><li>lengthAdjustment  长度域的偏移量矫正。如果长度域的值，除了包含有效数据域的长度外，还包含了其他域（如长度域自身）长度，那么，就需要进行矫正。矫正的值为：包长 - 长度域的值 – 长度域偏移 – 长度域长。</li><li>initialBytesToStrip  丢弃的起始字节数。丢弃处于此索引值前面的字节。</li></ul><p>前面三个参数比较简单，可以用下面这张图进行演示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/6/173249f1dcce734e?w=557&h=342&f=png&s=28445" srcset="/img/loading.gif" alt=""><br>矫正偏移量是什么意思呢？意思是假设你的长度域设置的值除了包括有效数据的长度还有其他域的长度包含在里面，那么就要设置这个值进行矫正，否则解码器拿不到有效数据。矫正值的公式就是上面写着了。</p><p>丢弃的起始字节数。这个比较简单，就是在这个索引值前面的数据都丢弃，只要后面的数据。一般都是丢弃长度域的数据。当然如果你希望得到全部数据，那就设置为0。</p><p>下面就在消息接收端使用自定义长度帧解码器，解决粘包的问题：</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //数据包最大长度是1024        //长度域的起始索引是0        //长度域的数据长度是4        //矫正值为0，因为长度域只有 有效数据的长度的值        //丢弃数据起始值是4，因为长度域长度为4，我要把长度域丢弃，才能得到有效数据        ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>接着编写发送端代码，根据解码器的设置，进行发送：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 5; i++) {            String str = &quot;msg No&quot; + i;            ByteBuf byteBuf = Unpooled.buffer(1024);            byte[] bytes = str.getBytes(Charset.forName(&quot;utf-8&quot;));            //设置长度域的值，为有效数据的长度            byteBuf.writeInt(bytes.length);            //设置有效数据            byteBuf.writeBytes(bytes);            ctx.writeAndFlush(byteBuf);        }    }</code></pre><p>然后启动服务端，客户端，我们可以看到控制台打印结果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/6/17324aa254af3f3f?w=343&h=199&f=png&s=15892" srcset="/img/loading.gif" alt=""><br>可以看到，利用自定义长度帧解码器解决了粘包问题。</p><h2 id="2-3-使用Google-Protobuf编解码器"><a href="#2-3-使用Google-Protobuf编解码器" class="headerlink" title="2.3 使用Google Protobuf编解码器"></a>2.3 使用Google Protobuf编解码器</h2><p>Netty<a href="https://netty.io/" target="_blank" rel="noopener">官网</a>上是明显写着支持Google Protobuf的，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/6/17322cc3e98146fe?w=599&h=343&f=png&s=56992" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-1-Google-Protobuf是什么"><a href="#2-3-1-Google-Protobuf是什么" class="headerlink" title="2.3.1 Google Protobuf是什么"></a>2.3.1 Google Protobuf是什么</h3><blockquote><p>摘自官网的原话：<br>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p></blockquote><p>翻译一下：Protocol buffers是Google公司的<strong>与语言无关、平台无关、可扩展的序列化数据的机制</strong>，类似XML，但是<strong>更小、更快、更简单</strong>。您只需<strong>定义一次数据的结构化方式</strong>，然后就可以使用<strong>特殊生成的源代码</strong>，轻松地<strong>将结构化数据写入和读取到各种数据流中，并支持多种语言</strong>。</p><p><a href="https://developers.google.cn/protocol-buffers/" target="_blank" rel="noopener">Google Protobuf官网</a></p><h3 id="2-3-2-使用Google-Protobuf"><a href="#2-3-2-使用Google-Protobuf" class="headerlink" title="2.3.2 使用Google Protobuf"></a>2.3.2 使用Google Protobuf</h3><p>首先先下载编译器，我使用的是win系统，所以下载的是win版本。<a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.6.1" target="_blank" rel="noopener">下载编译器链接，版本是v3.6.1</a></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17324e5a84010099?w=1041&h=240&f=png&s=31916" srcset="/img/loading.gif" alt=""></p><p>如果官网下载慢的话，我已经下载了一个，并且上传到百度网盘，<a href="https://pan.baidu.com/s/11yckiP4uWXR9I0bKyRBzOQ" target="_blank" rel="noopener">网盘链接</a>，提取码：8b1r。公众号什么的随缘关注吧，哈哈~</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17329eb724fd70a4?w=741&h=364&f=png&s=19605" srcset="/img/loading.gif" alt=""></p><p>以下步骤参考Google Protobuf的github项目的<a href="https://github.com/protocolbuffers/protobuf/tree/master/java" target="_blank" rel="noopener">指南</a>。</p><h4 id="第一步：添加maven依赖"><a href="#第一步：添加maven依赖" class="headerlink" title="第一步：添加maven依赖"></a>第一步：添加maven依赖</h4><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;    &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;    &lt;version&gt;3.6.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="第二步：编写proto文件Message-proto"><a href="#第二步：编写proto文件Message-proto" class="headerlink" title="第二步：编写proto文件Message.proto"></a>第二步：编写proto文件Message.proto</h4><p>如何编写.proto文件的相关文档说明，可以去<a href="https://developers.google.cn/protocol-buffers/docs/proto3#scalar" target="_blank" rel="noopener">官网查看</a></p><p>下面我写一个例子，请看示范：</p><pre><code class="proto">syntax = &quot;proto3&quot;; //版本option java_outer_classname = &quot;MessagePojo&quot;;//生成的外部类名，同时也是文件名message Message {    int32 id = 1;//Message类的一个属性，属性名称是id，序号为1    string content = 2;//Message类的一个属性，属性名称是content，序号为2}</code></pre><h4 id="第三步：使用编译器，通过-proto文件生成代码"><a href="#第三步：使用编译器，通过-proto文件生成代码" class="headerlink" title="第三步：使用编译器，通过.proto文件生成代码"></a>第三步：使用编译器，通过.proto文件生成代码</h4><p>解压前面下载下来的压缩包protoc-3.6.1-win32.zip,然后打开\protoc-3.6.1-win32\bin目录下，可以看到有一个protoc.exe程序。如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/1732508b9c9007ee?w=635&h=108&f=png&s=6967" srcset="/img/loading.gif" alt=""></p><p>然后复制前面写好的Message.proto文件到此目录下，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250997e5b223c?w=638&h=136&f=png&s=10706" srcset="/img/loading.gif" alt=""></p><p>接着在此目录下打开命令行cmd，输入命令：protoc.exe –java_out=. Message.proto</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250bea472e4c7?w=521&h=107&f=png&s=3797" srcset="/img/loading.gif" alt=""></p><p>然后就可以看到生成的MessagePojo.java文件。最后把文件复制到IDEA项目中。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250d5605c8188?w=242&h=179&f=png&s=7294" srcset="/img/loading.gif" alt=""></p><h4 id="第四步：在发送端添加编码器，在接收端添加解码器"><a href="#第四步：在发送端添加编码器，在接收端添加解码器" class="headerlink" title="第四步：在发送端添加编码器，在接收端添加解码器"></a>第四步：在发送端添加编码器，在接收端添加解码器</h4><p>客户端添加编码器，对消息进行编码。</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //在发送端添加Protobuf编码器        ch.pipeline().addLast(new ProtobufEncoder());        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>服务端添加解码器，对消息进行解码。</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //添加Protobuf解码器，构造器需要指定解码具体的对象实例        ch.pipeline().addLast(new ProtobufDecoder(MessagePojo.Message.getDefaultInstance()));        //给pipeline管道设置处理器        ch.pipeline().addLast(new TcpServerHandler());    }</code></pre><h4 id="第五步：发送消息"><a href="#第五步：发送消息" class="headerlink" title="第五步：发送消息"></a>第五步：发送消息</h4><p>客户端发送消息，代码如下：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        //使用的是构建者模式进行创建对象        MessagePojo.Message message = MessagePojo                .Message                .newBuilder()                .setId(1)                .setContent(&quot;芜湖大司马，起飞~&quot;)                .build();        ctx.writeAndFlush(message);    }</code></pre><p>服务端接收到数据，并且打印：</p><pre><code class="java">    @Override    protected void channelRead0(ChannelHandlerContext ctx, MessagePojo.Message messagePojo) throws Exception {        System.out.println(&quot;id:&quot; + messagePojo.getId());        System.out.println(&quot;content:&quot; + messagePojo.getContent());    }</code></pre><p>测试结果正确：<br><img src="https://user-gold-cdn.xitu.io/2020/7/7/17325145051d6e3a?w=364&h=68&f=png&s=2580" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-3-分析Protocol的粘包、拆包"><a href="#2-3-3-分析Protocol的粘包、拆包" class="headerlink" title="2.3.3 分析Protocol的粘包、拆包"></a>2.3.3 分析Protocol的粘包、拆包</h3><p>实际上直接使用Protocol编解码器还是存在粘包问题的。</p><p>证明一下，发送端循环一百次发送100条”大司马，起飞”的消息，请看发送端代码演示：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 100; i++) {            MessagePojo.Message message = MessagePojo                    .Message                    .newBuilder()                    .setId(i)                    .setContent(i + &quot;号大司马，起飞~&quot;)                    .build();            ctx.writeAndFlush(message);        }    }</code></pre><p>这时，启动服务端，客户端后，你会在控制台看到如下错误：</p><blockquote><p>com.google.protobuf.InvalidProtocolBufferException: While parsing a protocol message, the input ended unexpectedly in the middle of a field.  This could mean either that the input has been truncated or that an embedded message misreported its own length.</p></blockquote><p>意思是：分析protocol消息时，输入意外地在字段中间结束。这可能意味着输入被截断，或者嵌入的消息误报了自己的长度。</p><p>其实就是粘包问题，多条数据合并成一条数据了，导致解析出现异常。</p><h3 id="2-3-4-解决Protocol的粘包、拆包问题"><a href="#2-3-4-解决Protocol的粘包、拆包问题" class="headerlink" title="2.3.4 解决Protocol的粘包、拆包问题"></a>2.3.4 解决Protocol的粘包、拆包问题</h3><p>只需要在发送端加上编码器<strong>ProtobufVarint32LengthFieldPrepender</strong></p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());        ch.pipeline().addLast(new ProtobufEncoder());        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>接收方加上解码器<strong>ProtobufVarint32FrameDecoder</strong></p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());        ch.pipeline().addLast(new ProtobufDecoder(MessagePojo.Message.getDefaultInstance()));        //给pipeline管道设置处理器        ch.pipeline().addLast(new TcpServerHandler());    }</code></pre><p>然后再启动服务端和客户端，我们可以看到<strong>马老师成功地起飞了</strong><del>~</del></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17329b2d05572fb7?w=261&h=284&f=png&s=15543" srcset="/img/loading.gif" alt=""></p><p>ProtobufVarint32LengthFieldPrepender编码器的工作如下：</p><pre><code class="java"> * BEFORE ENCODE (300 bytes)       AFTER ENCODE (302 bytes) * +---------------+               +--------+---------------+ * | Protobuf Data |--------------&gt;| Length | Protobuf Data | * |  (300 bytes)  |               | 0xAC02 |  (300 bytes)  | * +---------------+               +--------+---------------+@Sharablepublic class ProtobufVarint32LengthFieldPrepender extends MessageToByteEncoder&lt;ByteBuf&gt; {    @Override    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throws Exception {        int bodyLen = msg.readableBytes();        int headerLen = computeRawVarint32Size(bodyLen);        //写入请求头，消息长度        out.ensureWritable(headerLen + bodyLen);        writeRawVarint32(out, bodyLen);        //写入数据        out.writeBytes(msg, msg.readerIndex(), bodyLen);    }}</code></pre><p>ProtobufVarint32FrameDecoder解码器的工作如下：</p><pre><code class="java"> * BEFORE DECODE (302 bytes)       AFTER DECODE (300 bytes) * +--------+---------------+      +---------------+ * | Length | Protobuf Data |-----&gt;| Protobuf Data | * | 0xAC02 |  (300 bytes)  |      |  (300 bytes)  | * +--------+---------------+      +---------------+public class ProtobufVarint32FrameDecoder extends ByteToMessageDecoder {    @Override    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {        //标记读取的下标位置        in.markReaderIndex();        //获取读取的下标位置        int preIndex = in.readerIndex();        //解码，获取消息的长度,并且移动读取的下标位置        int length = readRawVarint32(in);        //比较解码前和解码后的下标位置，如果相等。表示字节数不够读取，跳到下一轮        if (preIndex == in.readerIndex()) {            return;        }        //如果消息的长度小于0，抛出异常        if (length &lt; 0) {            throw new CorruptedFrameException(&quot;negative length: &quot; + length);        }        //如果不够读取一个完整的数据，reset还原下标位置。        if (in.readableBytes() &lt; length) {            in.resetReaderIndex();        } else {            //否则，把数据写入到out，接收端就拿到了完整的数据了            out.add(in.readRetainedSlice(length));        } }</code></pre><p>总结一下：</p><p>发送端通过编码器在发送的时候在<strong>消息体前面加上一个描述数据长度的数据块</strong>。</p><p>接收方通过<strong>解码器先获取描述数据长度的数据块</strong>，知道完整数据的长度，<strong>然后根据数据长度获取一条完整的数据</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>创作不易</strong>，觉得有用就<strong>关注一下</strong>吧。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty入门</title>
    <link href="/2020/07/04/Netty%E5%85%A5%E9%97%A8/"/>
    <url>/2020/07/04/Netty%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731948029b90fc2?w=755&h=648&f=png&s=53135" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲述Netty框架的一些特性以及重要组件，希望看完之后能对Netty框架有一个比较直观的感受，希望能帮助读者快速入门Netty，减少一些弯路。</p><a id="more"></a><h1 id="一、Netty概述"><a href="#一、Netty概述" class="headerlink" title="一、Netty概述"></a>一、Netty概述</h1><p>官方的介绍：</p><blockquote><p>Netty is <em>an asynchronous event-driven network application framework</em><br>for rapid development of maintainable high performance protocol servers &amp; clients.</p></blockquote><p><strong>Netty</strong>是 一个<strong>异步事件驱动</strong>的网络应用程序框架，用于<strong>快速开发可维护的高性能协议服务器和客户端</strong>。</p><h1 id="二、为什么使用Netty"><a href="#二、为什么使用Netty" class="headerlink" title="二、为什么使用Netty"></a>二、为什么使用Netty</h1><p>从官网上介绍，Netty是一个网络应用程序框架，开发服务器和客户端。也就是用于网络编程的一个框架。既然是网络编程，Socket就不谈了，为什么不用NIO呢？</p><h2 id="2-1-NIO的缺点"><a href="#2-1-NIO的缺点" class="headerlink" title="2.1 NIO的缺点"></a>2.1 NIO的缺点</h2><p>对于这个问题，之前我写了一篇文章<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw" target="_blank" rel="noopener">《NIO入门》</a>对NIO有比较详细的介绍，NIO的主要问题是：</p><ul><li>NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</li><li>需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。</li><li>臭名昭著的epoll bug。它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本依然没得到根本性的解决。</li></ul><h2 id="2-2-Netty的优点"><a href="#2-2-Netty的优点" class="headerlink" title="2.2 Netty的优点"></a>2.2 Netty的优点</h2><p>相对地，Netty的优点有很多：</p><ul><li>API使用简单，学习成本低。</li><li>功能强大，内置了多种解码编码器，支持多种协议。</li><li>性能高，对比其他主流的NIO框架，Netty的性能最优。</li><li>社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。</li><li>Dubbo、Elasticsearch都采用了Netty，质量得到验证。</li></ul><h1 id="三、架构图"><a href="#三、架构图" class="headerlink" title="三、架构图"></a>三、架构图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194d4a8fd419c?w=592&h=348&f=png&s=55075" srcset="/img/loading.gif" alt=""></p><p>上面这张图就是在官网首页的架构图，我们从上到下分析一下。</p><blockquote><p>绿色的部分<strong>Core</strong>核心模块，包括零拷贝、API库、可扩展的事件模型。</p></blockquote><blockquote><p>橙色部分<strong>Protocol Support</strong>协议支持，包括Http协议、webSocket、SSL(安全套接字协议)、谷歌Protobuf协议、zlib/gzip压缩与解压缩、Large File Transfer大文件传输等等。</p></blockquote><blockquote><p>红色的部分<strong>Transport Services</strong>传输服务，包括Socket、Datagram、Http Tunnel等等。</p></blockquote><p>以上可看出Netty的功能、协议、传输方式都比较全，比较强大。</p><h1 id="四、永远的Hello-Word"><a href="#四、永远的Hello-Word" class="headerlink" title="四、永远的Hello Word"></a>四、永远的Hello Word</h1><p>首先搭建一个HelloWord工程，先熟悉一下API，还有为后面的学习做铺垫。以下面这张图为依据：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc0641d4ed5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt=""></p><h2 id="4-1-引入Maven依赖"><a href="#4-1-引入Maven依赖" class="headerlink" title="4.1 引入Maven依赖"></a>4.1 引入Maven依赖</h2><p>使用的版本是4.1.20，相对比较稳定的一个版本。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.netty&lt;/groupId&gt;    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;    &lt;version&gt;4.1.20.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="4-2-创建服务端启动类"><a href="#4-2-创建服务端启动类" class="headerlink" title="4.2 创建服务端启动类"></a>4.2 创建服务端启动类</h2><pre><code class="java">public class MyServer {    public static void main(String[] args) throws Exception {        //创建两个线程组 boosGroup、workerGroup        EventLoopGroup bossGroup = new NioEventLoopGroup();        EventLoopGroup workerGroup = new NioEventLoopGroup();        try {            //创建服务端的启动对象，设置参数            ServerBootstrap bootstrap = new ServerBootstrap();            //设置两个线程组boosGroup和workerGroup            bootstrap.group(bossGroup, workerGroup)                //设置服务端通道实现类型                    .channel(NioServerSocketChannel.class)                //设置线程队列得到连接个数                    .option(ChannelOption.SO_BACKLOG, 128)                //设置保持活动连接状态                    .childOption(ChannelOption.SO_KEEPALIVE, true)                //使用匿名内部类的形式初始化通道对象                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {                        @Override                        protected void initChannel(SocketChannel socketChannel) throws Exception {                            //给pipeline管道设置处理器                            socketChannel.pipeline().addLast(new MyServerHandler());                        }                    });//给workerGroup的EventLoop对应的管道设置处理器            System.out.println(&quot;java技术爱好者的服务端已经准备就绪...&quot;);            //绑定端口号，启动服务端            ChannelFuture channelFuture = bootstrap.bind(6666).sync();            //对关闭通道进行监听            channelFuture.channel().closeFuture().sync();        } finally {            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        }    }}</code></pre><h2 id="4-3-创建服务端处理器"><a href="#4-3-创建服务端处理器" class="headerlink" title="4.3 创建服务端处理器"></a>4.3 创建服务端处理器</h2><pre><code class="java">/** * 自定义的Handler需要继承Netty规定好的HandlerAdapter * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式 **/public class MyServerHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //获取客户端发送过来的消息        ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(&quot;收到客户端&quot; + ctx.channel().remoteAddress() + &quot;发送的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));    }    @Override    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {        //发送消息给客户端        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;服务端已收到消息，并给你发送一个问号?&quot;, CharsetUtil.UTF_8));    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {        //发生异常，关闭通道        ctx.close();    }}</code></pre><h2 id="4-4-创建客户端启动类"><a href="#4-4-创建客户端启动类" class="headerlink" title="4.4 创建客户端启动类"></a>4.4 创建客户端启动类</h2><pre><code class="java">public class MyClient {    public static void main(String[] args) throws Exception {        NioEventLoopGroup eventExecutors = new NioEventLoopGroup();        try {            //创建bootstrap对象，配置参数            Bootstrap bootstrap = new Bootstrap();            //设置线程组            bootstrap.group(eventExecutors)                //设置客户端的通道实现类型                    .channel(NioSocketChannel.class)                //使用匿名内部类初始化通道                .handler(new ChannelInitializer&lt;SocketChannel&gt;() {                        @Override                        protected void initChannel(SocketChannel ch) throws Exception {                            //添加客户端通道的处理器                            ch.pipeline().addLast(new MyClientHandler());                        }                    });            System.out.println(&quot;客户端准备就绪，随时可以起飞~&quot;);            //连接服务端            ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666).sync();            //对通道关闭进行监听            channelFuture.channel().closeFuture().sync();        } finally {            //关闭线程组            eventExecutors.shutdownGracefully();        }    }}</code></pre><h2 id="4-5-创建客户端处理器"><a href="#4-5-创建客户端处理器" class="headerlink" title="4.5 创建客户端处理器"></a>4.5 创建客户端处理器</h2><pre><code class="java">public class MyClientHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        //发送消息到服务端        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;, CharsetUtil.UTF_8));    }    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //接收服务端发送过来的消息        ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(&quot;收到服务端&quot; + ctx.channel().remoteAddress() + &quot;的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));    }}</code></pre><h2 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h2><p>先启动服务端，再启动客户端，就可以看到结果：</p><p>MyServer打印结果:</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194df71b69cc2?w=764&h=65&f=png&s=10322" srcset="/img/loading.gif" alt=""></p><p>MyClient打印结果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194e2409505c1?w=712&h=49&f=png&s=7914" srcset="/img/loading.gif" alt=""></p><h1 id="五、Netty的特性与重要组件"><a href="#五、Netty的特性与重要组件" class="headerlink" title="五、Netty的特性与重要组件"></a>五、Netty的特性与重要组件</h1><h2 id="5-1-taskQueue任务队列"><a href="#5-1-taskQueue任务队列" class="headerlink" title="5.1 taskQueue任务队列"></a>5.1 taskQueue任务队列</h2><p>如果Handler处理器有一些长时间的业务处理，可以交给<strong>taskQueue异步处理</strong>。怎么用呢，请看代码演示：</p><pre><code class="java">public class MyServerHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //获取到线程池eventLoop，添加线程，执行        ctx.channel().eventLoop().execute(new Runnable() {            @Override            public void run() {                try {                    //长时间操作，不至于长时间的业务操作导致Handler阻塞                    Thread.sleep(1000);                    System.out.println(&quot;长时间的业务处理&quot;);                } catch (Exception e) {                    e.printStackTrace();                }            }        });    }}</code></pre><p>我们打一个debug调试，是可以看到添加进去的taskQueue有一个任务。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194f4d1d340fc?w=675&h=233&f=png&s=18480" srcset="/img/loading.gif" alt=""></p><h2 id="5-2-scheduleTaskQueue延时任务队列"><a href="#5-2-scheduleTaskQueue延时任务队列" class="headerlink" title="5.2 scheduleTaskQueue延时任务队列"></a>5.2 scheduleTaskQueue延时任务队列</h2><p>延时任务队列和上面介绍的任务队列非常相似，只是多了一个可延迟一定时间再执行的设置，请看代码演示：</p><pre><code class="java">ctx.channel().eventLoop().schedule(new Runnable() {    @Override    public void run() {        try {            //长时间操作，不至于长时间的业务操作导致Handler阻塞            Thread.sleep(1000);            System.out.println(&quot;长时间的业务处理&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }},5, TimeUnit.SECONDS);//5秒后执行</code></pre><p>依然打开debug进行调试查看，我们可以有一个scheduleTaskQueue任务待执行中</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194f21adfa111?w=705&h=214&f=png&s=17798" srcset="/img/loading.gif" alt=""></p><h2 id="5-3-Future异步机制"><a href="#5-3-Future异步机制" class="headerlink" title="5.3 Future异步机制"></a>5.3 Future异步机制</h2><p>在搭建HelloWord工程的时候，我们看到有一行这样的代码：</p><pre><code class="java">ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666);</code></pre><p>很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？</p><p>ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。请看一段代码演示：</p><pre><code class="java">//添加监听器channelFuture.addListener(new ChannelFutureListener() {    //使用匿名内部类，ChannelFutureListener接口    //重写operationComplete方法    @Override    public void operationComplete(ChannelFuture future) throws Exception {        //判断是否操作成功            if (future.isSuccess()) {            System.out.println(&quot;连接成功&quot;);        } else {            System.out.println(&quot;连接失败&quot;);        }    }});</code></pre><h2 id="5-4-Bootstrap与ServerBootStrap"><a href="#5-4-Bootstrap与ServerBootStrap" class="headerlink" title="5.4 Bootstrap与ServerBootStrap"></a>5.4 Bootstrap与ServerBootStrap</h2><p>Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731950cf2dbd785?w=595&h=296&f=png&s=7746" srcset="/img/loading.gif" alt=""></p><p>可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。</p><p>一般来说，使用Bootstrap创建启动器的步骤可分为以下几步：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731951012e334fc?w=960&h=292&f=png&s=20428" srcset="/img/loading.gif" alt=""></p><h3 id="5-4-1-group"><a href="#5-4-1-group" class="headerlink" title="5.4.1 group()"></a>5.4.1 group()</h3><p>在上一篇文章<a href="https://mp.weixin.qq.com/s/vWbbn1qXRFVva8Y9yET18Q" target="_blank" rel="noopener">《Reactor模式》</a>中，我们就讲过服务端要使用两个线程组：</p><ul><li>bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。</li><li>workerGroup用于处理每一个连接发生的读写事件。</li></ul><p>一般创建线程组直接使用以下new就完事了：</p><pre><code class="java">EventLoopGroup bossGroup = new NioEventLoopGroup();EventLoopGroup workerGroup = new NioEventLoopGroup();</code></pre><p>有点好奇的是，既然是线程组，那线程数默认是多少呢？深入源码：</p><pre><code class="java">    //使用一个常量保存    private static final int DEFAULT_EVENT_LOOP_THREADS;    static {        //NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量        DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(                &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));        if (logger.isDebugEnabled()) {            logger.debug(&quot;-Dio.netty.eventLoopThreads: {}&quot;, DEFAULT_EVENT_LOOP_THREADS);        }    }    protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {        //如果不传入，则使用常量的值，也就是cpu核数的两倍        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);    }</code></pre><p>通过源码可以看到，默认的线程数是cpu核数的两倍。假设想自定义线程数，可以使用有参构造器：</p><pre><code class="java">//设置bossGroup线程数为1EventLoopGroup bossGroup = new NioEventLoopGroup(1);//设置workerGroup线程数为16EventLoopGroup workerGroup = new NioEventLoopGroup(16);</code></pre><h3 id="5-4-2-channel"><a href="#5-4-2-channel" class="headerlink" title="5.4.2 channel()"></a>5.4.2 channel()</h3><p>这个方法用于设置通道类型，当建立连接后，会根据这个设置创建对应的Channel实例。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731951ae3c43228?w=838&h=328&f=png&s=59491" srcset="/img/loading.gif" alt=""></p><p>使用debug模式可以看到</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731951f80b07785?w=495&h=212&f=png&s=16456" srcset="/img/loading.gif" alt=""></p><p>通道类型有以下：</p><p><strong>NioSocketChannel</strong>： 异步非阻塞的客户端 TCP Socket 连接。</p><p><strong>NioServerSocketChannel</strong>： 异步非阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。</p></blockquote><p>OioSocketChannel： 同步阻塞的客户端 TCP Socket 连接。</p><p>OioServerSocketChannel： 同步阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>稍微在本地调试过，用起来和Nio有一些不同，是阻塞的，所以API调用也不一样。因为是阻塞的IO，几乎没什么人会选择使用Oio，所以也很难找到例子。我稍微琢磨了一下，经过几次报错之后，总算调通了。代码如下：</p></blockquote><pre><code class="java">//server端代码，跟上面几乎一样，只需改三个地方//这个地方使用的是OioEventLoopGroupEventLoopGroup bossGroup = new OioEventLoopGroup();ServerBootstrap bootstrap = new ServerBootstrap();bootstrap.group(bossGroup)//只需要设置一个线程组boosGroup        .channel(OioServerSocketChannel.class)//设置服务端通道实现类型//client端代码，只需改两个地方//使用的是OioEventLoopGroupEventLoopGroup eventExecutors = new OioEventLoopGroup();//通道类型设置为OioSocketChannelbootstrap.group(eventExecutors)//设置线程组        .channel(OioSocketChannel.class)//设置客户端的通道实现类型</code></pre><p>NioSctpChannel： 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。<br>NioSctpServerChannel： 异步的 Sctp 服务器端连接。</p><blockquote><p>本地没启动成功，网上看了一些网友的评论，说是只能在linux环境下才可以启动。从报错信息看：SCTP not supported on this platform，不支持这个平台。因为我电脑是window系统，所以网友说的有点道理。</p></blockquote><h3 id="5-4-3-option-与childOption"><a href="#5-4-3-option-与childOption" class="headerlink" title="5.4.3 option()与childOption()"></a>5.4.3 option()与childOption()</h3><p>首先说一下这两个的区别。</p><p>option()设置的是服务端用于接收进来的连接，也就是boosGroup线程。</p><p>childOption()是提供给父管道接收到的连接，也就是workerGroup线程。</p><p>搞清楚了之后，我们看一下常用的一些设置有哪些：</p><p>SocketChannel参数，也就是childOption()常用的参数：</p><blockquote><p><strong>SO_RCVBUF</strong>     Socket参数，TCP数据接收缓冲区大小。<br><strong>TCP_NODELAY</strong>     TCP参数，立即发送数据，默认值为Ture。<br><strong>SO_KEEPALIVE</strong>     Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。</p></blockquote><p>ServerSocketChannel参数，也就是option()常用参数：</p><blockquote><p><strong>SO_BACKLOG</strong>     Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。</p></blockquote><p>由于篇幅限制，其他就不列举了，大家可以去网上找资料看看，了解一下。</p><h3 id="5-4-4-设置流水线-重点"><a href="#5-4-4-设置流水线-重点" class="headerlink" title="5.4.4 设置流水线(重点)"></a>5.4.4 设置流水线(重点)</h3><p>ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。</p><p>在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。代码演示如下：</p><pre><code class="java">//使用匿名内部类的形式初始化通道对象bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {    @Override    protected void initChannel(SocketChannel socketChannel) throws Exception {        //给pipeline管道设置自定义的处理器        socketChannel.pipeline().addLast(new MyServerHandler());    }});</code></pre><p>处理器Handler主要分为两种：</p><blockquote><p>ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器)</p></blockquote><p>入站指的是数据从底层java NIO Channel到Netty的Channel。</p><p>出站指的是通过Netty的Channel来操作底层的java NIO Channel。</p><p><strong>ChannelInboundHandlerAdapter处理器常用的事件有</strong>：</p><ol><li><p>注册事件 fireChannelRegistered。</p></li><li><p>连接建立事件 fireChannelActive。</p></li><li><p>读事件和读完成事件 fireChannelRead、fireChannelReadComplete。</p></li><li><p>异常通知事件 fireExceptionCaught。</p></li><li><p>用户自定义事件 fireUserEventTriggered。</p></li><li><p>Channel 可写状态变化事件 fireChannelWritabilityChanged。</p></li><li><p>连接关闭事件 fireChannelInactive。</p></li></ol><p><strong>ChannelOutboundHandler处理器常用的事件有</strong>：</p><ol><li><p>端口绑定 bind。</p></li><li><p>连接服务端 connect。</p></li><li><p>写事件 write。</p></li><li><p>刷新时间 flush。</p></li><li><p>读事件 read。</p></li><li><p>主动断开连接 disconnect。</p></li><li><p>关闭 channel 事件 close。</p></li></ol><blockquote><p>还有一个类似的handler()，主要用于装配parent通道，也就是bossGroup线程。一般情况下，都用不上这个方法。</p></blockquote><h3 id="5-4-5-bind"><a href="#5-4-5-bind" class="headerlink" title="5.4.5 bind()"></a>5.4.5 bind()</h3><p>提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步。</p><p>有五个同名的重载方法，作用都是用于绑定地址端口号。不一一介绍了。</p><h3 id="5-4-6-优雅地关闭EventLoopGroup"><a href="#5-4-6-优雅地关闭EventLoopGroup" class="headerlink" title="5.4.6 优雅地关闭EventLoopGroup"></a>5.4.6 优雅地关闭EventLoopGroup</h3><pre><code class="java">//释放掉所有的资源，包括创建的线程bossGroup.shutdownGracefully();workerGroup.shutdownGracefully();</code></pre><p>会关闭所有的child Channel。关闭之后，释放掉底层的资源。</p><h2 id="5-5-Channel"><a href="#5-5-Channel" class="headerlink" title="5.5 Channel"></a>5.5 Channel</h2><p>Channel是什么？不妨看一下官方文档的说明：</p><blockquote><p>A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind</p></blockquote><p>翻译大意：一种连接到网络套接字或能进行读、写、连接和绑定等I/O操作的组件。</p><p>如果上面这段说明比较抽象，下面还有一段说明：</p><blockquote><p>A channel provides a user:</p><p>the current state of the channel (e.g. is it open? is it connected?),<br>the configuration parameters of the channel (e.g. receive buffer size),<br>the I/O operations that the channel supports (e.g. read, write, connect, and bind), and<br>the ChannelPipeline which handles all I/O events and requests associated with the channel.</p></blockquote><p>翻译大意：</p><p>channel为用户提供：</p><ol><li><p>通道当前的状态（例如它是打开？还是已连接？）</p></li><li><p>channel的配置参数（例如接收缓冲区的大小）</p></li><li><p>channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。</p></li></ol><h3 id="5-5-1-获取channel的状态"><a href="#5-5-1-获取channel的状态" class="headerlink" title="5.5.1 获取channel的状态"></a>5.5.1 获取channel的状态</h3><pre><code class="java">boolean isOpen(); //如果通道打开，则返回trueboolean isRegistered();//如果通道注册到EventLoop，则返回trueboolean isActive();//如果通道处于活动状态并且已连接，则返回trueboolean isWritable();//当且仅当I/O线程将立即执行请求的写入操作时，返回true。</code></pre><p>以上就是获取channel的四种状态的方法。</p><h3 id="5-5-2-获取channel的配置参数"><a href="#5-5-2-获取channel的配置参数" class="headerlink" title="5.5.2 获取channel的配置参数"></a>5.5.2 获取channel的配置参数</h3><p>获取单条配置信息，使用getOption()，代码演示：</p><pre><code class="java">ChannelConfig config = channel.config();//获取配置参数//获取ChannelOption.SO_BACKLOG参数,Integer soBackLogConfig = config.getOption(ChannelOption.SO_BACKLOG);//因为我启动器配置的是128，所以我这里获取的soBackLogConfig=128</code></pre><p>获取多条配置信息，使用getOptions()，代码演示：</p><pre><code class="java">ChannelConfig config = channel.config();Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = config.getOptions();for (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; entry : options.entrySet()) {    System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue());}/**SO_REUSEADDR : falseWRITE_BUFFER_LOW_WATER_MARK : 32768WRITE_BUFFER_WATER_MARK : WriteBufferWaterMark(low: 32768, high: 65536)SO_BACKLOG : 128以下省略...*/</code></pre><h3 id="5-5-3-channel支持的IO操作"><a href="#5-5-3-channel支持的IO操作" class="headerlink" title="5.5.3 channel支持的IO操作"></a>5.5.3 channel支持的IO操作</h3><p><strong>写操作</strong>，这里演示从服务端写消息发送到客户端：</p><pre><code class="java">@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {    ctx.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;这波啊，这波是肉蛋葱鸡~&quot;, CharsetUtil.UTF_8));}</code></pre><p>客户端控制台：</p><pre><code class="java">//收到服务端/127.0.0.1:6666的消息：这波啊，这波是肉蛋葱鸡~</code></pre><p><strong>连接</strong>操作，代码演示：</p><pre><code class="java">ChannelFuture connect = channelFuture.channel().connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666));//一般使用启动器，这种方式不常用</code></pre><p><strong>通过channel获取ChannelPipeline</strong>，并做相关的处理：</p><pre><code class="java">//获取ChannelPipeline对象ChannelPipeline pipeline = ctx.channel().pipeline();//往pipeline中添加ChannelHandler处理器，装配流水线pipeline.addLast(new MyServerHandler());</code></pre><h2 id="5-6-Selector"><a href="#5-6-Selector" class="headerlink" title="5.6 Selector"></a>5.6 Selector</h2><p>在NioEventLoop中，有一个成员变量selector，这是nio包的Selector，在之前<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw" target="_blank" rel="noopener">《NIO入门》</a>中，我已经讲过Selector了。</p><p>Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731957c1e90bf2a?w=725&h=576&f=png&s=326067" srcset="/img/loading.gif" alt=""></p><h2 id="5-7-PiPeline与ChannelPipeline"><a href="#5-7-PiPeline与ChannelPipeline" class="headerlink" title="5.7 PiPeline与ChannelPipeline"></a>5.7 PiPeline与ChannelPipeline</h2><p>在前面介绍Channel时，我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。</p><p>于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731954229ab93ac?w=719&h=240&f=png&s=8344" srcset="/img/loading.gif" alt=""></p><p>在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。</p><h2 id="5-8-ChannelHandlerContext"><a href="#5-8-ChannelHandlerContext" class="headerlink" title="5.8 ChannelHandlerContext"></a>5.8 ChannelHandlerContext</h2><p>在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。</p><p>于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731954657f33870?w=540&h=230&f=png&s=7746" srcset="/img/loading.gif" alt=""></p><p>通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。</p><p>实际上ChannelHandlerContext在pipeline中是一个链表的形式。看一段源码就明白了：</p><pre><code class="java">//ChannelPipeline实现类DefaultChannelPipeline的构造器方法protected DefaultChannelPipeline(Channel channel) {    this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);    succeededFuture = new SucceededChannelFuture(channel, null);    voidPromise =  new VoidChannelPromise(channel, true);    //设置头结点head，尾结点tail    tail = new TailContext(this);    head = new HeadContext(this);    head.next = tail;    tail.prev = head;}</code></pre><p>下面我用一张图来表示，会更加清晰一点：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731954b31d6c9cf?w=942&h=262&f=png&s=16168" srcset="/img/loading.gif" alt=""></p><h2 id="5-9-EventLoopGroup"><a href="#5-9-EventLoopGroup" class="headerlink" title="5.9 EventLoopGroup"></a>5.9 EventLoopGroup</h2><p>我们先看一下EventLoopGroup的类图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731955081291714?w=738&h=216&f=png&s=6894" srcset="/img/loading.gif" alt=""></p><p>其中包括了常用的实现类NioEventLoopGroup。OioEventLoopGroup在前面的例子中也有使用过。</p><p>从Netty的架构图中，可以知道服务器是需要两个线程组进行配合工作的，而这个线程组的接口就是EventLoopGroup。</p><p>每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。</p><h3 id="5-9-1-轮询机制的实现原理"><a href="#5-9-1-轮询机制的实现原理" class="headerlink" title="5.9.1 轮询机制的实现原理"></a>5.9.1 轮询机制的实现原理</h3><p>我们不妨看一段DefaultEventExecutorChooserFactory的源码：</p><pre><code class="java">private final AtomicInteger idx = new AtomicInteger();private final EventExecutor[] executors;@Overridepublic EventExecutor next() {    //idx.getAndIncrement()相当于idx++，然后对任务长度取模    return executors[idx.getAndIncrement() &amp; executors.length - 1];}</code></pre><p>这段代码可以确定执行的方式是轮询机制，接下来debug调试一下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17319554d4546047?w=1241&h=520&f=png&s=82119" srcset="/img/loading.gif" alt=""></p><p>它这里还有一个判断，如果线程数不是2的N次方，则采用取模算法实现。</p><pre><code class="java">@Overridepublic EventExecutor next() {    return executors[Math.abs(idx.getAndIncrement() % executors.length)];}</code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>参考Netty官网文档：<a href="https://netty.io/4.1/api/index.html" target="_blank" rel="noopener">API文档</a></p><p><strong>创作不易</strong>，觉得有用就<strong>点个赞</strong>吧。</p><p>我不要下次一定，希望<strong>这次一定素质三连</strong>，感谢！</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reactor模式</title>
    <link href="/2020/07/01/Reactor%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/07/01/Reactor%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05ba3465c?w=894&h=436&f=png&s=45997" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="一、Reactor模式介绍"><a href="#一、Reactor模式介绍" class="headerlink" title="一、Reactor模式介绍"></a>一、Reactor模式介绍</h1><p>本文主要参考Doug Lea(大神)的“<strong>Scalable IO in Java</strong>”中讲述的Reactor模式。</p><p>原文地址：<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p>有兴趣的可以看看这本书，受益匪浅！</p><a id="more"></a><h2 id="1-1-什么是Reactor模式"><a href="#1-1-什么是Reactor模式" class="headerlink" title="1.1 什么是Reactor模式"></a>1.1 什么是Reactor模式</h2><p>Reactor模式一般翻译成”<strong>反应器模式</strong>“，也有人称为”<strong>分发者模式</strong>“。它是将客户端请求提交到一个或者多个服务处理程序的设计模式。工作原理是由<strong>一个线程来接收所有的请求</strong>，然后<strong>派发这些请求到相关的工作线程中</strong>。</p><h2 id="1-2-为什么使用Reactor模式"><a href="#1-2-为什么使用Reactor模式" class="headerlink" title="1.2 为什么使用Reactor模式"></a>1.2 为什么使用Reactor模式</h2><p>在java中，没有NIO出现之前都是使用socket编程。socket的接收请求是阻塞的，需要处理完一个请求才能处理下一个请求，所以在面对高并发的服务请求时，性能就会很差。</p><p>那有人就会说使用多线程（如下图所示）。接收到一个请求，就创建一个线程处理，这样就不会阻塞了。实际上这样的确是可以在提升性能上起到一定的作用，<strong>但是当请求很多的时候，就会创建大量的线程，维护线程需要资源的消耗，线程之间的切换也需要消耗性能</strong>。而且系统创建线程的数量也是有限的，所以当高并发时，会直接把系统拖垮。<br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05ef76206?w=736&h=316&f=png&s=203508" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由于以上的问题，提出了Reactor模式。</p><p>基于Java，Doug Lea（Java并发包作者）提出了三种形式，<strong>单Reactor单线程，单Reactor多线程和多Reactor多线程</strong>。</p><h1 id="二、Reactor模式的演进过程"><a href="#二、Reactor模式的演进过程" class="headerlink" title="二、Reactor模式的演进过程"></a>二、Reactor模式的演进过程</h1><p>在介绍三种Reactor模式前，先简单地说明三个角色：</p><blockquote><p><code>Reactor</code>：负责响应事件，将事件分发到绑定了对应事件的Handler，如果是连接事件，则分发到Acceptor。</p></blockquote><blockquote><p><code>Handler</code>：事件处理器。负责执行对应事件对应的业务逻辑。</p></blockquote><blockquote><p><code>Acceptor</code>：绑定了 connect 事件，当客户端发起connect请求时，Reactor会将accept事件分发给Acceptor处理。</p></blockquote><h2 id="2-1-单Reactor单线程"><a href="#2-1-单Reactor单线程" class="headerlink" title="2.1 单Reactor单线程"></a>2.1 单Reactor单线程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05bf6fbe7?w=714&h=310&f=png&s=84409" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>只有一个<code>select</code>循环接收请求，客户端（client）注册进来由<code>Reactor</code>接收注册事件，然后再由reactor分发（dispatch）出去，由下面的处理器（Handler）去处理。</p></blockquote><h3 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>一个餐厅里只有一个既是前台也是服务员的人，负责接待客人，也负责把客人点的菜下达给厨师。</p><h3 id="单Reactor单线程的特点"><a href="#单Reactor单线程的特点" class="headerlink" title="单Reactor单线程的特点"></a>单Reactor单线程的特点</h3><p>单线程的问题实际上是很明显的。只要其中一个Handler方法阻塞了，那就会导致所有的client的Handler都被阻塞了，也会导致注册事件也无法处理，无法接收新的请求。所以这种模式用的比较少，因为不能充分利用到多核的资源。</p><p>这种模式仅仅只能处理Handler比较快速完成的场景。</p><h2 id="2-2-单Reactor多线程"><a href="#2-2-单Reactor多线程" class="headerlink" title="2.2 单Reactor多线程"></a>2.2 单Reactor多线程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05fac64c3?w=721&h=496&f=png&s=181611" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>在<strong>单Reactor多线程</strong>中，注册接收事件都是由<code>Reactor</code>来做，其它的计算，编解码由一个线程池来做。从图中可以看出工作线程是多线程的，监听注册事件的<code>Reactor</code>还是单线程。</p></blockquote><h3 id="通俗解释-1"><a href="#通俗解释-1" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>相当于餐厅里有一个前台，多个服务员。前台只负责接待客人，服务员只负责服务客人。</p><h3 id="单Reactor多线程的特点"><a href="#单Reactor多线程的特点" class="headerlink" title="单Reactor多线程的特点"></a>单Reactor多线程的特点</h3><p>对比<strong>单Reactor单线程</strong>模型，多线程Reactor模式在Handler读写处理时，交给工作线程池处理，不会导致Reactor无法执行，因为Reactor分发和Handler处理是分开的，能充分地利用资源。从而提升应用的性能。</p><p>缺点：<br>Reactor只在主线程中运行，承担所有事件的监听和响应，如果短时间的高并发场景下，依然会造成性能瓶颈。</p><h2 id="2-3-多Reactor多线程"><a href="#2-3-多Reactor多线程" class="headerlink" title="2.3 多Reactor多线程"></a>2.3 多Reactor多线程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05faeebc1?w=686&h=483&f=png&s=121267" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>1、mainReactor负责监听客户端请求，专门处理新连接的建立，将建立好的连接注册到subReactor。<br>2、subReactor 将分配的连接加入到队列进行监听，当有新的事件发生时，会调用连接相对应的Handler进行处理。</p></blockquote><h3 id="通俗解释-2"><a href="#通俗解释-2" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>相当于餐厅里有多个前台和多个服务员，前台只负责接待客人，服务员只负责服务客人。</p><h3 id="多Reactor多线程的特点"><a href="#多Reactor多线程的特点" class="headerlink" title="多Reactor多线程的特点"></a>多Reactor多线程的特点</h3><p>mainReactor 主要是用来处理客户端请求连接建立的操作。<br>subReactor主要做和建立起来的连接做数据交互和事件业务处理操作，每个subReactor一个线程来处理。</p><blockquote><p>这样的模型使得每个模块更加专一，耦合度更低，能支持更高的并发量。许多框架也使用这种模式，比如接下来要讲的Netty框架就采用了这种模式。</p></blockquote><h1 id="三、在Netty中的应用"><a href="#三、在Netty中的应用" class="headerlink" title="三、在Netty中的应用"></a>三、在Netty中的应用</h1><p>Netty可谓是框架中精品中的极品，要用一张图或者一段话来总结概括不太可能，所以下面我仅分析一下Netty框架的架构模型。在下一篇文章再继续深入探究Netty。<br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc0641d4ed5?w=855&h=726&f=png&s=400825" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这个架构实际上跟多Reactor多线程模型比较像。</p><blockquote><p>1、BossGroup相当于mainReactor，负责建立连接并且把连接注册到WorkGroup中。WorkGroup负责处理连接对应的读写事件。</p></blockquote><blockquote><p>2、BossGroup和WorkGroup是两个线程池，里面有多个NioEventGroup(实际上是线程)，默认BossGroup和WorkGroup里的线程数是cpu核数的两倍（源码中有体现）。</p></blockquote><blockquote><p>3、每一个NioEventGroup都是一个无限循环，负责监听相对应的事件。</p></blockquote><blockquote><p>4、Pipeline(通道)里包含多个ChannelHandler(业务处理)，按顺序执行。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>其实上面的这些模型都只是一种思想，很多人可能觉得学习思想不是很重要。实际上要学习一门技术，要先有天上飞的理论才有落地的产品。世界上的事物大多都是如此。</p><p>最后借用大神<strong>Doug Lea</strong>的名言：</p><blockquote><p>分享知识和分享苹果是不一样的，苹果会越分越少，而自己的知识并不会因为给了别人就减少了，知识的分享更能激荡出不一样的火花。</p></blockquote><p><strong>创作不易</strong>，觉得有用就<strong>点个赞</strong>吧。</p><p>下一篇讲Netty框架，想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO入门</title>
    <link href="/2020/06/25/NIO%E5%85%A5%E9%97%A8/"/>
    <url>/2020/06/25/NIO%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/image-20200625230224224.png" srcset="/img/loading.gif" alt="image-20200625230224224"></p><blockquote><p>学如逆水行舟，不进则退</p></blockquote><h1 id="1-NIO概述"><a href="#1-NIO概述" class="headerlink" title="1 NIO概述"></a>1 NIO概述</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p><strong>java.nio</strong>全称<strong>java non-blocking IO</strong>，是指<strong>JDK1.4 及以上</strong>版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供<strong>缓存支持的数据容器</strong>，使用它可以提供<strong>非阻塞式</strong>的高伸缩性网络(来源于百度百科)。</p><a id="more"></a><h2 id="1-2-为什么使用NIO"><a href="#1-2-为什么使用NIO" class="headerlink" title="1.2 为什么使用NIO"></a>1.2 为什么使用NIO</h2><p>在上面的描述中提到，是在JDK1.4以上的版本才提供NIO，那在之前使用的是什么呢？答案很简单，就是<strong>BIO</strong>(阻塞式IO)，也就是我们常用的IO流。</p><p>BIO的问题其实不用多说了，因为在使用BIO时，主线程会进入阻塞状态，这就非常影响程序的性能，<strong>不能充分利用机器资源</strong>。但是这样就会有人提出疑问了，那我<strong>使用多线程</strong>不就可以了吗？</p><p>但是在高并发的情况下，会创建很多线程，线程会占用内存，线程之间的切换也会浪费资源开销。</p><p>而NIO<strong>只有在连接/通道真正有读写事件</strong>发生时(<strong>事件驱动</strong>)，<strong>才会进行读写</strong>，就大大地减少了系统的开销。不必为每一个连接都创建一个线程，也不必去维护多个线程。</p><p><strong>避免了多个线程之间的上下文切换</strong>，导致资源的浪费。</p><h1 id="为什么使用NIO"><a href="#为什么使用NIO" class="headerlink" title="为什么使用NIO"></a>为什么使用NIO</h1><h1 id="2-NIO的三大核心"><a href="#2-NIO的三大核心" class="headerlink" title="2 NIO的三大核心"></a>2 NIO的三大核心</h1><table><thead><tr><th>NIO的核心</th><th>对应的类或接口</th><th>应用</th><th>作用</th></tr></thead><tbody><tr><td>缓冲区</td><td>java.nio.Buffer</td><td>文件IO/网络IO</td><td>存储数据</td></tr><tr><td>通道</td><td>java.nio.channels.Channel</td><td>文件IO/网络IO</td><td>运输</td></tr><tr><td>选择器</td><td>java.nio.channels.Selector</td><td>网络IO</td><td>控制器</td></tr></tbody></table><h2 id="2-1缓冲区-Buffer"><a href="#2-1缓冲区-Buffer" class="headerlink" title="2.1缓冲区(Buffer)"></a>2.1缓冲区(Buffer)</h2><h3 id="2-1-1-什么是缓冲区"><a href="#2-1-1-什么是缓冲区" class="headerlink" title="2.1.1 什么是缓冲区"></a>2.1.1 什么是缓冲区</h3><p>我们先看以下这张类图，可以看到<code>Buffer</code>有七种类型。</p><p><img src="https://static.lovebilibili.com/Buffer.png" srcset="/img/loading.gif" alt=""></p><p><code>Buffer</code>是一个内存块。在<code>NIO</code>中，所有的数据都是用<code>Buffer</code>处理，有读写两种模式。所以NIO和传统的IO的区别就体现在这里。传统IO是面向<code>Stream</code>流，<code>NIO</code>而是面向缓冲区(<code>Buffer</code>)。</p><h3 id="2-1-2-常用的类型ByteBuffer"><a href="#2-1-2-常用的类型ByteBuffer" class="headerlink" title="2.1.2 常用的类型ByteBuffer"></a>2.1.2 常用的类型ByteBuffer</h3><p>一般我们常用的类型是<code>ByteBuffer</code>，把数据转成字节进行处理。实质上是一个<code>byte[]</code>数组。</p><pre><code class="java">public abstract class ByteBuffer extends Buffer implements Comparable&lt;ByteBuffer&gt;{    //存储数据的数组    final byte[] hb;    //构造器方法    ByteBuffer(int mark, int pos, int lim, int cap, byte[] hb, int offset) {        super(mark, pos, lim, cap);        //初始化数组        this.hb = hb;        this.offset = offset;    }}</code></pre><h3 id="2-1-3-创建Buffer的方式"><a href="#2-1-3-创建Buffer的方式" class="headerlink" title="2.1.3 创建Buffer的方式"></a>2.1.3 创建Buffer的方式</h3><p>主要分成两种：JVM堆内内存块Buffer、堆外内存块Buffer。</p><p>创建堆内内存块(非直接缓冲区)的方法是：</p><pre><code class="java">//创建堆内内存块HeapByteBufferByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);String msg = &quot;java技术爱好者&quot;;//包装一个byte[]数组获得一个Buffer，实际类型是HeapByteBufferByteBuffer byteBuffer2 = ByteBuffer.wrap(msg.getBytes());</code></pre><p>创建堆外内存块(直接缓冲区)的方法：</p><pre><code class="java">//创建堆外内存块DirectByteBufferByteBuffer byteBuffer3 = ByteBuffer.allocateDirect(1024);</code></pre><h4 id="2-1-3-1-HeapByteBuffer与DirectByteBuffer的区别"><a href="#2-1-3-1-HeapByteBuffer与DirectByteBuffer的区别" class="headerlink" title="2.1.3.1 HeapByteBuffer与DirectByteBuffer的区别"></a>2.1.3.1 HeapByteBuffer与DirectByteBuffer的区别</h4><p>其实根据类名就可以看出，<code>HeapByteBuffer</code>所创建的字节缓冲区就是在JVM堆中的，即JVM内部所维护的字节数组。而<code>DirectByteBuffer</code>是<strong>直接操作操作系统本地代码</strong>创建的<strong>内存缓冲数组</strong>。</p><p><code>DirectByteBuffer</code>的使用场景：</p><ol><li><p>java程序与本地磁盘、socket传输数据</p></li><li><p>大文件对象，可以使用。不会受到堆内存大小的限制。</p></li><li><p>不需要频繁创建，生命周期较长的情况，能重复使用的情况。</p></li></ol><p><code>HeapByteBuffer</code>的使用场景：</p><p>除了以上的场景外，其他情况还是建议使用<code>HeapByteBuffer</code>，没有达到一定的量级，实际上使用<code>DirectByteBuffer</code>是体现不出优势的。</p><h4 id="2-1-3-2-Buffer的初体验"><a href="#2-1-3-2-Buffer的初体验" class="headerlink" title="2.1.3.2 Buffer的初体验"></a>2.1.3.2 Buffer的初体验</h4><p>接下来，使用<code>ByteBuffer</code>做一个小例子，熟悉一下：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        String msg = &quot;java技术爱好者，起飞！&quot;;        //创建一个固定大小的buffer(返回的是HeapByteBuffer)        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);        byte[] bytes = msg.getBytes();        //写入数据到Buffer中        byteBuffer.put(bytes);        //切换成读模式，关键一步        byteBuffer.flip();        //创建一个临时数组，用于存储获取到的数据        byte[] tempByte = new byte[bytes.length];        int i = 0;        //如果还有数据，就循环。循环判断条件        while (byteBuffer.hasRemaining()) {            //获取byteBuffer中的数据            byte b = byteBuffer.get();            //放到临时数组中            tempByte[i] = b;            i++;        }        //打印结果        System.out.println(new String(tempByte));//java技术爱好者，起飞！    }</code></pre><p>这上面有一个<code>flip()</code>方法是很重要的。意思是切换到读模式。上面已经提到<strong>缓存区是双向的</strong>，<strong>既可以往缓冲区写入数据，也可以从缓冲区读取数据</strong>。但是不能同时进行，需要切换。那么这个切换模式的本质是什么呢？</p><h3 id="2-1-4-三个重要参数"><a href="#2-1-4-三个重要参数" class="headerlink" title="2.1.4 三个重要参数"></a>2.1.4 三个重要参数</h3><pre><code class="java">//位置，默认是从第一个开始private int position = 0;//限制，不能读取或者写入的位置索引private int limit;//容量，缓冲区所包含的元素的数量private int capacity;</code></pre><p>那么我们以上面的例子，一句一句代码进行分析：</p><pre><code class="java">String msg = &quot;java技术爱好者，起飞！&quot;;//创建一个固定大小的buffer(返回的是HeapByteBuffer)ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</code></pre><p>当创建一个缓冲区时，参数的值是这样的：</p><p><img src="https://static.lovebilibili.com/image-20200625122035548.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/image-20200625122337215.png" srcset="/img/loading.gif" alt="image-20200625122337215"></p><p>当执行到<code>byteBuffer.put(bytes)</code>，当<code>put()</code>进入多少数据，position就会增加多少，参数就会发生变化：</p><p><img src="https://static.lovebilibili.com/image-20200625122640979.png" srcset="/img/loading.gif" alt="image-20200625122640979"></p><p><img src="https://static.lovebilibili.com/image-20200625123835657.png" srcset="/img/loading.gif" alt="image-20200625123835657"></p><p>接下来关键一步<code>byteBuffer.flip()</code>，会发生如下变化：</p><p><img src="https://static.lovebilibili.com/image-20200625122931713.png" srcset="/img/loading.gif" alt="image-20200625122931713"></p><p><img src="https://static.lovebilibili.com/image-20200625123004623.png" srcset="/img/loading.gif" alt="image-20200625123004623"></p><p><code>flip()</code>方法的源码如下：</p><pre><code class="java">    public final Buffer flip() {        limit = position;        position = 0;        mark = -1;        return this;    }</code></pre><p>为什么要这样赋值呢？因为下面有一句循环条件判断：</p><pre><code class="java">byteBuffer.hasRemaining();public final boolean hasRemaining() {    //判断position的索引是否小于limit。    //所以可以看出limit的作用就是记录写入数据的位置，那么当读取数据时，就知道读到哪个位置    return position &lt; limit;}</code></pre><p>接下来就是在<code>while</code>循环中<code>get()</code>读取数据，读取完之后。</p><p><img src="https://static.lovebilibili.com/image-20200625123623688.png" srcset="/img/loading.gif" alt="image-20200625123623688"></p><p><img src="https://static.lovebilibili.com/image-20200625123745018.png" srcset="/img/loading.gif" alt="image-20200625123745018"></p><p>最后当<code>position</code>等于<code>limit</code>时，循环判断条件不成立，就跳出循环，读取完毕。</p><p>所以可以看出实质上<code>capacity</code>容量大小是不变的，实际上是通过控制<code>position</code>和<code>limit</code>的值来控制读写的数据。</p><h2 id="2-2-管道-Channel"><a href="#2-2-管道-Channel" class="headerlink" title="2.2 管道(Channel)"></a>2.2 管道(Channel)</h2><p>首先我们看一下Channel有哪些子类：</p><p><img src="https://static.lovebilibili.com/Channel.png" srcset="/img/loading.gif" alt=""></p><p>常用的Channel有这四种：</p><blockquote><p>FileChannel，读写文件中的数据。<br>SocketChannel，通过TCP读写网络中的数据。<br>ServerSockectChannel，监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。<br>DatagramChannel，通过UDP读写网络中的数据。</p></blockquote><p><strong>Channel本身并不存储数据，只是负责数据的运输</strong>。必须要和<code>Buffer</code>一起使用。</p><h3 id="2-2-1-获取通道的方式"><a href="#2-2-1-获取通道的方式" class="headerlink" title="2.2.1 获取通道的方式"></a>2.2.1 获取通道的方式</h3><h4 id="2-2-1-1-FileChannel"><a href="#2-2-1-1-FileChannel" class="headerlink" title="2.2.1.1 FileChannel"></a>2.2.1.1 FileChannel</h4><p>FileChannel的获取方式，下面举个文件复制拷贝的例子进行说明：</p><p><img src="https://static.lovebilibili.com/image-20200625130742262.png" srcset="/img/loading.gif" alt="image-20200625130742262"></p><p>首先准备一个”1.txt”放在项目的根目录下，然后编写一个main方法：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了        ByteBuffer byteBuffer = ByteBuffer.allocate((int)file.length());        //把输入流通道的数据读取到缓冲区        inputStreamChannel.read(byteBuffer);        //切换成读模式        byteBuffer.flip();        //把数据从缓冲区写入到输出流通道        outputStreamChannel.write(byteBuffer);        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }</code></pre><p>执行后，我们就获得一个”2.txt”。执行成功。</p><p><img src="https://static.lovebilibili.com/image-20200625130945572.png" srcset="/img/loading.gif" alt="image-20200625130945572"></p><p>以上的例子，可以用一张示意图表示，是这样的：</p><p><img src="https://static.lovebilibili.com/image-20200625132433945.png" srcset="/img/loading.gif" alt="image-20200625132433945"></p><h4 id="2-2-1-2-SocketChannel"><a href="#2-2-1-2-SocketChannel" class="headerlink" title="2.2.1.2 SocketChannel"></a>2.2.1.2 SocketChannel</h4><p>接下来我们学习获取<code>SocketChannel</code>的方式。</p><p>还是一样，我们通过一个例子来快速上手：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取ServerSocketChannel        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666);        //绑定地址，端口号        serverSocketChannel.bind(address);        //创建一个缓冲区        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);        while (true) {            //获取SocketChannel            SocketChannel socketChannel = serverSocketChannel.accept();            while (socketChannel.read(byteBuffer) != -1){                //打印结果                System.out.println(new String(byteBuffer.array()));                //清空缓冲区                byteBuffer.clear();            }        }    }</code></pre><p>然后运行main()方法，我们可以通过<code>telnet</code>命令进行连接测试：</p><p><img src="https://static.lovebilibili.com/image-20200625134508044.png" srcset="/img/loading.gif" alt="image-20200625134508044"></p><p>通过上面的例子可以知道，通过<code>ServerSocketChannel.open()</code>方法可以获取服务器的通道，然后绑定一个地址端口号，接着<code>accept()</code>方法可获得一个<code>SocketChannel</code>通道，也就是客户端的连接通道。</p><p>最后配合使用<code>Buffer</code>进行读写即可。</p><p>这就是一个简单的例子，实际上上面的例子是阻塞式的。要做到非阻塞还需要使用选择器<code>Selector</code>。</p><h2 id="2-3-选择器-Selector"><a href="#2-3-选择器-Selector" class="headerlink" title="2.3 选择器(Selector)"></a>2.3 选择器(Selector)</h2><p><code>Selector</code>翻译成<strong>选择器</strong>，有些人也会翻译成<strong>多路复用器</strong>，实际上指的是同一样东西。</p><p>只有网络IO才会使用选择器，文件IO是不需要使用的。</p><p>选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。换句话说，也就是事件驱动。以此实现<strong>单线程管理多个Channel</strong>的目的。</p><p><img src="https://static.lovebilibili.com/20180813104125886.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-1-核心API"><a href="#2-3-1-核心API" class="headerlink" title="2.3.1 核心API"></a>2.3.1 核心API</h3><table><thead><tr><th>API方法名</th><th>作用</th></tr></thead><tbody><tr><td>Selector.open()</td><td>打开一个选择器。</td></tr><tr><td>select()</td><td>选择一组键，其相应的通道已为 I/O 操作准备就绪。</td></tr><tr><td>selectedKeys()</td><td>返回此选择器的已选择键集。</td></tr></tbody></table><p>以上的API会在后面的例子用到，先有个印象。</p><h1 id="3-NIO快速入门"><a href="#3-NIO快速入门" class="headerlink" title="3 NIO快速入门"></a>3 NIO快速入门</h1><h2 id="3-1-文件IO"><a href="#3-1-文件IO" class="headerlink" title="3.1 文件IO"></a>3.1 文件IO</h2><h3 id="3-1-1-通道间的数据传输"><a href="#3-1-1-通道间的数据传输" class="headerlink" title="3.1.1 通道间的数据传输"></a>3.1.1 通道间的数据传输</h3><p>这里主要介绍两个通道与通道之间数据传输的方式：</p><p><code>transferTo()</code>：把源通道的数据传输到目的通道中。</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了        ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length());        //把输入流通道的数据读取到输出流的通道        inputStreamChannel.transferTo(0, byteBuffer.limit(), outputStreamChannel);        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }    </code></pre><p><code>transferFrom()</code>：把来自源通道的数据传输到目的通道。</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了        ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length());        //把输入流通道的数据读取到输出流的通道        outputStreamChannel.transferFrom(inputStreamChannel,0,byteBuffer.limit());        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }</code></pre><h3 id="3-1-2-分散读取和聚合写入"><a href="#3-1-2-分散读取和聚合写入" class="headerlink" title="3.1.2 分散读取和聚合写入"></a>3.1.2 分散读取和聚合写入</h3><p>我们先看一下FileChannel的源码：</p><pre><code class="java">public abstract class FileChannel extends AbstractInterruptibleChannel    implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel {   }</code></pre><p>从源码中可以看出实现了GatheringByteChannel, ScatteringByteChannel接口。也就是支持分散读取和聚合写入的操作。怎么使用呢，请看以下例子：</p><p>我们写一个main方法来实现复制1.txt文件，文件内容是：</p><pre><code class="java">abcdefghijklmnopqrstuvwxyz//26个字母</code></pre><p>代码如下：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建三个缓冲区，分别都是5        ByteBuffer byteBuffer1 = ByteBuffer.allocate(5);        ByteBuffer byteBuffer2 = ByteBuffer.allocate(5);        ByteBuffer byteBuffer3 = ByteBuffer.allocate(5);        //创建一个缓冲区数组        ByteBuffer[] buffers = new ByteBuffer[]{byteBuffer1, byteBuffer2, byteBuffer3};        //循环写入到buffers缓冲区数组中，分散读取        long read;        long sumLength = 0;        while ((read = inputStreamChannel.read(buffers)) != -1) {            sumLength += read;            Arrays.stream(buffers)                    .map(buffer -&gt; &quot;posstion=&quot; + buffer.position() + &quot;,limit=&quot; + buffer.limit())                    .forEach(System.out::println);            //切换模式            Arrays.stream(buffers).forEach(Buffer::flip);            //聚合写入到文件输出通道            outputStreamChannel.write(buffers);            //清空缓冲区            Arrays.stream(buffers).forEach(Buffer::clear);        }        System.out.println(&quot;总长度:&quot; + sumLength);        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }</code></pre><p>打印结果：</p><pre><code class="java">posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=1,limit=5总长度:26</code></pre><p>可以看到循环了两次。第一次循环时，三个缓冲区都读取了5个字节，总共读取了15，也就是读满了。还剩下11个字节，于是第二次循环时，前两个缓冲区分配了5个字节，最后一个缓冲区给他分配了1个字节，刚好读完。总共就是26个字节。</p><p>这就是分散读取，聚合写入的过程。</p><p>使用场景就是可以<strong>使用一个缓冲区数组，自动地根据需要去分配缓冲区的大小。可以减少内存消耗</strong>。网络IO也可以使用，这里就不写例子演示了。</p><h3 id="3-1-3-非直接-直接缓冲区"><a href="#3-1-3-非直接-直接缓冲区" class="headerlink" title="3.1.3 非直接/直接缓冲区"></a>3.1.3 非直接/直接缓冲区</h3><p>非直接缓冲区的创建方式：</p><pre><code class="java">static ByteBuffer allocate(int capacity)</code></pre><p>直接缓冲区的创建方式：</p><pre><code class="java">static ByteBuffer allocateDirect(int capacity)</code></pre><p>非直接/直接缓冲区的区别示意图：</p><p><img src="https://static.lovebilibili.com/307536-20170731145300974-520326124.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/307536-20170731145311224-406164516.png" srcset="/img/loading.gif" alt=""></p><p>从示意图中我们可以发现，最大的不同在于直接缓冲区不需要再把文件内容copy到物理内存中。这就大大地提高了性能。其实在介绍Buffer时，我们就有接触到这个概念。直接缓冲区是堆外内存，在本地文件IO效率会更高一点。</p><p>接下来我们来对比一下效率，以一个136 MB的视频文件为例：</p><pre><code class="java">public static void main(String[] args) throws Exception {    long starTime = System.currentTimeMillis();    //获取文件输入流    File file = new File(&quot;D:\\小电影.mp4&quot;);//文件大小136 MB    FileInputStream inputStream = new FileInputStream(file);    //从文件输入流获取通道    FileChannel inputStreamChannel = inputStream.getChannel();    //获取文件输出流    FileOutputStream outputStream = new FileOutputStream(new File(&quot;D:\\test.mp4&quot;));    //从文件输出流获取通道    FileChannel outputStreamChannel = outputStream.getChannel();    //创建一个直接缓冲区    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(5 * 1024 * 1024);    //创建一个非直接缓冲区    //ByteBuffer byteBuffer = ByteBuffer.allocate(5 * 1024 * 1024);    //写入到缓冲区    while (inputStreamChannel.read(byteBuffer) != -1) {        //切换读模式        byteBuffer.flip();        outputStreamChannel.write(byteBuffer);        byteBuffer.clear();    }    //关闭通道    outputStream.close();    inputStream.close();    outputStreamChannel.close();    inputStreamChannel.close();    long endTime = System.currentTimeMillis();    System.out.println(&quot;消耗时间：&quot; + (endTime - starTime) + &quot;毫秒&quot;);}</code></pre><p>结果：</p><p>直接缓冲区的消耗时间：283毫秒</p><p>非直接缓冲区的消耗时间：487毫秒</p><h2 id="3-2-网络IO"><a href="#3-2-网络IO" class="headerlink" title="3.2 网络IO"></a>3.2 网络IO</h2><p>其实NIO的主要用途是网络IO，在NIO之前java要使用网络编程就只有用<code>Socket</code>。而<code>Socket</code>是阻塞的，显然对于高并发的场景是不适用的。所以NIO的出现就是解决了这个痛点。</p><p>主要思想是把Channel通道注册到Selector中，通过Selector去监听Channel中的事件状态，这样就不需要阻塞等待客户端的连接，从主动等待客户端的连接，变成了通过事件驱动。没有监听的事件，服务器可以做自己的事情。</p><h3 id="3-2-1-使用Selector的小例子"><a href="#3-2-1-使用Selector的小例子" class="headerlink" title="3.2.1 使用Selector的小例子"></a>3.2.1 使用Selector的小例子</h3><p>接下来趁热打铁，我们来做一个服务器接受客户端消息的例子：</p><p>首先服务端代码：</p><pre><code class="java">public class NIOServer {    public static void main(String[] args) throws Exception {        //打开一个ServerSocketChannel        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666);        //绑定地址        serverSocketChannel.bind(address);        //设置为非阻塞        serverSocketChannel.configureBlocking(false);        //打开一个选择器        Selector selector = Selector.open();        //serverSocketChannel注册到选择器中,监听连接事件        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        //循环等待客户端的连接        while (true) {            //等待3秒，（返回0相当于没有事件）如果没有事件，则跳过            if (selector.select(3000) == 0) {                System.out.println(&quot;服务器等待3秒，没有连接&quot;);                continue;            }            //如果有事件selector.select(3000)&gt;0的情况,获取事件            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();            //获取迭代器遍历            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();            while (it.hasNext()) {                //获取到事件                SelectionKey selectionKey = it.next();                //判断如果是连接事件                if (selectionKey.isAcceptable()) {                    //服务器与客户端建立连接，获取socketChannel                    SocketChannel socketChannel = serverSocketChannel.accept();                    //设置成非阻塞                    socketChannel.configureBlocking(false);                    //把socketChannel注册到selector中，监听读事件，并绑定一个缓冲区                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));                }                //如果是读事件                if (selectionKey.isReadable()) {                    //获取通道                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();                    //获取关联的ByteBuffer                    ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();                    //打印从客户端获取到的数据                    socketChannel.read(buffer);                    System.out.println(&quot;from 客户端：&quot; + new String(buffer.array()));                }                //从事件集合中删除已处理的事件，防止重复处理                it.remove();            }        }    }}</code></pre><p>客户端代码：</p><pre><code class="java">public class NIOClient {    public static void main(String[] args) throws Exception {        SocketChannel socketChannel = SocketChannel.open();        InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666);        socketChannel.configureBlocking(false);        //连接服务器        boolean connect = socketChannel.connect(address);        //判断是否连接成功        if(!connect){            //等待连接的过程中            while (!socketChannel.finishConnect()){                System.out.println(&quot;连接服务器需要时间，期间可以做其他事情...&quot;);            }        }        String msg = &quot;hello java技术爱好者！&quot;;        ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());        //把byteBuffer数据写入到通道中        socketChannel.write(byteBuffer);        //让程序卡在这个位置，不关闭连接        System.in.read();    }}</code></pre><p>接下来启动服务端，然后再启动客户端，我们可以看到控制台打印以下信息：</p><pre><code class="java">服务器等待3秒，没有连接服务器等待3秒，没有连接from 客户端：hello java技术爱好者！                       服务器等待3秒，没有连接服务器等待3秒，没有连接</code></pre><p>通过这个例子我们引出以下知识点。</p><h3 id="3-2-2-SelectionKey"><a href="#3-2-2-SelectionKey" class="headerlink" title="3.2.2 SelectionKey"></a>3.2.2 SelectionKey</h3><p>在<code>SelectionKey</code>类中有四个常量表示四种事件，来看源码：</p><pre><code class="java">public abstract class SelectionKey {    //读事件    public static final int OP_READ = 1 &lt;&lt; 0; //2^0=1    //写事件    public static final int OP_WRITE = 1 &lt;&lt; 2; // 2^2=4    //连接操作,Client端支持的一种操作    public static final int OP_CONNECT = 1 &lt;&lt; 3; // 2^3=8    //连接可接受操作,仅ServerSocketChannel支持    public static final int OP_ACCEPT = 1 &lt;&lt; 4; // 2^4=16}</code></pre><p>附加的对象(可选)，把通道注册到选择器中时可以附加一个对象。</p><pre><code class="java">public final SelectionKey register(Selector sel, int ops, Object att)</code></pre><p>从<code>selectionKey</code>中获取附件对象可以使用<code>attachment()</code>方法</p><pre><code class="java">public final Object attachment() {    return attachment;}</code></pre><h1 id="4-使用NIO实现多人聊天室"><a href="#4-使用NIO实现多人聊天室" class="headerlink" title="4 使用NIO实现多人聊天室"></a>4 使用NIO实现多人聊天室</h1><p>接下来进行一个实战例子，用NIO实现一个多人运动版本的聊天室。</p><p>服务端代码：</p><pre><code class="java">public class GroupChatServer {    private Selector selector;    private ServerSocketChannel serverSocketChannel;    public static final int PORT = 6667;    //构造器初始化成员变量    public GroupChatServer() {        try {            //打开一个选择器            this.selector = Selector.open();            //打开serverSocketChannel            this.serverSocketChannel = ServerSocketChannel.open();            //绑定地址，端口号            this.serverSocketChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, PORT));            //设置为非阻塞            serverSocketChannel.configureBlocking(false);            //把通道注册到选择器中            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 监听，并且接受客户端消息，转发到其他客户端     */    public void listen() {        try {            while (true) {                //获取监听的事件总数                int count = selector.select(2000);                if (count &gt; 0) {                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                    //获取SelectionKey集合                    Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();                    while (it.hasNext()) {                        SelectionKey key = it.next();                        //如果是获取连接事件                        if (key.isAcceptable()) {                            SocketChannel socketChannel = serverSocketChannel.accept();                            //设置为非阻塞                            socketChannel.configureBlocking(false);                            //注册到选择器中                            socketChannel.register(selector, SelectionKey.OP_READ);                            System.out.println(socketChannel.getRemoteAddress() + &quot;上线了~&quot;);                        }                        //如果是读就绪事件                        if (key.isReadable()) {                            //读取消息，并且转发到其他客户端                            readData(key);                        }                        it.remove();                    }                } else {                    System.out.println(&quot;等待...&quot;);                }            }        } catch (Exception e) {            e.printStackTrace();        }    }    //获取客户端发送过来的消息    private void readData(SelectionKey selectionKey) {        SocketChannel socketChannel = null;        try {            //从selectionKey中获取channel            socketChannel = (SocketChannel) selectionKey.channel();            //创建一个缓冲区            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);            //把通道的数据写入到缓冲区            int count = socketChannel.read(byteBuffer);            //判断返回的count是否大于0，大于0表示读取到了数据            if (count &gt; 0) {                //把缓冲区的byte[]转成字符串                String msg = new String(byteBuffer.array());                //输出该消息到控制台                System.out.println(&quot;from 客户端：&quot; + msg);                //转发到其他客户端                notifyAllClient(msg, socketChannel);            }        } catch (Exception e) {            try {                //打印离线的通知                System.out.println(socketChannel.getRemoteAddress() + &quot;离线了...&quot;);                //取消注册                selectionKey.cancel();                //关闭流                socketChannel.close();            } catch (IOException e1) {                e1.printStackTrace();            }        }    }    /**     * 转发消息到其他客户端     * msg 消息     * noNotifyChannel 不需要通知的Channel     */    private void notifyAllClient(String msg, SocketChannel noNotifyChannel) throws Exception {        System.out.println(&quot;服务器转发消息~&quot;);        for (SelectionKey selectionKey : selector.keys()) {            Channel channel = selectionKey.channel();            //channel的类型实际类型是SocketChannel，并且排除不需要通知的通道            if (channel instanceof SocketChannel &amp;&amp; channel != noNotifyChannel) {                //强转成SocketChannel类型                SocketChannel socketChannel = (SocketChannel) channel;                //通过消息，包裹获取一个缓冲区                ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());                socketChannel.write(byteBuffer);            }        }    }    public static void main(String[] args) throws Exception {        GroupChatServer chatServer = new GroupChatServer();        //启动服务器，监听        chatServer.listen();    }}</code></pre><p>客户端代码：</p><pre><code class="java">public class GroupChatClinet {    private Selector selector;    private SocketChannel socketChannel;    private String userName;    public GroupChatClinet() {        try {            //打开选择器            this.selector = Selector.open();            //连接服务器            socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, GroupChatServer.PORT));            //设置为非阻塞            socketChannel.configureBlocking(false);            //注册到选择器中            socketChannel.register(selector, SelectionKey.OP_READ);            //获取用户名            userName = socketChannel.getLocalAddress().toString().substring(1);            System.out.println(userName + &quot; is ok~&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }    //发送消息到服务端    private void sendMsg(String msg) {        msg = userName + &quot;说：&quot; + msg;        try {            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));        } catch (Exception e) {            e.printStackTrace();        }    }    //读取服务端发送过来的消息    private void readMsg() {        try {            int count = selector.select();            if (count &gt; 0) {                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                while (iterator.hasNext()) {                    SelectionKey selectionKey = iterator.next();                    //判断是读就绪事件                    if (selectionKey.isReadable()) {                        SocketChannel channel = (SocketChannel) selectionKey.channel();                        //创建一个缓冲区                        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);                        //从服务器的通道中读取数据到缓冲区                        channel.read(byteBuffer);                        //缓冲区的数据，转成字符串，并打印                        System.out.println(new String(byteBuffer.array()));                    }                    iterator.remove();                }            }        } catch (Exception e) {            e.printStackTrace();        }    }    public static void main(String[] args) throws Exception {        GroupChatClinet chatClinet = new GroupChatClinet();        //启动线程，读取服务器转发过来的消息        new Thread(() -&gt; {            while (true) {                chatClinet.readMsg();                try {                    Thread.sleep(3000);                } catch (Exception e) {                    e.printStackTrace();                }            }        }).start();        //主线程发送消息到服务器        Scanner scanner = new Scanner(System.in);        while (scanner.hasNextLine()) {            String msg = scanner.nextLine();            chatClinet.sendMsg(msg);        }    }}</code></pre><p>先启动服务端的main方法，再启动两个客户端的main方法：</p><p><img src="https://static.lovebilibili.com/image-20200625225034967.png" srcset="/img/loading.gif" alt="image-20200625225034967"></p><p>然后使用两个客户端开始聊天了~</p><p><img src="https://static.lovebilibili.com/image-20200625225118983.png" srcset="/img/loading.gif" alt="image-20200625225118983"></p><p><img src="https://static.lovebilibili.com/image-20200625225130048.png" srcset="/img/loading.gif" alt="image-20200625225130048"></p><p>以上就是使用NIO<strong>实现多人聊天室</strong>的例子，同学们可以看着我这个例子自己完成一下。要多写代码才好理解这些概念。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>创作不易</strong>，觉得有用就<strong>点个赞</strong>吧。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让别人记住的程序员。我们下期再见！！！</strong></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List集合的坑</title>
    <link href="/2020/06/21/List%E9%9B%86%E5%90%88%E7%9A%84%E5%9D%91/"/>
    <url>/2020/06/21/List%E9%9B%86%E5%90%88%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学如逆水行舟，不进则退</p></blockquote><p>经过几年的工作经验，我发现<code>List</code>有很多坑，之前公司有些实习生一不小心就踩到了，所以我打算写一篇文章总结一下，希望看到这篇文章的人能不再踩到坑，代码没bug。做个快乐的程序员。</p><a id="more"></a><h3 id="迭代时删除元素"><a href="#迭代时删除元素" class="headerlink" title="迭代时删除元素"></a>迭代时删除元素</h3><p>使用<code>for-each</code>迭代遍历时，删除集合中的元素，会报错。</p><pre><code class="java">    private static List&lt;String&gt; list = new ArrayList&lt;&gt;();    static {        //初始化集合        for (int i = 1; i &lt;= 10; i++) {            list.add(String.valueOf(i));        }    }    public static void main(String[] args) {        //使用for-each迭代时删除元素        for (String str : list) {            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }    }</code></pre><p>或者你使用迭代器<code>Iterator</code>遍历时，删除元素。</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        Iterator&lt;String&gt; it = list.iterator();        while (it.hasNext()) {            String str = it.next();            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }    }</code></pre><p>以上两种情况都会报这个错：</p><pre><code class="java">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)    at java.util.ArrayList$Itr.next(ArrayList.java:851)</code></pre><p>这就是不正确的删除姿势，那怎么删呢？</p><p>使用<code>for-i</code>循环遍历删除(亲测有效)：</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        for (int i = 0; i &lt; list.size(); i++) {            String s = list.get(i);            if (&quot;1&quot;.equals(s)) {                list.remove(s);            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>使用<code>for-i</code>循环倒序遍历，删除元素。</p><pre><code class="java">    public static void main(String[] args) {        //使用for-i倒序遍历，删除元素        for (int i = list.size() - 1; i &gt;= 0; i--) {            String str = list.get(i);            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>使用<code>Iterator</code>的<code>remove()</code>方法删除。</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        Iterator&lt;String&gt; it = list.iterator();        while (it.hasNext()) {            String str = it.next();            if (&quot;1&quot;.equals(str)) {                it.remove();            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>要么潇洒一点，用<code>Lambda</code>表达式。在java8中，<code>List</code>增加了一个<code>removeIf()</code>方法用于删除。</p><pre><code class="java">    public static void main(String[] args) {        //使用removeIf()遍历时，删除元素。删除集合中为1的元素        list.removeIf(str -&gt; &quot;1&quot;.equals(str));        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><h3 id="使用asList-获得集合删除-增加"><a href="#使用asList-获得集合删除-增加" class="headerlink" title="使用asList()获得集合删除/增加"></a>使用asList()获得集合删除/增加</h3><p>看代码演示：</p><pre><code class="java">    public static void main(String[] args) {        List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6);        nums.add(7);    }</code></pre><pre><code class="java">    public static void main(String[] args) {        List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6);        nums.remove(1);    }</code></pre><p>如果你进行以上操作，就会看到报错：</p><pre><code class="java">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException    at java.util.AbstractList.remove(AbstractList.java:161)</code></pre><p>为什么会报这个错，看一下源代码就知道了！</p><pre><code class="java">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable {}</code></pre><p><code>ArrayList</code>不是<code>util</code>包的<code>ArrayList</code>，而是<code>Arrays</code>的一个内部类。因为继承了<code>AbstractList</code>抽象类，但是又没有实现<code>add()</code>、<code>remove()</code>方法。所以会调用抽象类的<code>add()</code>和<code>remove()</code>。<br>你猜猜抽象类的<code>add()</code>怎么着？</p><pre><code class="java">    public void add(int index, E element) {        throw new UnsupportedOperationException();    }    public E remove(int index) {        throw new UnsupportedOperationException();    }</code></pre><p>所以不能用<code>asList()</code>得到的集合去增删了！</p><h3 id="通过subList-方法获得集合后增删"><a href="#通过subList-方法获得集合后增删" class="headerlink" title="通过subList()方法获得集合后增删"></a>通过subList()方法获得集合后增删</h3><p>当使用<code>subList()</code>方法获得集合后删除，原(父)集合也会被删除。</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; subList = list.subList(0, 5);        System.out.println(list);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5]        subList.remove(&quot;1&quot;);        System.out.println(list);//[2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[2, 3, 4, 5]    }</code></pre><p>当使用<code>subList()</code>方法获得集合后增加元素，原(父)集合也会增加。</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; subList = list.subList(0, 5);        System.out.println(list);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5]        subList.add(&quot;11&quot;);        System.out.println(list);//[1, 2, 3, 4, 5, 11, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5, 11]    }</code></pre><p>大家看一下源码就知道什么原因了。</p><pre><code class="java">private class SubList extends AbstractList&lt;E&gt; implements RandomAccess {        public void add(int index, E e) {            rangeCheckForAdd(index);            checkForComodification();            //父集合添加元素            parent.add(parentOffset + index, e);            this.modCount = parent.modCount;            this.size++;        }        public E remove(int index) {            rangeCheck(index);            checkForComodification();            //父集合删除元素            E result = parent.remove(parentOffset + index);            this.modCount = parent.modCount;            this.size--;            return result;        }}</code></pre><p>如果希望截取的集合是和原集合互不干扰的话，可以这样：</p><pre><code class="java">List&lt;String&gt; subList = new ArrayList&lt;&gt;(list.subList(0, 5));</code></pre><h3 id="使用Collections-unmodifiableList-创建不可变集合也是可变的。"><a href="#使用Collections-unmodifiableList-创建不可变集合也是可变的。" class="headerlink" title="使用Collections.unmodifiableList()创建不可变集合也是可变的。"></a>使用Collections.unmodifiableList()创建不可变集合也是可变的。</h3><p>当不可变集合的原集合改变时，不可变集合也跟着改变。演示代码：</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(list);        System.out.println(unmodifiableList);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        //删除原集合元素        list.remove(&quot;1&quot;);        System.out.println(unmodifiableList);//[2, 3, 4, 5, 6, 7, 8, 9, 10]    }</code></pre><p>看源码就知道原因了：</p><pre><code class="java">    UnmodifiableList(List&lt;? extends E&gt; list) {        super(list);        this.list = list;    }</code></pre><p><strong>因为不可变集合的成员变量的引用是指向原集合的，所以当原集合改变时，不可变集合也会随之改变</strong>。</p><p>解决方式：使用<code>Guava</code>工具包的<code>ImmutableList.copyOf()</code>方法创建。</p><pre><code class="java">    public static void main(String[] args) throws Exception {        List&lt;String&gt; unmodifiableList = ImmutableList.copyOf(list);        list.remove(&quot;1&quot;);        System.out.println(unmodifiableList);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]    }</code></pre><p>创作不易，觉得有用就<strong>点个赞</strong>吧。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong><br><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
      <tag>经验总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC全局异常处理</title>
    <link href="/2020/06/14/SpringMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2020/06/14/SpringMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC全局异常处理"><a href="#SpringMVC全局异常处理" class="headerlink" title="SpringMVC全局异常处理"></a>SpringMVC全局异常处理</h1><p><code>SpringMVC</code>除了可以做<code>URL映射</code>和<code>请求拦截</code>外，还可以做<code>全局异常</code>的处理。全局异常处理可能我们平时比较少机会接触，但是每个项目都肯定会做这个处理。比如在上一间公司，是前后端分离的架构，所以后端只要有运行时异常就会报“系统异常，请稍后再试”。如果想要走上架构师的话，这个肯定是要学会的。</p><h2 id="SpringMVC全局异常处理机制"><a href="#SpringMVC全局异常处理机制" class="headerlink" title="SpringMVC全局异常处理机制"></a>SpringMVC全局异常处理机制</h2><p>首先，要知道全局异常处理，<code>SpringMVC</code>提供了两种方式：</p><ul><li>实现<code>HandlerExceptionResolver</code>接口，自定义异常处理器。</li><li>使用<code>HandlerExceptionResolver</code>接口的子类，也就是<code>SpringMVC</code>提供的异常处理器。</li></ul><p>所以，总得来说就两种方式，一种是自定义异常处理器，第二种是<code>SpringMVC</code>提供的。接下来先说<code>SpringMVC</code>提供的几种异常处理器的使用方式，然后再讲自定义异常处理器。</p><p><code>SpringMVC</code>提供的异常处理器有哪些呢？我们可以直接看源码的类图。</p><p><img src="https://static.lovebilibili.com/HandlerExceptionResolver.png" srcset="/img/loading.gif" alt=""></p><p>可以看出有四种：</p><ul><li><code>DefaultHandlerExceptionResolver</code>，默认的异常处理器。根据各个不同类型的异常，返回不同的异常视图。</li><li><code>SimpleMappingExceptionResolver</code>，简单映射异常处理器。通过配置异常类和view的关系来解析异常。</li><li><code>ResponseStatusExceptionResolver</code>，状态码异常处理器。解析带有<code>@ResponseStatus</code>注释类型的异常。</li><li><code>ExceptionHandlerExceptionResolver</code>，注解形式的异常处理器。对<code>@ExceptionHandler</code>注解的方法进行异常解析。</li></ul><h3 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h3><p>这个异常处理器是<code>SprngMVC</code>默认的一个处理器，处理一些常见的异常，比如：没有找到请求参数，参数类型转换异常，请求方式不支持等等。</p><p>接着我们看<code>DefaultHandlerExceptionResolver</code>类的<code>doResolveException()</code>方法：</p><pre><code class="java">    @Override    @Nullable    protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response,@Nullable Object handler, Exception ex) {        try {            if (ex instanceof HttpRequestMethodNotSupportedException) {                return handleHttpRequestMethodNotSupported((HttpRequestMethodNotSupportedException) ex, request,                        response, handler);            }            else if (ex instanceof HttpMediaTypeNotSupportedException) {                return handleHttpMediaTypeNotSupported((HttpMediaTypeNotSupportedException) ex, request, response,                        handler);            }            else if (ex instanceof HttpMediaTypeNotAcceptableException) {                return handleHttpMediaTypeNotAcceptable((HttpMediaTypeNotAcceptableException) ex, request, response,                        handler);            }            //省略...以下还有十几种异常的else-if        }catch (Exception handlerException) {            //是否打开日志，如果打开，那就记录日志            if (logger.isWarnEnabled()) {                logger.warn(&quot;Handling of [&quot; + ex.getClass().getName() + &quot;] resulted in Exception&quot;, handlerException);            }        }        return null;    }</code></pre><p>通过<code>if-else</code>判断，判断继承什么异常就显示对应的错误码和错误提示信息。由此可以知道，处理一般有两步，一是设置响应码，二是在响应头设置异常信息。下面是<code>MissingServletRequestPartException</code>的处理的源码：</p><pre><code class="java">    protected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex,            HttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {        //设置响应码，设置异常信息，SC_BAD_REQUEST就是400(bad request)        response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage());        return new ModelAndView();    }    //响应码    public static final int SC_BAD_REQUEST = 400;</code></pre><p>为什么要存在这个异常处理器呢？</p><p>从框架的设计理念来看，这种公共的、常见的异常应该交给框架本身来完成，是一些必需处理的异常。比如参数类型转换异常，如果程序员不处理，还有框架提供默认的处理方式，<strong>不至于出现这种错误而无法排查</strong>。</p><h3 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a>SimpleMappingExceptionResolver</h3><p>这种异常处理器需要提前配置异常类和对应的<code>view</code>视图。一般用于使用<code>JSP</code>的项目中，出现异常则通过这个异常处理器跳转到指定的页面。</p><p>怎么配置？首先搭建<code>JSP</code>项目我就不浪费篇幅介绍了。首先要加载一个<code>XML</code>文件。</p><pre><code class="java">@SpringBootApplication//在启动类，加载配置文件@ImportResource(&quot;classpath:spring-config.xml&quot;)public class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre><p>然后在<code>resources</code>目录下，创建一个<code>spring-config.xml</code>文件，内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;        &lt;!-- 定义默认的异常处理页面 --&gt;        &lt;property name=&quot;defaultErrorView&quot; value=&quot;err&quot;/&gt;        &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt;        &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;        &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常也页名作为值 --&gt;        &lt;property name=&quot;exceptionMappings&quot;&gt;            &lt;props&gt;                &lt;!-- 数组越界异常 --&gt;                &lt;prop key=&quot;java.lang.ArrayIndexOutOfBoundsException&quot;&gt;err/arrayIndexOutOfBounds&lt;/prop&gt;                &lt;!-- 空指针异常 --&gt;                &lt;prop key=&quot;java.lang.NullPointerException&quot;&gt;err/nullPointer&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>然后在<code>webapp</code>也就是存放<code>JSP</code>页面的目录下，创建两个<code>JSP</code>页面。</p><p><code>arrayIndexOutOfBounds.jsp</code>如下：</p><pre><code class="JSP">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;数组越界异常&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;数组越界异常&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%= ex.getMessage() %&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>nullPointer.jsp</code>如下：</p><pre><code class="JSP">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;空指针异常&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;空指针异常&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%=ex.getMessage()%&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>接着创建两个<code>Controller</code>，分别抛出空指针异常和数组越界异常。</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/null&quot;)    public String err() throws Exception{        String str = null;        //抛出空指针异常        int length = str.length();        System.out.println(length);        return &quot;index&quot;;    }    @RequestMapping(&quot;/indexOut&quot;)    public String indexOut() throws Exception{        int[] nums = new int[2];        for (int i = 0; i &lt; 3; i++) {            //抛出数组越界异常            nums[i] = i;            System.out.println(nums[i]);        }        return &quot;index&quot;;    }}</code></pre><p>启动项目后，我们发送两个请求，就可以看到：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_2.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/exceptionResolver_3.png" srcset="/img/loading.gif" alt=""></p><p>通过上述例子可以看出，其实对于现在<strong>前后端分离的项目</strong>来说，<strong>这种异常处理器已经不是很常用了</strong>。</p><h3 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h3><p>这种异常处理器主要用于处理带有<code>@ResponseStatus</code>注释的异常。下面演示一下使用方式。</p><p>首先自定义异常类继承<code>Exception</code>，并且使用<code>@ResponseStatus</code>注解修饰。如下：</p><pre><code class="java">//value需要使用HttpStatus枚举类型，HttpStatus.FORBIDDEN=403。@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;My defined Exception&quot;)public class DefinedException extends Exception{}</code></pre><p>然后再在<code>Controller</code>层抛出此异常。如下：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/myException&quot;)    public String ex(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception {        if (num == 1) {            //抛出自定义异常            throw new DefinedException();        }        return &quot;index&quot;;    }}</code></pre><p>然后启动项目，请求接口，可以看到如下信息：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_4.png" srcset="/img/loading.gif" alt=""></p><p>使用这种异常处理器，需要自定义一个异常，一定要一直往上层抛出异常，如果不往上层抛出，在<code>service</code>或者<code>dao</code>层就<code>try-catch</code>处理掉的话，是不会触发的。</p><h3 id="ExceptionHandlerExceptionResolver"><a href="#ExceptionHandlerExceptionResolver" class="headerlink" title="ExceptionHandlerExceptionResolver"></a>ExceptionHandlerExceptionResolver</h3><p>这个异常处理器才是最重要的，也是最常用，最灵活的，因为是使用注解。首先我们还是简单地演示一下怎么使用：</p><p>首先需要定义一个全局的异常处理器。</p><pre><code class="java">//这里使用了RestControllerAdvice，是@ResponseBody和@ControllerAdvice的结合//会把实体类转成JSON格式的提示返回，符合前后端分离的架构@RestControllerAdvicepublic class GlobalExceptionHandler {    //这里自定义了一个BaseException，当抛出BaseException异常就会被此方法处理    @ExceptionHandler(BaseException.class)    public ErrorInfo errorHandler(HttpServletRequest req, BaseException e) throws Exception {        ErrorInfo r = new ErrorInfo();        r.setMessage(e.getMessage());        r.setCode(ErrorInfo.ERROR);        r.setUrl(req.getRequestURL().toString());        return r;    }}</code></pre><p>然后我们自定义一个自定义异常类<code>BaseException</code>：</p><pre><code class="java">public class BaseException extends Exception {    public BaseException(String message) {        super(message);    }}</code></pre><p>然后在<code>Controller</code>层定义一个方法测试：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/base&quot;)    public String base() throws BaseException {        throw new BaseException(&quot;系统异常，请稍后重试。&quot;);    }}</code></pre><p>老规矩，启动项目，请求接口可以看到结果：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_1.jpg" srcset="/img/loading.gif" alt=""></p><p>你也可以不自定义异常<code>BaseException</code>，而直接拦截常见的各种异常都可以。所以这是一个非常灵活的异常处理器。你也可以做跳转页面，返回<code>ModelAndView</code>即可（以免篇幅过长就不演示了，哈哈）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>经过以上的演示后我们学习了<code>SpringMVC</code>四种异常处理器的工作机制，最后这种作为程序员我觉得是必须掌握的，前面的简单映射异常处理器和状态映射处理器可以选择性掌握，默认的异常处理器了解即可。</p><p>那这么多异常处理器，究竟是如何工作的呢？为什么是设计一个接口，下面有一个抽象类加上四个实现子类呢？接下来我们通过源码分析来揭开谜底！</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码分析从哪里入手呢？在<code>SpringMVC</code>中，其实你想都不用想，肯定在<code>DispatcherServlet</code>类里。经过我顺藤摸瓜，我定位在了<code>processHandlerException()</code>方法。怎么定位的呢？其实很简单，看源码：</p><pre><code class="java">    private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,            @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,            @Nullable Exception exception) throws Exception {        boolean errorView = false;        //异常不为空        if (exception != null) {            if (exception instanceof ModelAndViewDefiningException) {                logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);                mv = ((ModelAndViewDefiningException) exception).getModelAndView();            }            else {                Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);                //关键点：执行异常处理                mv = processHandlerException(request, response, handler, exception);                //省略...            }        }        //省略...    }</code></pre><h3 id="processHandlerException"><a href="#processHandlerException" class="headerlink" title="processHandlerException()"></a>processHandlerException()</h3><p>就是这个直接的一个<code>if-else</code>判断，那个<code>processHandlerException()</code>方法又是怎么处理的呢？</p><pre><code class="java">@Nullableprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,      @Nullable Object handler, Exception ex) throws Exception {   ModelAndView exMv = null;   //判断异常处理器的集合是否为空   if (this.handlerExceptionResolvers != null) {      //不为空则遍历异常处理器       for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {         //调用异常处理器的resolveException()方法进行处理异常         exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);         //判断返回的ModelAndView是否为null，不为null则跳出循环，为null则继续下一个异常处理器         if (exMv != null) {            break;         }      }   }   //如果ModelAndView不为空   if (exMv != null) {      if (exMv.isEmpty()) {         //设置异常信息提示         request.setAttribute(EXCEPTION_ATTRIBUTE, ex);         return null;      }      //如果返回的ModelAndView不包含view      if (!exMv.hasView()) {         //设置一个默认的视图          String defaultViewName = getDefaultViewName(request);         if (defaultViewName != null) {            exMv.setViewName(defaultViewName);         }      }      //省略...      //返回异常的ModelAndView          return exMv;   }   throw ex;}</code></pre><p>这不就是责任链模式吗！提前加载异常处理器到<code>handlerExceptionResolvers</code>集合中，然后遍历去执行，能处理就处理，不能处理就跳到下一个异常处理器处理。</p><p>那接下来我们就有一个问题了，<code>handlerExceptionResolvers</code>集合是怎么加载异常处理器的？这个问题很简单，就是使用<code>DispatcherServlet.properties</code>配置文件。这个文件真的很重要！！！</p><pre><code class="properties">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</code></pre><p>默认是加载以上三种异常处理器到集合中，所以只要带有<code>@ControllerAdvice</code>、<code>@ExceptionHandler</code>、<code>@ResponseStatus</code>注解的都会被扫描。<code>SimpleMappingExceptionResolver</code>则是通过<code>xml</code>文件(当然也可以使用<code>@Configuration</code>)去配置。</p><h3 id="resolveException"><a href="#resolveException" class="headerlink" title="resolveException()"></a>resolveException()</h3><p>其实在<code>resolveException()</code>处理异常的方法中，还使用了模板模式。</p><pre><code class="java">    @Override    @Nullable    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response,            @Nullable Object handler, Exception ex) {            //省略...            //预处理            prepareResponse(ex, response);            //调用了一个抽象方法，抽象方法由子类去实现            ModelAndView result = doResolveException(request, response, handler, ex);            //省略...    }</code></pre><p>抽象方法<code>doResolveException()</code>，由子类实现。</p><pre><code class="java">@Nullableprotected abstract ModelAndView doResolveException(HttpServletRequest request,      HttpServletResponse response, @Nullable Object handler, Exception ex);</code></pre><p>怎么识别模板方法，其实很简单，只要看到抽象类，有个具体方法里面调用了抽象方法，那很大可能就是模板模式。抽象方法就是模板方法，由子类实现。</p><p>子类我们都知道就是那四个异常处理器实现类了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用流程图概括一下：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_5.png" srcset="/img/loading.gif" alt=""></p><p>经过以上的学习后，我们知道只需要把异常处理器加到集合中，就可以执行。所以我们可以使用直接实现<code>HandlerExceptionResolver</code>接口的方式来实现异常处理器。</p><h2 id="实现HandlerExceptionResolver接口实现全局异常处理"><a href="#实现HandlerExceptionResolver接口实现全局异常处理" class="headerlink" title="实现HandlerExceptionResolver接口实现全局异常处理"></a>实现HandlerExceptionResolver接口实现全局异常处理</h2><p>首先自定一个异常类<code>MyException</code>。</p><pre><code class="java">public class MyException extends Exception {    public MyException(String message) {        super(message);    }}</code></pre><p>然后实现<code>HandlerExceptionResolver</code>接口定义一个异常处理器。</p><pre><code class="java">//注册异常处理器到Spring容器中@Componentpublic class MyExceptionHandler implements HandlerExceptionResolver {    @Override    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {        try {            //如果属于MyException异常，则输出异常提示到页面            if (ex instanceof MyException) {                response.setContentType(&quot;text/html;charset=utf-8&quot;);                response.getWriter().println(ex.getMessage());                //这里返回null，不做处理。也可以返回ModelAndView跳转页面                return null;            }        } catch (IOException e) {            e.printStackTrace();        }        return null;    }}</code></pre><p>然后在<code>Controller</code>层定义一个方法测试：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/myEx&quot;)    public String myEx() throws MyException {        System.out.println(&quot;执行myEx()&quot;);        throw new MyException(&quot;自定义异常提示信息&quot;);    }}</code></pre><p>启动项目，请求接口，我们可以看到：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_6.png" srcset="/img/loading.gif" alt=""></p><h1 id="最后说几句"><a href="#最后说几句" class="headerlink" title="最后说几句"></a>最后说几句</h1><p>以上就是我对于<code>SpringMVC</code>全局异常处理机制的理解。更多的<code>java</code>技术分享，可以关注我的公众号“<strong>java技术爱好者</strong>”，后续会不断更新。</p>]]></content>
    
    
    
    <tags>
      
      <tag>源码分析</tag>
      
      <tag>java</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题总结-基础篇</title>
    <link href="/2020/06/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2020/06/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="JVM、JRE、JDK有什么联系与区别？"><a href="#JVM、JRE、JDK有什么联系与区别？" class="headerlink" title="JVM、JRE、JDK有什么联系与区别？"></a>JVM、JRE、JDK有什么联系与区别？</h3><p><strong>JVM是java虚拟机</strong>，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。<br><strong>JRE是java运行时环境</strong>，它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。换句话说，JRE包含JVM。<br><strong>JDK是java开发工具包</strong>，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。JDK包含JRE。<br>所以总得来说，<strong>JDK&gt;JRE&gt;JVM</strong>。</p><h3 id="面向对象的特征有哪些？"><a href="#面向对象的特征有哪些？" class="headerlink" title="面向对象的特征有哪些？"></a>面向对象的特征有哪些？</h3><p>有三大特征，继承，封装，多态。</p><h3 id="为什么java可以实现跨平台？"><a href="#为什么java可以实现跨平台？" class="headerlink" title="为什么java可以实现跨平台？"></a>为什么java可以实现跨平台？</h3><p>因为java是编译成.class文件运行在JVM上的。<strong>针对不同的系统有不同的JVM实现，在不同的JVM实现上会映射到不同系统的 API 调用</strong>，从而实现代码的跨平台运行。</p><h3 id="类的加载顺序？"><a href="#类的加载顺序？" class="headerlink" title="类的加载顺序？"></a>类的加载顺序？</h3><p>静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。</p><h3 id="接口和抽象类有什么共同点和不同点？"><a href="#接口和抽象类有什么共同点和不同点？" class="headerlink" title="接口和抽象类有什么共同点和不同点？"></a>接口和抽象类有什么共同点和不同点？</h3><p>共同点：<br>1.都可以定义抽象方法，子类都要实现定义的抽象方法。<br>2.都不能被实例化，但是可以定义抽象类和接口类型的引用。<br>不同点：<br>1.接口没有构造器，抽象类可以定义构造器。<br>2.接口定义具体方法只能定义<strong>default</strong>修饰，抽象类可以直接定义具体方法。<br>3.接口的子类是实现接口，关键字是<strong>implements</strong>，抽象类的子类是继承，关键字是<strong>extends</strong>。<br>4.接口不能定义成员变量，只能定义常量。抽象类可以定义成员变量。</p><h3 id="static关键字有哪些用法？"><a href="#static关键字有哪些用法？" class="headerlink" title="static关键字有哪些用法？"></a>static关键字有哪些用法？</h3><p>①<strong>修饰成员变量，用static修饰的成员变量就成为静态变量</strong>，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。<br>②<strong>static修饰方法，该方法就被定义为静态方法</strong>，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。<br>③<strong>用static修饰代码块，该代码块就被定义为静态代码块</strong>，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。</p><h3 id="Switch能用什么数据类型作为参数？"><a href="#Switch能用什么数据类型作为参数？" class="headerlink" title="Switch能用什么数据类型作为参数？"></a>Switch能用什么数据类型作为参数？</h3><p>JDK1.5前：<strong>byte、short、char、int</strong><br>JDK1.5：枚举<br>JDK1.7：String</p><h3 id="枚举有哪些特点？在项目中如何使用？"><a href="#枚举有哪些特点？在项目中如何使用？" class="headerlink" title="枚举有哪些特点？在项目中如何使用？"></a>枚举有哪些特点？在项目中如何使用？</h3><p>特点：<br>1.枚举的构造器是私有的。<br>2.枚举不能被继承。<br>3.枚举是绝对的单例，即使是反序列化也无法创建多个实例。<br>使用场景：<br>当变量只能从一堆固定的值中取出一个时，那么就应该使用枚举。比如时间的单位，季度等等。</p><h3 id="什么是方法重载？什么是方法重写？"><a href="#什么是方法重载？什么是方法重写？" class="headerlink" title="什么是方法重载？什么是方法重写？"></a>什么是方法重载？什么是方法重写？</h3><p><strong>方法重载</strong>，一个类中允许同时存在一个以上的同名方法，主要体现在方法参数的类型和数量不同，方法名相同，与访问修饰符和返回值类型都是无关的。口诀是”<strong>一同两不同</strong>“。<br><strong>方法重写</strong>一般在继承中，子类重写父类的方法，既然是重写一遍，那么方法名和参数部分一定是相同的。只是实现的功能不同。<strong>声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，声明为 private 的方法不能被重写。</strong></p><h3 id="静态变量和实例变量有什么不同？分别位于内存的什么区域？"><a href="#静态变量和实例变量有什么不同？分别位于内存的什么区域？" class="headerlink" title="静态变量和实例变量有什么不同？分别位于内存的什么区域？"></a>静态变量和实例变量有什么不同？分别位于内存的什么区域？</h3><p>1.静态变量使用static修饰，实例变量不需要。<br>2.静态变量在类被加载时就会分配内存空间，就可以使用。实例变量需要实例对象才会分配内存空间，才可以被引用，是属于实例的。<br>3.静态变量是存在于<strong>静态区(全局区)</strong>的，实例变量位于<strong>堆内存</strong>中。</p><h3 id="java的内部类的分类有哪些？"><a href="#java的内部类的分类有哪些？" class="headerlink" title="java的内部类的分类有哪些？"></a>java的内部类的分类有哪些？</h3><p>实例内部类、静态内部类、局部内部类、匿名内部类。</p><h3 id="break、continue、return-的作用是什么？"><a href="#break、continue、return-的作用是什么？" class="headerlink" title="break、continue、return 的作用是什么？"></a>break、continue、return 的作用是什么？</h3><ul><li>break：结束循环。不仅可以结束其所在的循环，还可结束其外层循环。</li><li>continue：跳过本次循环，开始下一次循环。</li><li>return：不是专用于结束循环，而是用于结束方法。如果在循环中使用return，就会结束整个方法，循环当然也会结束。<h3 id="Object类有哪些常用的方法？"><a href="#Object类有哪些常用的方法？" class="headerlink" title="Object类有哪些常用的方法？"></a>Object类有哪些常用的方法？</h3></li></ul><p><strong>toString()、equals()、hashCode()。</strong></p><ul><li><code>toString()</code>默认输出对象的内存地址，一般不希望输出内存地址可以重写toString()方法。</li><li><code>equals()</code>方法用于比较对象是否相等，默认比较是内存地址，所以要正确比较两个对象是否值相等，此方法必须被重写。</li><li><code>hashCode()</code>方法用来返回其所在对象的物理地址（哈希码值），常会和<code>equals()</code>方法同时重写，确保相等的两个对象拥有相等的<strong>hashCode</strong>。<h3 id="与equals-的区别？"><a href="#与equals-的区别？" class="headerlink" title="==与equals()的区别？"></a>==与equals()的区别？</h3><code>equals()</code>方法属于<code>Object</code>对象的，所以比较基础数据类型是不能使用<code>equals()</code>。必须使用<code>==</code>。</li></ul><p><strong>在默认情况下</strong>，<code>equals()</code>与<code>==</code>是一样的，都是比较内存地址。所以在业务逻辑中，我们一般会重写<code>equals()</code>方法。</p><h3 id="equals-与hashCode-有什么联系？"><a href="#equals-与hashCode-有什么联系？" class="headerlink" title="equals()与hashCode()有什么联系？"></a>equals()与hashCode()有什么联系？</h3><p>1.<code>equals()</code>相等的两个对象他们的<code>hashCode()</code>肯定相等，也就是用<code>equals()</code>对比是绝对可靠的。<br>2.<code>hashCode()</code>相等的两个对象他们的<code>equals()</code>不一定相等，也就是<code>hashCode()</code>不是绝对可靠的。<br>在使用<code>HashSet</code>或者<code>HashMap</code>集合中，比较两个对象是否相等时，会先调用<code>hashCode()</code>比较，如果<code>hashCode()</code>相等，则会继续调用<code>equals()</code>比较，<code>equals()</code>也相等才会认为是同一个对象。如果<code>hashCode()</code>返回不相等，则认为是不相等的对象。<br>所以一般我们会同时重写<code>hashCode()</code>和<code>equals()</code>方法。</p><h3 id="amp-和-amp-amp-有什么区别？"><a href="#amp-和-amp-amp-有什么区别？" class="headerlink" title="&amp; 和 &amp;&amp;有什么区别？"></a>&amp; 和 &amp;&amp;有什么区别？</h3><p><code>&amp;&amp;</code>具有短路的功能，也就是如果<code>&amp;&amp;</code>左边的条件为<code>fasle</code>就不再执行后面的条件判断。<br><code>&amp;</code>则会执行完左右两边的条件判断。</p><h3 id="final、finalize-、finally-分别有什么作用？"><a href="#final、finalize-、finally-分别有什么作用？" class="headerlink" title="final、finalize()、finally{}分别有什么作用？"></a>final、finalize()、finally{}分别有什么作用？</h3><p><code>final</code>修饰类，表明这个类不可被其他类继承。<br><code>final</code>修饰成员变量，表示此变量为常量，只能在初始化时被赋值一次，赋值后不能修改。<br><code>final</code>修饰方法。把方法锁定，不能被子类重写，以防止子类对其进行更改。<br><code>finalize()</code>是<code>Object</code>里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。一个对象的<code>finalize()</code>方法只会被调用一次。<br><code>finally</code>作为异常处理的一部分，它只能用在<code>try/catch</code>语句中，并且附带一个语句块。</p><h3 id="Cloneable接口有什么作用？"><a href="#Cloneable接口有什么作用？" class="headerlink" title="Cloneable接口有什么作用？"></a>Cloneable接口有什么作用？</h3><p><code>Cloneable</code>接口是一个标记接口，实现了此接口，表示可以使用<code>clone()</code>方法，没有实现此接口使用<code>clone()</code>会抛出<code>CloneNotSupportedException</code>异常。</p><h3 id="什么是浅克隆，什么是深克隆？"><a href="#什么是浅克隆，什么是深克隆？" class="headerlink" title="什么是浅克隆，什么是深克隆？"></a>什么是浅克隆，什么是深克隆？</h3><p><strong>浅克隆是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量）</strong>，而不拷贝对象包含的引用指向的对象。</p><p><strong>深克隆不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。</strong></p><h3 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h3><p>序列化：把<strong>对象</strong>转换为<strong>字节序列</strong>的过程称为对象的序列化。<br>反序列化：把<strong>字节序列</strong>恢复为<strong>对象</strong>的过程称为对象的反序列化。</p><h3 id="Serializable接口有什么作用？"><a href="#Serializable接口有什么作用？" class="headerlink" title="Serializable接口有什么作用？"></a>Serializable接口有什么作用？</h3><p><code>Serializable</code>接口是一个标记接口，一个类只有实现了<code>Serializable</code>接口，它的对象才是可序列化的。否则序列化时会报<code>NotSerializableException</code>异常。如果不显性声明<code>serialVersionUID</code>，则会默认生成一个。为了<code>serialVersionUID</code>的确定性，最好是显性声明。</p><h3 id="String、StringBuffer、StringBuilder有什么区别"><a href="#String、StringBuffer、StringBuilder有什么区别" class="headerlink" title="String、StringBuffer、StringBuilder有什么区别?"></a>String、StringBuffer、StringBuilder有什么区别?</h3><ul><li><code>String</code>被声明为<code>final class</code>，是由定义<code>final</code>的字符数组实现的，因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。<ul><li><code>StringBuffer</code>是由定义了临时数据<code>transient</code>的字符数组实现的，提供<code>append()</code>和<code>add()</code>方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列，所有修改数据的方法都加上<code>synchronized</code>。性能相对<code>StringBuilder</code>会差一点。</li></ul></li><li><code>StringBuilder</code>和<code>StringBuffer</code>本质上没什么区别，区别是去掉了保证线程安全的<code>synchronized</code>，减少了开销，性能有所提高。<h3 id="什么是泛型-什么是泛型的上界和下界"><a href="#什么是泛型-什么是泛型的上界和下界" class="headerlink" title="什么是泛型?什么是泛型的上界和下界?"></a>什么是泛型?什么是泛型的上界和下界?</h3>Java 泛型是 JDK1.5中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<br>上界用<code>extends</code>关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。<br>下界用<code>super</code>进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至Object。<h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><strong>Java反射机制</strong>是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在<strong>运行时动态的获取信息以及动态调用对象的方法的功能</strong>称为Java的反射机制。<h3 id="获取Class对象的方式有哪些？"><a href="#获取Class对象的方式有哪些？" class="headerlink" title="获取Class对象的方式有哪些？"></a>获取Class对象的方式有哪些？</h3><ul><li>通过<code>Object</code>类中的<code>getClass()</code>方法，想要用这种方法必须要明确具体的类并且创建该类的对象。</li><li>所有数据类型都具备一个静态的属性<code>.class</code>来获取对应的<code>Class</code>对象。但是还是要明确到类，然后才能调用类中的静态成员。</li><li>通过<code>Class.forName()</code>方法完成，必须要指定类的全限定名，由于前两种方法都是在知道该类的情况下获取该类的字节码对象，因此不会有异常，但是<code>Class.forName()</code>方法如果写错类的路径会报<code>ClassNotFoundException</code>的异常。<h3 id="java中的异常有哪几种异常？"><a href="#java中的异常有哪几种异常？" class="headerlink" title="java中的异常有哪几种异常？"></a>java中的异常有哪几种异常？</h3><code>Throwable</code>类是<code>Java</code>异常类型的顶层父类，<code>Throwable</code>包含了<code>Error</code>和<code>Excetion</code>。<code>Excetion</code>分为两种，一种是<strong>非运行时异常(又称为检查异常)</strong>，另一种是<strong>运行时异常(RuntimeException)</strong>。<h3 id="java是如何处理异常的？"><a href="#java是如何处理异常的？" class="headerlink" title="java是如何处理异常的？"></a>java是如何处理异常的？</h3></li><li><code>Error</code>是程序无法处理的, 比如<code>OutOfMemoryError</code>、<code>OutOfMemoryError</code>等等, 这些异常发生时, <code>JVM</code>一般会终止线程。</li><li>运行时异常(<code>RuntimeException</code>)，如 <code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>等，是在程序运行的时候可能会发生的，所以程序可以捕捉，也可以不捕捉。这些错误一般是由程序的逻辑错误引起的，<strong>程序应该从逻辑角度去尽量避免</strong>。</li><li>非运行时异常是<code>RuntimeException</code>以外的异常，是<code>Exception</code>及其子类，这些异常从程序的角度来说是必须经过捕捉检查处理的，否则不能通过编译。如<code>IOException</code>、<code>SQLException</code>等。<h1 id="java集合、IO流、日期处理等"><a href="#java集合、IO流、日期处理等" class="headerlink" title="java集合、IO流、日期处理等"></a>java集合、IO流、日期处理等</h1><h3 id="常用的集合有哪些？"><a href="#常用的集合有哪些？" class="headerlink" title="常用的集合有哪些？"></a>常用的集合有哪些？</h3>常用集合有<strong>Map、List、Set</strong>。<h3 id="HashMap是线程安全的吗？"><a href="#HashMap是线程安全的吗？" class="headerlink" title="HashMap是线程安全的吗？"></a>HashMap是线程安全的吗？</h3>不是线程安全的。<h3 id="如何使HashMap线程安全？"><a href="#如何使HashMap线程安全？" class="headerlink" title="如何使HashMap线程安全？"></a>如何使HashMap线程安全？</h3>使用<code>Collections</code>类的<code>synchronizedMap()</code>方法包装。<pre><code class="java">Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</code></pre>使用<code>java.util.concurrent</code>包下的<code>ConcurrentHashMap</code>类也可以获得线程安全的Map。<pre><code class="java">ConcurrentHashMap concurrentHashMap = new ConcurrentHashMap();</code></pre>使用<code>Hashtable</code>类，也可以获得线程安全的Map<pre><code class="java">Map&lt;String,Object&gt; hashtable = new Hashtable&lt;&gt;();</code></pre><h3 id="HashMap和Hashtable的区别是什么？"><a href="#HashMap和Hashtable的区别是什么？" class="headerlink" title="HashMap和Hashtable的区别是什么？"></a>HashMap和Hashtable的区别是什么？</h3></li><li><code>Hashtable</code>继承自<code>Dictionary</code>类，而<code>HashMap</code>继承自<code>AbstractMap</code>类。但二者都实现了Map接口。</li><li><code>Hashtable</code>是线程安全的，<code>HashMap</code>是线程不安全的。</li><li><code>Hashtable</code>中，key和value都不允许出现null值。</li><li><code>HashTable</code>在不指定容量的情况下的<strong>默认容量为11，而HashMap为16</strong>，<code>Hashtable</code>不要求底层数组的容量一定要为2的整数次幂，而<code>HashMap</code>则要求一定为2的整数次幂。<code>Hashtable</code>扩容时，将容量变为原来的2倍加1，而<code>HashMap</code>扩容时，将容量变为原来的2倍。<h3 id="HashMap是如何解决哈希冲突的？"><a href="#HashMap是如何解决哈希冲突的？" class="headerlink" title="HashMap是如何解决哈希冲突的？"></a>HashMap是如何解决哈希冲突的？</h3></li><li>在JDK1.8前，<code>HashMap</code>是采用<strong>链表法</strong>解决哈希冲突的。当<code>put()</code>一个值到<code>Map</code>时，会通过<code>Key</code>拿到一个哈希值，通过哈希值获取数组下标，先查询是否存在该<code>hash</code>值。若不存在，则直接以<code>Entry&lt;V,V&gt;</code>的方式存放在数组中。若存在，则再调用<code>equals()</code>方法对比<code>key</code>是否相同，若<code>hashcode()</code>值和<code>key</code>都相同，则替换<code>value</code>，若<code>hashcode()</code>值相同，<code>key</code>不相同，则形成一个单链表，将<code>hashcode()</code>值相同，<code>key</code>不同的元素以<code>Entry&lt;V,V&gt;</code>的方式存放在链表中，这样就解决了哈希冲突。</li><li>JDK1.8以后，当链表的长度达到某个限制值(默认是8)，就会转换成<strong>红黑树</strong>，提高性能。<h3 id="HashMap初始大小是多少？负载因子是多少？"><a href="#HashMap初始大小是多少？负载因子是多少？" class="headerlink" title="HashMap初始大小是多少？负载因子是多少？"></a>HashMap初始大小是多少？负载因子是多少？</h3>默认的数组初始大小是16。负载因子是0.75。</li></ul><strong>（为什么初始值是2的n次方，为什么负载因子取0.75，这两个问题可以网上找资料看看，这里就不详述了）</strong><h3 id="简述一下HashMap的扩容机制？"><a href="#简述一下HashMap的扩容机制？" class="headerlink" title="简述一下HashMap的扩容机制？"></a>简述一下HashMap的扩容机制？</h3><code>HashMap</code>是懒加载的，当调用<code>put()</code>方法时，会先初始化<code>Map</code>的大小，默认数组长度是16，负载因子是0.75，所以阈值是12。当<code>HashMap</code>元素的个数超过阈值时，就会把数组的大小扩展到原来的2倍，然后重新计算每个元素在数组中的位置。<h3 id="List有哪些常用的子类？"><a href="#List有哪些常用的子类？" class="headerlink" title="List有哪些常用的子类？"></a>List有哪些常用的子类？</h3><code>ArrayList</code>和<code>LinkedList</code>。<h3 id="ArrayList和LinkedList有什么区别？"><a href="#ArrayList和LinkedList有什么区别？" class="headerlink" title="ArrayList和LinkedList有什么区别？"></a>ArrayList和LinkedList有什么区别？</h3><ul><li>底层<strong>数据结构不同</strong>。<code>ArrayList</code>基于数组+动态扩容实现的，<code>LinkedList</code>基于双向链表实现。从储存结构上分析，<code>LinkedList</code>更加占内存，因为每个节点除了存储数据外还要<strong>存储指向前节点的引用和指向后节点的引用。</strong></li><li><strong>效率不同</strong>。当随机访问时，<code>ArrayList</code>是基于数组下标访问，<strong>查询效率较高</strong>，但是由于数组的长度是固定的，所以当添加的元素到一定的阈值时会扩容数组，消耗性能，<strong>增删效率偏低</strong>。<code>LinkedList</code>在查询时，需要从前到后依次遍历，所以<strong>查询效率不高</strong>，但是在增删时只需要更改节点的引用，开销较少，所以<strong>增删效率较高</strong>。<h3 id="List集合排序的方式有哪些？"><a href="#List集合排序的方式有哪些？" class="headerlink" title="List集合排序的方式有哪些？"></a>List集合排序的方式有哪些？</h3>使用List接口定义的sort()方法。<pre><code class="java">list.sort(Comparator.comparingInt(User::getAge));</code></pre>使用<code>Collections</code>的<code>sort()</code>方法，排序的对象需要实现<code>Comparable</code>接口，重写<code>compareTo()</code>方法。<pre><code class="java">//实现Comparable接口public class User implements Comparable&lt;User&gt; {//重写compareTo方法@Overridepublic int compareTo(User user) {      return Integer.compare(this.getAge(), user.getAge());}}</code></pre>使用<code>Collections</code>的<code>sort()</code>方法<pre><code class="java">Collections.sort(list);//如果不想实现Comparable接口，也可以使用这个方法Collections.sort(list,Comparator.comparingInt(User::getAge));</code></pre>使用Stream流操作的<code>sort()</code>方法，传入一个<code>Comparator</code>接口。<pre><code class="java">list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList());</code></pre><h3 id="栈和队列的特点分别是什么？在java中有哪些实现的类？"><a href="#栈和队列的特点分别是什么？在java中有哪些实现的类？" class="headerlink" title="栈和队列的特点分别是什么？在java中有哪些实现的类？"></a>栈和队列的特点分别是什么？在java中有哪些实现的类？</h3>栈是<strong>先进后出</strong>，队列是<strong>先进先出</strong>。<br><code>Stack</code>类是栈在java中的实现，继承<code>Vector</code>类，底层是基于数组存储数据。<br><code>Queue</code>接口是队列在java中的代表，<code>Queue</code>接口有几个常用的子类<code>ArrayDeque</code>、<code>LinkedList</code>。<h3 id="IO、NIO有什么区别？"><a href="#IO、NIO有什么区别？" class="headerlink" title="IO、NIO有什么区别？"></a>IO、NIO有什么区别？</h3>IO包括：<code>File</code>、<code>OutputStream</code>、<code>InputStream</code>、<code>Writer</code>，<code>Reader</code>。<br>NIO三大核心：<code>selector</code>（选择器），<code>channel</code>（通道），<code>buffer</code>（缓冲区）<br>NIO与IO区别在于，IO面向流，NIO面向缓冲区。IO是阻塞，NIO是非阻塞。<h3 id="如何进行日期的转换？"><a href="#如何进行日期的转换？" class="headerlink" title="如何进行日期的转换？"></a>如何进行日期的转换？</h3>使用<code>SimpleDateFormat</code>类进行<code>String</code>和<code>Date</code>之间的转换。<h3 id="如何获取上一年的今天的日期？"><a href="#如何获取上一年的今天的日期？" class="headerlink" title="如何获取上一年的今天的日期？"></a>如何获取上一年的今天的日期？</h3>使用<code>Calendar</code>对象。如下所示：<pre><code class="java">//创建Calendar对象Calendar calendar = Calendar.getInstance();//设置年份，当前年份减去一年calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1);//以下是打印结果Date time = calendar.getTime();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);System.out.println(sdf.format(time));//2019-06-08 23:43:14 正确</code></pre><h3 id="BigDecimal类型一定不会失真吗？"><a href="#BigDecimal类型一定不会失真吗？" class="headerlink" title="BigDecimal类型一定不会失真吗？"></a>BigDecimal类型一定不会失真吗？</h3>不一定。<br>参数类型为<code>double</code>的构造方法的结果有一定的不可预知性，是有可能产生失真的。<pre><code class="java">BigDecimal bigDecimal = new BigDecimal(0.99);System.out.println(bigDecimal);//结果如下//0.9899999999999999911182158029987476766109466552734375</code></pre>使用参数类型<code>String</code>构造方法是完全可预知的，不会产生失真。所以在开发中推荐使用参数类型<code>String</code>构造方法。<h1 id="java并发编程"><a href="#java并发编程" class="headerlink" title="java并发编程"></a>java并发编程</h1><h3 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h3></li><li>避免主线程阻塞，可以使用多线程做成异步调用。</li><li>提升性能，充分利用CPU资源。<h3 id="创建线程有哪几种方法？"><a href="#创建线程有哪几种方法？" class="headerlink" title="创建线程有哪几种方法？"></a>创建线程有哪几种方法？</h3></li><li>通过继承<code>Thread</code>类创建线程类。</li><li>通过实现<code>Runnable</code>接口创建线程类。</li><li>通过实现<code>Callable</code>接口创建线程类。<h3 id="如何获取多线程的返回值？"><a href="#如何获取多线程的返回值？" class="headerlink" title="如何获取多线程的返回值？"></a>如何获取多线程的返回值？</h3>使用<code>Callable</code>和<code>FutureTask</code>接口，获取返回值。<pre><code class="java">public static void main(String[] args) throws Exception {  try {      //使用匿名内部类创建Callable      Callable callable = () -&gt; &quot;hello call&quot;;      FutureTask futureTask = new FutureTask(callable);      //执行线程      new Thread(futureTask).start();      if (!futureTask.isDone()) {          //获取返回值          System.out.println(futureTask.get());      }  } catch (Exception e) {      e.printStackTrace();  }}</code></pre><h3 id="多线程的生命周期？"><a href="#多线程的生命周期？" class="headerlink" title="多线程的生命周期？"></a>多线程的生命周期？</h3>新建状态、就绪状态、运行状态、阻塞状态、死亡状态<h3 id="如何进行线程之间的通信？"><a href="#如何进行线程之间的通信？" class="headerlink" title="如何进行线程之间的通信？"></a>如何进行线程之间的通信？</h3></li><li>使用<code>synchronized、wait()、notify()</code></li><li>使用JUC工具类<code>CountDownLatch</code></li><li>使用<code>ReentrantLock</code>结合<code>Condition</code></li><li>基本<code>LockSupport</code>实现线程间的阻塞和唤醒</li></ul></li></ul><p>以上几种方式的具体实现代码，可以网上找一下资料，这里不演示了。</p><h3 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h3><p>相同点：</p><ul><li><code>sleep()</code>方法和<code>wait()</code>方法都用来改变线程的状态，能够让线程从<strong>运行状态</strong>，转变为<strong>休眠状态</strong>。</li></ul><p>不同点：</p><ul><li><code>sleep()</code>方法是<code>Thread</code>类中的静态方法，而<code>wait()</code>方法是<code>Object</code>类中的方法。</li><li><code>sleep()</code>方法可以在任何地方调用，而wait()方法只能在同步代码块或同步方法中使用(即使用<code>synchronized</code>关键字修饰的)。</li><li>这两个方法都在同步代码块或同步方法中使用时，<code>sleep()</code>方法不会释放对象锁。而<code>wait()</code>方法则会释放对象锁。<h3 id="如何停止线程？"><a href="#如何停止线程？" class="headerlink" title="如何停止线程？"></a>如何停止线程？</h3></li><li>使用退出标志，使线程正常退出，也就是当<code>run()</code>方法完成后线程终止。</li><li>使用<code>stop()</code>方法强行终止(不推荐)，可能会出现数据不同步，或者资源未释放等问题。</li><li>使用<code>interrupt()</code>方法中断线程。<h3 id="什么是线程的死锁？如何避免线程死锁？"><a href="#什么是线程的死锁？如何避免线程死锁？" class="headerlink" title="什么是线程的死锁？如何避免线程死锁？"></a>什么是线程的死锁？如何避免线程死锁？</h3>多个线程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进，这种现象称为死锁。</li></ul><p>避免死锁的三种方式：</p><ul><li>加锁顺序（线程按照一定的顺序加锁）</li><li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）<h3 id="线程池的作用？"><a href="#线程池的作用？" class="headerlink" title="线程池的作用？"></a>线程池的作用？</h3></li><li>利用线程池管理并复用线程，减少创建线程和销毁线程的资源消耗。</li><li>实现任务线程队列缓存策略和拒绝机制。</li><li>可以对线程进行统一的分配，监控和调优。</li><li>提供定时执行、最大线程数、并发数控制等功能。<h3 id="创建线程池的重要参数分别代表什么意思？"><a href="#创建线程池的重要参数分别代表什么意思？" class="headerlink" title="创建线程池的重要参数分别代表什么意思？"></a>创建线程池的重要参数分别代表什么意思？</h3></li><li><code>corePoolSize</code>线程池核心线程大小。在没有设置 <code>allowCoreThreadTimeOut</code>为<code>true</code>的情况下，核心线程会在线程池中一直存活，即使处于闲置状态。当向线程池提交一个任务时，若线程池已创建的线程数小于<code>corePoolSize</code>，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于<code>corePoolSize</code>。</li><li><code>maximumPoolSize</code>线程池最大线程数量。线程池所允许的最大线程个数。<strong>当队列满了</strong>，且已创建的线程数小于<code>maximumPoolSize</code>，则线程池会创建新的线程来执行任务。对于无界队列可以忽略此参数。</li><li><code>keepAliveTime</code>线程存活保持时间。当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</li><li><code>unit</code>空间线程存活时间单位。</li><li><code>workQueue</code>任务队列：用于传输和保存等待执行任务的阻塞队列。<br>①<code>ArrayBlockingQueue</code>，基于数组的有界阻塞队列，按FIFO排序。<br>②<code>LinkedBlockingQuene</code>，基于链表的无界阻塞队列（其实最大容量为<code>Interger.MAX</code>），按照FIFO排序。当使用该队列时，<code>maximumPoolSize</code>参数可以忽略。<br>③<code>SynchronousQuene</code>，一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。<br>④<code>PriorityBlockingQueue</code>，具有优先级的无界阻塞队列，优先级通过参数<code>Comparator</code>实现。</li><li><code>threadFactory</code>线程工厂，用于创建新线程。</li><li><code>handler</code>线程饱和策略，当线程池和队列都满了，再加入线程会执行此策略。<h3 id="线程池中submit-和-execute-方法有什么区别？"><a href="#线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中submit() 和 execute()方法有什么区别？"></a>线程池中submit() 和 execute()方法有什么区别？</h3></li><li>参数不同</li></ul><p><code>submit()</code>方法有三个重载方法。</p><pre><code class="java">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);</code></pre><p><code>execute()</code>方法只有一个</p><pre><code class="java">void execute(Runnable command);</code></pre><ul><li><code>execute()</code>没有返回值；而<code>submit()</code>有返回值</li><li><code>submit()</code>的返回值<code>Future</code>调用<code>get()</code>方法时，可以捕获处理异常。而<code>execute()</code>没有返回值不能捕获异常。<h3 id="有哪些常用的线程池？"><a href="#有哪些常用的线程池？" class="headerlink" title="有哪些常用的线程池？"></a>有哪些常用的线程池？</h3><code>Executors.newCacheThreadPool()</code>：<strong>可缓存线程池</strong>，先查看池中有没有已建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务。<br><code>Executors.newFixedThreadPool()</code>：<strong>可重用固定个数的线程池</strong>，以共享的无界队列方式来运行这些线程。<br><code>Executors.newScheduledThreadPool(int n)</code>：<strong>定长线程池</strong>，支持定时及周期性任务执行。<br><code>Executors.newSingleThreadExecutor()</code>：<strong>单线程化的线程池</strong>，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<h3 id="什么是线程安全问题？如何保证线程安全？"><a href="#什么是线程安全问题？如何保证线程安全？" class="headerlink" title="什么是线程安全问题？如何保证线程安全？"></a>什么是线程安全问题？如何保证线程安全？</h3>当<strong>多个线程</strong>同时共享，同一个<strong>全局变量或者静态变量</strong>，做写的操作时，可能会发生数据冲突问题，也就是<strong>线程安全问题</strong>。<h3 id="java的内存模型？"><a href="#java的内存模型？" class="headerlink" title="java的内存模型？"></a>java的内存模型？</h3>java的内存模型规定了所有的变量都<strong>存储在主内存中，每个线程拥有自己的工作内存</strong>，工作内存保存了该线程使用到的变量的主内存拷贝，<strong>线程对变量所有操作，读取，赋值，都必须在工作内存中进行，不能直接写主内存变量</strong>，线程间变量值的传递均需要主内存来完成。<h3 id="volatile关键字有什么作用？volatile一定能保证原子性吗？"><a href="#volatile关键字有什么作用？volatile一定能保证原子性吗？" class="headerlink" title="volatile关键字有什么作用？volatile一定能保证原子性吗？"></a>volatile关键字有什么作用？volatile一定能保证原子性吗？</h3>volatile关键字有什么作用：</li><li>内存<strong>可见性</strong>（Memory Visibility)：所有线程都能看到共享内存的最新状态。</li><li>禁止指令重排。</li></ul><p><code>volatile</code>是Java提供的一种<strong>轻量级的同步机制</strong>，并不能保证原子性。</p><h3 id="什么是指令重排？"><a href="#什么是指令重排？" class="headerlink" title="什么是指令重排？"></a>什么是指令重排？</h3><p>指令重排是指<code>JVM</code>在编译Java代码的时候，或者CPU在执行<code>JVM</code>字节码的时候，对现有的指令顺序进行重新排序。<br>指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。</p><h3 id="synchronized的使用方式？"><a href="#synchronized的使用方式？" class="headerlink" title="synchronized的使用方式？"></a>synchronized的使用方式？</h3><ul><li>修饰实例(非静态方法。被锁对象是类的实例(<code>this</code>)。</li><li>修饰静态方法。被锁对象是类对象。</li><li>同步代码块。有三种形式。<br>①<code>synchronized(this){}</code>，被锁对象是类的实例。<br>②<code>synchronized(XXX.Class)</code>，被锁对象是类对象。<br>③<code>synchronized(new Object())</code>，被锁对象是实例对象<code>object</code>。<h3 id="Lock锁的使用方式？"><a href="#Lock锁的使用方式？" class="headerlink" title="Lock锁的使用方式？"></a>Lock锁的使用方式？</h3></li></ul><p>1.获取锁。2.上锁。3.释放锁。<br>注意点：释放锁最好放在<code>finally{}</code>代码块中，保证能执行释放锁。</p><h3 id="什么是乐观锁、什么是悲观锁？"><a href="#什么是乐观锁、什么是悲观锁？" class="headerlink" title="什么是乐观锁、什么是悲观锁？"></a>什么是乐观锁、什么是悲观锁？</h3><ul><li><strong>悲观锁</strong>：它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。具有强烈的独占和排他特性。</li><li><strong>乐观锁</strong>：乐观锁认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的重提与否进行检测，如果发现冲突了，程序自动去重试。相对于悲观锁，在高并发的场景下有更好的性能表现，通常用”版本号”实现。<h3 id="synchronized与Lock锁的区别？"><a href="#synchronized与Lock锁的区别？" class="headerlink" title="synchronized与Lock锁的区别？"></a>synchronized与Lock锁的区别？</h3></li><li><code>synchronized</code>是java内置关键字，在<code>jvm</code>层面。<code>Lock</code>是个java类。</li><li><code>synchronized</code>无法判断是否获取锁的状态。<code>Lock</code>可以判断是否获取到锁。</li><li><code>synchronized</code>会自动释放锁。<code>Lock</code>锁需要在<code>finally{}</code>代码块中手工释放锁。</li><li><code>synchronized</code>的锁可重入、不可中断、非公平。而<code>Lock</code>锁可重入、可判断、可公平（两者皆可）。<h3 id="有哪些常用的线程安全的集合？"><a href="#有哪些常用的线程安全的集合？" class="headerlink" title="有哪些常用的线程安全的集合？"></a>有哪些常用的线程安全的集合？</h3><code>ConcurrentHashMap</code>、<code>Vector</code>、<code>Hashtable</code>、<code>Stack</code>。还可以使用<code>Collections包装方法</code>获得线程安全的集合。<h3 id="CAS是什么，有什么问题，如何解决？"><a href="#CAS是什么，有什么问题，如何解决？" class="headerlink" title="CAS是什么，有什么问题，如何解决？"></a>CAS是什么，有什么问题，如何解决？</h3><code>CAS</code>是<code>compare and swap</code>的缩写，意思是比较与交换。<code>CAS</code>是乐观锁的一种实现。CAS操作包含三个操作数—内存位置的值（V）、预期原值（A）和新值（B）。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。</li></ul><p><code>CAS</code>有以下缺点：</p><ul><li>ABA问题： 线程C、D。线程D将A修改为B后又修改为A，此时C线程以为A没有改变过。这个问题通常可以使用版本号来解决。</li><li>CPU开销过大。在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很到的压力。</li><li><code>CAS</code>机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用<code>synchronized</code>了。<h3 id="什么是ThreadLocal？"><a href="#什么是ThreadLocal？" class="headerlink" title="什么是ThreadLocal？"></a>什么是ThreadLocal？</h3>这个类提供了线程局部变量也称为线程本地变量，它为变量在每个线程中创建了一个副本，通过这样的方式做到变量在线程间隔离且在方法间共享的场景。<h3 id="ThreadLocal是如何保证线程安全的？"><a href="#ThreadLocal是如何保证线程安全的？" class="headerlink" title="ThreadLocal是如何保证线程安全的？"></a>ThreadLocal是如何保证线程安全的？</h3><code>ThreadLocal</code>存储的值不是线程共享的，而是属于线程的。内部会维护一个<code>ThreadLocalMap</code>，key是当前线程的<code>ThreadLocal</code>，value是存储的值。换句话说，每个线程都有自己的值，当然不会出现线程安全问题了。</li></ul><p>源码如下：</p><pre><code class="java">    public void set(T value) {        //获取当前线程        Thread t = Thread.currentThread();        //通过当前线程获取到ThreadLocalMap        ThreadLocalMap map = getMap(t);        if (map != null)            //key是this，value是需要存储的值            map.set(this, value);        else            //创建一个map            createMap(t, value);    }</code></pre><h1 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h1><h3 id="什么是JVM内存模型？"><a href="#什么是JVM内存模型？" class="headerlink" title="什么是JVM内存模型？"></a>什么是JVM内存模型？</h3><p>Java内存模型（Java Memory Model，简称为<strong>JMM</strong>)，是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p>根据java虚拟机规范，JVM内存共分为<strong>虚拟机栈，堆，方法区，程序计数器，本地方法栈</strong>五个部分。</p><h3 id="栈内存溢出-StackOverflowError-的常见原因有哪些？"><a href="#栈内存溢出-StackOverflowError-的常见原因有哪些？" class="headerlink" title="栈内存溢出(StackOverflowError)的常见原因有哪些？"></a>栈内存溢出(StackOverflowError)的常见原因有哪些？</h3><p>栈溢出原因就是方法执行时创建的栈帧超过了栈的深度。最有可能的就是<strong>方法递归调用</strong>产生这种结果。</p><h3 id="堆内存溢出-OOM-的常见原因有哪些？"><a href="#堆内存溢出-OOM-的常见原因有哪些？" class="headerlink" title="堆内存溢出(OOM)的常见原因有哪些？"></a>堆内存溢出(OOM)的常见原因有哪些？</h3><ul><li><code>OutOfMemoryError: Java heap space</code>。在创建新的对象时, 堆内存中的空间不足以存放新创建的对象时发生。产生原因：程序中出现了死循环，不断创建对象；程序占用内存太多，<strong>超过了JVM堆设置的最大值</strong>。</li><li><code>OutOfMemoryError: unable to create new native thread</code>。产生原因：系统内存耗尽，无法为新线程分配内存；<strong>创建线程数超过了操作系统的限制</strong>。</li><li><code>OutOfMemoryError: PermGen space</code>。永久代溢出，即方法区溢出了，一般<strong>出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况</strong>，因为上述情况会产生大量的Class信息存储于方法区。</li><li><code>OutOfMemoryError：GC overhead limit exceeded</code>。<strong>超过98%的时间都在用来做GC并且回收了不到2%的堆内存</strong>。连续多次的GC，都回收了不到2%的极端情况下才会抛出。</li></ul><h3 id="JVM参数调优有哪些重要的参数？分别有什么作用？"><a href="#JVM参数调优有哪些重要的参数？分别有什么作用？" class="headerlink" title="JVM参数调优有哪些重要的参数？分别有什么作用？"></a>JVM参数调优有哪些重要的参数？分别有什么作用？</h3><ul><li>-Xms  初始堆内存大小。</li><li>-Xmx  最大堆内存大小。</li><li>-Xss  每个线程的栈大小。</li><li>-XX:+PrintGC  每次GC时打印相关信息。</li><li>-XX:Newratio  设置年轻代和老年代的比例，比如值为2，则老年代是年轻代的2倍。</li><li>-XX:Newsize  设置年轻代的初始值大小。</li><li>-XX:Maxnewsize  设置年轻代的最大值大小。</li></ul><h3 id="GC垃圾回收机制，有哪些垃圾回收算法？"><a href="#GC垃圾回收机制，有哪些垃圾回收算法？" class="headerlink" title="GC垃圾回收机制，有哪些垃圾回收算法？"></a>GC垃圾回收机制，有哪些垃圾回收算法？</h3><p>标记-清除算法、复制算法、标记整理算法、分代收集算法。</p><h3 id="JVM如何判断对象是否可以回收？"><a href="#JVM如何判断对象是否可以回收？" class="headerlink" title="JVM如何判断对象是否可以回收？"></a>JVM如何判断对象是否可以回收？</h3><p>会使用可达性分析算法进行判断，原理是从一系列被称为<code>GC ROOT</code>的对象开始，向下搜索，搜索走过的路径称为引用链，当一个对象到<code>GC ROOT</code>之间没有引用链，说明这个对象不可用，那么就会被GC回收。</p><h3 id="什么是强引用、软引用、弱引用、虚引用？"><a href="#什么是强引用、软引用、弱引用、虚引用？" class="headerlink" title="什么是强引用、软引用、弱引用、虚引用？"></a>什么是强引用、软引用、弱引用、虚引用？</h3><p>强引用。一般<code>new</code>出来的对象都是强引用。如果一个对象具有强引用，<code>GC</code>绝不会回收它；当内存空间不足，JVM宁愿抛出<code>OutOfMemoryError</code>错误。</p><pre><code class="java">//强引用Object obj = new Object();</code></pre><p>软引用。如果一个对象只具有软引用。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p><pre><code class="java">//软引用SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(new Object());</code></pre><p>弱引用。如果一个对象具有弱引用，在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存。</p><pre><code class="java">//弱引用WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(new Object());</code></pre><p>虚引用。如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收。</p><pre><code class="java">//虚引用PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(new Object(), new ReferenceQueue&lt;&gt;());</code></pre><h3 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h3><p>Java类加载器是Java运行时环境的一部分，负责动态加载Java类到JVM的内存空间中。</p><h3 id="什么是双亲委派机制？"><a href="#什么是双亲委派机制？" class="headerlink" title="什么是双亲委派机制？"></a>什么是双亲委派机制？</h3><p>双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。</p><h3 id="类的生命周期？"><a href="#类的生命周期？" class="headerlink" title="类的生命周期？"></a>类的生命周期？</h3><p><strong>加载、验证、准备、解析、初始化、使用、卸载</strong>。</p><p>有些资料会把(验证、准备、解析)归纳为连接，于是就变成：<strong>加载、连接、初始化、使用、卸载</strong>。</p><h1 id="设计模式相关"><a href="#设计模式相关" class="headerlink" title="设计模式相关"></a>设计模式相关</h1><h3 id="如何实现单例模式？"><a href="#如何实现单例模式？" class="headerlink" title="如何实现单例模式？"></a>如何实现单例模式？</h3><ul><li>饿汉式单例模式。定义一个静态成员变量，把构造器私有化，只对外暴露一个获取实例的方法。<pre><code class="java">public class SingLeton {  //立即加载  private static SingLeton singLeton = new SingLeton();  //私有化构造器  private SingLeton(){}  //对外暴露获取实例的方法  public static SingLeton getSingLeton(){      return singLeton;  }}</code></pre></li><li>懒汉式单例模式。非线程安全。基本和上面饿汉式实现方式类似，只是在获取时再判断是否创建实例，但是会有线程安全问题。<pre><code class="java">public class SingLeton {  //立即加载  private static SingLeton singLeton;  //私有化构造器  private SingLeton() {  }  //对外暴露获取实例的方法  public static SingLeton getSingLeton() {      if (singLeton == null) {          singLeton = new SingLeton();      }      return singLeton;  }}</code></pre></li><li>使用静态内部类实现<pre><code class="java">public class SingLeton {  //私有化构造器  private SingLeton() {}  //对外暴露获取实例的方法  public static SingLeton getSingLeton() {      return SingLetonHolder.SINGLETON;  }  //私有静态内部类  private static class SingLetonHolder {      private static final SingLeton SINGLETON = new SingLeton();  }}</code></pre></li><li>使用枚举实现<pre><code class="java">public enum SingLeton {  SINGLETON;}</code></pre></li></ul><h3 id="如何实现线程安全的单例模式？"><a href="#如何实现线程安全的单例模式？" class="headerlink" title="如何实现线程安全的单例模式？"></a>如何实现线程安全的单例模式？</h3><p><strong>饿汉式实现、枚举、静态内部类</strong>都是<strong>线程安全</strong>的实现方式。<br>还可以使用<strong>双检锁</strong>的懒汉式方式实现：</p><pre><code class="java">public class SingLeton {    private static volatile SingLeton singLeton;    //私有化构造器    private SingLeton() {}    //对外暴露获取实例的方法    public static SingLeton getSingLeton() {        if (singLeton == null) {            synchronized (SingLeton.class) {                if (singLeton == null) {                    singLeton = new SingLeton();                }            }        }        return singLeton;    }}</code></pre><h3 id="为什么要使用工厂模式创建对象？"><a href="#为什么要使用工厂模式创建对象？" class="headerlink" title="为什么要使用工厂模式创建对象？"></a>为什么要使用工厂模式创建对象？</h3><ul><li><strong>解耦</strong>。把对象的创建和使用的过程分开。</li><li><strong>可以降低代码重复</strong>。如果创建B过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。</li><li><strong>减少了使用者因为创建逻辑导致的错误</strong>。因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可。</li><li><strong>提高了代码的可维护性</strong>。如果发生业务逻辑变化，不需要找到所有需要创建对象的地方去逐个修正，只需要在工厂里修改即可。</li></ul><h3 id="在java中，实现代理模式有哪几种方式？"><a href="#在java中，实现代理模式有哪几种方式？" class="headerlink" title="在java中，实现代理模式有哪几种方式？"></a>在java中，实现代理模式有哪几种方式？</h3><ul><li>静态代理。</li><li>JDK动态代理。</li><li>CGlib动态代理。</li></ul><h3 id="JDK动态代理和CGlib动态代理的区别？"><a href="#JDK动态代理和CGlib动态代理的区别？" class="headerlink" title="JDK动态代理和CGlib动态代理的区别？"></a>JDK动态代理和CGlib动态代理的区别？</h3><p> （1）<code>JDK动态代理</code>只能对实现了接口的类生成代理，而不能针对类。<br> （2）<code>CGLIB</code>是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。<br>   因为是继承，所以该类或方法不能声明成<code>final</code>。</p><h3 id="策略模式的使用场景？"><a href="#策略模式的使用场景？" class="headerlink" title="策略模式的使用场景？"></a>策略模式的使用场景？</h3><ul><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时<strong>动态选择具体要执行的行为</strong>。</li><li>需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</li><li>对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</li></ul><h3 id="装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？"><a href="#装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？" class="headerlink" title="装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？"></a>装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？</h3><p>使用场景：</p><ul><li>扩展一个类的功能。<ul><li>动态增加功能，动态撤销。</li></ul></li></ul><p>java中经典的例子就是I/O流。具体分析过程可以参考我写的这篇文章：<a href="https://blog.csdn.net/yehongzhi1994/article/details/106065136" target="_blank" rel="noopener">装饰者模式与IO流的应用</a>。</p><h1 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h1><h3 id="有哪些经典的排序算法？"><a href="#有哪些经典的排序算法？" class="headerlink" title="有哪些经典的排序算法？"></a>有哪些经典的排序算法？</h3><p>插入排序、冒泡排序、归并排序、快速排序、堆排序、桶排序、基数排序等等。</p><h3 id="冒泡排序的时间复杂度和空间复杂度？"><a href="#冒泡排序的时间复杂度和空间复杂度？" class="headerlink" title="冒泡排序的时间复杂度和空间复杂度？"></a>冒泡排序的时间复杂度和空间复杂度？</h3><p>平均的时间复杂度是<code>O(n^2)</code>，最好的情况是<code>O(n)</code>，最坏的情况是<code>O(n^2)</code>。空间复杂度是<code>O(1)</code>。</p><h3 id="哪一种排序算法的时间复杂度比较稳定？"><a href="#哪一种排序算法的时间复杂度比较稳定？" class="headerlink" title="哪一种排序算法的时间复杂度比较稳定？"></a>哪一种排序算法的时间复杂度比较稳定？</h3><p>归并排序。最好和最坏的情况下，时间复杂度都是<code>O(n*log n)</code>。</p><h3 id="如何实现二分查找？二分查找的时间复杂度？-笔试常见"><a href="#如何实现二分查找？二分查找的时间复杂度？-笔试常见" class="headerlink" title="如何实现二分查找？二分查找的时间复杂度？(笔试常见)"></a>如何实现二分查找？二分查找的时间复杂度？(笔试常见)</h3><p>有两种方式，迭代法和递归法。具体实现代码，可以参考我写的这篇《<a href="https://blog.csdn.net/yehongzhi1994/article/details/105835380" target="_blank" rel="noopener">手把手教你实现二分查找</a>》。时间复杂度是<code>O(log n)</code>。</p><h3 id="跳楼梯的问题。-笔试常见"><a href="#跳楼梯的问题。-笔试常见" class="headerlink" title="跳楼梯的问题。(笔试常见)"></a>跳楼梯的问题。(笔试常见)</h3><p>这是一个经典的斐波那契数列问题。力扣题库第70题。可以看看大佬们的题解。这是我的题解，使用了<code>Map</code>作为缓存，减少一些不必要的递归，效率还不错。执行时间：1 ms。当然你去掉那个<code>Map</code>也是完全没错的，只是运行时间会久一些，可能会超出<code>leetcode</code>的时间限制，没法通过。<br><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/guan-fang-jie-fa-yi-chao-shi-cai-yong-maphuan-cun-/" target="_blank" rel="noopener">我的题解链接</a></p><pre><code class="java">/** * 题目描述： * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？*/class Solution {    private Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    public int climbStairs(int n) {        if (n == 1) {            map.put(n, 1);            return 1;        }        if (n == 2) {            map.put(n, 2);            return 2;        }        if (map.get(n) != null) {            return map.get(n);        } else {            int num = climbStairs(n - 1) + climbStairs(n - 2);            map.put(n, num);            return num;        }    }}</code></pre><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>责任链模式</title>
    <link href="/2020/06/06/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/06/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>各位<strong>java技术爱好者</strong>，我们又见面了！<br>之前我在面试的时候遇到这个问题，当时答不上来。这件事就一直在我心里耿耿于怀。相信很多人面试完都有这种体验，哈哈~<br>不过今日不同往日了，现在我已经搞懂了，其实并不是很难。</p><a id="more"></a><p><img src="https://static.lovebilibili.com/20200606_2211_01.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="开始搞事情"><a href="#开始搞事情" class="headerlink" title="开始搞事情"></a>开始搞事情</h1><p>要学习一种技术，当然要搞清楚能解决什么问题，这是最关键的，否则就像买了一个开瓶器，还是用嘴咬开啤酒瓶盖一样(比喻很巧妙)。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先我们用<code>Request</code>对象，表示一个请求。</p><pre><code class="java">public class Request {    //请求数据    private String data;    public String getData() {        return data;    }    public void setData(String data) {        this.data = data;    }}</code></pre><p>假设<code>data</code>中有很多数据，我们要过滤掉一些关键字，比如<code>水果</code>、<code>蔬菜</code>。<br>如果不用设计模式，直接用<code>if</code>解决，就是这样写：</p><pre><code class="java">public static void main(String[] args) throws Exception {        //创建请求体        String data = &quot;肉蛋葱鸡水果蔬菜千层饼雅俗共赏第五层的马老师&quot;;        Request request = new Request();        request.setData(data);        String requestData = request.getData();        //如果包含水果关键字        if (requestData.contains(&quot;水果&quot;)) {            //过滤水果关键字            requestData = filterByWord(requestData, &quot;水果&quot;);        }        //如果包含蔬菜关键字        if (requestData.contains(&quot;蔬菜&quot;)) {            //过滤蔬菜关键字            requestData = filterByWord(requestData, &quot;蔬菜&quot;);        }        request.setData(requestData);        System.out.println(requestData);//肉蛋葱鸡千层饼雅俗共赏第五层的马老师    }    //过滤关键字的方法    private static String filterByWord(String data, String word) {        StringBuilder sb = new StringBuilder(data);        while (true) {            int index = sb.indexOf(word);            //如果不等于-1，搜索到关键字            if (index != -1) {                for (int i = 0; i &lt; word.length(); i++) {                    //关键字有多长就删多少次，比如水果，在index位置上删两次                    sb.deleteCharAt(index);                }            } else {                //等于-1，没有关键字，跳出循环                break;            }        }        return sb.toString();    }}    </code></pre><p>这样的代码在项目中不要太多，遇事不决来个<code>if</code>，不行就再来一个。一般这种程序员就只看到了<strong>第一层</strong>。<br>问题：<br>1.如果这时候要增加多一些关键字呢，怎么处理？在原来的代码里继续加<code>if</code>的话，那这个方法就越写越长。而且破坏了<code>开闭原则</code>。<br>2.如果要调换顺序呢。难道要剪切复制代码？<br><strong>所以一个好的程序员，实现功能只是基本要求，重要是代码要有好的维护性和扩展性。</strong><br><img src="https://static.lovebilibili.com/20200606_2211_00.png" srcset="/img/loading.gif" alt=""></p><h2 id="怎么优化呢？"><a href="#怎么优化呢？" class="headerlink" title="怎么优化呢？"></a>怎么优化呢？</h2><p>我们可以这样想，把每个过滤关键字的方法<strong>抽成一个类</strong>，然后定义一个<strong>过滤关键字的方法</strong>，因为有很多个类似职责的类，所以<strong>定义一个接口</strong>，<strong>公共的方法</strong>可以定义在接口。<br>第一步：定义<strong>过滤器接口</strong></p><pre><code class="java">public interface Filter {    //接口方法    String doFilter(String data, FilterChain filterChain);    //过滤关键字的方法    default String filterByWord(String data, String word) {        StringBuilder sb = new StringBuilder(data);        while (true) {            int index = sb.indexOf(word);            if (index != -1) {                for (int i = 0; i &lt; word.length(); i++) {                    //关键字有几个字，就删几次。比如水果就在index删两次即可                    sb.deleteCharAt(index);                }            } else {                //如果找不到关键字，就跳出循环                break;            }        }        return sb.toString();    }}</code></pre><p>第二步：定义<strong>水果关键字过滤器</strong></p><pre><code class="java">public class FruitsFilter implements Filter {    @Override    public String doFilter(String data, FilterChain filterChain) {        //过滤水果关键字        data = filterByWord(data, &quot;水果&quot;);        //拿到控制器，继续调用下一个过滤器        return filterChain.preHandleRequest(data);    }}</code></pre><p>第三部：定义<strong>蔬菜关键字过滤器</strong></p><pre><code class="java">public class VegetablesFilter implements Filter {    @Override    public String doFilter(String data, FilterChain filterChain) {        //过滤蔬菜关键字        data = filterByWord(data, &quot;蔬菜&quot;);        //拿到控制器，继续调用下一个过滤器        return filterChain.preHandleRequest(data);    }}</code></pre><p>第四步：定义一个<strong>过滤器的控制器</strong></p><pre><code class="java">public class FilterChain {    //使用List装过滤器，List是有序的    private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();    //过滤器的下标，从0开始，每次调用preHandleRequest方法就+1    private int index = 0;    //添加过滤器    public void addFilter(Filter filter) {        filters.add(filter);    }    //调用过滤器的doFilter()方法，并把指针+1指向下一个过滤器    public String preHandleRequest(String data) {        //如果指针大于集合的size，则return，不再往下调用，相当于递归的终结条件        if (index == filters.size()) {            return data;        }        Filter filter = filters.get(index);        //下标指针+1        index++;        //精髓在这个this，把自己再当做参数传进去，实现了递归        return filter.doFilter(data, this);    }}</code></pre><p>这样就大功告成了，最后我们创建一个Main方法试试吧~</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //创建请求体        String data = &quot;肉蛋葱鸡水果蔬菜千层饼雅俗共赏第五层的马老师&quot;;        Request request = new Request();        request.setData(data);        //创建FilterChain执行链        FilterChain filterChain = new FilterChain();        //添加过滤器        filterChain.addFilter(new FruitsFilter());        filterChain.addFilter(new VegetablesFilter());        //执行预处理        String s = filterChain.preHandleRequest(request.getData());        request.setData(s);        //打印结果，验证        System.out.println(request.getData());//下面是打印结果，结果正确        //肉蛋葱鸡千层饼雅俗共赏第五层的马老师    }}</code></pre><p>这就是责任链模式！下面用一张图来看看调用链的执行顺序。其实没有想得那么难吧。你学会了吗？<br><img src="https://img-blog.csdnimg.cn/20200606120835391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="责任链模式的优点"><a href="#责任链模式的优点" class="headerlink" title="责任链模式的优点"></a>责任链模式的优点</h2><p>我们回过头去看，为什么这么绕呢，直接<code>if</code>不香吗？<br>还真不香，在用<code>if</code>的时候，提到的两个问题，破坏<code>开闭原则</code>，还有调用顺序的问题，用责任链模式都得到解决了。<br><strong>1.如果要加一些过滤的关键字，只需要加一个过滤的类，然后再添加到过滤器的集合中，不需要对原来的代码进行侵入式的开发。符合<code>开闭原则</code>。<br>2.执行顺序要变更的话，也不需要侵入式的改代码，只需要改一下添加过滤器的顺序。在<code>Servlet</code>中，过滤器的顺序就是按<code>xml</code>文件定义的顺序。在<code>SpringMVC</code>则是按注册的顺序。这就非常易于扩展。</strong><br>要多为下一个程序员着想，我为人人，人人为我，世界才会变得更美好！哈哈~~</p><h1 id="SpringMVC的责任链模式"><a href="#SpringMVC的责任链模式" class="headerlink" title="SpringMVC的责任链模式"></a>SpringMVC的责任链模式</h1><p>以上就是一个简单的<code>demo</code>，重要的是学习这种思想。那么我们看实战中是怎么应用的，所谓知其然知其所以然，学习<strong>忌讳浅尝辄止</strong>，趁热打铁，我们看看框架中怎么应用责任链模式。</p><h2 id="SpringMVC拦截器的使用"><a href="#SpringMVC拦截器的使用" class="headerlink" title="SpringMVC拦截器的使用"></a>SpringMVC拦截器的使用</h2><p>很简单，实现<code>HandlerInterceptor</code>接口，接口有三个方法需要重写。</p><ul><li>preHandle()：在业务处理器处理请求之前被调用。预处理。</li><li>postHandle()：在业务处理器处理请求执行完成后，生成视图之前执行。后处理。</li><li>afterCompletion()：在<code>DispatcherServlet</code>完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）；</li></ul><p>我们定义一个关键字过滤器<code>WordInterceptor</code>：</p><pre><code class="java">//定义一个关键字拦截器public class WordInterceptor implements HandlerInterceptor {    //在执行controller定义的请求方法前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;执行WordInterceptor的preHandle()&quot;);        return true;    }    //controller定义的请求方法执行后，但还没渲染页面前，执行    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;执行WordInterceptor的postHandle()&quot;);    }    //在渲染页面完毕后执行，或者preHandle()返回fasle时执行    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(&quot;执行WordInterceptor的afterCompletion()&quot;);    }}</code></pre><p>如法炮制，再定义一个登录拦截器</p><pre><code class="java">public class LoginInterceptor implements HandlerInterceptor {    //在执行controller定义的请求方法前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;执行LoginInterceptor的preHandle()&quot;);        return true;    }    //controller定义的请求方法执行后，但还没渲染页面前，执行    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;执行LoginInterceptor的postHandle()&quot;);    }    //在渲染页面完毕后执行，或者preHandle()返回fasle时执行    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(&quot;执行LoginInterceptor的afterCompletion()&quot;);    }}</code></pre><p>然后再注册到拦截器的集合中。</p><pre><code class="java">@Componentpublic class WebInterceptorConfig implements WebMvcConfigurer {    @Override    public void addInterceptors(InterceptorRegistry registry) {        //先注册关键字拦截器，拦截所有请求        registry.addInterceptor(new WordInterceptor()).addPathPatterns(&quot;/**&quot;);        //再注册登录拦截器，拦截所有请求        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;);    }}</code></pre><p>然后启动项目，发起一个请求，我们就可以在控制台看到调用的顺序了。注意观察：</p><pre><code class="java">//按注册顺序执行preHandle()方法执行WordInterceptor的preHandle()执行LoginInterceptor的preHandle()//按注册顺序，逆序执行postHandle()方法执行LoginInterceptor的postHandle()执行WordInterceptor的postHandle()//从最后一个preHandle()执行的类，逆序执行afterCompletion()执行LoginInterceptor的afterCompletion()执行WordInterceptor的afterCompletion()</code></pre><p>执行的流程图就是这样：<br><img src="https://static.lovebilibili.com/SpringMVC_liuchengtu.png" srcset="/img/loading.gif" alt=""><br>原理是什么呢？我们不妨走进源码去分析。</p><h2 id="SpringMVC拦截器源码分析"><a href="#SpringMVC拦截器源码分析" class="headerlink" title="SpringMVC拦截器源码分析"></a>SpringMVC拦截器源码分析</h2><p>还是要看<code>DispatcherServlet</code>的<code>doDispatch()</code>方法</p><h3 id="doDispatch-调用顺序"><a href="#doDispatch-调用顺序" class="headerlink" title="doDispatch()调用顺序"></a><code>doDispatch()</code>调用顺序</h3><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        //请求对象        HttpServletRequest processedRequest = request;        //定义一个调用链        HandlerExecutionChain mappedHandler = null;        boolean multipartRequestParsed = false;        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                //省略                // 获取调用链                mappedHandler = getHandler(processedRequest);                if (mappedHandler == null) {                    noHandlerFound(processedRequest, response);                    return;                }                //获取对应的适配器                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());                //调用拦截器的preHandle()前处理方法                if (!mappedHandler.applyPreHandle(processedRequest, response)) {                    //如果上面返回fasle,取反就是true，进来这里就return，结束了                    return;                }                //调用Controller的RequestMapping对应的方法                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                //调用拦截器的postHandle()后处理方法                mappedHandler.applyPostHandle(processedRequest, response, mv);                //省略            }catch (Exception ex) {            //如果出现异常还是会执行triggerAfterCompletion()方法            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);        }        catch (Throwable err) {            //如果出现异常还是会执行triggerAfterCompletion()方法            triggerAfterCompletion(processedRequest, response, mappedHandler,                    new NestedServletException(&quot;Handler processing failed&quot;, err));        }        finally {            //省略        }    }</code></pre><p>从上面源码中明显可以知道，拦截器接口的执行顺序:<br><code>applyPreHandle()</code>→<code>handle()</code>→<code>applyPostHandle()</code>→<code>triggerAfterCompletion()</code><br>或者<br><code>applyPreHandle()</code>→<code>triggerAfterCompletion()</code></p><h3 id="关键在于HandlerExecutionChain接口"><a href="#关键在于HandlerExecutionChain接口" class="headerlink" title="关键在于HandlerExecutionChain接口"></a>关键在于<code>HandlerExecutionChain</code>接口</h3><p>其实上面这些方法除了<code>handle()</code>定义在适配器中，其他都是这个接口的。<code>handle()</code>方法我已经在上一篇《适配器模式与SpringMV》讲过了。下面我们看<code>HandlerExecutionChain</code>接口。</p><pre><code class="java">public class HandlerExecutionChain {    //省略    @Nullable    private HandlerInterceptor[] interceptors;    @Nullable//拦截器集合    private List&lt;HandlerInterceptor&gt; interceptorList;    //指针,用来记录applyPreHandle()方法执行到哪一个拦截器    private int interceptorIndex = -1;}</code></pre><p>这不就跟我们的<code>demo</code>类似吗？定义了一个集合封装拦截器，定义一个指针遍历集合。</p><h4 id="applyPreHandle-方法"><a href="#applyPreHandle-方法" class="headerlink" title="applyPreHandle()方法"></a>applyPreHandle()方法</h4><p>那么前置方法<code>applyPreHandle()</code>是怎么样执行的呢？</p><pre><code class="java">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {        //获取拦截器        HandlerInterceptor[] interceptors = getInterceptors();        //判断不为空        if (!ObjectUtils.isEmpty(interceptors)) {            //按顺序遍历，所以拦截器接口定义的preHandle()是按顺序执行的            for (int i = 0; i &lt; interceptors.length; i++) {                //按顺序获取注册的拦截器                HandlerInterceptor interceptor = interceptors[i];                //执行拦截器的preHandle()方法                if (!interceptor.preHandle(request, response, this.handler)) {                    //如果preHandle()返回false,那就调用triggerAfterCompletion()方法                    triggerAfterCompletion(request, response, null);                    //返回false，结束调用                    return false;                }                //如果preHandle()返回true，继续执行                //把下标索引记录到成员变量的指针中，用于后面执行triggerAfterCompletion()方法                this.interceptorIndex = i;            }        }        return true;    }</code></pre><h4 id="applyPostHandle-方法"><a href="#applyPostHandle-方法" class="headerlink" title="applyPostHandle()方法"></a>applyPostHandle()方法</h4><p>然后下一步执行的<code>applyPostHandle()</code>方法，又是怎么执行的呢？</p><pre><code class="java">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)            throws Exception {        HandlerInterceptor[] interceptors = getInterceptors();        if (!ObjectUtils.isEmpty(interceptors)) {            //倒序遍历，所以postHandle()方法是从最后一个拦截器开始执行的            for (int i = interceptors.length - 1; i &gt;= 0; i--) {                HandlerInterceptor interceptor = interceptors[i];                //postHandle()能获取到ModelAndView对象，拦截器可以对mv对象进行后处理                interceptor.postHandle(request, response, this.handler, mv);            }        }    }</code></pre><h4 id="triggerAfterCompletion-方法"><a href="#triggerAfterCompletion-方法" class="headerlink" title="triggerAfterCompletion()方法"></a>triggerAfterCompletion()方法</h4><pre><code class="java">void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex)            throws Exception {        HandlerInterceptor[] interceptors = getInterceptors();        if (!ObjectUtils.isEmpty(interceptors)) {            //从成员变量interceptorIndex记录的指针值，开始倒序遍历            for (int i = this.interceptorIndex; i &gt;= 0; i--) {                HandlerInterceptor interceptor = interceptors[i];                try {                    interceptor.afterCompletion(request, response, this.handler, ex);                }                catch (Throwable ex2) {                    logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);                }            }        }    }</code></pre><h3 id="拦截器集合-interceptorList如何组装"><a href="#拦截器集合-interceptorList如何组装" class="headerlink" title="拦截器集合 interceptorList如何组装"></a>拦截器集合 <code>interceptorList</code>如何组装</h3><p>我们都看到上面三个方法都有一个公用的方法<code>getInterceptors()</code>。</p><pre><code class="java">    @Nullable    public HandlerInterceptor[] getInterceptors() {        if (this.interceptors == null &amp;&amp; this.interceptorList != null) {            this.interceptors = this.interceptorList.toArray(new HandlerInterceptor[0]);        }        return this.interceptors;    }</code></pre><p>关键是这个<code>interceptorList</code>是在哪里把拦截器<code>add()</code>进去的呢？<br>其实很简单，经过一路顺藤摸瓜，我们看到<code>AbstractHandlerMapping</code>的<code>getHandlerExecutionChain()</code>方法：</p><pre><code class="java">    protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {        HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?                (HandlerExecutionChain) handler : new HandlerExecutionChain(handler));        String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);        for (HandlerInterceptor interceptor : this.adaptedInterceptors) {            //判断是否继承拦截器父类            if (interceptor instanceof MappedInterceptor) {                MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;                if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) {                    //添加拦截器                    chain.addInterceptor(mappedInterceptor.getInterceptor());                }            }            else {                //添加拦截器                chain.addInterceptor(interceptor);            }        }        //返回调用链        return chain;    }</code></pre><p>那么上面这个方法又在什么时候被调用呢？我们一直往上找调用方。<br>首先是<code>AbstractHandlerMapping</code>的<code>getHandler()</code>方法</p><pre><code class="java">    @Override    @Nullable    public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {        //获取调用链        HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);        //省略        return executionChain;    }</code></pre><p>然后到了<code>DispatcherServlet</code>的<code>getHandler()</code>方法</p><pre><code class="java">    @Nullable    protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {        if (this.handlerMappings != null) {            for (HandlerMapping hm : this.handlerMappings) {                //省略                //获取调用链                HandlerExecutionChain handler = hm.getHandler(request);                if (handler != null) {                    //不为null则返回                    return handler;                }            }        }        return null;    }</code></pre><p>最后回到了<code>DispatcherServlet</code>的<code>doDispatch()</code>方法</p><pre><code class="java">    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                // 获取调用链方法！！！                mappedHandler = getHandler(processedRequest);                //省略                }            }        }    }</code></pre><p>哈哈~~真相大白了！是在<code>doDispatch()</code>方法里，获取调用链<code>getHandler()</code>方法中组装好<code>interceptorList</code>拦截器集合的！</p><h3 id="SpringMVC拦截器执行流程图解"><a href="#SpringMVC拦截器执行流程图解" class="headerlink" title="SpringMVC拦截器执行流程图解"></a>SpringMVC拦截器执行流程图解</h3><p>用张图总结一下，就是这样，我用不同的颜色分步骤从浅到深标记了(<strong>求点赞</strong>)：<br><img src="https://static.lovebilibili.com/SringMVC_tujie.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="最后说多几句"><a href="#最后说多几句" class="headerlink" title="最后说多几句"></a>最后说多几句</h1><p>除了<code>SpringMVC</code>外，其实还有很多框架都使用了责任链模式，比如<code>Servlet</code>的<code>Filter</code>，还有<code>Struts2</code>的<code>Interceptor</code>等等。有兴趣的同学可以去看看源码，其实都大同小异，思想懂了之后，源码看起来就没那么费劲了。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong><br><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote><blockquote><p>学之，则难者亦易矣。不学，则易者亦难矣。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式与SpringMVC</title>
    <link href="/2020/05/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8ESpringMVC/"/>
    <url>/2020/05/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8ESpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>适配器模式是将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>用生活中的例子就是充电器的转接头或者数据线转接头，也就是两个类不兼容的情况下，通过适配器类来做到兼容。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>我看了网上很多人的博客，关于适配器模式的一些例子，主要有两种，一种叫类适配器，一种叫对象适配器。写完这两个例子后，我有种恍然大悟的感觉！</p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>首先有一个接口是目标接口<code>PayService</code>，目标方法<code>pay()</code>。</p><pre><code class="java">public interface PayService {    String pay(String channel, String amount) throws Exception;}</code></pre><p>然后有一个被适配的类<code>CheckHelper</code>，适配方法<code>checkedPay()</code></p><pre><code class="java">public class CheckHelper {    //检查支付渠道和支付金额    public boolean checkedPay(String channel, String amount) {        try {            //字符串转成数字，如果出现转换异常返回fasle            int mount = Integer.parseInt(amount);            //PayEnum定义了一些支付渠道，比如支付宝、微信、银联等等            List&lt;String&gt; channelList = Arrays.stream(PayEnum.values())                .map(PayEnum::getChannel)                .collect(Collectors.toList());            //包含在支付渠道中，并且金额大于0，返回true，否则返回false            return channelList.contains(channel) &amp;&amp; mount &gt; 0;        } catch (Exception e) {            return false;        }    }}</code></pre><p>需求是要使得在接口<code>PayService</code>调用<code>CheckHelper</code>的<code>checkedPay()</code>方法，现在使用类适配器的方式演示：</p><pre><code class="java">public class PayAdapter extends CheckHelper implements PayService {    @Override    public String pay(String channel, String amount) throws Exception {        boolean checked = super.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>其实就是使用继承的方式来完成，适配器类继承<code>CheckHelper</code>类，然后使用<code>super</code>来调用被适配类</p><p><code>CheckHelper</code>的<code>checkedPay()</code>方法，一目了然了。</p><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>明显使用类适配器的方式不太灵活，因为<code>java</code>是单继承，所以我们可以改成成员变量的方式，也就是对象适配器。代码如下：</p><pre><code class="java">public class PayAdapter implements PayService {    //使用成员变量    private CheckHelper checkHelper = new CheckHelper();    @Override    public String pay(String channel, String amount) throws Exception {        //调用CheckHelper的checkedPay()方法        boolean checked = checkHelper.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>那么肯定有人会说，你这样直接<code>new</code>一个对象不好，可以使用<code>SpringIOC</code>注入，于是又可以写成这样：</p><pre><code class="java">//注册到Spring容器中@Component(&quot;checkHelper&quot;)public class CheckHelper {}</code></pre><pre><code class="java">public class PayAdapter implements PayService {    @Resource(name = &quot;checkHelper&quot;)    private CheckHelper checkHelper;    @Override    public String pay(String channel, String amount) throws Exception {        boolean checked = checkHelper.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>然后有人可能已经开始察觉了，这不就是平时我们使用的依赖注入吗？没错！所以我开始就说了，写完这两个例子后，我恍然大悟了。原来适配器模式我们一直都在用，只是没认出来罢了。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>那么我们用适配器模式有什么优点呢？为什么要这样写：</p><p>1.解耦，降低了对象与对象之间的耦合性。</p><p>2.增加了类的复用，这点是比较重要的。</p><p>3.灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。这点我待会在下面<code>SpringMVC</code>的应用中详细说明。</p><h2 id="在SpringMVC中的应用"><a href="#在SpringMVC中的应用" class="headerlink" title="在SpringMVC中的应用"></a>在SpringMVC中的应用</h2><p>我们都知道<code>SpringMVC</code>定义一个映射的方式很简单，使用<code>@RequestMapping</code>注解，如下所示：</p><pre><code class="java">@RestControllerpublic class PayController {    @RequestMapping(&quot;/pay&quot;)    public String pay(String channel,String amount)throws Exception{        return &quot;&quot;;    }}</code></pre><p>实际上除了上面这种常用的方式外，还有其他的方式定义：</p><blockquote><p>实现<code>Controller</code>接口</p></blockquote><pre><code class="java">@org.springframework.stereotype.Controller(&quot;/path&quot;)public class TestController implements Controller {    @Override    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {        return null;    }}</code></pre><blockquote><p>实现<code>HttpRequestHandler</code>接口</p></blockquote><pre><code class="java">@Controller(&quot;/httpPath&quot;)public class HttpController implements HttpRequestHandler {    @Override    public void handleRequest(HttpServletRequest request,                              HttpServletResponse response    ) throws ServletException, IOException {        //业务处理，页面跳转，返回响应结果等等    }}</code></pre><blockquote><p>实现<code>Servlet</code>接口</p></blockquote><pre><code class="java">@Controller(&quot;/servletPath&quot;)public class ServletController implements Servlet {    //Servlet生命周期函数    //重写init()方法      //重写getServletConfig()方法    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {        //业务处理    }    //重写getServletInfo()方法    //重写destroy()方法}</code></pre><p>还要配置一个<code>SimpleServletHandlerAdapter</code>适配器的<code>bean</code>，因为默认只加载前面三种适配器，所以这种适配器需要自己手动添加。从这里也可以看出<code>SpringMVC</code>已经不推荐这种创建方式。</p><pre><code class="java">@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter {    @Bean    public SimpleServletHandlerAdapter simpleServletHandlerAdapter() {        return new SimpleServletHandlerAdapter();    }}</code></pre><blockquote><p><code>HandlerFunction</code>接口，关于响应式接口的开发</p></blockquote><p>最后一种是使用<code>HandlerFunction</code>函数式接口，这是<code>Spring5.0</code>后引入的方式，主要用于做响应式接口的开发，这里就不举例子了。后面我会写一篇文章再详述。</p><p><strong>问题：</strong>以上就有五种方式定义<code>Mapping</code>映射，那么<code>SpringMVC</code>是如何去适配的呢？并且具有良好的扩展性和维护性呢？</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先我们把目光放在<code>DispatcherServlet</code>类的<code>doDispatch()</code>方法</p><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        boolean multipartRequestParsed = false;        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                processedRequest = checkMultipart(request);                multipartRequestParsed = (processedRequest != request);                // Determine handler for the current request.                mappedHandler = getHandler(processedRequest);                if (mappedHandler == null) {                    noHandlerFound(processedRequest, response);                    return;                }                //重点： 获取到对应的适配器                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());                //省略...                //重点： 调用HandlerAdapter接口的handle()方法，得到ModelAndView结果                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                //省略...            }            catch (Exception ex) {                //省略...            }            catch (Throwable err) {                //省略..            }        }    }</code></pre><p>先不要慌张，其实学过策略模式你一眼就可以看出来，实际上这里就是运用了类似于策略模式的方式，根据不同的对象获取到对应的适配器，然后执行<code>HandlerAdapter</code>接口的<code>handle()</code>方法得到结果。</p><p>关键是这个<code>getHandlerAdapter()</code>方法，是怎么获取到对应的<code>HandlerAdapter</code>。</p><pre><code class="java">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {        if (this.handlerAdapters != null) {            //这个handlerAdapters有全部的适配器，遍历handlerAdapters集合            for (HandlerAdapter adapter : this.handlerAdapters) {                //如果匹配                if (adapter.supports(handler)) {                    //就返回这个适配器                    return adapter;                }            }        }        throw new ServletException(&quot;No adapter for handler [&quot; + handler +                &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);    }</code></pre><p>那么你看到上面这个<code>this.handlerAdapters</code>肯定会有疑问，<code>handlerAdapters</code>集合里面的适配器是什么时候初始化的？哪里初始化？继续看。</p><p>在<code>DispatcherServlet</code>的<code>initStrategies()</code>方法中有一堆初始化方法。</p><pre><code class="java">protected void initStrategies(ApplicationContext context) {        initMultipartResolver(context);        initLocaleResolver(context);        initThemeResolver(context);        initHandlerMappings(context);        //这个就是初始化适配器的方法，handlerAdapters就是在这里初始化的        initHandlerAdapters(context);        initHandlerExceptionResolvers(context);        initRequestToViewNameTranslator(context);        initViewResolvers(context);        initFlashMapManager(context);    }</code></pre><p>接着我们看<code>initHandlerAdapters()</code>方法</p><pre><code class="java">private void initHandlerAdapters(ApplicationContext context) {        this.handlerAdapters = null;        //省略...        //如果为null，刚开始当然为null，所以加载handlerAdapters集合        if (this.handlerAdapters == null) {            //关键又在于getDefaultStrategies方法            this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);            if (logger.isDebugEnabled()) {                logger.debug(&quot;No HandlerAdapters found in servlet &#39;&quot; + getServletName() + &quot;&#39;: using default&quot;);            }        }    }</code></pre><p>然后我们又去<code>getDefaultStrategies()</code>方法中看你会发现：</p><pre><code class="java">    protected &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) {        String key = strategyInterface.getName();        //defaultStrategies中获取值，key就是HandlerAdapter.class对象        String value = defaultStrategies.getProperty(key);        //省略...    }</code></pre><p>然后重点就在于这个<code>defaultStrategies</code>对象。我们继续看，很快看到了。</p><pre><code class="java">    //DispatcherServlet.properties文件名    private static final String DEFAULT_STRATEGIES_PATH = &quot;DispatcherServlet.properties&quot;;    //Properties对象，全局变量    private static final Properties defaultStrategies;    static {        try {            ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);            //加载DispatcherServlet.properties文件            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);        }        catch (IOException ex) {            throw new IllegalStateException(&quot;Could not load &#39;&quot; + DEFAULT_STRATEGIES_PATH + &quot;&#39;: &quot; + ex.getMessage());        }    }</code></pre><p>所以明显可以看到所有的适配器类都是写在<code>DispatcherServlet.properties</code>文件里了！默认加载这三种适配器。</p><pre><code class="properties">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\    org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</code></pre><h3 id="得到结论："><a href="#得到结论：" class="headerlink" title="得到结论："></a>得到结论：</h3><p>适配器实现类是从<code>DispatcherServlet.properties</code>文件加载到内存中的。</p><h2 id="HandlerAdapter接口"><a href="#HandlerAdapter接口" class="headerlink" title="HandlerAdapter接口"></a>HandlerAdapter接口</h2><p>所以关键在于<code>HandlerAdapter</code>接口，接口信息如下：</p><pre><code class="java">public interface HandlerAdapter {    //子类去实现，用于判断上级接口    boolean supports(Object handler);    //子类实现这个方法，返回响应的结果    @Nullable    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;    //判断是否使用浏览器缓存，返回-1表示不使用浏览器缓存    long getLastModified(HttpServletRequest request, Object handler);}</code></pre><p>学过策略模式的应该很清楚了，上面讲过有5种方式定义<code>Mapping</code>。</p><p>所以应该可以猜测<code>HandlerAdapter</code>接口有五个子类。打开类图：</p><p><img src="https://static.lovebilibili.com/HandlerAdapter.png" srcset="/img/loading.gif" alt=""></p><p>果然是有五个实现的子类分别对应五种方式！</p><p>那么我们找其中一个实现类，比如最简单的<code>SimpleControllerHandlerAdapter</code>，来分析一下：</p><pre><code class="java">public class SimpleControllerHandlerAdapter implements HandlerAdapter {    @Override    //getHandlerAdapter()方法就会调用这个方法判断，然后返回对应的适配器实现类    //这里返回的就是SimpleControllerHandlerAdapter适配器    public boolean supports(Object handler) {        return (handler instanceof Controller);    }    @Override    @Nullable    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception {        //执行Controller接口的handleRequest，也就是mapping映射的方法        return ((Controller) handler).handleRequest(request, response);    }    //判断是否使用浏览器缓存，返回-1表示不使用浏览器缓存    @Override    public long getLastModified(HttpServletRequest request, Object handler) {        if (handler instanceof LastModified) {            return ((LastModified) handler).getLastModified(request);        }        return -1L;    }}</code></pre><p>下面画一张图来总结一下以上的分析过程：</p><p><img src="https://static.lovebilibili.com/adapterProcessPic.png" srcset="/img/loading.gif" alt=""></p><p>这不就像策略模式吗…只能解释为设计模式有很多都比较类似。假设<code>SpringMVC</code>要增加一种定义<code>Mapping</code>的方式，那就很容易了，增加对应的适配器实现类，对原有的代码没有任何的侵入，这就非常符合开闭原则。接下来我们就对适配器进行扩展，自定义一个适配器。</p><h2 id="自定义SpringMVC适配器"><a href="#自定义SpringMVC适配器" class="headerlink" title="自定义SpringMVC适配器"></a>自定义SpringMVC适配器</h2><p>首先要定义一个适配器<code>MyHandlerAdapter</code>，实现<code>HandlerAdapter</code>接口。</p><pre><code class="java">public class MyHandlerAdapter implements HandlerAdapter {    @Override    public boolean supports(Object handler) {        return handler instanceof MyController;    }    @Override    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        return ((MyController) handler).handleRequest(request, response);    }    @Override    public long getLastModified(HttpServletRequest request, Object handler) {        //不使用浏览器缓存，返回-1        return -1;    }}</code></pre><p>接着定义一个<code>MyController</code>接口。</p><pre><code class="java">public interface MyController {    /**     * 处理请求     */    @Nullable    ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;}</code></pre><p>注册适配器到<code>Spring</code>容器中。</p><pre><code class="java">@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter {    //注册自定义的适配器    @Bean    public MyHandlerAdapter myHandlerAdapter() {        return new MyHandlerAdapter();    }}</code></pre><p>最后创建一个<code>MyTestController</code>实现<code>MyController</code>进行测试。</p><pre><code class="java">@Controller(&quot;/myTest&quot;)public class MyTestController implements MyController {    @Override    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {        response.getWriter().println(&quot;MyTestController Test success!!!&quot;);        return null;    }}</code></pre><p>启动项目，然后在浏览器输入访问地址，即可看到。</p><p><img src="https://static.lovebilibili.com/adapter_test.png" srcset="/img/loading.gif" alt=""></p><p>当你理解透彻之后，你就可以这样自定义一个适配器，来加深一下理解，验证之前的分析的正确性。</p><p>沉下心学习，才能跑得更快！</p><p>以上就是适配器模式的学习，更多的java技术分享，就关注<strong>java技术爱好者</strong>吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次高级java面试</title>
    <link href="/2020/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E7%BA%A7java%E9%9D%A2%E8%AF%95/"/>
    <url>/2020/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E7%BA%A7java%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一次高级JAVA开发面试题目"><a href="#记录一次高级JAVA开发面试题目" class="headerlink" title="记录一次高级JAVA开发面试题目"></a>记录一次高级JAVA开发面试题目</h1><p>面试时间大概40多分钟，问了有十几个问题，回忆一下记录下来，总结经验，以供参考。</p><a id="more"></a><p><strong>1、 static关键字的作用，平时开发用在什么地方？</strong><br>答：主要有三种用法。<br>①修饰成员变量，用static修饰的成员变量就成为静态变量，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。<br>②static修饰方法，该方法就被定义为静态方法，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。<br>③用static修饰代码块，该代码块就被定义为静态代码块，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。</p><p><strong>2、static修饰的成员变量和非static修饰的成员变量有什么区别？分别存在什么区域？</strong><br>答：静态成员变量在内存中只会存在一份，是通过类名访问，存在于静态区中。非静态成员变量是随着对象的创建而存在的，可以有多份，通过创建的对象访问，存在于堆内存中。</p><p><strong>3、说一下类初始化的顺序。</strong><br>答：静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。</p><p><strong>4、常用的集合类型有哪些？</strong><br>答：有Map、Set、List是比较常用的。</p><p><strong>5、List常用的实现类有哪些？ArrayList和LinkedList底层实现原理是什么？</strong><br>答：List常用的实现类有ArrayList和LinkedList。ArrayList底层原理是数组+动态扩容机制实现的，LinkedList底层原理是用Node结点形成的链表实现的。</p><p><strong>6、在开发中如何选择使用ArrayList和LinkedList？</strong><br>答：ArrayList是数组实现，所以通过下标访问效率最快，但是缺点是如果增删比较频繁的情况下，需要经常扩容，性能不是很好。LinkedList在增删的情况下，效率较高，但是访问集合中的元素时都需要从第一个元素开始遍历，效率较低。所以如果增删的情况较多的时候，可以使用LinkedList。查询较多时使用ArrayList。</p><p> <strong>7、List集合如果要排序有哪些实现方式？</strong><br>①使用List接口定义的sort()方法。</p><pre><code class="java">list.sort(Comparator.comparingInt(User::getAge));</code></pre><p>②使用Collections的sort()方法，排序的对象需要实现Comparable接口，重写compareTo()方法。</p><pre><code class="java">//实现Comparable接口public class User implements Comparable&lt;User&gt; {    //重写compareTo方法    @Override    public int compareTo(User user) {            return Integer.compare(this.getAge(), user.getAge());    }}</code></pre><p>使用Collections的sort()方法</p><pre><code class="java">Collections.sort(list);//如果不想实现Comparable接口，也可以使用这个方法Collections.sort(list,Comparator.comparingInt(User::getAge));</code></pre><p>③使用Stream流操作的sort()方法，传入一个Comparator接口。</p><pre><code class="java">list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList());</code></pre><p> <strong>8、ArrayList是线程安全的吗？有什么方式可以让ArrayList变成线程安全的？</strong><br>答：不是线程安全的。<br>使用Collections的synchronizedList()方法包装可获得线程安全的ArrayList。</p><pre><code class="java">List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code></pre><p><strong>9、你是怎么在项目中使用redis的？</strong><br>答：这其实是考了“redis常用的应用场景”这个问题。<br>①利用redis读写速度快的特点，可以做热点数据的储存，降低数据库查询的压力。<br>②利用redis键值设置有效期的特性，做一些限时的业务。比如手机验证码。<br>③利用setnx命令的特性，可以实现分布式锁。</p><p><strong>10、使用Redis实现分布式锁的原理是什么？</strong><br>答： 利用setnx命令的特性。使用setnx一个lockKey字符串作为键，当前的时间+上锁时间作为value。如果返回是0，表示已经被上锁了，需要等待锁持有者释放锁；如果返回1，则表示获得了锁。客户端释放锁的话执行del命令删除lockKey对应的键值。</p><p><strong>11、如果使用分布式锁加锁后，由于一些异常的原因没有执行解锁的操作，怎么办？</strong><br>答：一般解锁操作会放在finally代码块中执行。如果有极端情况下没有执行到解锁的操作，可以通过key对应的时间戳判断是否超时，然后使用GETSET命令去进行解锁，通过判断返回的时间戳是否是超时的key对应的时间戳，确认是否成功上锁。</p><p><strong>12、如果加分布式锁的时候，业务操作时间比较长，造成长时间的阻塞，有什么解决方案？</strong><br>答：可以在加锁时启动一个watch dog(看门狗)线程，每隔10秒检查一下，如果客户端还持有锁则加长lockKey的生存时间。或者可以考虑用zookeeper实现的分布式锁，因为zk实现原理是基于事件监听的方式来实现。</p><p><strong>13、MySQL性能优化的策略有哪些？</strong><br>①复杂的多表查询可以拆成多句简单查询。<br>②返回尽量少的列，按需返回，严禁使用select *。<br>③尽量使用索引列做查询条件和排序条件。<br>④使用复合索引要遵循最左匹配原则。</p><p><strong>14、MySQL索引创建的原则是什么？</strong><br>①对于查询频率高的字段，创建索引。<br>②对排序、分组、联合查询频率高的字段创建索引。<br>③如果多个列都需要设置索引，可以考虑创建复合索引。<br>④尽量选择数据量较少的列作为索引。<br>⑤一个表的索引数量不宜过多，会降低查询的效率。</p><p><strong>15、雪花算法是什么原理？</strong><br>答：使用一个 64 bit 的 long 型的数字作为全局唯一 id。是由时间戳、机房id、机器id、序号组成的。结合了UUID的全局唯一的特点，又具有自增有顺序的特点。</p><p><strong>16、为什么雪花算法生成的主键有字符串类型和long类型两种类型？</strong><br>答：因为后端返回给前端一个long类型时，会有可能产生丢失精度的问题，所以会有字符串的类型，弥补这个问题。</p><p><strong>17、谈一谈MySQL锁机制。</strong><br>主要有以下几种锁：<br>表锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>行锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>在MySQL中只有InnoDB存储引擎可以使用行锁。行锁又分为以下两种形式：<br>读锁(共享锁)：当读取一条数据时，会加上读锁，其他事务如果要读取是可以的，如果要修改则要等事务释放才可以。<br>写锁(排他锁)：这个比较简单，当有一个事务要修改数据时，就会给这些行加上写锁。在加锁期间，不允许其他事务加上任何的锁，只有当这个事务释放了，才可以加锁操作。</p><p>在这次面试中，其实也不是特别难，大部分都回答得不错，但是有两个问题不是很好。雪花算法为什么主键生成有两种类型这个问题没有答出来，还有分布式锁长时间阻塞的解决方案没有详细展开讲。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式在实战中的应用</title>
    <link href="/2020/05/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>比如有些人喜欢写文章，但是如果从头到尾原创的话太麻烦了，那么他可以上网去搜索，找一篇写得不错的文章，然后复制下来，做一些修改，最后发布就是自己的文章了。这其实就使用了原型模式的设计模式，创建一个对象过于麻烦的时候，我们只需要创建一次，后面再创建的话只需要对原对象进行克隆即可。</p><h2 id="不使用原型模式的问题"><a href="#不使用原型模式的问题" class="headerlink" title="不使用原型模式的问题"></a>不使用原型模式的问题</h2><p>假设我们有一个用户<code>User</code>的类，类里面有很多字段，当我们创建对象时，就会像这样子：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setAge(18);        user.setJob(&quot;程序员&quot;);        user.setSchool(&quot;家里蹲大学&quot;);        user.setNation(&quot;汉族&quot;);        //0-男 1-女        user.setGender((byte)0);        user.setPhone(&quot;110&quot;);        user.setPoliticalFeatures(&quot;群众&quot;);        user.setEducation(&quot;大学本科&quot;);        //第二个用户，跟第一个用户只有id，name，phone这三个字段不同        User user1 = new User();        user1.setId(2);        user1.setName(&quot;李四&quot;);        user1.setAge(18);        user1.setJob(&quot;程序员&quot;);        user1.setSchool(&quot;家里蹲大学&quot;);        user1.setNation(&quot;汉族&quot;);        //0-男 1-女        user1.setGender((byte)0);        user1.setPhone(&quot;111&quot;);        user1.setPoliticalFeatures(&quot;群众&quot;);        user1.setEducation(&quot;大学本科&quot;);    }}</code></pre><p>不难看出上面的代码有以下问题：</p><p>1.<code>user</code>对象有10个字段，明显在创建第二个<code>user</code>对象的时候有很多重复的设值的操作。在实际项目中，肯定还不止设置10个字段，那么就会显得很难看。</p><p>2.创建对象如果消耗资源很多的话，这样多次去创建设值肯定会造成资源浪费。</p><p>对于以上的问题，我们可以使用原型模式进行优化。</p><h2 id="使用Cloneable接口优化"><a href="#使用Cloneable接口优化" class="headerlink" title="使用Cloneable接口优化"></a>使用Cloneable接口优化</h2><p><code>java</code>提供了一个<code>Cloneable</code>接口，可以实现克隆对象的用途，怎么实现，请看以下代码：</p><pre><code class="java">//实现Cloneable接口public class User implements Cloneable {    //省略了字段    //省略了字段的Get、Set方法    //重写clone()方法    @Override    public User clone() throws CloneNotSupportedException {        return (User) super.clone();    }}</code></pre><p>然后就可以把<code>main()</code>方法的代码改成以下这样：</p><pre><code class="java">public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setAge(18);        user.setJob(&quot;程序员&quot;);        user.setSchool(&quot;家里蹲大学&quot;);        user.setNation(&quot;汉族&quot;);        //0-男 1-女        user.setGender((byte)0);        user.setPhone(&quot;110&quot;);        user.setPoliticalFeatures(&quot;群众&quot;);        user.setEducation(&quot;大学本科&quot;);        //调用克隆方法，复制第一个user对象        User user1 = user.clone();        user1.setId(2);        user1.setName(&quot;李四&quot;);        user1.setPhone(&quot;111&quot;);        System.out.println(user1);        //控制台打印结果        //User{id=2, name=&#39;李四&#39;, phone=&#39;111&#39;, nation=&#39;汉族&#39;...}}</code></pre><p>你是不是有疑问，这两个<code>user</code>对象内存地址是否一致呢？我们可以打印出来看看：</p><pre><code class="java">com.yehongzhi.httpclient.model.User@4c873330com.yehongzhi.httpclient.model.User@119d7047</code></pre><p>内存地址是不一样的，所以我们可以得出一个结论：<strong>克隆出来的对象是一个新的对象。</strong></p><p><strong>问题：</strong>克隆方法的底层是不是调用了构造器创建了一个对象的呢？</p><p>我们可以在构造器上面加一些打印语句来验证一下：</p><pre><code class="java">public class User implements Cloneable {    //其他非重点代码省略    //构造器，如果以下语句打印了两次，则证明clone调用了构造器创建对象    public User() {        System.out.println(&quot;调用了无参构造器&quot;);    }    //克隆方法    @Override    public User clone() throws CloneNotSupportedException {        System.out.println(&quot;调用了clone()方法&quot;);        return (User) super.clone();    }}</code></pre><p>我们运行<code>main()</code>方法后，可以看到控制台打印信息如下：</p><pre><code class="java">// 调用了无参构造器// 调用了clone()方法</code></pre><p>只调用了一次构造器，我们可以得出结论：</p><blockquote><p>clone()方法不是调用了构造器创建对象的。</p></blockquote><p>如果你刨根究底，究竟clone()方法是怎么创建对象的，其实也很简单，打开源码：</p><pre><code class="java">public class Object {    private static native void registerNatives();    static {        registerNatives();    }    //最终会调用Object的克隆方法，是一个native修饰的方法    protected native Object clone() throws CloneNotSupportedException;}</code></pre><p>native修饰的方法是什么意思呢？意思就是这个方法的实现不是用<code>java</code>，而是<code>C/C++</code>实现。这个native关键字我们可以单独写一篇文章细讲，这里就不深入展开。底层的实现逻辑就是拷贝一份数据，开辟一块新的内存。所以拷贝出来的对象，打印的内存地址和原来的对象不一样。</p><h2 id="使用Cloneable接口的问题"><a href="#使用Cloneable接口的问题" class="headerlink" title="使用Cloneable接口的问题"></a>使用Cloneable接口的问题</h2><p>使用<code>Cloneable</code>接口是不是就完美的呢，其实并不是，因为如果一个对象的字段也是一个对象，是一个引用数据类型时，那就会有问题。请看以下代码：</p><p>我们增加一个对象<code>IdCard</code>类</p><pre><code class="java">public class IdCard {    private String cardNo;    private Integer validityPeriod;    private Date createDate;    //省略getter、setter方法}</code></pre><pre><code class="java">public class User implements Cloneable {    //其他字段省略    //身份证对象    private IdCard idCard;    //省略getter、setter方法}</code></pre><p>然后我们在<code>main()</code>方法赋值：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        //省略其他字段的赋值        //创建一个IdCard对象        IdCard idCard = new IdCard();        //身份证号码        idCard.setCardNo(&quot;111111&quot;);        //创建日期        idCard.setCreateDate(new Date());        //身份证有效期        idCard.setValidityPeriod(10);        //user对象设置身份证对象        user.setIdCard(idCard);        //user克隆，得到user1        User user1 = user.clone();        //打印user、user1的IdCard对象的内存地址，内存地址一样！        System.out.println(user.getIdCard());//IdCard@4c873330        System.out.println(user1.getIdCard());//IdCard@4c873330        //当改变克隆体user1的IdCard里面的字段值        user1.getIdCard().setCardNo(&quot;222222&quot;);        //源对象user的IdCard里面的字段值也跟着一起改变了        System.out.println(user.getIdCard().getCardNo());//222222    }}</code></pre><p>明显这样的克隆是有巨大的问题的，因为项目中不可能只有基本数据类型。那怎么解决呢？</p><pre><code class="java">//IdCard对象也要实现Cloneable接口public class IdCard implements Cloneable{    //也需要重写clone()方法    @Override    protected IdCard clone() throws CloneNotSupportedException {        return (IdCard)super.clone();    }}</code></pre><pre><code class="java">public class User implements Cloneable {    @Override    public User clone() throws CloneNotSupportedException {        User user = (User) super.clone();        //获取idCard源对象        IdCard idCard = user.getIdCard();        //克隆一个idCard对象。然后set值到user对象中        user.setIdCard(idCard.clone());        return user;    }}</code></pre><p>最后我们再调用<code>main()</code>方法：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        //创建一个IdCard对象        IdCard idCard = new IdCard();        //身份证号码        idCard.setCardNo(&quot;111111&quot;);        //user对象设置身份证对象        user.setIdCard(idCard);        //克隆user对象，得到user1对象        User user1 = user.clone();        //打印user、user1的IdCard对象的内存地址，内存地址不一样了！        System.out.println(user.getIdCard());//IdCard@4c873330        System.out.println(user1.getIdCard());//IdCard@119d7047        //当改变克隆体user1的IdCard里面的字段值        user1.getIdCard().setCardNo(&quot;222222&quot;);        //源对象user的IdCard里面的字段值也跟着一起改变了        System.out.println(user.getIdCard().getCardNo());//111111    }}</code></pre><h2 id="使用序列化实现深克隆"><a href="#使用序列化实现深克隆" class="headerlink" title="使用序列化实现深克隆"></a>使用序列化实现深克隆</h2><p>上面使用<code>Cloneable</code>接口的方式，被称为浅克隆，如果你想要克隆的源对象里面又有对象时，里面的对象也要实现<code>Cloneable</code>接口，然后修改源对象的<code>clone()</code>方法，这样就非常麻烦，而且当扩展时会破坏开闭原则。</p><p>解决方法，我们可以采用序列化对象的方式，实现深克隆呢？请看以下代码：</p><p><code>User</code>对象实现<code>Serializable</code>接口:</p><pre><code class="java">public class User implements Serializable {    private static final long serialVersionUID = 8656071024384993135L;}</code></pre><p><code>IdCard</code>对象实现<code>Serializable</code>接口：</p><pre><code class="java">public class IdCard implements Serializable {    private static final long serialVersionUID = -422430076410272813L;}</code></pre><p>创建一个工具类<code>CloneUtil</code>实现深克隆：</p><pre><code class="java">public class CloneUtil {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T&gt; T depthClone(T t, Class&lt;T&gt; clazz) throws Exception {        ByteArrayOutputStream baos = null;        ObjectOutputStream ous = null;        ByteArrayInputStream bais = null;        ObjectInputStream ois = null;        try {            //将源对象序列化，写入流中，写入流的对象是一个拷贝的对象，原对象还在JVM中            baos = new ByteArrayOutputStream();            ous = new ObjectOutputStream(baos);            ous.writeObject(t);            //把流中的对象再读取到内存中，就获得了克隆后的对象            bais = new ByteArrayInputStream(baos.toByteArray());            ois = new ObjectInputStream(bais);            return (T) ois.readObject();        } catch (Exception e) {            e.printStackTrace();            throw new RuntimeException(&quot;深克隆出现异常&quot;);        } finally {            if (ous != null) {ous.close();}            if (baos != null) {baos.close();}            if (bais != null) {bais.close();}            if (ois != null) {ois.close();}        }    }}</code></pre><p>验证是否深克隆，在<code>main()</code>方法中打印内存地址查看即可：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        User user = new User();        user.setIdCard(new IdCard());        User user1 = CloneUtil.depthClone(user, User.class);        //内存地址都不相同，达到了深克隆的效果        System.out.println(user);//User@3d075dc0        System.out.println(user1);//User@2ef1e4fa        System.out.println(user.getIdCard());//IdCard@214c265e        System.out.println(user1.getIdCard());//IdCard@306a30c7    }}</code></pre><p>用序列化实现深克隆的优点就是，对源代码侵入性很低，只需要实现<code>Serializable</code>接口，不需要一层一层去实现<code>Cloneable</code>接口，还有重写<code>clone()</code>方法。</p><p><strong>问题：</strong>如果这个实体类是在<code>jar</code>包中的呢，我们没法去修改实体类的代码，那怎么实现克隆呢？</p><h2 id="使用反射实现克隆"><a href="#使用反射实现克隆" class="headerlink" title="使用反射实现克隆"></a>使用反射实现克隆</h2><p>利用反射，实际上我们可以拿到源对象的任何值，所以就可以实现克隆，请看以下代码：</p><p>我们创建一个<code>copyProperties()</code>方法，具体实现看以下代码：</p><pre><code class="java">public class CloneUtil {    public static void copyProperties(Object source, Object target) throws Exception {        //获取源对象的属性描述器        PropertyDescriptor[] sourceDescriptors = Introspector                .getBeanInfo(source.getClass())                .getPropertyDescriptors();        //获取目标对象的字段名称集合        List&lt;String&gt; targetFieldNames = Arrays                .stream(target.getClass().getDeclaredFields())                .map(Field::getName)                .collect(Collectors.toList());        for (PropertyDescriptor sourceProperty : sourceDescriptors) {            //获取源对象的属性名称            String name = sourceProperty.getName();            //源对象的getter方法            Method readMethod = sourceProperty.getReadMethod();            if (!readMethod.isAccessible()) {                //设置方法的可访问权限                readMethod.setAccessible(true);            }            //调用源对象的getter方法，获取到里面的每一个值            Object value = readMethod.invoke(source);            //如果源对象的属性名称包含在目标对象的字段名称集合中            if (targetFieldNames.contains(name)) {                //则通过源对象的属性名称获取目标对象属性的属性描述器                PropertyDescriptor propertyDescriptor = new PropertyDescriptor(name, target.getClass());                //获取目标对象的setter方法                Method writeMethod = propertyDescriptor.getWriteMethod();                writeMethod.setAccessible(true);                //执行setter方法，参数是从源对象getter方法获取到的值                writeMethod.invoke(target, value);            }        }    }}</code></pre><p>测试：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setIdCard(new IdCard());        User user1 = new User();        CloneUtil.copyProperties(user, user1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三        System.out.println(user.getIdCard());//IdCard@b81eda8        System.out.println(user1.getIdCard());//IdCard@b81eda8    }</code></pre><p>这样实现的不是深克隆的效果，所以<code>IdCard</code>对象的内存地址还是一样的。为了避免这样的结果，我们可以在使用时注意一下：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setName(&quot;张三&quot;);        IdCard idCard = new IdCard();        user.setIdCard(idCard);        User user1 = new User();        //创建一个新的IdCard对象        IdCard idCard1 = new IdCard();        CloneUtil.copyProperties(user, user1);        //复制idCard的值到idCard1里        CloneUtil.copyProperties(idCard,idCard1);        //再设置idCard1到user1中        user1.setIdCard(idCard1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三        System.out.println(user.getIdCard());//IdCard@68de145        //内存地址不同        System.out.println(user1.getIdCard());//IdCard@27fa135a    }</code></pre><p>这样就避免产生内存地址一样的情况了。</p><h2 id="Spring的copyProperties"><a href="#Spring的copyProperties" class="headerlink" title="Spring的copyProperties()"></a>Spring的copyProperties()</h2><p>实际上在<code>Spring</code>框架中，已经提供了<code>copyProperties()</code>方法：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setName(&quot;张三&quot;);        User user1 = new User();        //Spring的copyProperties()方法        BeanUtils.copyProperties(user,user1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三    }</code></pre><p>一般在实际项目中，我们采用<code>copyProperties()</code>方法实现原型模式会更好，因为这样不会破坏开闭原则，即使是<code>jar</code>包中定义的实体类，也可以使用。缺点就是如果对象层级比较多的话，会比较麻烦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现原型模式的三种方式：实现<code>Cloneable</code>接口、序列化对象、反射机制。</p><p>原型模式的优点：</p><ol><li>提高了创建对象的性能，避免了调用构造器创建对象。</li><li>对于创建一个对象需要很多资源的情况，可以减少资源的浪费。</li></ol><p>原型模式的缺点：</p><ol><li>如果使用<code>Cloneable</code>接口的方式，需要实现<code>Cloneable</code>接口，对代码有一定的侵入性。</li><li>如果使用序列化方式，则需要实现<code>Serializable</code>接口，对代码也有一定的侵入性。</li><li>如果使用反射机制，层级较多时会比较难维护。</li></ol><p>以上就是原型模式的学习，更多的java技术分享，就关注<strong>java技术爱好者</strong>吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰者模式与IO流</title>
    <link href="/2020/05/04/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8EIO%E6%B5%81/"/>
    <url>/2020/05/04/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8EIO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>装饰者模式是一种<strong>对象结构型</strong>模式。<strong>动态</strong>地给一个对象添加一些<strong>额外的</strong>职责，就增加功能来说，装饰者模式比生成子类更为灵活。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>上面的定义在网上是随处可见的描述，怎么解释呢。比如：我前几天和女朋友去买戒指，珠宝店的销售给我推荐了一种<strong>自由搭配</strong>的原创戒指。他跟我介绍戒指的元素需要选择材质(黄金，铂金，彩金)、表面工艺(拉丝，磨砂，光滑，铸造)、镶钻(内嵌，外嵌)、指环大小等等，然后组成一个戒指。这种就是装饰者模式的应用，原型是一个戒指，不断地给对象添加额外的职责，然后得到最终想要的产品。这样就可以通过不同的搭配产生很多不同类型的戒指。</p><p>后面那句<strong>装饰者模式比生成子类更为灵活</strong>怎么理解。如果用子类去描述的话，要把每一种搭配的结果都变成一个子类，也就是要穷举，就会产生很多子类，也就是造成<strong>“类爆炸”</strong>。所以就会说装饰者模式更加灵活。</p><h2 id="来个例子"><a href="#来个例子" class="headerlink" title="来个例子"></a>来个例子</h2><p>现在有一个需求，要求做一个加密的工具类，对传入的字符串加密。加密的算法有很多，有<strong>MD5、AES、DES等等</strong>，一般加密都不是单独使用一种加密算法，而是多种混合一起使用，这样可以提高安全性。</p><p>现在有三种算法：<code>MD5、AES、DES</code>。做一个工具类，给系统提供加密的服务，要求可以自由搭配使用。</p><h2 id="使用继承的方式实现"><a href="#使用继承的方式实现" class="headerlink" title="使用继承的方式实现"></a>使用继承的方式实现</h2><p>我们就创建一个抽象类<code>EncryptionBase</code>，每一种组合方式就创建一个子类继承<code>EncryptionBase</code>，现在有三种加密方式，很容易我们可以穷举完，总共有6种组合。请看以下代码：</p><p>首先创建一个抽象类<code>EncryptionBase</code>：</p><pre><code class="java">public abstract class EncryptionBase {    public abstract String encrypt(String string,String password);}</code></pre><p>接着创建子类继承抽象类，并且实现其方法。以其中一个为例，其他实现类都类似：</p><pre><code class="java">public class AESandDESandMD5Encryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        //网上可以找具体加密的代码，我这里篇幅受限就不展示了        //AES加密        byte[] encryptByAES = AESUtil.encrypt(string, password);        //DES加密        byte[] encryptByDES = DESUtil.encrypt(encryptByAES, password);        //MD5加密        return MD5Util.encryptByMD5(new String(encryptByDES) + password);    }}</code></pre><p>我们就可以实现以下效果，有6个实现类分别实现了3种加密算法的不同顺序。</p><pre><code class="java">public static void main(String[] args) {        String string = &quot;需要加密的字符串&quot;;        //秘钥        String password = &quot;12345678&quot;;        //第一种加密顺序：AES-&gt;DES-&gt;MD5        EncryptionBase AESandDESandMD5 = new AESandDESandMD5Encryption();        //第二种加密顺序：AES-&gt;MD5-&gt;DES        EncryptionBase AESandMD5andDES = new AESandMD5andDESEncryption();        //第三种加密顺序：DES-&gt;AES-&gt;MD5        EncryptionBase DESandAESandMD5 = new DESandAESandMD5Encryption();        //第四种加密顺序：DES-&gt;MD5-&gt;AES        EncryptionBase DESandMD5andAES = new DESandMD5andAESEncryption();        //第五种加密顺序：MD5-&gt;DES-&gt;AES        EncryptionBase MD5andDESandAES = new MD5andDESandAESEncryption();        //第六种加密顺序：MD5-&gt;AES-&gt;DES        EncryptionBase MD5andAESandDES = new MD5andAESandDESEncryption();    }</code></pre><p>以上就是使用继承的方式来完成这个需求。看起来没什么问题，但是仔细思考你会发现几个问题。</p><ol><li><strong>会创建很多子类。</strong>为什么3种算法是6个类呢？这是根据数学的排列组合<code>3*2*1=6</code>，假设再多两种算法呢？那就是<code>5*4*3*2*1=120</code>，那就是120个类了！这就是<strong>“类爆炸”</strong>。</li><li><strong>不符合开闭原则。</strong>假设增加了新的算法，那就要修改原来的类，不利于代码的维护。</li><li>假如其中一种加密算法要用两次，比如双重<code>MD5</code>加密，那也是很难扩展的。</li></ol><p>如果你不会装饰者模式，那估计要加班加点去写代码，创建很多类。如果你会装饰者模式，那问题就很简单了，那怎么做呢？请继续看下去。</p><h2 id="使用装饰者模式实现"><a href="#使用装饰者模式实现" class="headerlink" title="使用装饰者模式实现"></a>使用装饰者模式实现</h2><p>首先创建三种算法的基础类，继承<code>EncryptionBase</code>，实现三种加密算法。</p><p>MD5加密</p><pre><code class="java">public class MD5Encryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用MD5加密，得到基础密文&quot;);        return MD5Util.encryptByMD5(string + password);    }}</code></pre><p>AES加密</p><pre><code class="java">public class AESEncryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用AES加密，得到基础密文&quot;);        return new String(AESUtil.encrypt(string, password));    }}</code></pre><p>DES加密</p><pre><code class="java">public class DESEncryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用DES加密，得到基础密文&quot;);        return new String(DESUtil.encrypt(string.getBytes(), password));    }}</code></pre><p>接着创建一个装饰抽象类<code>EncryptionDecorator</code>，需要继承<code>EncryptionBase</code></p><pre><code class="java">public abstract class EncryptionDecorator extends EncryptionBase {    //定义一个父类的成员变量，用来存储其他装饰类，或者基础加密类    private EncryptionBase encryption;    public EncryptionDecorator(EncryptionBase encryption) {        this.encryption = encryption;    }    @Override    public String encrypt(String string, String password) throws Exception{        return encryption.encrypt(string, password);    }}</code></pre><p>然后实现三种加密的装饰者实现类，需要继承抽象装饰者类<code>EncryptionDecorator</code>。</p><p>MD5加密装饰者实现类<code>MD5EncryptionDecorator</code></p><pre><code class="java">public class MD5EncryptionDecorator extends EncryptionDecorator {    public MD5EncryptionDecorator(EncryptionBase encryption) {        //有参构造器获取到参数，调用父类的有参构造器，        //当下面encrypt()方法里调用父类的加密算法就会调用传入的算法实现类的加密算法        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用MD5加密&quot;);        //得到的密文，再用MD5算法加密，返回        return MD5Util.encryptByMD5(encrypt + password);    }}</code></pre><p>AES加密装饰者实现类<code>AESEncryptionDecorator</code></p><pre><code class="java">public class AESEncryptionDecorator extends EncryptionDecorator {    public AESEncryptionDecorator(EncryptionBase encryption) {        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用AES加密&quot;);        //得到的密文，再用AES算法加密，返回        return new String(AESUtil.encrypt(encrypt, password),&quot;UTF-8&quot;);    }}</code></pre><p>DES加密装饰者实现类<code>DESEncryptionDecorator</code></p><pre><code class="java">public class DESEncryptionDecorator extends EncryptionDecorator {    public DESEncryptionDecorator(EncryptionBase encryption) {        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用DES加密&quot;);        //得到的密文，再用DES算法加密，返回        return new String(DESUtil.encrypt(encrypt.getBytes(), password),&quot;UTF-8&quot;);    }}</code></pre><p>大功告成！我们用<code>main()</code>方法测试一下：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception{        String string = &quot;需要加密的字符串&quot;;        String password = &quot;12345678&quot;;        //第一种加密顺序：AES-&gt;DES-&gt;MD5        EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption()));        encryptionBase.encrypt(string, password);    }}</code></pre><p>控制台打印结果：</p><pre><code class="java">/**使用AES加密，得到基础密文使用DES加密使用MD5加密*/</code></pre><p>我们可以看到结果是很完美地实现了，你可以任意搭配加密算法，即使加多N种算法，我们也不会呈指数增加类的数量，只需要增加M*N个类即可，M是基础构件数量，N是具体装饰类数量。</p><p>原理是什么呢？我们不能说只学到形式，而不明白原理。接下来看类图。</p><p>在IDEA可以选中类名，然后右键，选中“Diagrams”，再选中“show Diagrams…”，就可以打开类图。</p><img src="https://static.lovebilibili.com/MD5EncryptionDecorator.png" srcset="/img/loading.gif"/><pre><code class="java">//MD5(DES(AES))，最顶层的父类是AES，所以先执行，第二层是DES，第二执行，最外层是MD5第三执行EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption()));encryptionBase.encrypt(string, password);</code></pre><p>以上面这句代码为例，那么调用顺序就是：AES-&gt;DES-&gt;MD5</p><img src="https://static.lovebilibili.com/decorator1.png" srcset="/img/loading.gif" style="width:100%;"/><p>这就是装饰者模式的原理，其实很简单的，很容易就可以看清楚。</p><h2 id="装饰者模式与I-O流"><a href="#装饰者模式与I-O流" class="headerlink" title="装饰者模式与I/O流"></a>装饰者模式与I/O流</h2><p>看了上面的代码，很容易我们能联想到IO流也有类似的创建方式，比如我们要用文件缓冲输入流，那就要这样创建：</p><pre><code class="java">InputStream inputStream     = new BufferedInputStream(new FileInputStream(new File(&quot;/D:abc.text&quot;)));</code></pre><p>可以看出IO流使用了装饰者模式。</p><p>如果我们打开源码，查看<code>BufferedInputStream</code>，我们可以看到：</p><pre><code class="java">public class BufferedInputStream extends FilterInputStream {    //有参构造器    public BufferedInputStream(InputStream in, int size) {        //调用父类构造器，这是关键        //通过上面我们学过的例子，可以知道BufferedInputStream是装饰实现类        super(in);        if (size &lt;= 0) {            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);        }        buf = new byte[size];    }}</code></pre><p>关键在<code>FilterInputStream</code>这个类，这是装饰者模式的基类。查看源码：</p><pre><code class="java">public class FilterInputStream extends InputStream {    /**     * The input stream to be filtered.     */    protected volatile InputStream in;    protected FilterInputStream(InputStream in) {        this.in = in;    }    public int read() throws IOException {        return in.read();    }}</code></pre><p><code>FilterInputStream</code>类似于加密算法例子的<code>EncryptionDecorator</code>类。我们可以通过加密算法的例子和这个作对比，就可以很容易地看出他们的关系。类图如下：</p><img src="https://static.lovebilibili.com/FilterInputStream.png" srcset="/img/loading.gif" style="width:100%;"/><p><code>FileInputStream</code>就是基础构件类，可以通过<code>FilterInputStream</code>的子类去做扩展，增加额外的功能，比如可以使用<code>BufferedInputStream</code>增加缓冲的作用。</p><p>接着我们真正理解了IO流的装饰者模式的应用后，我们可以写一个扩展类，实现一个功能：读取磁盘的文件，把所有字母变成大写的字母。代码如下：</p><pre><code class="java">public class CapitalizaInputStream extends FilterInputStream {    public CapitalizaInputStream(InputStream in) {        super(in);    }    @Override    public int read(byte[] b, int off, int len) throws IOException {        int result = super.read(b, off, len);        for (int i = off; i &lt; off + result; i++){            //如果是小写字母，转成大写，其他不是小写字母的不变            if(Character.isLetter((char)b[i])){                b[i] = (byte) Character.toUpperCase((char) b[i]);            }        }        return result;    }}</code></pre><p>abc.txt文件内容：</p><pre><code class="yaml">abcdefghijklmnopqrstuvwxyz</code></pre><p>Main方法测试代码：</p><pre><code class="java">public static void main(String[] args) throws Exception {        InputStream inputStream             = new CapitalizaInputStream(new FileInputStream(new File(&quot;D://abc.txt&quot;)));        byte[] bytes = new byte[1024 * 2];        int c;        while ((c = inputStream.read(bytes, 0, bytes.length)) != -1) {            System.out.println(new String(bytes, 0, c));        }        inputStream.close();    }</code></pre><p>控制台打印结果：</p><pre><code class="yaml">ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre><p>以上就是IO流关于装饰者模式的扩展，能够加深我们对装饰者模式的理解。很多博客写不清楚，讲得很复杂，或者讲得很简单，很大原因是我们只看，而没有动手去做，动手去自己写，自己琢磨，就很容易能理解。这是学习方法，不是关注了公众号，看几篇文章就能轻松学会的，学习总是要自己动手才会理解深刻。看我的文章可以提供一些思路，更容易去上手。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰者模式的优点：</p><ol><li>可以动态地扩展类的功能，不会相互耦合。</li><li>符合开闭原则，利于代码维护。</li><li>比继承扩展的方式要更加灵活。</li></ol><p>缺点：多层装饰，代码结构变得复杂。</p><p>更多的java技术分享，就关注java技术爱好者吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式以及实际项目应用</title>
    <link href="/2020/05/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式（Observer），又叫<strong>发布-订阅模式（Publish/Subscribe）</strong>，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>比如我们在宿舍打斗地主，我们要找个人来“放风”，这个人在门口观察，如果有宿管过了检查，那么就通知宿舍其他的小伙伴停止斗地主回床上睡觉。这种模式就被称为观察者模式。</p><p>从这个例子看，“宿管是否过来宿舍”是订阅的主题，观察者是放风的人，订阅者是打斗地主的小伙伴，被观察者就是宿管。</p><h2 id="不使用观察者模式的问题"><a href="#不使用观察者模式的问题" class="headerlink" title="不使用观察者模式的问题"></a>不使用观察者模式的问题</h2><p>假设我们基于之前在策略模式讲的电子支付的例子，支付完成后要发送消息，发送的消息有：短信，公众号消息，APP站内消息，邮箱。如果不使用观察者模式，怎么做呢？看代码：</p><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        //发送短信        System.out.println(&quot;发送短信：&quot;+msg);        //发送微信公众号消息        System.out.println(&quot;发送微信公众号消息：&quot;+msg);        //发送邮件        System.out.println(&quot;发送邮件：&quot;+msg);        //发送APP系统信息        System.out.println(&quot;发送APP系统信息：&quot;+msg);        return msg;    }</code></pre><p>启动项目是没有问题的，我们调用接口后可以看到控制台打印以下信息：</p><pre><code class="java">/**发送短信：使用 支付宝支付 ,消费了 100 元发送微信公众号消息：使用 支付宝支付 ,消费了 100 元发送邮件：使用 支付宝支付 ,消费了 100 元发送APP系统信息：使用 支付宝支付 ,消费了 100 元*/</code></pre><p><strong>但是我们很明显可以看出有以下的问题：</strong></p><ul><li>每次支付如果需要新增一种消息通知方式，则要修改原来的类，不利于维护。</li><li>违反了开闭原则，对拓展开放，对修改关闭。</li><li>违反了单一职责原则，支付不应该糅杂消息通知的功能。</li></ul><p>上面就从代码演示了为什么要使用观察者模式，很多文章说不清楚，单纯地抛出一个概念和一些简单的例子，实际项目中肯定是没有那么简单。</p><h2 id="使用观察者模式优化"><a href="#使用观察者模式优化" class="headerlink" title="使用观察者模式优化"></a>使用观察者模式优化</h2><p>这里的话，我不使用<code>java</code>自带的<code>Observer</code>和<code>Observable</code>来做，因为实际项目中一般都会使用<code>Spring</code>框架，<code>Spring</code>框架有一个事件机制，也是使用观察者模式的这种设计模式，而且在实际项目中我们往往会采用这种成熟度更高的框架，就像代理模式我们也很少会直接使用原生的<code>JDK动态代理</code>，而是采用<code>SpringAOP</code>来实现。</p><h2 id="创建支付的事件"><a href="#创建支付的事件" class="headerlink" title="创建支付的事件"></a>创建支付的事件</h2><pre><code class="java">//继承ApplicationEvent类public class PayEvent extends ApplicationEvent {    //消息体    private Map&lt;String,String&gt; map;    //订阅主题    private String topic;    public PayEvent(Object source, Map&lt;String, String&gt; map, String topic) {        //调用父类的构造器        super(source);        this.map = map;        this.topic = topic;    }    public Map&lt;String, String&gt; getMap() {        return map;    }    public void setMap(Map&lt;String, String&gt; map) {        this.map = map;    }    public String getTopic() {        return topic;    }    public void setTopic(String topic) {        this.topic = topic;    }}</code></pre><h2 id="创建事件监听类"><a href="#创建事件监听类" class="headerlink" title="创建事件监听类"></a>创建事件监听类</h2><pre><code class="java">//短信监听，实现ApplicationListener接口，重写onApplicationEvent()方法@Componentpublic class SmsListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        //订阅主题        String topic = payEvent.getTopic();        //消息体        Map&lt;String, String&gt; map = payEvent.getMap();        //发送短信        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送短信:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//公众号监听@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//邮箱监听@Componentpublic class MailListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送邮件:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//App站内消息监听@Componentpublic class AppListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送App站内消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><h2 id="重构PayServiceImpl类"><a href="#重构PayServiceImpl类" class="headerlink" title="重构PayServiceImpl类"></a>重构PayServiceImpl类</h2><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,msg);        //创建一个支付事件        PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;);        //获取Spring的ApplicationContext容器，发布事件，监听类监听到事件后就会发送消息        SpringContextUtil.getApplicationContext().publishEvent(payEvent);        return msg;    }</code></pre><p>然后我们启动项目，调用接口，控制台就可以打印的信息：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送公众号消息:使用 支付宝支付 ,消费了 100 元*/</code></pre><h2 id="异步监听事件，实现解耦"><a href="#异步监听事件，实现解耦" class="headerlink" title="异步监听事件，实现解耦"></a>异步监听事件，实现解耦</h2><p>改造之后是否就一劳永逸了呢，实际上并非如此。因为上面的消息发送的监听类是同步的，也就是如果发送消息出现异常，那就会导致支付的接口无法正常返回。请看以下代码：</p><pre><code class="java">@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        //在发送微信公众号消息的逻辑中制造异常        System.out.println(10 / 0);        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,msg);        //创建一个支付事件        PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;);        //获取Spring的ApplicationContext容器，发布事件        SpringContextUtil.getApplicationContext().publishEvent(payEvent);        //发送消息后的逻辑，打印日志到控制台        System.out.println(&quot;发送消息后的逻辑代码...&quot;);        return msg;    }</code></pre><p>我们在发送公众号消息的逻辑里制造了一个异常，然后在<code>pay()</code>方法中加了一个打印日志在发布支付的事件后面，接下来调用接口，结果是：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/</code></pre><p>发送消息后的逻辑是没有被执行。这样显然是不符合业务要求的，因为在很多时候，发送消息失败是不能影响支付流程的，应该异步进行。怎么异步进行发送消息呢？</p><p>很简单，只需要两个步骤。</p><p><strong>第一步</strong>:在监听类或者方法上添加<code>@Async</code>注解，例如：</p><pre><code class="java">@Component@Async//加上异步执行的注解public class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(10 / 0);        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><p><strong>第二步</strong>：在<code>SpringBoot</code>启动类上添加<code>@EnableAsync</code>注解，例如：</p><pre><code class="java">@SpringBootApplication@EnableAsync//添加启用异步的注解public class StrategyApplication {    public static void main(String[] args) {        SpringApplication.run(StrategyApplication.class, args);    }}</code></pre><p>然后就可以实现异步监听了，调用接口，我们可以看到控制台打印的日志如下：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元发送消息后的逻辑代码...使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/</code></pre><p>明显可以看到支付后的逻辑也能正常执行下去，证明实现了异步监听！</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在<code>Spring</code>里提供了许多的监听器，这里只是介绍了其中一种。</p><p>还有一种叫<code>SpringApplicationRunListener</code>也是很常用的监听器，可以监听<code>SpringBoot</code>项目启动的事件，用于在启动项目时加载一些配置。</p><p>还有一种叫<code>SmartApplicationListener</code>，这种监听器可以设置优先级。假设发送消息需要按顺序先发送短信，再发送公众号，再发送邮箱…，那就可以使用这种监听器实现，这里就不多做介绍了，小伙伴有兴趣的话，我可以再写一篇文章详细介绍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过重构之后，我们可以明显看到，如果以后要增加一种新的消息通知方式，是不需要修改<code>PayServiceImpl</code>的，我们只需要再增加一个监听类即可，这就符合了<code>开闭原则</code>。有利于代码的维护。而且最重要是解耦，支付的业务逻辑和发送消息的业务逻辑不会再糅合在一起了，符合<code>职责单一</code>原则。</p><p>在很多框架中，观察者模式都有应用，对于学习很多例如<code>zookeeper</code>、<code>消息中间件</code>、<code>微服务注册中心</code>等知识是有很大帮助的。在实际项目中，观察者模式也是一种很常用的设计模式。比如有一种业务场景，通讯录的部门里有员工离职，需要通知其他依赖于通讯录的应用都要同步部门的员工，那就可以使用这种方式来实现。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你用构建者(生成器)模式优雅地创建对象</title>
    <link href="/2020/04/27/%E6%95%99%E4%BD%A0%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85-%E7%94%9F%E6%88%90%E5%99%A8-%E6%A8%A1%E5%BC%8F%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/04/27/%E6%95%99%E4%BD%A0%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85-%E7%94%9F%E6%88%90%E5%99%A8-%E6%A8%A1%E5%BC%8F%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要用构建者模式"><a href="#为什么要用构建者模式" class="headerlink" title="为什么要用构建者模式"></a>为什么要用构建者模式</h1><p>很多博客文章上来就先抛出一个定义，我们不妨反过来问一句为什么要用构建者模式。<br>首先我们创建一个<code>User</code>类，然后采用有参构造器的方式创建对象。</p><pre><code class="java">public class User {    private String id;    private String name;    private String gender;    private String address;    private Integer age;    private String phone;    //省略无参构造器，有参构造器，getter，setter方法...}</code></pre><pre><code class="java">public static void main(String[] args) throws Exception {    String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);    User user = new User(id, &quot;张三&quot;, &quot;男&quot;, &quot;广州天河&quot;, 20, &quot;135461852xx&quot;);}</code></pre><p>我们通过有参构造器创建对象，并且赋值，看起来没什么问题，因为我们经常看到有人是这样写的。<br>事实上，如果<code>User</code>对象里面有更多的字段，通过有参构造器去创建对象是很难一眼看出字段具体是什么意思，我们经常要看着<code>User构造器</code>的代码，然后对照顺序才能看出字段的代表什么意思。</p><pre><code class="java">public User(String id, String name, String gender, String address, Integer age, String phone) {    this.id = id;    this.name = name;    this.gender = gender;    this.address = address;    this.age = age;    this.phone = phone;}</code></pre><p>比如通过上面这个，我们可以知道第一个参数是id，第二个参数是名字，第三个是性别…</p><h2 id="使用有参构造器的缺点："><a href="#使用有参构造器的缺点：" class="headerlink" title="使用有参构造器的缺点："></a>使用有参构造器的缺点：</h2><p>这显然不利于代码的维护性，对于不熟悉业务的新入职的员工，如果看到这种方式构建一个对象，估计要看上一会，有些项目我遇过一个构造器十几个参数的，更加离谱。而且一般老代码还不敢乱动他的这个构造器，一不小心你动了构造器里面的一个参数的顺序，直接GG；或者你在他原有的构造器后面加多一个参数，你会发现他很多地方都引用了这个有参构造器，你很多地方都要去修改，是真的恶心。</p><h2 id="解决方法一-使用无参构造器，通过setter方法设置属性值"><a href="#解决方法一-使用无参构造器，通过setter方法设置属性值" class="headerlink" title="解决方法一 使用无参构造器，通过setter方法设置属性值"></a>解决方法一 使用无参构造器，通过setter方法设置属性值</h2><pre><code class="java">public static void main(String[] args) throws Exception {    User user = new User();    user.setId(UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;));    user.setName(&quot;张三&quot;);    user.setAge(20);    user.setGender(&quot;男&quot;);    user.setPhone(&quot;135461852xx&quot;);    user.setAddress(&quot;广州天河&quot;);    out.println(user);}</code></pre><p>上面这样，显然比直接用有参构造器要好很多，因为这样就可以创建对象和赋值分开进行，一眼就可以看出对什么属性值赋值，而且如果加一个字段，我们不需要再每一处都去修改，因为用的是<strong>无参构造器</strong>，是不是这样写就是万全之计呢？<br>也不是，因为这样创建对象和赋值是分开的，各个参数的初始化被放到了不同的方法中调用，这会导致严重的线程不安全问题(使用构造器则不会有这个问题)，对象在一连串的set方法中，可能会出现状态不一致的情况，这是应该尽量避免的。</p><h2 id="解决方法二-通过构建者模式，链式调用构建方法设置属性值"><a href="#解决方法二-通过构建者模式，链式调用构建方法设置属性值" class="headerlink" title="解决方法二 通过构建者模式，链式调用构建方法设置属性值"></a>解决方法二 通过构建者模式，链式调用构建方法设置属性值</h2><p>什么是链式编程，就是调用一个方法，返回值是他本身，可以继续调用下一个方法，返回又是他本身，如此调用下去，看上去就像一条链子一样。典型的例子可以看<code>java8</code>新特性的<code>Stream</code>流操作。我们可以使用构建者模式，也能达到这种效果，并且线程安全，而且能直观地看到属性值的意思。总得来说，既保证线程安全，也很具有代码的可读性。先看结果代码：</p><pre><code class="java">public static void main(String[] args) throws Exception {    String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);    User user = UserBuilder.getInstance()            .newPojo()            .addId(id)            .addName(&quot;张三&quot;)            .addGender(&quot;男&quot;)            .addAge(20)            .addPhone(&quot;135461852xx&quot;)            .addAddress(&quot;广州天河&quot;)            .build();}</code></pre><p>怎么实现呢？其实很简单，我们只需要创建一个<code>UserBuilder</code>类即可。代码如下：</p><pre><code class="java">public class UserBuilder {    private User user;    private UserBuilder() {    }    public static UserBuilder getInstance() {        return new UserBuilder();    }    public UserBuilder newPojo() {        this.user = new User();        //返回本身        return this;    }    public UserBuilder addId(String id) {        this.user.setId(id);        //返回本身        return this;    }    public UserBuilder addName(String name) {        this.user.setName(name);        return this;    }    public UserBuilder addGender(String gender) {        this.user.setGender(gender);        return this;    }    public UserBuilder addAge(Integer age) {        this.user.setAge(age);        return this;    }    public UserBuilder addAddress(String address) {        this.user.setAddress(address);        return this;    }    public UserBuilder addPhone(String phone) {        this.user.setPhone(phone);        return this;    }    public User build() {        return this.user;    }}</code></pre><p>那么是不是这种方式就是万全之计呢，就一定没有缺点吗？</p><h3 id="构造者模式的缺点还是有的"><a href="#构造者模式的缺点还是有的" class="headerlink" title="构造者模式的缺点还是有的"></a>构造者模式的缺点还是有的</h3><p>1.代码冗长。如果一个对象的属性很多，那我们在创建一个对象时，链式就会变得很长，但是这也没有办法，无论采用构造器还是builder模式都会很长。如果非要变得简洁一点，那就只有采用原型模式(克隆)等其他方式了。<br>2.会产生很多<code>Builder</code>类。我们可以放在一个包下统一管理应该问题不大。<br>第二个缺点实际上可以使用<code>Lombok</code>插件，然后在实体类上使用<code>@Builder</code>注解，就不会产生过多的<code>Builder</code>类了。但是有些公司的技术总监不太建议使用<code>Lombok</code>，那就莫得办法了…</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>有很多博客的示范代码，<code>Builder</code>类的<code>addXXX</code>方法会写成<code>setXXX</code>方法，这是一个隐患。因为很多框架，对Setter方法比较敏感，往往会对<code>Setter</code>方法做一些处理，所以<code>Builder</code>类里的设置属性值方法尽量不要用<code>setXXX</code>命名，防止出现一些不明原因的错误。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>一般我们在项目中创建复杂的对象时，建议采用这种构建者模式创建对象。这样可以使代码可读性更好。<br>在java源码中，我们也可以看到构建者模式的应用。比如在<code>StringBuilder</code>类中：</p><pre><code class="java">@Overridepublic StringBuilder append(CharSequence s) {    super.append(s);    return this;}/** * @throws     IndexOutOfBoundsException {@inheritDoc} */@Overridepublic StringBuilder append(CharSequence s, int start, int end) {    super.append(s, start, end);    return this;}@Overridepublic StringBuilder append(char[] str) {    super.append(str);    return this;}</code></pre><p><code>StringBuilder</code>的<code>append()</code>方法也是通过返回<code>this</code>对象实现链式构建对象，人们经常说这个<code>StringBuilder</code>类线程不安全是因为<code>append()</code>方法没有用<code>synchronized</code>修饰。<code>StringBuffer</code>则用了<code>synchronized</code>修饰，所以就是线程安全的。<br>还有<code>Mybatis</code>框架中，构建<code>SqlSessionFactory</code>对象是使用<code>SqlSessionFactoryBuilder</code>类进行构建，构建者模式运用非常广泛，非常值得学习。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式以及应用</title>
    <link href="/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><strong>代理模式的定义：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</p><a id="more"></a><p>通俗点说，就是一个中介，比如有一个广州人，是个本地人，有两套房，他要租出去收租，但是除了收租，他还要去找租客，带租客看房，还要准备租房合同，核算水电费等等，很麻烦。这个本地人他也不想这么折腾，他只想<strong>完成他的核心业务(收钱)</strong>,其他杂七杂八的事情就不想管，但是总要有人去做，那就找<strong>租房中介</strong>，也就是二手房东。二手房东就代理这个广州本地人把房子租给租客。这个道理就是这么简单。</p><p>他们这些在广州有房子的本地人都可以找中介公司去代理租房是一样的。因为很多广州本地人都有这个需求，干脆就搞一个中介公司来专门去做租房子的事情。</p><p><strong>代理模式，运用在编程里，也是这个道理，有一些非核心业务的代码，在很多地方都需要用到的逻辑，可以交给代理对象完成，程序员只需要关心核心业务的逻辑即可。</strong></p><h1 id="实现代理模式的三种方式"><a href="#实现代理模式的三种方式" class="headerlink" title="实现代理模式的三种方式"></a>实现代理模式的三种方式</h1><p>项目就基于上一篇<code>模板模式</code>的文章的项目进行试验。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假设原来有一个接口<code>UserService</code>，controller层调用<code>userService</code>的<code>getAllUser()</code>方法。如下所示：</p><pre><code class="java">public interface UserService {    /**     * 获取所有用户信息     *     * @return List     * @author Ye hongzhi     * @date 2020/4/12     */    List&lt;User&gt; getAllUser() throws Exception;}</code></pre><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return userService.getAllUser();    }}</code></pre><p>如果用静态代理实现记录日志信息，怎么记录呢？</p><p>首先创建一个代理类<code>UserServiceProxy</code>，实现<code>UserService</code>接口，然后在<code>UserServiceProxy</code>里面创建一个成员变量<code>userService</code>，再写一个有参构造器来初始化<code>userService</code>。代码如下：</p><pre><code class="java">public class UserServiceProxy implements UserService {    private UserService userService;    public UserServiceProxy(UserService userService) {        this.userService = userService;    }    @Override    public List&lt;User&gt; getAllUser() throws Exception {        System.out.println(&quot;记录日志：执行getAllUser()方法前&quot;);        List&lt;User&gt; userList = userService.getAllUser();        System.out.println(userList);        System.out.println(&quot;记录日志：执行getAllUser()方法后&quot;);        return userList;    }}</code></pre><p>所以在controller层调用的方式就要改一下，是用代理类<code>UserServiceProxy</code>调用<code>getAllUser()</code>方法。如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return new UserServiceProxy(userService).getAllUser();    }}</code></pre><p>然后启动项目，调用一下接口，就可以看到控制台打印如下日志：</p><pre><code class="java">/*记录日志：执行getAllUser()方法前[User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser()方法后*/</code></pre><p>这就是静态代理的实现思路，很简单。但是一般我们肯定是不用这种方式。因为这种方式太笨了，很容易就可以看出几个缺点。</p><p><strong>1.要实现接口，也就是目标的方法要定义一个接口方法，实际上是运用了java多态的特性</strong></p><p><strong>2.第一点还不是致命的，因为JDK动态代理也是必须要定义接口；致命的是每一个你想代理的接口你都要去创建一个代理类去实现，假设有很多要代理的接口，那就创建很多代理类，这样显得很臃肿</strong></p><p>假设还是不理解为什么要动态代理，不妨我们再多加一个支付接口<code>PayService</code>，这个支付接口我们也要加上日志记录。</p><p>用静态代理怎么做？很简单呀，再创建一个<code>PayServiceProxy</code>类不就完了吗，如果还有<code>OrderService</code>(订单),</p><p><code>WarehouseService</code>(仓库)等等。那就要创建很多<code>XXXServiceProxy</code>类。如果使用动态代理，就没必要创建这么多代理类，创建一个代理类就够了！</p><blockquote><p>动态代理就是为了解决静态代理的这个缺点产生的。</p></blockquote><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK本身就带有动态代理，必须要满足一个条件，就是要有接口。原理其实和静态代理是一样的，也是用代理类去实现接口，但是代理类不是一开始就写好的，而是在程序运行时通过反射创建字节码文件然后加载到JVM。也就是动态生成的代理类对象。</p><p>下面就是用<code>JDK动态代理</code>实现代理模式。</p><pre><code class="java">public class LogRecordProxy&lt;T&gt; implements InvocationHandler {    private T target;    public LogRecordProxy(T t) {        this.target = t;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前&quot;);        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后&quot;);        return result;    }    /**     * 获取代理对象的方法     * */    @SuppressWarnings(&quot;unchecked&quot;)    public &lt;T&gt; T getProxy() throws Exception {        return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }}</code></pre><p>在controller层，就要改成这样。</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        //获取代理对象        UserService userServiceProxy = new LogRecordProxy&lt;&gt;(userService).getProxy();        return userServiceProxy.getAllUser();    }}</code></pre><p>假设有一个<code>PayService</code>也要做日志记录，就可以直接使用。</p><pre><code class="java">    @Resource(name = &quot;payService&quot;)    private PayService payService;        @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        //获取代理对象，实际上就在构造器上改一下传入的参数即可        PayService payServiceProxy = new LogRecordProxy&lt;&gt;(payService).getProxy();        return payServiceProxy.pay(channel,amount);    }</code></pre><p>很多文章给的例子都不带泛型，也可以，就是获取的代理对象需要强转一下，强转成对应的接口类。</p><p><strong>注意：这里一定要用接口接收代理对象，不能用实现类！</strong></p><p>因为返回的对象已经不是实现类的对象，而是和实现类有共同的接口类的代理类对象，所以当然只能用接口类去接收。</p><blockquote><p>这也是为什么一再强调要面向接口编程的原因，因为面向接口编程可以做更多的扩展。假设是面向实现类去编程，那就不能用JDK动态代理去扩展了！</p></blockquote><h2 id="CGLB动态代理"><a href="#CGLB动态代理" class="headerlink" title="CGLB动态代理"></a>CGLB动态代理</h2><p>那如果有些场景真的没有接口呢，我们怎么运用代理模式？</p><p>首先引入maven配置</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后创建一个方法拦截器<code>LogRecordInterceptor</code>，要实现<code>MethodInterceptor</code>类，如下：</p><pre><code class="java">public class LogRecordInterceptor implements MethodInterceptor {    private Object target;    public LogRecordInterceptor(Object target) {        this.target = target;    }    @Override    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前,参数：&quot; + Arrays.toString(args));        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后,参数：&quot; + Arrays.toString(args));        return result;    }}</code></pre><p>然后再创建一个工厂类<code>InterceptorFactory</code>，用于创建代理对象。</p><pre><code class="java">public class InterceptorFactory {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T&gt; T getInterceptor(Class&lt;T&gt; clazz, MethodInterceptor methodInterceptor) {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(clazz);        enhancer.setCallback(methodInterceptor);        return (T) enhancer.create();    }}</code></pre><p>接着我们就可以创建一个没有接口的类，我这里就创建一个数学工具类进行测试</p><pre><code class="java">public class MathUtil {    /**     * 获取一个数的平方     * */    public String getSquare(int num) {        return String.valueOf(num * num);    }}</code></pre><p>然后在controller层定义一个接口来测试</p><pre><code class="java">@RequestMapping(&quot;/getSquare&quot;)    public String getSquare(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception {        MathUtil mathUtil = InterceptorFactory.getInterceptor(MathUtil.class, new LogRecordInterceptor(new MathUtil()));        return mathUtil.getSquare(num);    }</code></pre><p>用浏览器或者<code>POSTMAN</code>工具调用接口，就可以在控制台看到以下输出：</p><pre><code class="java">/*记录日志：执行getSquare方法前,参数：[2]4记录日志：执行getSquare方法后,参数：[2]*/</code></pre><p>这样就实现没有定义接口也可以实现动态代理！</p><p>实际上，定义接口的也可以用这种方法来进行扩展，比如上面的<code>userService</code>接口</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        UserServiceImpl userServiceProxy = InterceptorFactory            .getInterceptor(UserServiceImpl.class,                            new LogRecordInterceptor(userService));        return userServiceProxy.getAllUser();    }}</code></pre><p>调用接口我们在控制台也是可以看到以下输出日志：</p><pre><code class="java">/*记录日志：执行getAllUser方法前,参数：[][User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser方法后,参数：[]*/</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>以上就是代理模式的一些通俗的解释，还有三种实现的方式的学习</strong></p><p>多说几句，我们都知道<code>Spring</code>框架有两个核心技术，一个叫控制反转<code>IOC</code>，另一个叫切面编程<code>AOP</code>。切面编程大家都很熟悉，用的就是代理模式，那么<code>AOP</code>实现的代理模式用的是<code>JDK动态代理</code>还是<code>CLB动态代理</code>？</p><p>答曰：<strong>两个都用！</strong></p><p>最简单的，我们看<code>Spring</code>的事务管理，就是用代理模式实现的，如果有兴趣，其实我们自己也可以通过<code>JDK动态代理</code>手写实现事务管理，其实不是很难。篇幅有限，以后可以单独写一篇文章详细说明<code>Spring</code>的事务管理，敬请期待。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板模式以及实战应用</title>
    <link href="/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>上一篇讲了策略模式，知道了可以使用策略模式对多重if-else进行优化，而且符合开闭原则。那么除了策略模式，还有什么设计模式比较好用而且常用的呢。这就是今天要讲的模板模式。</p><a id="more"></a><p>模板模式解决什么问题呢？</p><h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><p>首先我们使用SpringBoot来搭建一个工程。</p><pre><code class="xml">    &lt;!-- maven配置 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;commons-lang&lt;/groupId&gt;        &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;        &lt;version&gt;2.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><p>application.yml配置如下：</p><pre><code class="yaml">server:  port: 8888spring:  datasource:    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8    username: 账号    password: 密码    driver-class-name: com.mysql.jdbc.Driver</code></pre><p>创建一个全局配置类<code>GlobalProperties</code>，我们通过这个类可以获取yml的配置信息</p><pre><code class="java">@Component(&quot;globalProperties&quot;)public class GlobalProperties {    @Value(&quot;${spring.datasource.driver-class-name}&quot;)    private String driverClass;    @Value(&quot;${spring.datasource.url}&quot;)    private String url;    @Value(&quot;${spring.datasource.username}&quot;)    private String username;    @Value(&quot;${spring.datasource.password}&quot;)    private String password;    //字段对应的getter、setter方法...</code></pre><p>创建一个连接工厂类<code>ConnectFactory</code>，获取数据库连接</p><pre><code class="java">public class ConnectFactory {    public static Connection getConnection() throws Exception{        //获取yml文件的配置，SpringContextUtil工具类在上一篇文章有介绍，可以参考上一篇文章的代码        GlobalProperties properties = SpringContextUtil                .getBean(&quot;globalProperties&quot;, GlobalProperties.class);        //加载数据驱动        Class.forName(properties.getDriverClass());        //获取数据库连接，返回数据库连接对象        return DriverManager.getConnection(properties.getUrl(),                properties.getUsername(), properties.getPassword());    }}</code></pre><p>创建实体类<code>User</code></p><pre><code class="java">public class User {    private Integer id;    private String name;    private Integer age;    private String job;    //字段对应的getter、setter方法...</code></pre><p>接着在mysql对应的数据库创建数据表<code>tb_user</code>，sql语句如下：</p><pre><code class="sql">CREATE TABLE `tb_user` (  `id` bigint(10) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,  `name` varchar(255) NOT NULL COMMENT &#39;名称&#39;,  `age` tinyint(4) NOT NULL COMMENT &#39;年龄&#39;,  `job` varchar(255) DEFAULT NULL COMMENT &#39;工作&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4</code></pre><p>插入一些测试数据</p><pre><code class="sql">INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大司马&#39;,36,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;朴老师&#39;,36,&#39;主播&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;王刚&#39;,30,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大sao&#39;,32,&#39;美食up主&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;姚大秋&#39;,35,&#39;主持人&#39;);</code></pre><p>假设我们有一张user表，我们通过原生的JDBC来进行数据库操作，那么需要在dao层完成以下几步。</p><p>1.装载相应的数据库的JDBC驱动并进行初始化</p><p>2.建立JDBC和数据库之间的Connection连接</p><p>3.创建Statement或者PreparedStatement接口，执行SQL语句</p><p>4.处理和显示结果</p><p>5.释放资源</p><p>例子如下：</p><pre><code class="java">    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        User user = new User();        //获取数据连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement             .executeQuery(String.format(GET_USER_BY_NAME_SQL, name))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        User user = new User();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet =             statement.executeQuery(String.format(GET_USER_BY_ID_SQL, id))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }</code></pre><p>PS:这里为了简单一点就直接把参数拼接sql语句，不采用预编译来处理sql的参数。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过上面的代码，我们很明显可以看到是有很大的问题的。</p><p>1.每次在进行数据库操作都需要获取<code>Connection</code>对象，创建<code>Statement</code>对象。</p><p>2.每次获取结果后，都要进行结果处理，而且如果是同一张表的查询，会很重复。每次都需要把结果值set回到对象的字段中。</p><p>模板模式就可以解决这个问题！</p><h2 id="使用模板模式重构代码"><a href="#使用模板模式重构代码" class="headerlink" title="使用模板模式重构代码"></a>使用模板模式重构代码</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>创建一个模板类<code>DaoTemplate</code>，如下：</p><pre><code class="java">/** * @author Ye Hongzhi * @program DaoTemplate * @description * @date 2020-04-12 17:04 **/@Componentpublic class DaoTemplate {    public &lt;T&gt; T query(String sql, Class&lt;T&gt; clazz) throws Exception {        //通过clazz创建返回值对象        T t = clazz.newInstance();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement.executeQuery(sql)        ) {            while (resultSet.next()) {                //获取所有字段                Field[] fields = clazz.getDeclaredFields();                //获取所有方法                Method[] methods = clazz.getDeclaredMethods();                Map&lt;String, Method&gt; methodNameMap = Arrays.stream(methods)                        .collect(Collectors.toMap(Method::getName, Function.identity()));                //把数据库对应的列的值赋值给 泛型T对象的 对应的字段                for (Field field : fields) {                    //获取字段名                    String fieldName = field.getName();                    //获取set方法                    Method method = methodNameMap.get(&quot;set&quot; + change(fieldName));                    //获取数据库的列的值                    Object fieldValue = null;                    if (field.getType() == String.class) {                        fieldValue = resultSet.getString(fieldName);                    }                    if (field.getType() == Integer.class) {                        fieldValue = resultSet.getInt(fieldName);                    }                    if (field.getType() == Boolean.class) {                        fieldValue = resultSet.getBoolean(fieldName);                    }                    if (field.getType() == Long.class) {                        fieldValue = resultSet.getLong(fieldName);                    }                    if(field.getType() == Double.class){                        fieldValue = resultSet.getDouble(fieldName);                    }                    if(field.getType() == BigDecimal.class){                        fieldValue = resultSet.getBigDecimal(fieldName);                    }                    if (field.getType() == Date.class) {                        fieldValue = resultSet.getDate(fieldName);                    }                    //设置更多的字段类型...                    //利用反射执行对象的set方法，把数据库的值设置到对象的字段中                    method.invoke(t, fieldValue);                }            }        } catch (Exception e) {            e.printStackTrace();        }        return t;    }    /**     * 将一个字符串首字母大写，其它字母小写     *     * @param str 字符串     * @return     */    private static String change(String str) {        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();    }}</code></pre><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>创建模板后，可以在<code>DAO</code>层引入模板，然后使用。如下：</p><pre><code class="java">    //引入模板        @Resource    private DaoTemplate daoTemplate;    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_ID_SQL, id), User.class);    }    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_NAME_SQL, name), User.class);    }</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><h1 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h1><p>实际上在Spring框架就有提供<code>JDBC</code>模板</p><p>我们可以在<code>MAVEN</code>中引入以下配置：</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>创建一个映射类<code>UserRowMapper</code></p><pre><code class="java">public class UserRowMapper implements RowMapper&lt;User&gt; {    @Override    public User mapRow(ResultSet resultSet, int i) throws SQLException {        User user = new User();        user.setId(resultSet.getInt(&quot;id&quot;));        user.setName(resultSet.getString(&quot;name&quot;));        user.setAge(resultSet.getInt(&quot;age&quot;));        user.setJob(resultSet.getString(&quot;job&quot;));        return user;    }}</code></pre><p>然后在<code>DAO</code>层的<code>UserDaoImpl</code>，我们就可以引入<code>JdbcTemplate</code></p><pre><code class="java">    @Resource    private JdbcTemplate jdbcTemplate;    //使用jdbcTemplate查询    @Override    public User getUserByName(String name) throws Exception {        return jdbcTemplate.queryForObject(String.format(GET_USER_BY_NAME_SQL, name), new UserRowMapper());    }</code></pre><p>从这里可以看出实际上<code>Spring</code>框架就是采用这种思想来实现<code>JdbcTemplate</code>模板。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>所以在实际项目的开发中，我们有时候遇到某些代码块的前后都有重复操作时，可以采用模板模式去重构代码，使代码更加简洁，容易维护。</p><p>更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你用策略模式解决多重if-else</title>
    <link href="/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/"/>
    <url>/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>很多人可能在公司就是做普通的CRUD的业务，对于设计模式，即使学了好像也用处不大，顶多就在面试的时候能说上几种常见的单例模式，工厂模式。而在实际开发中，设计模式似乎很难用起来。</p><p>在现在的环境下，程序员的竞争已经非常激烈了，要体现出自身的价值，最直接的体现当然是差异化。这无需多说，我认为在实际开发中能运用设计模式，是很能体现差异化的。设计模式是一些前人总结的较好的方法，使程序能有更好的扩展性，可读性，维护性。</p><p>下面举个例子，使用策略模式解决多重if-else的代码结构。想学习更多的设计模式的实战经验，那就点个关注吧，谢谢大佬。</p><h1 id="使用if-else"><a href="#使用if-else" class="headerlink" title="使用if-else"></a>使用if-else</h1><p>假设我们要开发一个支付接口，要对接多种支付方式，通过渠道码区分各种的支付方式。于是定义一个枚举<code>PayEnum</code>，如下：</p><pre><code class="java">public enum PayEnum {    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;);    /**渠道*/    private String channel;    /**描述*/    private String description;    PayEnum(String channel, String description) {        this.channel = channel;        this.description = description;    }    /**以下省略字段的get、set方法*/</code></pre><p>创建一个<code>PayController</code>类，代码如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class PayController {    @Resource(name = &quot;payService&quot;)    private PayService payService;    /**    * 支付接口    * @param channel 渠道    * @param amount  消费金额    * @return String 返回消费结果    * @author Ye hongzhi    * @date 2020/4/5    */    @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        return payService.pay(channel,amount);    }}</code></pre><p>再创建一个<code>PayService</code>接口以及实现类<code>PayServiceImpl</code></p><pre><code class="java">public interface PayService {    /**    * 支付接口    * @param channel 渠道    * @param amount  金额    * @return String    * @author Ye hongzhi    * @date 2020/4/5    */    String pay(String channel,String amount)throws Exception;}</code></pre><pre><code class="java">@Service(&quot;payService&quot;)public class PayServiceImpl implements PayService {    private static String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    @Override    public String pay(String channel, String amount) throws Exception {        if (PayEnum.ALI_PAY.getChannel().equals(channel)) {            //支付宝            //业务代码...            return String.format(MSG,PayEnum.ALI_PAY.getDescription(),amount);        }else if(PayEnum.WECHAT_PAY.getChannel().equals(channel)){            //微信支付            //业务代码...            return String.format(MSG,PayEnum.WECHAT_PAY.getDescription(),amount);        }else if(PayEnum.UNION_PAY.getChannel().equals(channel)){            //银联支付            //业务代码...            return         String.format(MSG,PayEnum.UNION_PAY.getDescription(),amount);        }else if(PayEnum.XIAO_MI_PAY.getChannel().equals(channel)){            //小米支付            //业务代码...            return String.format(MSG,PayEnum.XIAO_MI_PAY.getDescription(),amount);        }else{            return &quot;输入渠道码有误&quot;;        }    }}</code></pre><p>然后通过浏览器，我们可以看到效果</p><p><img src="https://static.lovebilibili.com/01.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/02.png" srcset="/img/loading.gif" alt=""></p><p>这样看，以上代码的确可以实现需求，通过渠道码区分支付方式，可是看到上面那么多达4个的<code>if-else</code>的代码结构，已经开始显示出问题了。假设有更多的支付方式，那么这段代码就要写更多的<code>else if</code>去判断，这显然会不利于代码的扩展，这样会导致这个支付的方法越写越长。</p><p>在设计模式六大原则中，其中一个原则叫做<code>开闭原则</code>，对扩展开放，对修改关闭，应尽量在不修改原有代码的情况下进行扩展。</p><p>基于上面提到的<code>开闭原则</code>，我们可以使用策略模式进行重构。</p><h1 id="使用策略模式重构代码"><a href="#使用策略模式重构代码" class="headerlink" title="使用策略模式重构代码"></a>使用策略模式重构代码</h1><p>定义一个策略接口类<code>PayStrategy</code></p><pre><code class="java">public interface PayStrategy {    String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    String pay(String channel,String amount)throws Exception;}</code></pre><p>然后再创建四种策略实现类实现接口</p><pre><code class="java">@Component(&quot;aliPayStrategy&quot;)public class AliPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.ALI_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;wechatPayStrategy&quot;)public class WechatPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.WECHAT_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;unionPayStrategy&quot;)public class UnionPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.UNION_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;xiaomiPayStrategy&quot;)public class XiaomiPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.XIAO_MI_PAY.getDescription(),amount);    }}</code></pre><p>看到这里实际上已经很清晰了，思路就是通过渠道码，动态获取到具体的实现类，这样就可以实现不需要<code>if else</code>判断。怎么通过渠道码获取实现类呢？</p><p>在<code>PayEnum</code>枚举加上<code>BeanName</code>字段，然后增加一个通过渠道码获取<code>BeanName</code>的方法</p><pre><code class="java">    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;,&quot;aliPayStrategy&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;,&quot;wechatPayStrategy&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;,&quot;unionPayStrategy&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;,&quot;xiaomiPayStrategy&quot;);    /**策略实现类对应的 beanName*/    private String beanName;    /**     * 通过渠道码获取枚举     * */    public static PayEnum findPayEnumBychannel(String channel){        PayEnum[] enums = PayEnum.values();        for (PayEnum payEnum : enums){            if(payEnum.getChannel().equals(channel)){                return payEnum;            }        }        return null;    }    //构造器    PayEnum(String channel, String description, String beanName) {        this.channel = channel;        this.description = description;        this.beanName = beanName;    }</code></pre><p>这时候还差一个获取Spring上下文对象的工具类，于是我们创建一个<code>SpringContextUtil</code>类</p><pre><code class="java">@Componentpublic class SpringContextUtil implements ApplicationContextAware {    /**     * 上下文对象实例     */    private static ApplicationContext applicationContext;    /**     * 获取applicationContext     */    private static ApplicationContext getApplicationContext() {        return applicationContext;    }    /**     * 通过name获取Bean     * */    public static Object getBean(String name){        return getApplicationContext().getBean(name);    }    /**     * 通过name,以及Clazz返回指定的Bean     * */    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz){        return getApplicationContext().getBean(name,clazz);    }    @Override    @Autowired    public void setApplicationContext(ApplicationContext applicationContext) throws         BeansException {        SpringContextUtil.applicationContext = applicationContext;    }</code></pre><p>接着定义一个工厂类，通过渠道码获取对应的策略实现类</p><pre><code class="java">public class PayStrategyFactory {    /**     * 通过渠道码获取支付策略具体实现类     * */    public static PayStrategy getPayStrategy(String channel){        PayEnum payEnum = PayEnum.findPayEnumBychannel(channel);        if(payEnum == null){            return null;        }        return SpringContextUtil.getBean(payEnum.getBeanName(),PayStrategy.class);    }}</code></pre><p>最后我们再改造一下原来的<code>PayServiceImpl</code>的<code>pay</code>方法</p><pre><code class="java">@Overridepublic String pay(String channel, String amount) throws Exception {    PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);    if(payStrategy == null){        return &quot;输入渠道码有误&quot;;    }    return payStrategy.pay(channel,amount);}</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><blockquote><p>假设需要增加新的支付方式，就不需要再使用else if 去判断，而是在枚举中定义一个新的枚举对象，然后再增加一个策略实现类，实现对应的方法，那就可以很轻松地扩展。也实现了开闭原则。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>设计模式运用得熟练的话，很多代码可以写得很优雅。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot系列之自定义spring-boot-starter</title>
    <link href="/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/"/>
    <url>/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>传统的 Maven项目一般将需要被复用的组件做成 Module来进行管理，以便二次调用；而在 Spring Boot项目中我们则可以使用更加优雅的 Spring Boot Starter来完成这一切。</p><a id="more"></a><p>这个开箱即用的魔法特性很大程度上来源于各式各样 Spring Boot Starter的加持，而且随着版本的迭代 Starter家族成员日益庞大，而且各种优秀开源作者也提供了很多非常好用的Spring Boot Starter。</p><p>本文尝试自定义一个Spring Boot Starter用于图片链接转换BASE64编码。</p><h1 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h1><ol><li>在GItHub上创建base64util-spring-boot-starter项目，然后clone下来本地进行开发。</li></ol><p><img src="https://static.lovebilibili.com/Github_Create.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>pom.xml文件配置如下</li></ol><pre><code class="xml">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;&lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;0.0.1&lt;/version&gt;&lt;dependencies&gt;    &lt;!-- 引入SpringBoot自动配置jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ol start="3"><li>业务代码</li></ol><pre><code class="java">import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL;/** * @author Ye Hongzhi * @program Base64Util * @description * @date 2020-02-17 14:04 **/public class Base64Util {    /**     * 本地图片转为BASE64编码     *     * @param imgFile 本地图片地址     * @return BASE64 解码后的字符串编码     * @description: 根据图片地址转换为base64编码字符串     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static String getImageFile(String imgFile) {        byte[] data = null;        try (InputStream inputStream = new FileInputStream(imgFile)) {            data = new byte[inputStream.available()];            int length = inputStream.read(data);            if (length == -1) {                return null;            }        } catch (Exception e) {            e.printStackTrace();        }        // 加密        BASE64Encoder encoder = new BASE64Encoder();        if (data != null) {            return encoder.encode(data);        } else {            return null;        }    }    public static String image2Base64(String imgUrl) throws Exception {        URL url = new URL(imgUrl);        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();        try(InputStream inputStream = urlConnection.getInputStream();            ByteArrayOutputStream baos = new ByteArrayOutputStream()) {            urlConnection.connect();            byte[] buffer = new byte[1024];            int len;            //使用一个输入流从buffer里把数据读取出来            while ((len = inputStream.read(buffer)) != -1) {                //用输出流往buffer里写入数据，中间参数代表从哪个位置开始读，len代表读取的长度                baos.write(buffer, 0, len);            }            // 对字节数组Base64编码            return Base64.encode(baos.toByteArray());        } catch (Exception e) {            e.printStackTrace();        } finally {            if (urlConnection != null) {                urlConnection.disconnect();            }        }        return imgUrl;    }    /**     * BASE64编码转为图片     * 注意：&quot;data:image/jpeg;base64,&quot; 解码之前得去掉。     *     * @param imgStr base64编码字符串     * @param path   图片路径-具体到文件     * @return 是否转换成功     * @description: 将base64编码字符串转换为图片     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static boolean generateImage(String imgStr, String path) {        if (imgStr == null) {            return false;        }        try (OutputStream out = new FileOutputStream(path)) {            BASE64Decoder decoder = new BASE64Decoder();            // 解密            byte[] b = decoder.decodeBuffer(imgStr);            // 处理数据            for (int i = 0; i &lt; b.length; ++i) {                if (b[i] &lt; 0) {                    b[i] += 256;                }            }            out.write(b);            out.flush();            return true;        } catch (Exception e) {            e.printStackTrace();            return false;        }    }}</code></pre><ol start="4"><li>创建一个service调用，这里为了简单，就不定义为接口的形式</li></ol><pre><code class="java">public class Base64Service {    /**     * 本地图片转为BASE64编码     */    public String getImageFile(String imgFile) {        return Base64Util.getImageFile(imgFile);    }    /**     * BASE64编码转为图片     * */    public boolean generateImage(String imgStr, String path) {        return Base64Util.generateImage(imgStr,path);    }    /**     * 在线图片转为BASE64编码     * */    public String image2Base64(String imgUrl) throws Exception{        return Base64Util.image2Base64(imgUrl);    }}</code></pre><ol start="5"><li>关键的一步，使用配置类，把service定义成bean，加入到spring容器中管理</li></ol><pre><code class="java">@Configurationpublic class Base64AutoConfiguration {    @Bean    Base64Service base64Service(){        return new Base64Service();    }}</code></pre><ol start="6"><li>最关键一步在于需要在resources文件夹下创建<code>META-INF/spring.factories</code>，<code>spring.factories</code>里的代码如下:</li></ol><pre><code class="yaml">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.lovebilibili.me.config.Base64AutoConfiguration</code></pre><p>这一步是重点，因为Spring Boot应用在启动过程中会通过 <code>SpringFactoriesLoader</code> 加载所有 <code>META-INF/spring.factories</code> 文件，通过一系列的处理流程最终将 spring.factories 文件中的定义的各种 <code>beans</code> 装载入 ApplicationContext容器。</p><blockquote><p>至此，自定义的用于base64转码工具的spring-boot-starter就完成了</p><p>可以通过使用maven命令<code>mvn install</code>打包，传到私有/公有Maven仓库使用。</p><p>形成一个公共的模块，供有需要的项目使用。</p></blockquote><ol start="7"><li>完成后把代码推送到Github仓库中，方便以后继续优化。</li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li>在其他项目中的pom文件加入以下依赖：</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;    &lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.0.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在Controller层中，我们可以引入base64Service。</li></ol><pre><code class="java">@Resourceprivate Base64Service base64Service;</code></pre><ol start="3"><li>然后在Controller层中的@RequestMapping对应的方法中使用</li></ol><pre><code class="java">//把在线图片转为BASE64编码String base64 = base64Service.image2Base64(imgUrl);</code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要创建个人博客</title>
    <link href="/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>很高兴你能点进来看我的第一篇文章。</p><p>内容也和标题一样无聊，为什么要创建个人博客，既然我已经创建了还要找什么理由呢。但是你点进来很大原因是因为你还没有个人博客，所以想来听听我创建个人博客的理由，以此来驱动自己去创建个人博客。这非常好，证明你已经有冲动了，只差行动起来。</p><p>我的理由有以下几点：</p><ol><li>想要记录下一些自己的技术学习的过程。比记录在有道云笔记自己看更加有价值，因为博客是可以分享，可以传播，知识需要传播起来才有力量。这是最大的一个原因。</li><li>通过输出博客文章提升自己的技术水平。因为输出就是最好的学习，输出一篇好的技术文章，往往就是最好的学习方式。</li><li>通过这个博客和网友互相学习。毕竟外面的世界很大，可以通过博客这个窗口和网上的开发者互相学习讨论，不失为一种乐趣。</li><li>记录一些生活感想、读书笔记、美食经历等等。</li></ol><p>这就是我的理由。如果你想要创建个人博客的话，马上去做吧。</p><p>教程的话可以参考</p><p>B站up主“CodeSheep”的视频<a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></p><p>我的hexo主题使用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">fluid</a>,如果你觉得不错也可以使用哦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
