<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代理模式以及应用</title>
    <link href="/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><strong>代理模式的定义：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</p><a id="more"></a><p>通俗点说，就是一个中介，比如有一个广州人，是个本地人，有两套房，他要租出去收租，但是除了收租，他还要去找租客，带租客看房，还要准备租房合同，核算水电费等等，很麻烦。这个本地人他也不想这么折腾，他只想<strong>完成他的核心业务(收钱)</strong>,其他杂七杂八的事情就不想管，但是总要有人去做，那就找<strong>租房中介</strong>，也就是二手房东。二手房东就代理这个广州本地人把房子租给租客。这个道理就是这么简单。</p><p>他们这些在广州有房子的本地人都可以找中介公司去代理租房是一样的。因为很多广州本地人都有这个需求，干脆就搞一个中介公司来专门去做租房子的事情。</p><p><strong>代理模式，运用在编程里，也是这个道理，有一些非核心业务的代码，在很多地方都需要用到的逻辑，可以交给代理对象完成，程序员只需要关心核心业务的逻辑即可。</strong></p><h1 id="实现代理模式的三种方式"><a href="#实现代理模式的三种方式" class="headerlink" title="实现代理模式的三种方式"></a>实现代理模式的三种方式</h1><p>项目就基于上一篇<code>模板模式</code>的文章的项目进行试验。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假设原来有一个接口<code>UserService</code>，controller层调用<code>userService</code>的<code>getAllUser()</code>方法。如下所示：</p><pre><code class="java">public interface UserService {    /**     * 获取所有用户信息     *     * @return List     * @author Ye hongzhi     * @date 2020/4/12     */    List&lt;User&gt; getAllUser() throws Exception;}</code></pre><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return userService.getAllUser();    }}</code></pre><p>如果用静态代理实现记录日志信息，怎么记录呢？</p><p>首先创建一个代理类<code>UserServiceProxy</code>，实现<code>UserService</code>接口，然后在<code>UserServiceProxy</code>里面创建一个成员变量<code>userService</code>，再写一个有参构造器来初始化<code>userService</code>。代码如下：</p><pre><code class="java">public class UserServiceProxy implements UserService {    private UserService userService;    public UserServiceProxy(UserService userService) {        this.userService = userService;    }    @Override    public List&lt;User&gt; getAllUser() throws Exception {        System.out.println(&quot;记录日志：执行getAllUser()方法前&quot;);        List&lt;User&gt; userList = userService.getAllUser();        System.out.println(userList);        System.out.println(&quot;记录日志：执行getAllUser()方法后&quot;);        return userList;    }}</code></pre><p>所以在controller层调用的方式就要改一下，是用代理类<code>UserServiceProxy</code>调用<code>getAllUser()</code>方法。如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return new UserServiceProxy(userService).getAllUser();    }}</code></pre><p>然后启动项目，调用一下接口，就可以看到控制台打印如下日志：</p><pre><code class="java">/*记录日志：执行getAllUser()方法前[User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser()方法后*/</code></pre><p>这就是静态代理的实现思路，很简单。但是一般我们肯定是不用这种方式。因为这种方式太笨了，很容易就可以看出几个缺点。</p><p><strong>1.要实现接口，也就是目标的方法要定义一个接口方法，实际上是运用了java多态的特性</strong></p><p><strong>2.第一点还不是致命的，因为JDK动态代理也是必须要定义接口；致命的是每一个你想代理的接口你都要去创建一个代理类去实现，假设有很多要代理的接口，那就创建很多代理类，这样显得很臃肿</strong></p><p>假设还是不理解为什么要动态代理，不妨我们再多加一个支付接口<code>PayService</code>，这个支付接口我们也要加上日志记录。</p><p>用静态代理怎么做？很简单呀，再创建一个<code>PayServiceProxy</code>类不就完了吗，如果还有<code>OrderService</code>(订单),</p><p><code>WarehouseService</code>(仓库)等等。那就要创建很多<code>XXXServiceProxy</code>类。如果使用动态代理，就没必要创建这么多代理类，创建一个代理类就够了！</p><blockquote><p>动态代理就是为了解决静态代理的这个缺点产生的。</p></blockquote><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK本身就带有动态代理，必须要满足一个条件，就是要有接口。原理其实和静态代理是一样的，也是用代理类去实现接口，但是代理类不是一开始就写好的，而是在程序运行时通过反射创建字节码文件然后加载到JVM。也就是动态生成的代理类对象。</p><p>下面就是用<code>JDK动态代理</code>实现代理模式。</p><pre><code class="java">public class LogRecordProxy&lt;T&gt; implements InvocationHandler {    private T target;    public LogRecordProxy(T t) {        this.target = t;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前&quot;);        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后&quot;);        return result;    }    /**     * 获取代理对象的方法     * */    @SuppressWarnings(&quot;unchecked&quot;)    public &lt;T&gt; T getProxy() throws Exception {        return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }}</code></pre><p>在controller层，就要改成这样。</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        //获取代理对象        UserService userServiceProxy = new LogRecordProxy&lt;&gt;(userService).getProxy();        return userServiceProxy.getAllUser();    }}</code></pre><p>假设有一个<code>PayService</code>也要做日志记录，就可以直接使用。</p><pre><code class="java">    @Resource(name = &quot;payService&quot;)    private PayService payService;        @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        //获取代理对象，实际上就在构造器上改一下传入的参数即可        PayService payServiceProxy = new LogRecordProxy&lt;&gt;(payService).getProxy();        return payServiceProxy.pay(channel,amount);    }</code></pre><p>很多文章给的例子都不带泛型，也可以，就是获取的代理对象需要强转一下，强转成对应的接口类。</p><p><strong>注意：这里一定要用接口接收代理对象，不能用实现类！</strong></p><p>因为返回的对象已经不是实现类的对象，而是和实现类有共同的接口类的代理类对象，所以当然只能用接口类去接收。</p><blockquote><p>这也是为什么一再强调要面向接口编程的原因，因为面向接口编程可以做更多的扩展。假设是面向实现类去编程，那就不能用JDK动态代理去扩展了！</p></blockquote><h2 id="CGLB动态代理"><a href="#CGLB动态代理" class="headerlink" title="CGLB动态代理"></a>CGLB动态代理</h2><p>那如果有些场景真的没有接口呢，我们怎么运用代理模式？</p><p>首先引入maven配置</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后创建一个方法拦截器<code>LogRecordInterceptor</code>，要实现<code>MethodInterceptor</code>类，如下：</p><pre><code class="java">public class LogRecordInterceptor implements MethodInterceptor {    private Object target;    public LogRecordInterceptor(Object target) {        this.target = target;    }    @Override    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前,参数：&quot; + Arrays.toString(args));        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后,参数：&quot; + Arrays.toString(args));        return result;    }}</code></pre><p>然后再创建一个工厂类<code>InterceptorFactory</code>，用于创建代理对象。</p><pre><code class="java">public class InterceptorFactory {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T&gt; T getInterceptor(Class&lt;T&gt; clazz, MethodInterceptor methodInterceptor) {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(clazz);        enhancer.setCallback(methodInterceptor);        return (T) enhancer.create();    }}</code></pre><p>接着我们就可以创建一个没有接口的类，我这里就创建一个数学工具类进行测试</p><pre><code class="java">public class MathUtil {    /**     * 获取一个数的平方     * */    public String getSquare(int num) {        return String.valueOf(num * num);    }}</code></pre><p>然后在controller层定义一个接口来测试</p><pre><code class="java">@RequestMapping(&quot;/getSquare&quot;)    public String getSquare(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception {        MathUtil mathUtil = InterceptorFactory.getInterceptor(MathUtil.class, new LogRecordInterceptor(new MathUtil()));        return mathUtil.getSquare(num);    }</code></pre><p>用浏览器或者<code>POSTMAN</code>工具调用接口，就可以在控制台看到以下输出：</p><pre><code class="java">/*记录日志：执行getSquare方法前,参数：[2]4记录日志：执行getSquare方法后,参数：[2]*/</code></pre><p>这样就实现没有定义接口也可以实现动态代理！</p><p>实际上，定义接口的也可以用这种方法来进行扩展，比如上面的<code>userService</code>接口</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        UserServiceImpl userServiceProxy = InterceptorFactory            .getInterceptor(UserServiceImpl.class,                            new LogRecordInterceptor(userService));        return userServiceProxy.getAllUser();    }}</code></pre><p>调用接口我们在控制台也是可以看到以下输出日志：</p><pre><code class="java">/*记录日志：执行getAllUser方法前,参数：[][User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser方法后,参数：[]*/</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>以上就是代理模式的一些通俗的解释，还有三种实现的方式的学习</strong></p><p>多说几句，我们都知道<code>Spring</code>框架有两个核心技术，一个叫控制反转<code>IOC</code>，另一个叫切面编程<code>AOP</code>。切面编程大家都很熟悉，用的就是代理模式，那么<code>AOP</code>实现的代理模式用的是<code>JDK动态代理</code>还是<code>CLB动态代理</code>？</p><p>答曰：<strong>两个都用！</strong></p><p>最简单的，我们看<code>Spring</code>的事务管理，就是用代理模式实现的，如果有兴趣，其实我们自己也可以通过<code>JDK动态代理</code>手写实现事务管理，其实不是很难。篇幅有限，以后可以单独写一篇文章详细说明<code>Spring</code>的事务管理，敬请期待。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板模式以及实战应用</title>
    <link href="/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>上一篇讲了策略模式，知道了可以使用策略模式对多重if-else进行优化，而且符合开闭原则。那么除了策略模式，还有什么设计模式比较好用而且常用的呢。这就是今天要讲的模板模式。</p><a id="more"></a><p>模板模式解决什么问题呢？</p><h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><p>首先我们使用SpringBoot来搭建一个工程。</p><pre><code class="xml">    &lt;!-- maven配置 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;commons-lang&lt;/groupId&gt;        &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;        &lt;version&gt;2.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><p>application.yml配置如下：</p><pre><code class="yaml">server:  port: 8888spring:  datasource:    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8    username: 账号    password: 密码    driver-class-name: com.mysql.jdbc.Driver</code></pre><p>创建一个全局配置类<code>GlobalProperties</code>，我们通过这个类可以获取yml的配置信息</p><pre><code class="java">@Component(&quot;globalProperties&quot;)public class GlobalProperties {    @Value(&quot;${spring.datasource.driver-class-name}&quot;)    private String driverClass;    @Value(&quot;${spring.datasource.url}&quot;)    private String url;    @Value(&quot;${spring.datasource.username}&quot;)    private String username;    @Value(&quot;${spring.datasource.password}&quot;)    private String password;    //字段对应的getter、setter方法...</code></pre><p>创建一个连接工厂类<code>ConnectFactory</code>，获取数据库连接</p><pre><code class="java">public class ConnectFactory {    public static Connection getConnection() throws Exception{        //获取yml文件的配置，SpringContextUtil工具类在上一篇文章有介绍，可以参考上一篇文章的代码        GlobalProperties properties = SpringContextUtil                .getBean(&quot;globalProperties&quot;, GlobalProperties.class);        //加载数据驱动        Class.forName(properties.getDriverClass());        //获取数据库连接，返回数据库连接对象        return DriverManager.getConnection(properties.getUrl(),                properties.getUsername(), properties.getPassword());    }}</code></pre><p>创建实体类<code>User</code></p><pre><code class="java">public class User {    private Integer id;    private String name;    private Integer age;    private String job;    //字段对应的getter、setter方法...</code></pre><p>接着在mysql对应的数据库创建数据表<code>tb_user</code>，sql语句如下：</p><pre><code class="sql">CREATE TABLE `tb_user` (  `id` bigint(10) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,  `name` varchar(255) NOT NULL COMMENT &#39;名称&#39;,  `age` tinyint(4) NOT NULL COMMENT &#39;年龄&#39;,  `job` varchar(255) DEFAULT NULL COMMENT &#39;工作&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4</code></pre><p>插入一些测试数据</p><pre><code class="sql">INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大司马&#39;,36,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;朴老师&#39;,36,&#39;主播&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;王刚&#39;,30,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大sao&#39;,32,&#39;美食up主&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;姚大秋&#39;,35,&#39;主持人&#39;);</code></pre><p>假设我们有一张user表，我们通过原生的JDBC来进行数据库操作，那么需要在dao层完成以下几步。</p><p>1.装载相应的数据库的JDBC驱动并进行初始化</p><p>2.建立JDBC和数据库之间的Connection连接</p><p>3.创建Statement或者PreparedStatement接口，执行SQL语句</p><p>4.处理和显示结果</p><p>5.释放资源</p><p>例子如下：</p><pre><code class="java">    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        User user = new User();        //获取数据连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement             .executeQuery(String.format(GET_USER_BY_NAME_SQL, name))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        User user = new User();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet =             statement.executeQuery(String.format(GET_USER_BY_ID_SQL, id))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }</code></pre><p>PS:这里为了简单一点就直接把参数拼接sql语句，不采用预编译来处理sql的参数。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过上面的代码，我们很明显可以看到是有很大的问题的。</p><p>1.每次在进行数据库操作都需要获取<code>Connection</code>对象，创建<code>Statement</code>对象。</p><p>2.每次获取结果后，都要进行结果处理，而且如果是同一张表的查询，会很重复。每次都需要把结果值set回到对象的字段中。</p><p>模板模式就可以解决这个问题！</p><h2 id="使用模板模式重构代码"><a href="#使用模板模式重构代码" class="headerlink" title="使用模板模式重构代码"></a>使用模板模式重构代码</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>创建一个模板类<code>DaoTemplate</code>，如下：</p><pre><code class="java">/** * @author Ye Hongzhi * @program DaoTemplate * @description * @date 2020-04-12 17:04 **/@Componentpublic class DaoTemplate {    public &lt;T&gt; T query(String sql, Class&lt;T&gt; clazz) throws Exception {        //通过clazz创建返回值对象        T t = clazz.newInstance();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement.executeQuery(sql)        ) {            while (resultSet.next()) {                //获取所有字段                Field[] fields = clazz.getDeclaredFields();                //获取所有方法                Method[] methods = clazz.getDeclaredMethods();                Map&lt;String, Method&gt; methodNameMap = Arrays.stream(methods)                        .collect(Collectors.toMap(Method::getName, Function.identity()));                //把数据库对应的列的值赋值给 泛型T对象的 对应的字段                for (Field field : fields) {                    //获取字段名                    String fieldName = field.getName();                    //获取set方法                    Method method = methodNameMap.get(&quot;set&quot; + change(fieldName));                    //获取数据库的列的值                    Object fieldValue = null;                    if (field.getType() == String.class) {                        fieldValue = resultSet.getString(fieldName);                    }                    if (field.getType() == Integer.class) {                        fieldValue = resultSet.getInt(fieldName);                    }                    if (field.getType() == Boolean.class) {                        fieldValue = resultSet.getBoolean(fieldName);                    }                    if (field.getType() == Long.class) {                        fieldValue = resultSet.getLong(fieldName);                    }                    if(field.getType() == Double.class){                        fieldValue = resultSet.getDouble(fieldName);                    }                    if(field.getType() == BigDecimal.class){                        fieldValue = resultSet.getBigDecimal(fieldName);                    }                    if (field.getType() == Date.class) {                        fieldValue = resultSet.getDate(fieldName);                    }                    //设置更多的字段类型...                    //利用反射执行对象的set方法，把数据库的值设置到对象的字段中                    method.invoke(t, fieldValue);                }            }        } catch (Exception e) {            e.printStackTrace();        }        return t;    }    /**     * 将一个字符串首字母大写，其它字母小写     *     * @param str 字符串     * @return     */    private static String change(String str) {        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();    }}</code></pre><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>创建模板后，可以在<code>DAO</code>层引入模板，然后使用。如下：</p><pre><code class="java">    //引入模板        @Resource    private DaoTemplate daoTemplate;    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_ID_SQL, id), User.class);    }    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_NAME_SQL, name), User.class);    }</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><h1 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h1><p>实际上在Spring框架就有提供<code>JDBC</code>模板</p><p>我们可以在<code>MAVEN</code>中引入以下配置：</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>创建一个映射类<code>UserRowMapper</code></p><pre><code class="java">public class UserRowMapper implements RowMapper&lt;User&gt; {    @Override    public User mapRow(ResultSet resultSet, int i) throws SQLException {        User user = new User();        user.setId(resultSet.getInt(&quot;id&quot;));        user.setName(resultSet.getString(&quot;name&quot;));        user.setAge(resultSet.getInt(&quot;age&quot;));        user.setJob(resultSet.getString(&quot;job&quot;));        return user;    }}</code></pre><p>然后在<code>DAO</code>层的<code>UserDaoImpl</code>，我们就可以引入<code>JdbcTemplate</code></p><pre><code class="java">    @Resource    private JdbcTemplate jdbcTemplate;    //使用jdbcTemplate查询    @Override    public User getUserByName(String name) throws Exception {        return jdbcTemplate.queryForObject(String.format(GET_USER_BY_NAME_SQL, name), new UserRowMapper());    }</code></pre><p>从这里可以看出实际上<code>Spring</code>框架就是采用这种思想来实现<code>JdbcTemplate</code>模板。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>所以在实际项目的开发中，我们有时候遇到某些代码块的前后都有重复操作时，可以采用模板模式去重构代码，使代码更加简洁，容易维护。</p><p>更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你用策略模式解决多重if-else</title>
    <link href="/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/"/>
    <url>/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>很多人可能在公司就是做普通的CRUD的业务，对于设计模式，即使学了好像也用处不大，顶多就在面试的时候能说上几种常见的单例模式，工厂模式。而在实际开发中，设计模式似乎很难用起来。</p><p>在现在的环境下，程序员的竞争已经非常激烈了，要体现出自身的价值，最直接的体现当然是差异化。这无需多说，我认为在实际开发中能运用设计模式，是很能体现差异化的。设计模式是一些前人总结的较好的方法，使程序能有更好的扩展性，可读性，维护性。</p><p>下面举个例子，使用策略模式解决多重if-else的代码结构。想学习更多的设计模式的实战经验，那就点个关注吧，谢谢大佬。</p><h1 id="使用if-else"><a href="#使用if-else" class="headerlink" title="使用if-else"></a>使用if-else</h1><p>假设我们要开发一个支付接口，要对接多种支付方式，通过渠道码区分各种的支付方式。于是定义一个枚举<code>PayEnum</code>，如下：</p><pre><code class="java">public enum PayEnum {    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;);    /**渠道*/    private String channel;    /**描述*/    private String description;    PayEnum(String channel, String description) {        this.channel = channel;        this.description = description;    }    /**以下省略字段的get、set方法*/</code></pre><p>创建一个<code>PayController</code>类，代码如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class PayController {    @Resource(name = &quot;payService&quot;)    private PayService payService;    /**    * 支付接口    * @param channel 渠道    * @param amount  消费金额    * @return String 返回消费结果    * @author Ye hongzhi    * @date 2020/4/5    */    @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        return payService.pay(channel,amount);    }}</code></pre><p>再创建一个<code>PayService</code>接口以及实现类<code>PayServiceImpl</code></p><pre><code class="java">public interface PayService {    /**    * 支付接口    * @param channel 渠道    * @param amount  金额    * @return String    * @author Ye hongzhi    * @date 2020/4/5    */    String pay(String channel,String amount)throws Exception;}</code></pre><pre><code class="java">@Service(&quot;payService&quot;)public class PayServiceImpl implements PayService {    private static String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    @Override    public String pay(String channel, String amount) throws Exception {        if (PayEnum.ALI_PAY.getChannel().equals(channel)) {            //支付宝            //业务代码...            return String.format(MSG,PayEnum.ALI_PAY.getDescription(),amount);        }else if(PayEnum.WECHAT_PAY.getChannel().equals(channel)){            //微信支付            //业务代码...            return String.format(MSG,PayEnum.WECHAT_PAY.getDescription(),amount);        }else if(PayEnum.UNION_PAY.getChannel().equals(channel)){            //银联支付            //业务代码...            return         String.format(MSG,PayEnum.UNION_PAY.getDescription(),amount);        }else if(PayEnum.XIAO_MI_PAY.getChannel().equals(channel)){            //小米支付            //业务代码...            return String.format(MSG,PayEnum.XIAO_MI_PAY.getDescription(),amount);        }else{            return &quot;输入渠道码有误&quot;;        }    }}</code></pre><p>然后通过浏览器，我们可以看到效果</p><p><img src="https://static.lovebilibili.com/01.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/02.png" srcset="/img/loading.gif" alt=""></p><p>这样看，以上代码的确可以实现需求，通过渠道码区分支付方式，可是看到上面那么多达4个的<code>if-else</code>的代码结构，已经开始显示出问题了。假设有更多的支付方式，那么这段代码就要写更多的<code>else if</code>去判断，这显然会不利于代码的扩展，这样会导致这个支付的方法越写越长。</p><p>在设计模式六大原则中，其中一个原则叫做<code>开闭原则</code>，对扩展开放，对修改关闭，应尽量在不修改原有代码的情况下进行扩展。</p><p>基于上面提到的<code>开闭原则</code>，我们可以使用策略模式进行重构。</p><h1 id="使用策略模式重构代码"><a href="#使用策略模式重构代码" class="headerlink" title="使用策略模式重构代码"></a>使用策略模式重构代码</h1><p>定义一个策略接口类<code>PayStrategy</code></p><pre><code class="java">public interface PayStrategy {    String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    String pay(String channel,String amount)throws Exception;}</code></pre><p>然后再创建四种策略实现类实现接口</p><pre><code class="java">@Component(&quot;aliPayStrategy&quot;)public class AliPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.ALI_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;wechatPayStrategy&quot;)public class WechatPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.WECHAT_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;unionPayStrategy&quot;)public class UnionPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.UNION_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;xiaomiPayStrategy&quot;)public class XiaomiPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.XIAO_MI_PAY.getDescription(),amount);    }}</code></pre><p>看到这里实际上已经很清晰了，思路就是通过渠道码，动态获取到具体的实现类，这样就可以实现不需要<code>if else</code>判断。怎么通过渠道码获取实现类呢？</p><p>在<code>PayEnum</code>枚举加上<code>BeanName</code>字段，然后增加一个通过渠道码获取<code>BeanName</code>的方法</p><pre><code class="java">    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;,&quot;aliPayStrategy&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;,&quot;wechatPayStrategy&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;,&quot;unionPayStrategy&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;,&quot;xiaomiPayStrategy&quot;);    /**策略实现类对应的 beanName*/    private String beanName;    /**     * 通过渠道码获取枚举     * */    public static PayEnum findPayEnumBychannel(String channel){        PayEnum[] enums = PayEnum.values();        for (PayEnum payEnum : enums){            if(payEnum.getChannel().equals(channel)){                return payEnum;            }        }        return null;    }    //构造器    PayEnum(String channel, String description, String beanName) {        this.channel = channel;        this.description = description;        this.beanName = beanName;    }</code></pre><p>这时候还差一个获取Spring上下文对象的工具类，于是我们创建一个<code>SpringContextUtil</code>类</p><pre><code class="java">@Componentpublic class SpringContextUtil implements ApplicationContextAware {    /**     * 上下文对象实例     */    private static ApplicationContext applicationContext;    /**     * 获取applicationContext     */    private static ApplicationContext getApplicationContext() {        return applicationContext;    }    /**     * 通过name获取Bean     * */    public static Object getBean(String name){        return getApplicationContext().getBean(name);    }    /**     * 通过name,以及Clazz返回指定的Bean     * */    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz){        return getApplicationContext().getBean(name,clazz);    }    @Override    @Autowired    public void setApplicationContext(ApplicationContext applicationContext) throws         BeansException {        SpringContextUtil.applicationContext = applicationContext;    }</code></pre><p>接着定义一个工厂类，通过渠道码获取对应的策略实现类</p><pre><code class="java">public class PayStrategyFactory {    /**     * 通过渠道码获取支付策略具体实现类     * */    public static PayStrategy getPayStrategy(String channel){        PayEnum payEnum = PayEnum.findPayEnumBychannel(channel);        if(payEnum == null){            return null;        }        return SpringContextUtil.getBean(payEnum.getBeanName(),PayStrategy.class);    }}</code></pre><p>最后我们再改造一下原来的<code>PayServiceImpl</code>的<code>pay</code>方法</p><pre><code class="java">@Overridepublic String pay(String channel, String amount) throws Exception {    PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);    if(payStrategy == null){        return &quot;输入渠道码有误&quot;;    }    return payStrategy.pay(channel,amount);}</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><blockquote><p>假设需要增加新的支付方式，就不需要再使用else if 去判断，而是在枚举中定义一个新的枚举对象，然后再增加一个策略实现类，实现对应的方法，那就可以很轻松地扩展。也实现了开闭原则。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>设计模式运用得熟练的话，很多代码可以写得很优雅。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot系列之自定义spring-boot-starter</title>
    <link href="/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/"/>
    <url>/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>传统的 Maven项目一般将需要被复用的组件做成 Module来进行管理，以便二次调用；而在 Spring Boot项目中我们则可以使用更加优雅的 Spring Boot Starter来完成这一切。</p><a id="more"></a><p>这个开箱即用的魔法特性很大程度上来源于各式各样 Spring Boot Starter的加持，而且随着版本的迭代 Starter家族成员日益庞大，而且各种优秀开源作者也提供了很多非常好用的Spring Boot Starter。</p><p>本文尝试自定义一个Spring Boot Starter用于图片链接转换BASE64编码。</p><h1 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h1><ol><li>在GItHub上创建base64util-spring-boot-starter项目，然后clone下来本地进行开发。</li></ol><p><img src="https://static.lovebilibili.com/Github_Create.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>pom.xml文件配置如下</li></ol><pre><code class="xml">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;&lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;0.0.1&lt;/version&gt;&lt;dependencies&gt;    &lt;!-- 引入SpringBoot自动配置jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ol start="3"><li>业务代码</li></ol><pre><code class="java">import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL;/** * @author Ye Hongzhi * @program Base64Util * @description * @date 2020-02-17 14:04 **/public class Base64Util {    /**     * 本地图片转为BASE64编码     *     * @param imgFile 本地图片地址     * @return BASE64 解码后的字符串编码     * @description: 根据图片地址转换为base64编码字符串     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static String getImageFile(String imgFile) {        byte[] data = null;        try (InputStream inputStream = new FileInputStream(imgFile)) {            data = new byte[inputStream.available()];            int length = inputStream.read(data);            if (length == -1) {                return null;            }        } catch (Exception e) {            e.printStackTrace();        }        // 加密        BASE64Encoder encoder = new BASE64Encoder();        if (data != null) {            return encoder.encode(data);        } else {            return null;        }    }    public static String image2Base64(String imgUrl) throws Exception {        URL url = new URL(imgUrl);        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();        try(InputStream inputStream = urlConnection.getInputStream();            ByteArrayOutputStream baos = new ByteArrayOutputStream()) {            urlConnection.connect();            byte[] buffer = new byte[1024];            int len;            //使用一个输入流从buffer里把数据读取出来            while ((len = inputStream.read(buffer)) != -1) {                //用输出流往buffer里写入数据，中间参数代表从哪个位置开始读，len代表读取的长度                baos.write(buffer, 0, len);            }            // 对字节数组Base64编码            return Base64.encode(baos.toByteArray());        } catch (Exception e) {            e.printStackTrace();        } finally {            if (urlConnection != null) {                urlConnection.disconnect();            }        }        return imgUrl;    }    /**     * BASE64编码转为图片     * 注意：&quot;data:image/jpeg;base64,&quot; 解码之前得去掉。     *     * @param imgStr base64编码字符串     * @param path   图片路径-具体到文件     * @return 是否转换成功     * @description: 将base64编码字符串转换为图片     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static boolean generateImage(String imgStr, String path) {        if (imgStr == null) {            return false;        }        try (OutputStream out = new FileOutputStream(path)) {            BASE64Decoder decoder = new BASE64Decoder();            // 解密            byte[] b = decoder.decodeBuffer(imgStr);            // 处理数据            for (int i = 0; i &lt; b.length; ++i) {                if (b[i] &lt; 0) {                    b[i] += 256;                }            }            out.write(b);            out.flush();            return true;        } catch (Exception e) {            e.printStackTrace();            return false;        }    }}</code></pre><ol start="4"><li>创建一个service调用，这里为了简单，就不定义为接口的形式</li></ol><pre><code class="java">public class Base64Service {    /**     * 本地图片转为BASE64编码     */    public String getImageFile(String imgFile) {        return Base64Util.getImageFile(imgFile);    }    /**     * BASE64编码转为图片     * */    public boolean generateImage(String imgStr, String path) {        return Base64Util.generateImage(imgStr,path);    }    /**     * 在线图片转为BASE64编码     * */    public String image2Base64(String imgUrl) throws Exception{        return Base64Util.image2Base64(imgUrl);    }}</code></pre><ol start="5"><li>关键的一步，使用配置类，把service定义成bean，加入到spring容器中管理</li></ol><pre><code class="java">@Configurationpublic class Base64AutoConfiguration {    @Bean    Base64Service base64Service(){        return new Base64Service();    }}</code></pre><ol start="6"><li>最关键一步在于需要在resources文件夹下创建<code>META-INF/spring.factories</code>，<code>spring.factories</code>里的代码如下:</li></ol><pre><code class="yaml">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.lovebilibili.me.config.Base64AutoConfiguration</code></pre><p>这一步是重点，因为Spring Boot应用在启动过程中会通过 <code>SpringFactoriesLoader</code> 加载所有 <code>META-INF/spring.factories</code> 文件，通过一系列的处理流程最终将 spring.factories 文件中的定义的各种 <code>beans</code> 装载入 ApplicationContext容器。</p><blockquote><p>至此，自定义的用于base64转码工具的spring-boot-starter就完成了</p><p>可以通过使用maven命令<code>mvn install</code>打包，传到私有/公有Maven仓库使用。</p><p>形成一个公共的模块，供有需要的项目使用。</p></blockquote><ol start="7"><li>完成后把代码推送到Github仓库中，方便以后继续优化。</li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li>在其他项目中的pom文件加入以下依赖：</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;    &lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.0.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在Controller层中，我们可以引入base64Service。</li></ol><pre><code class="java">@Resourceprivate Base64Service base64Service;</code></pre><ol start="3"><li>然后在Controller层中的@RequestMapping对应的方法中使用</li></ol><pre><code class="java">//把在线图片转为BASE64编码String base64 = base64Service.image2Base64(imgUrl);</code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要创建个人博客</title>
    <link href="/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>很高兴你能点进来看我的第一篇文章。</p><p>内容也和标题一样无聊，为什么要创建个人博客，既然我已经创建了还要找什么理由呢。但是你点进来很大原因是因为你还没有个人博客，所以想来听听我创建个人博客的理由，以此来驱动自己去创建个人博客。这非常好，证明你已经有冲动了，只差行动起来。</p><p>我的理由有以下几点：</p><ol><li>想要记录下一些自己的技术学习的过程。比记录在有道云笔记自己看更加有价值，因为博客是可以分享，可以传播，知识需要传播起来才有力量。这是最大的一个原因。</li><li>通过输出博客文章提升自己的技术水平。因为输出就是最好的学习，输出一篇好的技术文章，往往就是最好的学习方式。</li><li>通过这个博客和网友互相学习。毕竟外面的世界很大，可以通过博客这个窗口和网上的开发者互相学习讨论，不失为一种乐趣。</li><li>记录一些生活感想、读书笔记、美食经历等等。</li></ol><p>这就是我的理由。如果你想要创建个人博客的话，马上去做吧。</p><p>教程的话可以参考</p><p>B站up主“CodeSheep”的视频<a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></p><p>我的hexo主题使用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">fluid</a>,如果你觉得不错也可以使用哦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
