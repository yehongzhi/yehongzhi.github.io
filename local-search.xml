<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>List集合的坑</title>
    <link href="/2020/06/21/List%E9%9B%86%E5%90%88%E7%9A%84%E5%9D%91/"/>
    <url>/2020/06/21/List%E9%9B%86%E5%90%88%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学如逆水行舟，不进则退</p></blockquote><p>经过几年的工作经验，我发现<code>List</code>有很多坑，之前公司有些实习生一不小心就踩到了，所以我打算写一篇文章总结一下，希望看到这篇文章的人能不再踩到坑，代码没bug。做个快乐的程序员。</p><a id="more"></a><h3 id="迭代时删除元素"><a href="#迭代时删除元素" class="headerlink" title="迭代时删除元素"></a>迭代时删除元素</h3><p>使用<code>for-each</code>迭代遍历时，删除集合中的元素，会报错。</p><pre><code class="java">    private static List&lt;String&gt; list = new ArrayList&lt;&gt;();    static {        //初始化集合        for (int i = 1; i &lt;= 10; i++) {            list.add(String.valueOf(i));        }    }    public static void main(String[] args) {        //使用for-each迭代时删除元素        for (String str : list) {            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }    }</code></pre><p>或者你使用迭代器<code>Iterator</code>遍历时，删除元素。</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        Iterator&lt;String&gt; it = list.iterator();        while (it.hasNext()) {            String str = it.next();            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }    }</code></pre><p>以上两种情况都会报这个错：</p><pre><code class="java">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)    at java.util.ArrayList$Itr.next(ArrayList.java:851)</code></pre><p>这就是不正确的删除姿势，那怎么删呢？</p><p>使用<code>for-i</code>循环遍历删除(亲测有效)：</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        for (int i = 0; i &lt; list.size(); i++) {            String s = list.get(i);            if (&quot;1&quot;.equals(s)) {                list.remove(s);            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>使用<code>for-i</code>循环倒序遍历，删除元素。</p><pre><code class="java">    public static void main(String[] args) {        //使用for-i倒序遍历，删除元素        for (int i = list.size() - 1; i &gt;= 0; i--) {            String str = list.get(i);            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>使用<code>Iterator</code>的<code>remove()</code>方法删除。</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        Iterator&lt;String&gt; it = list.iterator();        while (it.hasNext()) {            String str = it.next();            if (&quot;1&quot;.equals(str)) {                it.remove();            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>要么潇洒一点，用<code>Lambda</code>表达式。在java8中，<code>List</code>增加了一个<code>removeIf()</code>方法用于删除。</p><pre><code class="java">    public static void main(String[] args) {        //使用removeIf()遍历时，删除元素。删除集合中为1的元素        list.removeIf(str -&gt; &quot;1&quot;.equals(str));        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><h3 id="使用asList-获得集合删除-增加"><a href="#使用asList-获得集合删除-增加" class="headerlink" title="使用asList()获得集合删除/增加"></a>使用asList()获得集合删除/增加</h3><p>看代码演示：</p><pre><code class="java">    public static void main(String[] args) {        List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6);        nums.add(7);    }</code></pre><pre><code class="java">    public static void main(String[] args) {        List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6);        nums.remove(1);    }</code></pre><p>如果你进行以上操作，就会看到报错：</p><pre><code class="java">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException    at java.util.AbstractList.remove(AbstractList.java:161)</code></pre><p>为什么会报这个错，看一下源代码就知道了！</p><pre><code class="java">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable {}</code></pre><p><code>ArrayList</code>不是<code>util</code>包的<code>ArrayList</code>，而是<code>Arrays</code>的一个内部类。因为继承了<code>AbstractList</code>抽象类，但是又没有实现<code>add()</code>、<code>remove()</code>方法。所以会调用抽象类的<code>add()</code>和<code>remove()</code>。<br>你猜猜抽象类的<code>add()</code>怎么着？</p><pre><code class="java">    public void add(int index, E element) {        throw new UnsupportedOperationException();    }    public E remove(int index) {        throw new UnsupportedOperationException();    }</code></pre><p>所以不能用<code>asList()</code>得到的集合去增删了！</p><h3 id="通过subList-方法获得集合后增删"><a href="#通过subList-方法获得集合后增删" class="headerlink" title="通过subList()方法获得集合后增删"></a>通过subList()方法获得集合后增删</h3><p>当使用<code>subList()</code>方法获得集合后删除，原(父)集合也会被删除。</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; subList = list.subList(0, 5);        System.out.println(list);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5]        subList.remove(&quot;1&quot;);        System.out.println(list);//[2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[2, 3, 4, 5]    }</code></pre><p>当使用<code>subList()</code>方法获得集合后增加元素，原(父)集合也会增加。</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; subList = list.subList(0, 5);        System.out.println(list);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5]        subList.add(&quot;11&quot;);        System.out.println(list);//[1, 2, 3, 4, 5, 11, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5, 11]    }</code></pre><p>大家看一下源码就知道什么原因了。</p><pre><code class="java">private class SubList extends AbstractList&lt;E&gt; implements RandomAccess {        public void add(int index, E e) {            rangeCheckForAdd(index);            checkForComodification();            //父集合添加元素            parent.add(parentOffset + index, e);            this.modCount = parent.modCount;            this.size++;        }        public E remove(int index) {            rangeCheck(index);            checkForComodification();            //父集合删除元素            E result = parent.remove(parentOffset + index);            this.modCount = parent.modCount;            this.size--;            return result;        }}</code></pre><p>如果希望截取的集合是和原集合互不干扰的话，可以这样：</p><pre><code class="java">List&lt;String&gt; subList = new ArrayList&lt;&gt;(list.subList(0, 5));</code></pre><h3 id="使用Collections-unmodifiableList-创建不可变集合也是可变的。"><a href="#使用Collections-unmodifiableList-创建不可变集合也是可变的。" class="headerlink" title="使用Collections.unmodifiableList()创建不可变集合也是可变的。"></a>使用Collections.unmodifiableList()创建不可变集合也是可变的。</h3><p>当不可变集合的原集合改变时，不可变集合也跟着改变。演示代码：</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(list);        System.out.println(unmodifiableList);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        //删除原集合元素        list.remove(&quot;1&quot;);        System.out.println(unmodifiableList);//[2, 3, 4, 5, 6, 7, 8, 9, 10]    }</code></pre><p>看源码就知道原因了：</p><pre><code class="java">    UnmodifiableList(List&lt;? extends E&gt; list) {        super(list);        this.list = list;    }</code></pre><p><strong>因为不可变集合的成员变量的引用是指向原集合的，所以当原集合改变时，不可变集合也会随之改变</strong>。</p><p>解决方式：使用<code>Guava</code>工具包的<code>ImmutableList.copyOf()</code>方法创建。</p><pre><code class="java">    public static void main(String[] args) throws Exception {        List&lt;String&gt; unmodifiableList = ImmutableList.copyOf(list);        list.remove(&quot;1&quot;);        System.out.println(unmodifiableList);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]    }</code></pre><p>创作不易，觉得有用就<strong>点个赞</strong>吧。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong><br><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
      <tag>经验总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC全局异常处理</title>
    <link href="/2020/06/14/SpringMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2020/06/14/SpringMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC全局异常处理"><a href="#SpringMVC全局异常处理" class="headerlink" title="SpringMVC全局异常处理"></a>SpringMVC全局异常处理</h1><p><code>SpringMVC</code>除了可以做<code>URL映射</code>和<code>请求拦截</code>外，还可以做<code>全局异常</code>的处理。全局异常处理可能我们平时比较少机会接触，但是每个项目都肯定会做这个处理。比如在上一间公司，是前后端分离的架构，所以后端只要有运行时异常就会报“系统异常，请稍后再试”。如果想要走上架构师的话，这个肯定是要学会的。</p><h2 id="SpringMVC全局异常处理机制"><a href="#SpringMVC全局异常处理机制" class="headerlink" title="SpringMVC全局异常处理机制"></a>SpringMVC全局异常处理机制</h2><p>首先，要知道全局异常处理，<code>SpringMVC</code>提供了两种方式：</p><ul><li>实现<code>HandlerExceptionResolver</code>接口，自定义异常处理器。</li><li>使用<code>HandlerExceptionResolver</code>接口的子类，也就是<code>SpringMVC</code>提供的异常处理器。</li></ul><p>所以，总得来说就两种方式，一种是自定义异常处理器，第二种是<code>SpringMVC</code>提供的。接下来先说<code>SpringMVC</code>提供的几种异常处理器的使用方式，然后再讲自定义异常处理器。</p><p><code>SpringMVC</code>提供的异常处理器有哪些呢？我们可以直接看源码的类图。</p><p><img src="https://static.lovebilibili.com/HandlerExceptionResolver.png" srcset="/img/loading.gif" alt=""></p><p>可以看出有四种：</p><ul><li><code>DefaultHandlerExceptionResolver</code>，默认的异常处理器。根据各个不同类型的异常，返回不同的异常视图。</li><li><code>SimpleMappingExceptionResolver</code>，简单映射异常处理器。通过配置异常类和view的关系来解析异常。</li><li><code>ResponseStatusExceptionResolver</code>，状态码异常处理器。解析带有<code>@ResponseStatus</code>注释类型的异常。</li><li><code>ExceptionHandlerExceptionResolver</code>，注解形式的异常处理器。对<code>@ExceptionHandler</code>注解的方法进行异常解析。</li></ul><h3 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h3><p>这个异常处理器是<code>SprngMVC</code>默认的一个处理器，处理一些常见的异常，比如：没有找到请求参数，参数类型转换异常，请求方式不支持等等。</p><p>接着我们看<code>DefaultHandlerExceptionResolver</code>类的<code>doResolveException()</code>方法：</p><pre><code class="java">    @Override    @Nullable    protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response,@Nullable Object handler, Exception ex) {        try {            if (ex instanceof HttpRequestMethodNotSupportedException) {                return handleHttpRequestMethodNotSupported((HttpRequestMethodNotSupportedException) ex, request,                        response, handler);            }            else if (ex instanceof HttpMediaTypeNotSupportedException) {                return handleHttpMediaTypeNotSupported((HttpMediaTypeNotSupportedException) ex, request, response,                        handler);            }            else if (ex instanceof HttpMediaTypeNotAcceptableException) {                return handleHttpMediaTypeNotAcceptable((HttpMediaTypeNotAcceptableException) ex, request, response,                        handler);            }            //省略...以下还有十几种异常的else-if        }catch (Exception handlerException) {            //是否打开日志，如果打开，那就记录日志            if (logger.isWarnEnabled()) {                logger.warn(&quot;Handling of [&quot; + ex.getClass().getName() + &quot;] resulted in Exception&quot;, handlerException);            }        }        return null;    }</code></pre><p>通过<code>if-else</code>判断，判断继承什么异常就显示对应的错误码和错误提示信息。由此可以知道，处理一般有两步，一是设置响应码，二是在响应头设置异常信息。下面是<code>MissingServletRequestPartException</code>的处理的源码：</p><pre><code class="java">    protected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex,            HttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {        //设置响应码，设置异常信息，SC_BAD_REQUEST就是400(bad request)        response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage());        return new ModelAndView();    }    //响应码    public static final int SC_BAD_REQUEST = 400;</code></pre><p>为什么要存在这个异常处理器呢？</p><p>从框架的设计理念来看，这种公共的、常见的异常应该交给框架本身来完成，是一些必需处理的异常。比如参数类型转换异常，如果程序员不处理，还有框架提供默认的处理方式，<strong>不至于出现这种错误而无法排查</strong>。</p><h3 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a>SimpleMappingExceptionResolver</h3><p>这种异常处理器需要提前配置异常类和对应的<code>view</code>视图。一般用于使用<code>JSP</code>的项目中，出现异常则通过这个异常处理器跳转到指定的页面。</p><p>怎么配置？首先搭建<code>JSP</code>项目我就不浪费篇幅介绍了。首先要加载一个<code>XML</code>文件。</p><pre><code class="java">@SpringBootApplication//在启动类，加载配置文件@ImportResource(&quot;classpath:spring-config.xml&quot;)public class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre><p>然后在<code>resources</code>目录下，创建一个<code>spring-config.xml</code>文件，内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;        &lt;!-- 定义默认的异常处理页面 --&gt;        &lt;property name=&quot;defaultErrorView&quot; value=&quot;err&quot;/&gt;        &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt;        &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;        &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常也页名作为值 --&gt;        &lt;property name=&quot;exceptionMappings&quot;&gt;            &lt;props&gt;                &lt;!-- 数组越界异常 --&gt;                &lt;prop key=&quot;java.lang.ArrayIndexOutOfBoundsException&quot;&gt;err/arrayIndexOutOfBounds&lt;/prop&gt;                &lt;!-- 空指针异常 --&gt;                &lt;prop key=&quot;java.lang.NullPointerException&quot;&gt;err/nullPointer&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>然后在<code>webapp</code>也就是存放<code>JSP</code>页面的目录下，创建两个<code>JSP</code>页面。</p><p><code>arrayIndexOutOfBounds.jsp</code>如下：</p><pre><code class="JSP">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;数组越界异常&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;数组越界异常&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%= ex.getMessage() %&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>nullPointer.jsp</code>如下：</p><pre><code class="JSP">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;空指针异常&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;空指针异常&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%=ex.getMessage()%&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>接着创建两个<code>Controller</code>，分别抛出空指针异常和数组越界异常。</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/null&quot;)    public String err() throws Exception{        String str = null;        //抛出空指针异常        int length = str.length();        System.out.println(length);        return &quot;index&quot;;    }    @RequestMapping(&quot;/indexOut&quot;)    public String indexOut() throws Exception{        int[] nums = new int[2];        for (int i = 0; i &lt; 3; i++) {            //抛出数组越界异常            nums[i] = i;            System.out.println(nums[i]);        }        return &quot;index&quot;;    }}</code></pre><p>启动项目后，我们发送两个请求，就可以看到：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_2.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/exceptionResolver_3.png" srcset="/img/loading.gif" alt=""></p><p>通过上述例子可以看出，其实对于现在<strong>前后端分离的项目</strong>来说，<strong>这种异常处理器已经不是很常用了</strong>。</p><h3 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h3><p>这种异常处理器主要用于处理带有<code>@ResponseStatus</code>注释的异常。下面演示一下使用方式。</p><p>首先自定义异常类继承<code>Exception</code>，并且使用<code>@ResponseStatus</code>注解修饰。如下：</p><pre><code class="java">//value需要使用HttpStatus枚举类型，HttpStatus.FORBIDDEN=403。@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;My defined Exception&quot;)public class DefinedException extends Exception{}</code></pre><p>然后再在<code>Controller</code>层抛出此异常。如下：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/myException&quot;)    public String ex(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception {        if (num == 1) {            //抛出自定义异常            throw new DefinedException();        }        return &quot;index&quot;;    }}</code></pre><p>然后启动项目，请求接口，可以看到如下信息：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_4.png" srcset="/img/loading.gif" alt=""></p><p>使用这种异常处理器，需要自定义一个异常，一定要一直往上层抛出异常，如果不往上层抛出，在<code>service</code>或者<code>dao</code>层就<code>try-catch</code>处理掉的话，是不会触发的。</p><h3 id="ExceptionHandlerExceptionResolver"><a href="#ExceptionHandlerExceptionResolver" class="headerlink" title="ExceptionHandlerExceptionResolver"></a>ExceptionHandlerExceptionResolver</h3><p>这个异常处理器才是最重要的，也是最常用，最灵活的，因为是使用注解。首先我们还是简单地演示一下怎么使用：</p><p>首先需要定义一个全局的异常处理器。</p><pre><code class="java">//这里使用了RestControllerAdvice，是@ResponseBody和@ControllerAdvice的结合//会把实体类转成JSON格式的提示返回，符合前后端分离的架构@RestControllerAdvicepublic class GlobalExceptionHandler {    //这里自定义了一个BaseException，当抛出BaseException异常就会被此方法处理    @ExceptionHandler(BaseException.class)    public ErrorInfo errorHandler(HttpServletRequest req, BaseException e) throws Exception {        ErrorInfo r = new ErrorInfo();        r.setMessage(e.getMessage());        r.setCode(ErrorInfo.ERROR);        r.setUrl(req.getRequestURL().toString());        return r;    }}</code></pre><p>然后我们自定义一个自定义异常类<code>BaseException</code>：</p><pre><code class="java">public class BaseException extends Exception {    public BaseException(String message) {        super(message);    }}</code></pre><p>然后在<code>Controller</code>层定义一个方法测试：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/base&quot;)    public String base() throws BaseException {        throw new BaseException(&quot;系统异常，请稍后重试。&quot;);    }}</code></pre><p>老规矩，启动项目，请求接口可以看到结果：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_1.jpg" srcset="/img/loading.gif" alt=""></p><p>你也可以不自定义异常<code>BaseException</code>，而直接拦截常见的各种异常都可以。所以这是一个非常灵活的异常处理器。你也可以做跳转页面，返回<code>ModelAndView</code>即可（以免篇幅过长就不演示了，哈哈）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>经过以上的演示后我们学习了<code>SpringMVC</code>四种异常处理器的工作机制，最后这种作为程序员我觉得是必须掌握的，前面的简单映射异常处理器和状态映射处理器可以选择性掌握，默认的异常处理器了解即可。</p><p>那这么多异常处理器，究竟是如何工作的呢？为什么是设计一个接口，下面有一个抽象类加上四个实现子类呢？接下来我们通过源码分析来揭开谜底！</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码分析从哪里入手呢？在<code>SpringMVC</code>中，其实你想都不用想，肯定在<code>DispatcherServlet</code>类里。经过我顺藤摸瓜，我定位在了<code>processHandlerException()</code>方法。怎么定位的呢？其实很简单，看源码：</p><pre><code class="java">    private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,            @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,            @Nullable Exception exception) throws Exception {        boolean errorView = false;        //异常不为空        if (exception != null) {            if (exception instanceof ModelAndViewDefiningException) {                logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);                mv = ((ModelAndViewDefiningException) exception).getModelAndView();            }            else {                Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);                //关键点：执行异常处理                mv = processHandlerException(request, response, handler, exception);                //省略...            }        }        //省略...    }</code></pre><h3 id="processHandlerException"><a href="#processHandlerException" class="headerlink" title="processHandlerException()"></a>processHandlerException()</h3><p>就是这个直接的一个<code>if-else</code>判断，那个<code>processHandlerException()</code>方法又是怎么处理的呢？</p><pre><code class="java">@Nullableprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,      @Nullable Object handler, Exception ex) throws Exception {   ModelAndView exMv = null;   //判断异常处理器的集合是否为空   if (this.handlerExceptionResolvers != null) {      //不为空则遍历异常处理器       for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {         //调用异常处理器的resolveException()方法进行处理异常         exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);         //判断返回的ModelAndView是否为null，不为null则跳出循环，为null则继续下一个异常处理器         if (exMv != null) {            break;         }      }   }   //如果ModelAndView不为空   if (exMv != null) {      if (exMv.isEmpty()) {         //设置异常信息提示         request.setAttribute(EXCEPTION_ATTRIBUTE, ex);         return null;      }      //如果返回的ModelAndView不包含view      if (!exMv.hasView()) {         //设置一个默认的视图          String defaultViewName = getDefaultViewName(request);         if (defaultViewName != null) {            exMv.setViewName(defaultViewName);         }      }      //省略...      //返回异常的ModelAndView          return exMv;   }   throw ex;}</code></pre><p>这不就是责任链模式吗！提前加载异常处理器到<code>handlerExceptionResolvers</code>集合中，然后遍历去执行，能处理就处理，不能处理就跳到下一个异常处理器处理。</p><p>那接下来我们就有一个问题了，<code>handlerExceptionResolvers</code>集合是怎么加载异常处理器的？这个问题很简单，就是使用<code>DispatcherServlet.properties</code>配置文件。这个文件真的很重要！！！</p><pre><code class="properties">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</code></pre><p>默认是加载以上三种异常处理器到集合中，所以只要带有<code>@ControllerAdvice</code>、<code>@ExceptionHandler</code>、<code>@ResponseStatus</code>注解的都会被扫描。<code>SimpleMappingExceptionResolver</code>则是通过<code>xml</code>文件(当然也可以使用<code>@Configuration</code>)去配置。</p><h3 id="resolveException"><a href="#resolveException" class="headerlink" title="resolveException()"></a>resolveException()</h3><p>其实在<code>resolveException()</code>处理异常的方法中，还使用了模板模式。</p><pre><code class="java">    @Override    @Nullable    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response,            @Nullable Object handler, Exception ex) {            //省略...            //预处理            prepareResponse(ex, response);            //调用了一个抽象方法，抽象方法由子类去实现            ModelAndView result = doResolveException(request, response, handler, ex);            //省略...    }</code></pre><p>抽象方法<code>doResolveException()</code>，由子类实现。</p><pre><code class="java">@Nullableprotected abstract ModelAndView doResolveException(HttpServletRequest request,      HttpServletResponse response, @Nullable Object handler, Exception ex);</code></pre><p>怎么识别模板方法，其实很简单，只要看到抽象类，有个具体方法里面调用了抽象方法，那很大可能就是模板模式。抽象方法就是模板方法，由子类实现。</p><p>子类我们都知道就是那四个异常处理器实现类了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用流程图概括一下：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_5.png" srcset="/img/loading.gif" alt=""></p><p>经过以上的学习后，我们知道只需要把异常处理器加到集合中，就可以执行。所以我们可以使用直接实现<code>HandlerExceptionResolver</code>接口的方式来实现异常处理器。</p><h2 id="实现HandlerExceptionResolver接口实现全局异常处理"><a href="#实现HandlerExceptionResolver接口实现全局异常处理" class="headerlink" title="实现HandlerExceptionResolver接口实现全局异常处理"></a>实现HandlerExceptionResolver接口实现全局异常处理</h2><p>首先自定一个异常类<code>MyException</code>。</p><pre><code class="java">public class MyException extends Exception {    public MyException(String message) {        super(message);    }}</code></pre><p>然后实现<code>HandlerExceptionResolver</code>接口定义一个异常处理器。</p><pre><code class="java">//注册异常处理器到Spring容器中@Componentpublic class MyExceptionHandler implements HandlerExceptionResolver {    @Override    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {        try {            //如果属于MyException异常，则输出异常提示到页面            if (ex instanceof MyException) {                response.setContentType(&quot;text/html;charset=utf-8&quot;);                response.getWriter().println(ex.getMessage());                //这里返回null，不做处理。也可以返回ModelAndView跳转页面                return null;            }        } catch (IOException e) {            e.printStackTrace();        }        return null;    }}</code></pre><p>然后在<code>Controller</code>层定义一个方法测试：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/myEx&quot;)    public String myEx() throws MyException {        System.out.println(&quot;执行myEx()&quot;);        throw new MyException(&quot;自定义异常提示信息&quot;);    }}</code></pre><p>启动项目，请求接口，我们可以看到：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_6.png" srcset="/img/loading.gif" alt=""></p><h1 id="最后说几句"><a href="#最后说几句" class="headerlink" title="最后说几句"></a>最后说几句</h1><p>以上就是我对于<code>SpringMVC</code>全局异常处理机制的理解。更多的<code>java</code>技术分享，可以关注我的公众号“<strong>java技术爱好者</strong>”，后续会不断更新。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringMVC</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题总结-基础篇</title>
    <link href="/2020/06/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2020/06/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="JVM、JRE、JDK有什么联系与区别？"><a href="#JVM、JRE、JDK有什么联系与区别？" class="headerlink" title="JVM、JRE、JDK有什么联系与区别？"></a>JVM、JRE、JDK有什么联系与区别？</h3><p><strong>JVM是java虚拟机</strong>，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。<br><strong>JRE是java运行时环境</strong>，它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。换句话说，JRE包含JVM。<br><strong>JDK是java开发工具包</strong>，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。JDK包含JRE。<br>所以总得来说，<strong>JDK&gt;JRE&gt;JVM</strong>。</p><h3 id="面向对象的特征有哪些？"><a href="#面向对象的特征有哪些？" class="headerlink" title="面向对象的特征有哪些？"></a>面向对象的特征有哪些？</h3><p>有三大特征，继承，封装，多态。</p><h3 id="为什么java可以实现跨平台？"><a href="#为什么java可以实现跨平台？" class="headerlink" title="为什么java可以实现跨平台？"></a>为什么java可以实现跨平台？</h3><p>因为java是编译成.class文件运行在JVM上的。<strong>针对不同的系统有不同的JVM实现，在不同的JVM实现上会映射到不同系统的 API 调用</strong>，从而实现代码的跨平台运行。</p><h3 id="类的加载顺序？"><a href="#类的加载顺序？" class="headerlink" title="类的加载顺序？"></a>类的加载顺序？</h3><p>静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。</p><h3 id="接口和抽象类有什么共同点和不同点？"><a href="#接口和抽象类有什么共同点和不同点？" class="headerlink" title="接口和抽象类有什么共同点和不同点？"></a>接口和抽象类有什么共同点和不同点？</h3><p>共同点：<br>1.都可以定义抽象方法，子类都要实现定义的抽象方法。<br>2.都不能被实例化，但是可以定义抽象类和接口类型的引用。<br>不同点：<br>1.接口没有构造器，抽象类可以定义构造器。<br>2.接口定义具体方法只能定义<strong>default</strong>修饰，抽象类可以直接定义具体方法。<br>3.接口的子类是实现接口，关键字是<strong>implements</strong>，抽象类的子类是继承，关键字是<strong>extends</strong>。<br>4.接口不能定义成员变量，只能定义常量。抽象类可以定义成员变量。</p><h3 id="static关键字有哪些用法？"><a href="#static关键字有哪些用法？" class="headerlink" title="static关键字有哪些用法？"></a>static关键字有哪些用法？</h3><p>①<strong>修饰成员变量，用static修饰的成员变量就成为静态变量</strong>，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。<br>②<strong>static修饰方法，该方法就被定义为静态方法</strong>，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。<br>③<strong>用static修饰代码块，该代码块就被定义为静态代码块</strong>，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。</p><h3 id="Switch能用什么数据类型作为参数？"><a href="#Switch能用什么数据类型作为参数？" class="headerlink" title="Switch能用什么数据类型作为参数？"></a>Switch能用什么数据类型作为参数？</h3><p>JDK1.5前：<strong>byte、short、char、int</strong><br>JDK1.5：枚举<br>JDK1.7：String</p><h3 id="枚举有哪些特点？在项目中如何使用？"><a href="#枚举有哪些特点？在项目中如何使用？" class="headerlink" title="枚举有哪些特点？在项目中如何使用？"></a>枚举有哪些特点？在项目中如何使用？</h3><p>特点：<br>1.枚举的构造器是私有的。<br>2.枚举不能被继承。<br>3.枚举是绝对的单例，即使是反序列化也无法创建多个实例。<br>使用场景：<br>当变量只能从一堆固定的值中取出一个时，那么就应该使用枚举。比如时间的单位，季度等等。</p><h3 id="什么是方法重载？什么是方法重写？"><a href="#什么是方法重载？什么是方法重写？" class="headerlink" title="什么是方法重载？什么是方法重写？"></a>什么是方法重载？什么是方法重写？</h3><p><strong>方法重载</strong>，一个类中允许同时存在一个以上的同名方法，主要体现在方法参数的类型和数量不同，方法名相同，与访问修饰符和返回值类型都是无关的。口诀是”<strong>一同两不同</strong>“。<br><strong>方法重写</strong>一般在继承中，子类重写父类的方法，既然是重写一遍，那么方法名和参数部分一定是相同的。只是实现的功能不同。<strong>声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，声明为 private 的方法不能被重写。</strong></p><h3 id="静态变量和实例变量有什么不同？分别位于内存的什么区域？"><a href="#静态变量和实例变量有什么不同？分别位于内存的什么区域？" class="headerlink" title="静态变量和实例变量有什么不同？分别位于内存的什么区域？"></a>静态变量和实例变量有什么不同？分别位于内存的什么区域？</h3><p>1.静态变量使用static修饰，实例变量不需要。<br>2.静态变量在类被加载时就会分配内存空间，就可以使用。实例变量需要实例对象才会分配内存空间，才可以被引用，是属于实例的。<br>3.静态变量是存在于<strong>静态区(全局区)</strong>的，实例变量位于<strong>堆内存</strong>中。</p><h3 id="java的内部类的分类有哪些？"><a href="#java的内部类的分类有哪些？" class="headerlink" title="java的内部类的分类有哪些？"></a>java的内部类的分类有哪些？</h3><p>实例内部类、静态内部类、局部内部类、匿名内部类。</p><h3 id="break、continue、return-的作用是什么？"><a href="#break、continue、return-的作用是什么？" class="headerlink" title="break、continue、return 的作用是什么？"></a>break、continue、return 的作用是什么？</h3><ul><li>break：结束循环。不仅可以结束其所在的循环，还可结束其外层循环。</li><li>continue：跳过本次循环，开始下一次循环。</li><li>return：不是专用于结束循环，而是用于结束方法。如果在循环中使用return，就会结束整个方法，循环当然也会结束。<h3 id="Object类有哪些常用的方法？"><a href="#Object类有哪些常用的方法？" class="headerlink" title="Object类有哪些常用的方法？"></a>Object类有哪些常用的方法？</h3></li></ul><p><strong>toString()、equals()、hashCode()。</strong></p><ul><li><code>toString()</code>默认输出对象的内存地址，一般不希望输出内存地址可以重写toString()方法。</li><li><code>equals()</code>方法用于比较对象是否相等，默认比较是内存地址，所以要正确比较两个对象是否值相等，此方法必须被重写。</li><li><code>hashCode()</code>方法用来返回其所在对象的物理地址（哈希码值），常会和<code>equals()</code>方法同时重写，确保相等的两个对象拥有相等的<strong>hashCode</strong>。<h3 id="与equals-的区别？"><a href="#与equals-的区别？" class="headerlink" title="==与equals()的区别？"></a>==与equals()的区别？</h3><code>equals()</code>方法属于<code>Object</code>对象的，所以比较基础数据类型是不能使用<code>equals()</code>。必须使用<code>==</code>。</li></ul><p><strong>在默认情况下</strong>，<code>equals()</code>与<code>==</code>是一样的，都是比较内存地址。所以在业务逻辑中，我们一般会重写<code>equals()</code>方法。</p><h3 id="equals-与hashCode-有什么联系？"><a href="#equals-与hashCode-有什么联系？" class="headerlink" title="equals()与hashCode()有什么联系？"></a>equals()与hashCode()有什么联系？</h3><p>1.<code>equals()</code>相等的两个对象他们的<code>hashCode()</code>肯定相等，也就是用<code>equals()</code>对比是绝对可靠的。<br>2.<code>hashCode()</code>相等的两个对象他们的<code>equals()</code>不一定相等，也就是<code>hashCode()</code>不是绝对可靠的。<br>在使用<code>HashSet</code>或者<code>HashMap</code>集合中，比较两个对象是否相等时，会先调用<code>hashCode()</code>比较，如果<code>hashCode()</code>相等，则会继续调用<code>equals()</code>比较，<code>equals()</code>也相等才会认为是同一个对象。如果<code>hashCode()</code>返回不相等，则认为是不相等的对象。<br>所以一般我们会同时重写<code>hashCode()</code>和<code>equals()</code>方法。</p><h3 id="amp-和-amp-amp-有什么区别？"><a href="#amp-和-amp-amp-有什么区别？" class="headerlink" title="&amp; 和 &amp;&amp;有什么区别？"></a>&amp; 和 &amp;&amp;有什么区别？</h3><p><code>&amp;&amp;</code>具有短路的功能，也就是如果<code>&amp;&amp;</code>左边的条件为<code>fasle</code>就不再执行后面的条件判断。<br><code>&amp;</code>则会执行完左右两边的条件判断。</p><h3 id="final、finalize-、finally-分别有什么作用？"><a href="#final、finalize-、finally-分别有什么作用？" class="headerlink" title="final、finalize()、finally{}分别有什么作用？"></a>final、finalize()、finally{}分别有什么作用？</h3><p><code>final</code>修饰类，表明这个类不可被其他类继承。<br><code>final</code>修饰成员变量，表示此变量为常量，只能在初始化时被赋值一次，赋值后不能修改。<br><code>final</code>修饰方法。把方法锁定，不能被子类重写，以防止子类对其进行更改。<br><code>finalize()</code>是<code>Object</code>里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。一个对象的<code>finalize()</code>方法只会被调用一次。<br><code>finally</code>作为异常处理的一部分，它只能用在<code>try/catch</code>语句中，并且附带一个语句块。</p><h3 id="Cloneable接口有什么作用？"><a href="#Cloneable接口有什么作用？" class="headerlink" title="Cloneable接口有什么作用？"></a>Cloneable接口有什么作用？</h3><p><code>Cloneable</code>接口是一个标记接口，实现了此接口，表示可以使用<code>clone()</code>方法，没有实现此接口使用<code>clone()</code>会抛出<code>CloneNotSupportedException</code>异常。</p><h3 id="什么是浅克隆，什么是深克隆？"><a href="#什么是浅克隆，什么是深克隆？" class="headerlink" title="什么是浅克隆，什么是深克隆？"></a>什么是浅克隆，什么是深克隆？</h3><p><strong>浅克隆是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量）</strong>，而不拷贝对象包含的引用指向的对象。</p><p><strong>深克隆不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。</strong></p><h3 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h3><p>序列化：把<strong>对象</strong>转换为<strong>字节序列</strong>的过程称为对象的序列化。<br>反序列化：把<strong>字节序列</strong>恢复为<strong>对象</strong>的过程称为对象的反序列化。</p><h3 id="Serializable接口有什么作用？"><a href="#Serializable接口有什么作用？" class="headerlink" title="Serializable接口有什么作用？"></a>Serializable接口有什么作用？</h3><p><code>Serializable</code>接口是一个标记接口，一个类只有实现了<code>Serializable</code>接口，它的对象才是可序列化的。否则序列化时会报<code>NotSerializableException</code>异常。如果不显性声明<code>serialVersionUID</code>，则会默认生成一个。为了<code>serialVersionUID</code>的确定性，最好是显性声明。</p><h3 id="String、StringBuffer、StringBuilder有什么区别"><a href="#String、StringBuffer、StringBuilder有什么区别" class="headerlink" title="String、StringBuffer、StringBuilder有什么区别?"></a>String、StringBuffer、StringBuilder有什么区别?</h3><ul><li><code>String</code>被声明为<code>final class</code>，是由定义<code>final</code>的字符数组实现的，因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。<ul><li><code>StringBuffer</code>是由定义了临时数据<code>transient</code>的字符数组实现的，提供<code>append()</code>和<code>add()</code>方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列，所有修改数据的方法都加上<code>synchronized</code>。性能相对<code>StringBuilder</code>会差一点。</li></ul></li><li><code>StringBuilder</code>和<code>StringBuffer</code>本质上没什么区别，区别是去掉了保证线程安全的<code>synchronized</code>，减少了开销，性能有所提高。<h3 id="什么是泛型-什么是泛型的上界和下界"><a href="#什么是泛型-什么是泛型的上界和下界" class="headerlink" title="什么是泛型?什么是泛型的上界和下界?"></a>什么是泛型?什么是泛型的上界和下界?</h3>Java 泛型是 JDK1.5中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<br>上界用<code>extends</code>关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。<br>下界用<code>super</code>进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至Object。<h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><strong>Java反射机制</strong>是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在<strong>运行时动态的获取信息以及动态调用对象的方法的功能</strong>称为Java的反射机制。<h3 id="获取Class对象的方式有哪些？"><a href="#获取Class对象的方式有哪些？" class="headerlink" title="获取Class对象的方式有哪些？"></a>获取Class对象的方式有哪些？</h3><ul><li>通过<code>Object</code>类中的<code>getClass()</code>方法，想要用这种方法必须要明确具体的类并且创建该类的对象。</li><li>所有数据类型都具备一个静态的属性<code>.class</code>来获取对应的<code>Class</code>对象。但是还是要明确到类，然后才能调用类中的静态成员。</li><li>通过<code>Class.forName()</code>方法完成，必须要指定类的全限定名，由于前两种方法都是在知道该类的情况下获取该类的字节码对象，因此不会有异常，但是<code>Class.forName()</code>方法如果写错类的路径会报<code>ClassNotFoundException</code>的异常。<h3 id="java中的异常有哪几种异常？"><a href="#java中的异常有哪几种异常？" class="headerlink" title="java中的异常有哪几种异常？"></a>java中的异常有哪几种异常？</h3><code>Throwable</code>类是<code>Java</code>异常类型的顶层父类，<code>Throwable</code>包含了<code>Error</code>和<code>Excetion</code>。<code>Excetion</code>分为两种，一种是<strong>非运行时异常(又称为检查异常)</strong>，另一种是<strong>运行时异常(RuntimeException)</strong>。<h3 id="java是如何处理异常的？"><a href="#java是如何处理异常的？" class="headerlink" title="java是如何处理异常的？"></a>java是如何处理异常的？</h3></li><li><code>Error</code>是程序无法处理的, 比如<code>OutOfMemoryError</code>、<code>OutOfMemoryError</code>等等, 这些异常发生时, <code>JVM</code>一般会终止线程。</li><li>运行时异常(<code>RuntimeException</code>)，如 <code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>等，是在程序运行的时候可能会发生的，所以程序可以捕捉，也可以不捕捉。这些错误一般是由程序的逻辑错误引起的，<strong>程序应该从逻辑角度去尽量避免</strong>。</li><li>非运行时异常是<code>RuntimeException</code>以外的异常，是<code>Exception</code>及其子类，这些异常从程序的角度来说是必须经过捕捉检查处理的，否则不能通过编译。如<code>IOException</code>、<code>SQLException</code>等。<h1 id="java集合、IO流、日期处理等"><a href="#java集合、IO流、日期处理等" class="headerlink" title="java集合、IO流、日期处理等"></a>java集合、IO流、日期处理等</h1><h3 id="常用的集合有哪些？"><a href="#常用的集合有哪些？" class="headerlink" title="常用的集合有哪些？"></a>常用的集合有哪些？</h3>常用集合有<strong>Map、List、Set</strong>。<h3 id="HashMap是线程安全的吗？"><a href="#HashMap是线程安全的吗？" class="headerlink" title="HashMap是线程安全的吗？"></a>HashMap是线程安全的吗？</h3>不是线程安全的。<h3 id="如何使HashMap线程安全？"><a href="#如何使HashMap线程安全？" class="headerlink" title="如何使HashMap线程安全？"></a>如何使HashMap线程安全？</h3>使用<code>Collections</code>类的<code>synchronizedMap()</code>方法包装。<pre><code class="java">Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</code></pre>使用<code>java.util.concurrent</code>包下的<code>ConcurrentHashMap</code>类也可以获得线程安全的Map。<pre><code class="java">ConcurrentHashMap concurrentHashMap = new ConcurrentHashMap();</code></pre>使用<code>Hashtable</code>类，也可以获得线程安全的Map<pre><code class="java">Map&lt;String,Object&gt; hashtable = new Hashtable&lt;&gt;();</code></pre><h3 id="HashMap和Hashtable的区别是什么？"><a href="#HashMap和Hashtable的区别是什么？" class="headerlink" title="HashMap和Hashtable的区别是什么？"></a>HashMap和Hashtable的区别是什么？</h3></li><li><code>Hashtable</code>继承自<code>Dictionary</code>类，而<code>HashMap</code>继承自<code>AbstractMap</code>类。但二者都实现了Map接口。</li><li><code>Hashtable</code>是线程安全的，<code>HashMap</code>是线程不安全的。</li><li><code>Hashtable</code>中，key和value都不允许出现null值。</li><li><code>HashTable</code>在不指定容量的情况下的<strong>默认容量为11，而HashMap为16</strong>，<code>Hashtable</code>不要求底层数组的容量一定要为2的整数次幂，而<code>HashMap</code>则要求一定为2的整数次幂。<code>Hashtable</code>扩容时，将容量变为原来的2倍加1，而<code>HashMap</code>扩容时，将容量变为原来的2倍。<h3 id="HashMap是如何解决哈希冲突的？"><a href="#HashMap是如何解决哈希冲突的？" class="headerlink" title="HashMap是如何解决哈希冲突的？"></a>HashMap是如何解决哈希冲突的？</h3></li><li>在JDK1.8前，<code>HashMap</code>是采用<strong>链表法</strong>解决哈希冲突的。当<code>put()</code>一个值到<code>Map</code>时，会通过<code>Key</code>拿到一个哈希值，通过哈希值获取数组下标，先查询是否存在该<code>hash</code>值。若不存在，则直接以<code>Entry&lt;V,V&gt;</code>的方式存放在数组中。若存在，则再调用<code>equals()</code>方法对比<code>key</code>是否相同，若<code>hashcode()</code>值和<code>key</code>都相同，则替换<code>value</code>，若<code>hashcode()</code>值相同，<code>key</code>不相同，则形成一个单链表，将<code>hashcode()</code>值相同，<code>key</code>不同的元素以<code>Entry&lt;V,V&gt;</code>的方式存放在链表中，这样就解决了哈希冲突。</li><li>JDK1.8以后，当链表的长度达到某个限制值(默认是8)，就会转换成<strong>红黑树</strong>，提高性能。<h3 id="HashMap初始大小是多少？负载因子是多少？"><a href="#HashMap初始大小是多少？负载因子是多少？" class="headerlink" title="HashMap初始大小是多少？负载因子是多少？"></a>HashMap初始大小是多少？负载因子是多少？</h3>默认的数组初始大小是16。负载因子是0.75。</li></ul><strong>（为什么初始值是2的n次方，为什么负载因子取0.75，这两个问题可以网上找资料看看，这里就不详述了）</strong><h3 id="简述一下HashMap的扩容机制？"><a href="#简述一下HashMap的扩容机制？" class="headerlink" title="简述一下HashMap的扩容机制？"></a>简述一下HashMap的扩容机制？</h3><code>HashMap</code>是懒加载的，当调用<code>put()</code>方法时，会先初始化<code>Map</code>的大小，默认数组长度是16，负载因子是0.75，所以阈值是12。当<code>HashMap</code>元素的个数超过阈值时，就会把数组的大小扩展到原来的2倍，然后重新计算每个元素在数组中的位置。<h3 id="List有哪些常用的子类？"><a href="#List有哪些常用的子类？" class="headerlink" title="List有哪些常用的子类？"></a>List有哪些常用的子类？</h3><code>ArrayList</code>和<code>LinkedList</code>。<h3 id="ArrayList和LinkedList有什么区别？"><a href="#ArrayList和LinkedList有什么区别？" class="headerlink" title="ArrayList和LinkedList有什么区别？"></a>ArrayList和LinkedList有什么区别？</h3><ul><li>底层<strong>数据结构不同</strong>。<code>ArrayList</code>基于数组+动态扩容实现的，<code>LinkedList</code>基于双向链表实现。从储存结构上分析，<code>LinkedList</code>更加占内存，因为每个节点除了存储数据外还要<strong>存储指向前节点的引用和指向后节点的引用。</strong></li><li><strong>效率不同</strong>。当随机访问时，<code>ArrayList</code>是基于数组下标访问，<strong>查询效率较高</strong>，但是由于数组的长度是固定的，所以当添加的元素到一定的阈值时会扩容数组，消耗性能，<strong>增删效率偏低</strong>。<code>LinkedList</code>在查询时，需要从前到后依次遍历，所以<strong>查询效率不高</strong>，但是在增删时只需要更改节点的引用，开销较少，所以<strong>增删效率较高</strong>。<h3 id="List集合排序的方式有哪些？"><a href="#List集合排序的方式有哪些？" class="headerlink" title="List集合排序的方式有哪些？"></a>List集合排序的方式有哪些？</h3>使用List接口定义的sort()方法。<pre><code class="java">list.sort(Comparator.comparingInt(User::getAge));</code></pre>使用<code>Collections</code>的<code>sort()</code>方法，排序的对象需要实现<code>Comparable</code>接口，重写<code>compareTo()</code>方法。<pre><code class="java">//实现Comparable接口public class User implements Comparable&lt;User&gt; {//重写compareTo方法@Overridepublic int compareTo(User user) {      return Integer.compare(this.getAge(), user.getAge());}}</code></pre>使用<code>Collections</code>的<code>sort()</code>方法<pre><code class="java">Collections.sort(list);//如果不想实现Comparable接口，也可以使用这个方法Collections.sort(list,Comparator.comparingInt(User::getAge));</code></pre>使用Stream流操作的<code>sort()</code>方法，传入一个<code>Comparator</code>接口。<pre><code class="java">list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList());</code></pre><h3 id="栈和队列的特点分别是什么？在java中有哪些实现的类？"><a href="#栈和队列的特点分别是什么？在java中有哪些实现的类？" class="headerlink" title="栈和队列的特点分别是什么？在java中有哪些实现的类？"></a>栈和队列的特点分别是什么？在java中有哪些实现的类？</h3>栈是<strong>先进后出</strong>，队列是<strong>先进先出</strong>。<br><code>Stack</code>类是栈在java中的实现，继承<code>Vector</code>类，底层是基于数组存储数据。<br><code>Queue</code>接口是队列在java中的代表，<code>Queue</code>接口有几个常用的子类<code>ArrayDeque</code>、<code>LinkedList</code>。<h3 id="IO、NIO有什么区别？"><a href="#IO、NIO有什么区别？" class="headerlink" title="IO、NIO有什么区别？"></a>IO、NIO有什么区别？</h3>IO包括：<code>File</code>、<code>OutputStream</code>、<code>InputStream</code>、<code>Writer</code>，<code>Reader</code>。<br>NIO三大核心：<code>selector</code>（选择器），<code>channel</code>（通道），<code>buffer</code>（缓冲区）<br>NIO与IO区别在于，IO面向流，NIO面向缓冲区。IO是阻塞，NIO是非阻塞。<h3 id="如何进行日期的转换？"><a href="#如何进行日期的转换？" class="headerlink" title="如何进行日期的转换？"></a>如何进行日期的转换？</h3>使用<code>SimpleDateFormat</code>类进行<code>String</code>和<code>Date</code>之间的转换。<h3 id="如何获取上一年的今天的日期？"><a href="#如何获取上一年的今天的日期？" class="headerlink" title="如何获取上一年的今天的日期？"></a>如何获取上一年的今天的日期？</h3>使用<code>Calendar</code>对象。如下所示：<pre><code class="java">//创建Calendar对象Calendar calendar = Calendar.getInstance();//设置年份，当前年份减去一年calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1);//以下是打印结果Date time = calendar.getTime();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);System.out.println(sdf.format(time));//2019-06-08 23:43:14 正确</code></pre><h3 id="BigDecimal类型一定不会失真吗？"><a href="#BigDecimal类型一定不会失真吗？" class="headerlink" title="BigDecimal类型一定不会失真吗？"></a>BigDecimal类型一定不会失真吗？</h3>不一定。<br>参数类型为<code>double</code>的构造方法的结果有一定的不可预知性，是有可能产生失真的。<pre><code class="java">BigDecimal bigDecimal = new BigDecimal(0.99);System.out.println(bigDecimal);//结果如下//0.9899999999999999911182158029987476766109466552734375</code></pre>使用参数类型<code>String</code>构造方法是完全可预知的，不会产生失真。所以在开发中推荐使用参数类型<code>String</code>构造方法。<h1 id="java并发编程"><a href="#java并发编程" class="headerlink" title="java并发编程"></a>java并发编程</h1><h3 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h3></li><li>避免主线程阻塞，可以使用多线程做成异步调用。</li><li>提升性能，充分利用CPU资源。<h3 id="创建线程有哪几种方法？"><a href="#创建线程有哪几种方法？" class="headerlink" title="创建线程有哪几种方法？"></a>创建线程有哪几种方法？</h3></li><li>通过继承<code>Thread</code>类创建线程类。</li><li>通过实现<code>Runnable</code>接口创建线程类。</li><li>通过实现<code>Callable</code>接口创建线程类。<h3 id="如何获取多线程的返回值？"><a href="#如何获取多线程的返回值？" class="headerlink" title="如何获取多线程的返回值？"></a>如何获取多线程的返回值？</h3>使用<code>Callable</code>和<code>FutureTask</code>接口，获取返回值。<pre><code class="java">public static void main(String[] args) throws Exception {  try {      //使用匿名内部类创建Callable      Callable callable = () -&gt; &quot;hello call&quot;;      FutureTask futureTask = new FutureTask(callable);      //执行线程      new Thread(futureTask).start();      if (!futureTask.isDone()) {          //获取返回值          System.out.println(futureTask.get());      }  } catch (Exception e) {      e.printStackTrace();  }}</code></pre><h3 id="多线程的生命周期？"><a href="#多线程的生命周期？" class="headerlink" title="多线程的生命周期？"></a>多线程的生命周期？</h3>新建状态、就绪状态、运行状态、阻塞状态、死亡状态<h3 id="如何进行线程之间的通信？"><a href="#如何进行线程之间的通信？" class="headerlink" title="如何进行线程之间的通信？"></a>如何进行线程之间的通信？</h3></li><li>使用<code>synchronized、wait()、notify()</code></li><li>使用JUC工具类<code>CountDownLatch</code></li><li>使用<code>ReentrantLock</code>结合<code>Condition</code></li><li>基本<code>LockSupport</code>实现线程间的阻塞和唤醒</li></ul></li></ul><p>以上几种方式的具体实现代码，可以网上找一下资料，这里不演示了。</p><h3 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h3><p>相同点：</p><ul><li><code>sleep()</code>方法和<code>wait()</code>方法都用来改变线程的状态，能够让线程从<strong>运行状态</strong>，转变为<strong>休眠状态</strong>。</li></ul><p>不同点：</p><ul><li><code>sleep()</code>方法是<code>Thread</code>类中的静态方法，而<code>wait()</code>方法是<code>Object</code>类中的方法。</li><li><code>sleep()</code>方法可以在任何地方调用，而wait()方法只能在同步代码块或同步方法中使用(即使用<code>synchronized</code>关键字修饰的)。</li><li>这两个方法都在同步代码块或同步方法中使用时，<code>sleep()</code>方法不会释放对象锁。而<code>wait()</code>方法则会释放对象锁。<h3 id="如何停止线程？"><a href="#如何停止线程？" class="headerlink" title="如何停止线程？"></a>如何停止线程？</h3></li><li>使用退出标志，使线程正常退出，也就是当<code>run()</code>方法完成后线程终止。</li><li>使用<code>stop()</code>方法强行终止(不推荐)，可能会出现数据不同步，或者资源未释放等问题。</li><li>使用<code>interrupt()</code>方法中断线程。<h3 id="什么是线程的死锁？如何避免线程死锁？"><a href="#什么是线程的死锁？如何避免线程死锁？" class="headerlink" title="什么是线程的死锁？如何避免线程死锁？"></a>什么是线程的死锁？如何避免线程死锁？</h3>多个线程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进，这种现象称为死锁。</li></ul><p>避免死锁的三种方式：</p><ul><li>加锁顺序（线程按照一定的顺序加锁）</li><li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）<h3 id="线程池的作用？"><a href="#线程池的作用？" class="headerlink" title="线程池的作用？"></a>线程池的作用？</h3></li><li>利用线程池管理并复用线程，减少创建线程和销毁线程的资源消耗。</li><li>实现任务线程队列缓存策略和拒绝机制。</li><li>可以对线程进行统一的分配，监控和调优。</li><li>提供定时执行、最大线程数、并发数控制等功能。<h3 id="创建线程池的重要参数分别代表什么意思？"><a href="#创建线程池的重要参数分别代表什么意思？" class="headerlink" title="创建线程池的重要参数分别代表什么意思？"></a>创建线程池的重要参数分别代表什么意思？</h3></li><li><code>corePoolSize</code>线程池核心线程大小。在没有设置 <code>allowCoreThreadTimeOut</code>为<code>true</code>的情况下，核心线程会在线程池中一直存活，即使处于闲置状态。当向线程池提交一个任务时，若线程池已创建的线程数小于<code>corePoolSize</code>，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于<code>corePoolSize</code>。</li><li><code>maximumPoolSize</code>线程池最大线程数量。线程池所允许的最大线程个数。<strong>当队列满了</strong>，且已创建的线程数小于<code>maximumPoolSize</code>，则线程池会创建新的线程来执行任务。对于无界队列可以忽略此参数。</li><li><code>keepAliveTime</code>线程存活保持时间。当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</li><li><code>unit</code>空间线程存活时间单位。</li><li><code>workQueue</code>任务队列：用于传输和保存等待执行任务的阻塞队列。<br>①<code>ArrayBlockingQueue</code>，基于数组的有界阻塞队列，按FIFO排序。<br>②<code>LinkedBlockingQuene</code>，基于链表的无界阻塞队列（其实最大容量为<code>Interger.MAX</code>），按照FIFO排序。当使用该队列时，<code>maximumPoolSize</code>参数可以忽略。<br>③<code>SynchronousQuene</code>，一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。<br>④<code>PriorityBlockingQueue</code>，具有优先级的无界阻塞队列，优先级通过参数<code>Comparator</code>实现。</li><li><code>threadFactory</code>线程工厂，用于创建新线程。</li><li><code>handler</code>线程饱和策略，当线程池和队列都满了，再加入线程会执行此策略。<h3 id="线程池中submit-和-execute-方法有什么区别？"><a href="#线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中submit() 和 execute()方法有什么区别？"></a>线程池中submit() 和 execute()方法有什么区别？</h3></li><li>参数不同</li></ul><p><code>submit()</code>方法有三个重载方法。</p><pre><code class="java">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);</code></pre><p><code>execute()</code>方法只有一个</p><pre><code class="java">void execute(Runnable command);</code></pre><ul><li><code>execute()</code>没有返回值；而<code>submit()</code>有返回值</li><li><code>submit()</code>的返回值<code>Future</code>调用<code>get()</code>方法时，可以捕获处理异常。而<code>execute()</code>没有返回值不能捕获异常。<h3 id="有哪些常用的线程池？"><a href="#有哪些常用的线程池？" class="headerlink" title="有哪些常用的线程池？"></a>有哪些常用的线程池？</h3><code>Executors.newCacheThreadPool()</code>：<strong>可缓存线程池</strong>，先查看池中有没有已建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务。<br><code>Executors.newFixedThreadPool()</code>：<strong>可重用固定个数的线程池</strong>，以共享的无界队列方式来运行这些线程。<br><code>Executors.newScheduledThreadPool(int n)</code>：<strong>定长线程池</strong>，支持定时及周期性任务执行。<br><code>Executors.newSingleThreadExecutor()</code>：<strong>单线程化的线程池</strong>，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<h3 id="什么是线程安全问题？如何保证线程安全？"><a href="#什么是线程安全问题？如何保证线程安全？" class="headerlink" title="什么是线程安全问题？如何保证线程安全？"></a>什么是线程安全问题？如何保证线程安全？</h3>当<strong>多个线程</strong>同时共享，同一个<strong>全局变量或者静态变量</strong>，做写的操作时，可能会发生数据冲突问题，也就是<strong>线程安全问题</strong>。<h3 id="java的内存模型？"><a href="#java的内存模型？" class="headerlink" title="java的内存模型？"></a>java的内存模型？</h3>java的内存模型规定了所有的变量都<strong>存储在主内存中，每个线程拥有自己的工作内存</strong>，工作内存保存了该线程使用到的变量的主内存拷贝，<strong>线程对变量所有操作，读取，赋值，都必须在工作内存中进行，不能直接写主内存变量</strong>，线程间变量值的传递均需要主内存来完成。<h3 id="volatile关键字有什么作用？volatile一定能保证原子性吗？"><a href="#volatile关键字有什么作用？volatile一定能保证原子性吗？" class="headerlink" title="volatile关键字有什么作用？volatile一定能保证原子性吗？"></a>volatile关键字有什么作用？volatile一定能保证原子性吗？</h3>volatile关键字有什么作用：</li><li>内存<strong>可见性</strong>（Memory Visibility)：所有线程都能看到共享内存的最新状态。</li><li>禁止指令重排。</li></ul><p><code>volatile</code>是Java提供的一种<strong>轻量级的同步机制</strong>，并不能保证原子性。</p><h3 id="什么是指令重排？"><a href="#什么是指令重排？" class="headerlink" title="什么是指令重排？"></a>什么是指令重排？</h3><p>指令重排是指<code>JVM</code>在编译Java代码的时候，或者CPU在执行<code>JVM</code>字节码的时候，对现有的指令顺序进行重新排序。<br>指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。</p><h3 id="synchronized的使用方式？"><a href="#synchronized的使用方式？" class="headerlink" title="synchronized的使用方式？"></a>synchronized的使用方式？</h3><ul><li>修饰实例(非静态方法。被锁对象是类的实例(<code>this</code>)。</li><li>修饰静态方法。被锁对象是类对象。</li><li>同步代码块。有三种形式。<br>①<code>synchronized(this){}</code>，被锁对象是类的实例。<br>②<code>synchronized(XXX.Class)</code>，被锁对象是类对象。<br>③<code>synchronized(new Object())</code>，被锁对象是实例对象<code>object</code>。<h3 id="Lock锁的使用方式？"><a href="#Lock锁的使用方式？" class="headerlink" title="Lock锁的使用方式？"></a>Lock锁的使用方式？</h3></li></ul><p>1.获取锁。2.上锁。3.释放锁。<br>注意点：释放锁最好放在<code>finally{}</code>代码块中，保证能执行释放锁。</p><h3 id="什么是乐观锁、什么是悲观锁？"><a href="#什么是乐观锁、什么是悲观锁？" class="headerlink" title="什么是乐观锁、什么是悲观锁？"></a>什么是乐观锁、什么是悲观锁？</h3><ul><li><strong>悲观锁</strong>：它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。具有强烈的独占和排他特性。</li><li><strong>乐观锁</strong>：乐观锁认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的重提与否进行检测，如果发现冲突了，程序自动去重试。相对于悲观锁，在高并发的场景下有更好的性能表现，通常用”版本号”实现。<h3 id="synchronized与Lock锁的区别？"><a href="#synchronized与Lock锁的区别？" class="headerlink" title="synchronized与Lock锁的区别？"></a>synchronized与Lock锁的区别？</h3></li><li><code>synchronized</code>是java内置关键字，在<code>jvm</code>层面。<code>Lock</code>是个java类。</li><li><code>synchronized</code>无法判断是否获取锁的状态。<code>Lock</code>可以判断是否获取到锁。</li><li><code>synchronized</code>会自动释放锁。<code>Lock</code>锁需要在<code>finally{}</code>代码块中手工释放锁。</li><li><code>synchronized</code>的锁可重入、不可中断、非公平。而<code>Lock</code>锁可重入、可判断、可公平（两者皆可）。<h3 id="有哪些常用的线程安全的集合？"><a href="#有哪些常用的线程安全的集合？" class="headerlink" title="有哪些常用的线程安全的集合？"></a>有哪些常用的线程安全的集合？</h3><code>ConcurrentHashMap</code>、<code>Vector</code>、<code>Hashtable</code>、<code>Stack</code>。还可以使用<code>Collections包装方法</code>获得线程安全的集合。<h3 id="CAS是什么，有什么问题，如何解决？"><a href="#CAS是什么，有什么问题，如何解决？" class="headerlink" title="CAS是什么，有什么问题，如何解决？"></a>CAS是什么，有什么问题，如何解决？</h3><code>CAS</code>是<code>compare and swap</code>的缩写，意思是比较与交换。<code>CAS</code>是乐观锁的一种实现。CAS操作包含三个操作数—内存位置的值（V）、预期原值（A）和新值（B）。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。</li></ul><p><code>CAS</code>有以下缺点：</p><ul><li>ABA问题： 线程C、D。线程D将A修改为B后又修改为A，此时C线程以为A没有改变过。这个问题通常可以使用版本号来解决。</li><li>CPU开销过大。在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很到的压力。</li><li><code>CAS</code>机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用<code>synchronized</code>了。<h3 id="什么是ThreadLocal？"><a href="#什么是ThreadLocal？" class="headerlink" title="什么是ThreadLocal？"></a>什么是ThreadLocal？</h3>这个类提供了线程局部变量也称为线程本地变量，它为变量在每个线程中创建了一个副本，通过这样的方式做到变量在线程间隔离且在方法间共享的场景。<h3 id="ThreadLocal是如何保证线程安全的？"><a href="#ThreadLocal是如何保证线程安全的？" class="headerlink" title="ThreadLocal是如何保证线程安全的？"></a>ThreadLocal是如何保证线程安全的？</h3><code>ThreadLocal</code>存储的值不是线程共享的，而是属于线程的。内部会维护一个<code>ThreadLocalMap</code>，key是当前线程的<code>ThreadLocal</code>，value是存储的值。换句话说，每个线程都有自己的值，当然不会出现线程安全问题了。</li></ul><p>源码如下：</p><pre><code class="java">    public void set(T value) {        //获取当前线程        Thread t = Thread.currentThread();        //通过当前线程获取到ThreadLocalMap        ThreadLocalMap map = getMap(t);        if (map != null)            //key是this，value是需要存储的值            map.set(this, value);        else            //创建一个map            createMap(t, value);    }</code></pre><h1 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h1><h3 id="什么是JVM内存模型？"><a href="#什么是JVM内存模型？" class="headerlink" title="什么是JVM内存模型？"></a>什么是JVM内存模型？</h3><p>Java内存模型（Java Memory Model，简称为<strong>JMM</strong>)，是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p>根据java虚拟机规范，JVM内存共分为<strong>虚拟机栈，堆，方法区，程序计数器，本地方法栈</strong>五个部分。</p><h3 id="栈内存溢出-StackOverflowError-的常见原因有哪些？"><a href="#栈内存溢出-StackOverflowError-的常见原因有哪些？" class="headerlink" title="栈内存溢出(StackOverflowError)的常见原因有哪些？"></a>栈内存溢出(StackOverflowError)的常见原因有哪些？</h3><p>栈溢出原因就是方法执行时创建的栈帧超过了栈的深度。最有可能的就是<strong>方法递归调用</strong>产生这种结果。</p><h3 id="堆内存溢出-OOM-的常见原因有哪些？"><a href="#堆内存溢出-OOM-的常见原因有哪些？" class="headerlink" title="堆内存溢出(OOM)的常见原因有哪些？"></a>堆内存溢出(OOM)的常见原因有哪些？</h3><ul><li><code>OutOfMemoryError: Java heap space</code>。在创建新的对象时, 堆内存中的空间不足以存放新创建的对象时发生。产生原因：程序中出现了死循环，不断创建对象；程序占用内存太多，<strong>超过了JVM堆设置的最大值</strong>。</li><li><code>OutOfMemoryError: unable to create new native thread</code>。产生原因：系统内存耗尽，无法为新线程分配内存；<strong>创建线程数超过了操作系统的限制</strong>。</li><li><code>OutOfMemoryError: PermGen space</code>。永久代溢出，即方法区溢出了，一般<strong>出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况</strong>，因为上述情况会产生大量的Class信息存储于方法区。</li><li><code>OutOfMemoryError：GC overhead limit exceeded</code>。<strong>超过98%的时间都在用来做GC并且回收了不到2%的堆内存</strong>。连续多次的GC，都回收了不到2%的极端情况下才会抛出。</li></ul><h3 id="JVM参数调优有哪些重要的参数？分别有什么作用？"><a href="#JVM参数调优有哪些重要的参数？分别有什么作用？" class="headerlink" title="JVM参数调优有哪些重要的参数？分别有什么作用？"></a>JVM参数调优有哪些重要的参数？分别有什么作用？</h3><ul><li>-Xms  初始堆内存大小。</li><li>-Xmx  最大堆内存大小。</li><li>-Xss  每个线程的栈大小。</li><li>-XX:+PrintGC  每次GC时打印相关信息。</li><li>-XX:Newratio  设置年轻代和老年代的比例，比如值为2，则老年代是年轻代的2倍。</li><li>-XX:Newsize  设置年轻代的初始值大小。</li><li>-XX:Maxnewsize  设置年轻代的最大值大小。</li></ul><h3 id="GC垃圾回收机制，有哪些垃圾回收算法？"><a href="#GC垃圾回收机制，有哪些垃圾回收算法？" class="headerlink" title="GC垃圾回收机制，有哪些垃圾回收算法？"></a>GC垃圾回收机制，有哪些垃圾回收算法？</h3><p>标记-清除算法、复制算法、标记整理算法、分代收集算法。</p><h3 id="JVM如何判断对象是否可以回收？"><a href="#JVM如何判断对象是否可以回收？" class="headerlink" title="JVM如何判断对象是否可以回收？"></a>JVM如何判断对象是否可以回收？</h3><p>会使用可达性分析算法进行判断，原理是从一系列被称为<code>GC ROOT</code>的对象开始，向下搜索，搜索走过的路径称为引用链，当一个对象到<code>GC ROOT</code>之间没有引用链，说明这个对象不可用，那么就会被GC回收。</p><h3 id="什么是强引用、软引用、弱引用、虚引用？"><a href="#什么是强引用、软引用、弱引用、虚引用？" class="headerlink" title="什么是强引用、软引用、弱引用、虚引用？"></a>什么是强引用、软引用、弱引用、虚引用？</h3><p>强引用。一般<code>new</code>出来的对象都是强引用。如果一个对象具有强引用，<code>GC</code>绝不会回收它；当内存空间不足，JVM宁愿抛出<code>OutOfMemoryError</code>错误。</p><pre><code class="java">//强引用Object obj = new Object();</code></pre><p>软引用。如果一个对象只具有软引用。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p><pre><code class="java">//软引用SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(new Object());</code></pre><p>弱引用。如果一个对象具有弱引用，在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存。</p><pre><code class="java">//弱引用WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(new Object());</code></pre><p>虚引用。如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收。</p><pre><code class="java">//虚引用PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(new Object(), new ReferenceQueue&lt;&gt;());</code></pre><h3 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h3><p>Java类加载器是Java运行时环境的一部分，负责动态加载Java类到JVM的内存空间中。</p><h3 id="什么是双亲委派机制？"><a href="#什么是双亲委派机制？" class="headerlink" title="什么是双亲委派机制？"></a>什么是双亲委派机制？</h3><p>双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。</p><h3 id="类的生命周期？"><a href="#类的生命周期？" class="headerlink" title="类的生命周期？"></a>类的生命周期？</h3><p><strong>加载、验证、准备、解析、初始化、使用、卸载</strong>。</p><p>有些资料会把(验证、准备、解析)归纳为连接，于是就变成：<strong>加载、连接、初始化、使用、卸载</strong>。</p><h1 id="设计模式相关"><a href="#设计模式相关" class="headerlink" title="设计模式相关"></a>设计模式相关</h1><h3 id="如何实现单例模式？"><a href="#如何实现单例模式？" class="headerlink" title="如何实现单例模式？"></a>如何实现单例模式？</h3><ul><li>饿汉式单例模式。定义一个静态成员变量，把构造器私有化，只对外暴露一个获取实例的方法。<pre><code class="java">public class SingLeton {  //立即加载  private static SingLeton singLeton = new SingLeton();  //私有化构造器  private SingLeton(){}  //对外暴露获取实例的方法  public static SingLeton getSingLeton(){      return singLeton;  }}</code></pre></li><li>懒汉式单例模式。非线程安全。基本和上面饿汉式实现方式类似，只是在获取时再判断是否创建实例，但是会有线程安全问题。<pre><code class="java">public class SingLeton {  //立即加载  private static SingLeton singLeton;  //私有化构造器  private SingLeton() {  }  //对外暴露获取实例的方法  public static SingLeton getSingLeton() {      if (singLeton == null) {          singLeton = new SingLeton();      }      return singLeton;  }}</code></pre></li><li>使用静态内部类实现<pre><code class="java">public class SingLeton {  //私有化构造器  private SingLeton() {}  //对外暴露获取实例的方法  public static SingLeton getSingLeton() {      return SingLetonHolder.SINGLETON;  }  //私有静态内部类  private static class SingLetonHolder {      private static final SingLeton SINGLETON = new SingLeton();  }}</code></pre></li><li>使用枚举实现<pre><code class="java">public enum SingLeton {  SINGLETON;}</code></pre></li></ul><h3 id="如何实现线程安全的单例模式？"><a href="#如何实现线程安全的单例模式？" class="headerlink" title="如何实现线程安全的单例模式？"></a>如何实现线程安全的单例模式？</h3><p><strong>饿汉式实现、枚举、静态内部类</strong>都是<strong>线程安全</strong>的实现方式。<br>还可以使用<strong>双检锁</strong>的懒汉式方式实现：</p><pre><code class="java">public class SingLeton {    private static volatile SingLeton singLeton;    //私有化构造器    private SingLeton() {}    //对外暴露获取实例的方法    public static SingLeton getSingLeton() {        if (singLeton == null) {            synchronized (SingLeton.class) {                if (singLeton == null) {                    singLeton = new SingLeton();                }            }        }        return singLeton;    }}</code></pre><h3 id="为什么要使用工厂模式创建对象？"><a href="#为什么要使用工厂模式创建对象？" class="headerlink" title="为什么要使用工厂模式创建对象？"></a>为什么要使用工厂模式创建对象？</h3><ul><li><strong>解耦</strong>。把对象的创建和使用的过程分开。</li><li><strong>可以降低代码重复</strong>。如果创建B过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。</li><li><strong>减少了使用者因为创建逻辑导致的错误</strong>。因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可。</li><li><strong>提高了代码的可维护性</strong>。如果发生业务逻辑变化，不需要找到所有需要创建对象的地方去逐个修正，只需要在工厂里修改即可。</li></ul><h3 id="在java中，实现代理模式有哪几种方式？"><a href="#在java中，实现代理模式有哪几种方式？" class="headerlink" title="在java中，实现代理模式有哪几种方式？"></a>在java中，实现代理模式有哪几种方式？</h3><ul><li>静态代理。</li><li>JDK动态代理。</li><li>CGlib动态代理。</li></ul><h3 id="JDK动态代理和CGlib动态代理的区别？"><a href="#JDK动态代理和CGlib动态代理的区别？" class="headerlink" title="JDK动态代理和CGlib动态代理的区别？"></a>JDK动态代理和CGlib动态代理的区别？</h3><p> （1）<code>JDK动态代理</code>只能对实现了接口的类生成代理，而不能针对类。<br> （2）<code>CGLIB</code>是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。<br>   因为是继承，所以该类或方法不能声明成<code>final</code>。</p><h3 id="策略模式的使用场景？"><a href="#策略模式的使用场景？" class="headerlink" title="策略模式的使用场景？"></a>策略模式的使用场景？</h3><ul><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时<strong>动态选择具体要执行的行为</strong>。</li><li>需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</li><li>对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</li></ul><h3 id="装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？"><a href="#装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？" class="headerlink" title="装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？"></a>装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？</h3><p>使用场景：</p><ul><li>扩展一个类的功能。<ul><li>动态增加功能，动态撤销。</li></ul></li></ul><p>java中经典的例子就是I/O流。具体分析过程可以参考我写的这篇文章：<a href="https://blog.csdn.net/yehongzhi1994/article/details/106065136" target="_blank" rel="noopener">装饰者模式与IO流的应用</a>。</p><h1 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h1><h3 id="有哪些经典的排序算法？"><a href="#有哪些经典的排序算法？" class="headerlink" title="有哪些经典的排序算法？"></a>有哪些经典的排序算法？</h3><p>插入排序、冒泡排序、归并排序、快速排序、堆排序、桶排序、基数排序等等。</p><h3 id="冒泡排序的时间复杂度和空间复杂度？"><a href="#冒泡排序的时间复杂度和空间复杂度？" class="headerlink" title="冒泡排序的时间复杂度和空间复杂度？"></a>冒泡排序的时间复杂度和空间复杂度？</h3><p>平均的时间复杂度是<code>O(n^2)</code>，最好的情况是<code>O(n)</code>，最坏的情况是<code>O(n^2)</code>。空间复杂度是<code>O(1)</code>。</p><h3 id="哪一种排序算法的时间复杂度比较稳定？"><a href="#哪一种排序算法的时间复杂度比较稳定？" class="headerlink" title="哪一种排序算法的时间复杂度比较稳定？"></a>哪一种排序算法的时间复杂度比较稳定？</h3><p>归并排序。最好和最坏的情况下，时间复杂度都是<code>O(n*log n)</code>。</p><h3 id="如何实现二分查找？二分查找的时间复杂度？-笔试常见"><a href="#如何实现二分查找？二分查找的时间复杂度？-笔试常见" class="headerlink" title="如何实现二分查找？二分查找的时间复杂度？(笔试常见)"></a>如何实现二分查找？二分查找的时间复杂度？(笔试常见)</h3><p>有两种方式，迭代法和递归法。具体实现代码，可以参考我写的这篇《<a href="https://blog.csdn.net/yehongzhi1994/article/details/105835380" target="_blank" rel="noopener">手把手教你实现二分查找</a>》。时间复杂度是<code>O(log n)</code>。</p><h3 id="跳楼梯的问题。-笔试常见"><a href="#跳楼梯的问题。-笔试常见" class="headerlink" title="跳楼梯的问题。(笔试常见)"></a>跳楼梯的问题。(笔试常见)</h3><p>这是一个经典的斐波那契数列问题。力扣题库第70题。可以看看大佬们的题解。这是我的题解，使用了<code>Map</code>作为缓存，减少一些不必要的递归，效率还不错。执行时间：1 ms。当然你去掉那个<code>Map</code>也是完全没错的，只是运行时间会久一些，可能会超出<code>leetcode</code>的时间限制，没法通过。<br><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/guan-fang-jie-fa-yi-chao-shi-cai-yong-maphuan-cun-/" target="_blank" rel="noopener">我的题解链接</a></p><pre><code class="java">/** * 题目描述： * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？*/class Solution {    private Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    public int climbStairs(int n) {        if (n == 1) {            map.put(n, 1);            return 1;        }        if (n == 2) {            map.put(n, 2);            return 2;        }        if (map.get(n) != null) {            return map.get(n);        } else {            int num = climbStairs(n - 1) + climbStairs(n - 2);            map.put(n, num);            return num;        }    }}</code></pre><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>责任链模式</title>
    <link href="/2020/06/06/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/06/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>各位<strong>java技术爱好者</strong>，我们又见面了！<br>之前我在面试的时候遇到这个问题，当时答不上来。这件事就一直在我心里耿耿于怀。相信很多人面试完都有这种体验，哈哈~<br>不过今日不同往日了，现在我已经搞懂了，其实并不是很难。</p><a id="more"></a><p><img src="https://static.lovebilibili.com/20200606_2211_01.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="开始搞事情"><a href="#开始搞事情" class="headerlink" title="开始搞事情"></a>开始搞事情</h1><p>要学习一种技术，当然要搞清楚能解决什么问题，这是最关键的，否则就像买了一个开瓶器，还是用嘴咬开啤酒瓶盖一样(比喻很巧妙)。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先我们用<code>Request</code>对象，表示一个请求。</p><pre><code class="java">public class Request {    //请求数据    private String data;    public String getData() {        return data;    }    public void setData(String data) {        this.data = data;    }}</code></pre><p>假设<code>data</code>中有很多数据，我们要过滤掉一些关键字，比如<code>水果</code>、<code>蔬菜</code>。<br>如果不用设计模式，直接用<code>if</code>解决，就是这样写：</p><pre><code class="java">public static void main(String[] args) throws Exception {        //创建请求体        String data = &quot;肉蛋葱鸡水果蔬菜千层饼雅俗共赏第五层的马老师&quot;;        Request request = new Request();        request.setData(data);        String requestData = request.getData();        //如果包含水果关键字        if (requestData.contains(&quot;水果&quot;)) {            //过滤水果关键字            requestData = filterByWord(requestData, &quot;水果&quot;);        }        //如果包含蔬菜关键字        if (requestData.contains(&quot;蔬菜&quot;)) {            //过滤蔬菜关键字            requestData = filterByWord(requestData, &quot;蔬菜&quot;);        }        request.setData(requestData);        System.out.println(requestData);//肉蛋葱鸡千层饼雅俗共赏第五层的马老师    }    //过滤关键字的方法    private static String filterByWord(String data, String word) {        StringBuilder sb = new StringBuilder(data);        while (true) {            int index = sb.indexOf(word);            //如果不等于-1，搜索到关键字            if (index != -1) {                for (int i = 0; i &lt; word.length(); i++) {                    //关键字有多长就删多少次，比如水果，在index位置上删两次                    sb.deleteCharAt(index);                }            } else {                //等于-1，没有关键字，跳出循环                break;            }        }        return sb.toString();    }}    </code></pre><p>这样的代码在项目中不要太多，遇事不决来个<code>if</code>，不行就再来一个。一般这种程序员就只看到了<strong>第一层</strong>。<br>问题：<br>1.如果这时候要增加多一些关键字呢，怎么处理？在原来的代码里继续加<code>if</code>的话，那这个方法就越写越长。而且破坏了<code>开闭原则</code>。<br>2.如果要调换顺序呢。难道要剪切复制代码？<br><strong>所以一个好的程序员，实现功能只是基本要求，重要是代码要有好的维护性和扩展性。</strong><br><img src="https://static.lovebilibili.com/20200606_2211_00.png" srcset="/img/loading.gif" alt=""></p><h2 id="怎么优化呢？"><a href="#怎么优化呢？" class="headerlink" title="怎么优化呢？"></a>怎么优化呢？</h2><p>我们可以这样想，把每个过滤关键字的方法<strong>抽成一个类</strong>，然后定义一个<strong>过滤关键字的方法</strong>，因为有很多个类似职责的类，所以<strong>定义一个接口</strong>，<strong>公共的方法</strong>可以定义在接口。<br>第一步：定义<strong>过滤器接口</strong></p><pre><code class="java">public interface Filter {    //接口方法    String doFilter(String data, FilterChain filterChain);    //过滤关键字的方法    default String filterByWord(String data, String word) {        StringBuilder sb = new StringBuilder(data);        while (true) {            int index = sb.indexOf(word);            if (index != -1) {                for (int i = 0; i &lt; word.length(); i++) {                    //关键字有几个字，就删几次。比如水果就在index删两次即可                    sb.deleteCharAt(index);                }            } else {                //如果找不到关键字，就跳出循环                break;            }        }        return sb.toString();    }}</code></pre><p>第二步：定义<strong>水果关键字过滤器</strong></p><pre><code class="java">public class FruitsFilter implements Filter {    @Override    public String doFilter(String data, FilterChain filterChain) {        //过滤水果关键字        data = filterByWord(data, &quot;水果&quot;);        //拿到控制器，继续调用下一个过滤器        return filterChain.preHandleRequest(data);    }}</code></pre><p>第三部：定义<strong>蔬菜关键字过滤器</strong></p><pre><code class="java">public class VegetablesFilter implements Filter {    @Override    public String doFilter(String data, FilterChain filterChain) {        //过滤蔬菜关键字        data = filterByWord(data, &quot;蔬菜&quot;);        //拿到控制器，继续调用下一个过滤器        return filterChain.preHandleRequest(data);    }}</code></pre><p>第四步：定义一个<strong>过滤器的控制器</strong></p><pre><code class="java">public class FilterChain {    //使用List装过滤器，List是有序的    private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();    //过滤器的下标，从0开始，每次调用preHandleRequest方法就+1    private int index = 0;    //添加过滤器    public void addFilter(Filter filter) {        filters.add(filter);    }    //调用过滤器的doFilter()方法，并把指针+1指向下一个过滤器    public String preHandleRequest(String data) {        //如果指针大于集合的size，则return，不再往下调用，相当于递归的终结条件        if (index == filters.size()) {            return data;        }        Filter filter = filters.get(index);        //下标指针+1        index++;        //精髓在这个this，把自己再当做参数传进去，实现了递归        return filter.doFilter(data, this);    }}</code></pre><p>这样就大功告成了，最后我们创建一个Main方法试试吧~</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //创建请求体        String data = &quot;肉蛋葱鸡水果蔬菜千层饼雅俗共赏第五层的马老师&quot;;        Request request = new Request();        request.setData(data);        //创建FilterChain执行链        FilterChain filterChain = new FilterChain();        //添加过滤器        filterChain.addFilter(new FruitsFilter());        filterChain.addFilter(new VegetablesFilter());        //执行预处理        String s = filterChain.preHandleRequest(request.getData());        request.setData(s);        //打印结果，验证        System.out.println(request.getData());//下面是打印结果，结果正确        //肉蛋葱鸡千层饼雅俗共赏第五层的马老师    }}</code></pre><p>这就是责任链模式！下面用一张图来看看调用链的执行顺序。其实没有想得那么难吧。你学会了吗？<br><img src="https://img-blog.csdnimg.cn/20200606120835391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="责任链模式的优点"><a href="#责任链模式的优点" class="headerlink" title="责任链模式的优点"></a>责任链模式的优点</h2><p>我们回过头去看，为什么这么绕呢，直接<code>if</code>不香吗？<br>还真不香，在用<code>if</code>的时候，提到的两个问题，破坏<code>开闭原则</code>，还有调用顺序的问题，用责任链模式都得到解决了。<br><strong>1.如果要加一些过滤的关键字，只需要加一个过滤的类，然后再添加到过滤器的集合中，不需要对原来的代码进行侵入式的开发。符合<code>开闭原则</code>。<br>2.执行顺序要变更的话，也不需要侵入式的改代码，只需要改一下添加过滤器的顺序。在<code>Servlet</code>中，过滤器的顺序就是按<code>xml</code>文件定义的顺序。在<code>SpringMVC</code>则是按注册的顺序。这就非常易于扩展。</strong><br>要多为下一个程序员着想，我为人人，人人为我，世界才会变得更美好！哈哈~~</p><h1 id="SpringMVC的责任链模式"><a href="#SpringMVC的责任链模式" class="headerlink" title="SpringMVC的责任链模式"></a>SpringMVC的责任链模式</h1><p>以上就是一个简单的<code>demo</code>，重要的是学习这种思想。那么我们看实战中是怎么应用的，所谓知其然知其所以然，学习<strong>忌讳浅尝辄止</strong>，趁热打铁，我们看看框架中怎么应用责任链模式。</p><h2 id="SpringMVC拦截器的使用"><a href="#SpringMVC拦截器的使用" class="headerlink" title="SpringMVC拦截器的使用"></a>SpringMVC拦截器的使用</h2><p>很简单，实现<code>HandlerInterceptor</code>接口，接口有三个方法需要重写。</p><ul><li>preHandle()：在业务处理器处理请求之前被调用。预处理。</li><li>postHandle()：在业务处理器处理请求执行完成后，生成视图之前执行。后处理。</li><li>afterCompletion()：在<code>DispatcherServlet</code>完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）；</li></ul><p>我们定义一个关键字过滤器<code>WordInterceptor</code>：</p><pre><code class="java">//定义一个关键字拦截器public class WordInterceptor implements HandlerInterceptor {    //在执行controller定义的请求方法前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;执行WordInterceptor的preHandle()&quot;);        return true;    }    //controller定义的请求方法执行后，但还没渲染页面前，执行    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;执行WordInterceptor的postHandle()&quot;);    }    //在渲染页面完毕后执行，或者preHandle()返回fasle时执行    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(&quot;执行WordInterceptor的afterCompletion()&quot;);    }}</code></pre><p>如法炮制，再定义一个登录拦截器</p><pre><code class="java">public class LoginInterceptor implements HandlerInterceptor {    //在执行controller定义的请求方法前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;执行LoginInterceptor的preHandle()&quot;);        return true;    }    //controller定义的请求方法执行后，但还没渲染页面前，执行    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;执行LoginInterceptor的postHandle()&quot;);    }    //在渲染页面完毕后执行，或者preHandle()返回fasle时执行    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(&quot;执行LoginInterceptor的afterCompletion()&quot;);    }}</code></pre><p>然后再注册到拦截器的集合中。</p><pre><code class="java">@Componentpublic class WebInterceptorConfig implements WebMvcConfigurer {    @Override    public void addInterceptors(InterceptorRegistry registry) {        //先注册关键字拦截器，拦截所有请求        registry.addInterceptor(new WordInterceptor()).addPathPatterns(&quot;/**&quot;);        //再注册登录拦截器，拦截所有请求        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;);    }}</code></pre><p>然后启动项目，发起一个请求，我们就可以在控制台看到调用的顺序了。注意观察：</p><pre><code class="java">//按注册顺序执行preHandle()方法执行WordInterceptor的preHandle()执行LoginInterceptor的preHandle()//按注册顺序，逆序执行postHandle()方法执行LoginInterceptor的postHandle()执行WordInterceptor的postHandle()//从最后一个preHandle()执行的类，逆序执行afterCompletion()执行LoginInterceptor的afterCompletion()执行WordInterceptor的afterCompletion()</code></pre><p>执行的流程图就是这样：<br><img src="https://static.lovebilibili.com/SpringMVC_liuchengtu.png" srcset="/img/loading.gif" alt=""><br>原理是什么呢？我们不妨走进源码去分析。</p><h2 id="SpringMVC拦截器源码分析"><a href="#SpringMVC拦截器源码分析" class="headerlink" title="SpringMVC拦截器源码分析"></a>SpringMVC拦截器源码分析</h2><p>还是要看<code>DispatcherServlet</code>的<code>doDispatch()</code>方法</p><h3 id="doDispatch-调用顺序"><a href="#doDispatch-调用顺序" class="headerlink" title="doDispatch()调用顺序"></a><code>doDispatch()</code>调用顺序</h3><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        //请求对象        HttpServletRequest processedRequest = request;        //定义一个调用链        HandlerExecutionChain mappedHandler = null;        boolean multipartRequestParsed = false;        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                //省略                // 获取调用链                mappedHandler = getHandler(processedRequest);                if (mappedHandler == null) {                    noHandlerFound(processedRequest, response);                    return;                }                //获取对应的适配器                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());                //调用拦截器的preHandle()前处理方法                if (!mappedHandler.applyPreHandle(processedRequest, response)) {                    //如果上面返回fasle,取反就是true，进来这里就return，结束了                    return;                }                //调用Controller的RequestMapping对应的方法                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                //调用拦截器的postHandle()后处理方法                mappedHandler.applyPostHandle(processedRequest, response, mv);                //省略            }catch (Exception ex) {            //如果出现异常还是会执行triggerAfterCompletion()方法            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);        }        catch (Throwable err) {            //如果出现异常还是会执行triggerAfterCompletion()方法            triggerAfterCompletion(processedRequest, response, mappedHandler,                    new NestedServletException(&quot;Handler processing failed&quot;, err));        }        finally {            //省略        }    }</code></pre><p>从上面源码中明显可以知道，拦截器接口的执行顺序:<br><code>applyPreHandle()</code>→<code>handle()</code>→<code>applyPostHandle()</code>→<code>triggerAfterCompletion()</code><br>或者<br><code>applyPreHandle()</code>→<code>triggerAfterCompletion()</code></p><h3 id="关键在于HandlerExecutionChain接口"><a href="#关键在于HandlerExecutionChain接口" class="headerlink" title="关键在于HandlerExecutionChain接口"></a>关键在于<code>HandlerExecutionChain</code>接口</h3><p>其实上面这些方法除了<code>handle()</code>定义在适配器中，其他都是这个接口的。<code>handle()</code>方法我已经在上一篇《适配器模式与SpringMV》讲过了。下面我们看<code>HandlerExecutionChain</code>接口。</p><pre><code class="java">public class HandlerExecutionChain {    //省略    @Nullable    private HandlerInterceptor[] interceptors;    @Nullable//拦截器集合    private List&lt;HandlerInterceptor&gt; interceptorList;    //指针,用来记录applyPreHandle()方法执行到哪一个拦截器    private int interceptorIndex = -1;}</code></pre><p>这不就跟我们的<code>demo</code>类似吗？定义了一个集合封装拦截器，定义一个指针遍历集合。</p><h4 id="applyPreHandle-方法"><a href="#applyPreHandle-方法" class="headerlink" title="applyPreHandle()方法"></a>applyPreHandle()方法</h4><p>那么前置方法<code>applyPreHandle()</code>是怎么样执行的呢？</p><pre><code class="java">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {        //获取拦截器        HandlerInterceptor[] interceptors = getInterceptors();        //判断不为空        if (!ObjectUtils.isEmpty(interceptors)) {            //按顺序遍历，所以拦截器接口定义的preHandle()是按顺序执行的            for (int i = 0; i &lt; interceptors.length; i++) {                //按顺序获取注册的拦截器                HandlerInterceptor interceptor = interceptors[i];                //执行拦截器的preHandle()方法                if (!interceptor.preHandle(request, response, this.handler)) {                    //如果preHandle()返回false,那就调用triggerAfterCompletion()方法                    triggerAfterCompletion(request, response, null);                    //返回false，结束调用                    return false;                }                //如果preHandle()返回true，继续执行                //把下标索引记录到成员变量的指针中，用于后面执行triggerAfterCompletion()方法                this.interceptorIndex = i;            }        }        return true;    }</code></pre><h4 id="applyPostHandle-方法"><a href="#applyPostHandle-方法" class="headerlink" title="applyPostHandle()方法"></a>applyPostHandle()方法</h4><p>然后下一步执行的<code>applyPostHandle()</code>方法，又是怎么执行的呢？</p><pre><code class="java">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)            throws Exception {        HandlerInterceptor[] interceptors = getInterceptors();        if (!ObjectUtils.isEmpty(interceptors)) {            //倒序遍历，所以postHandle()方法是从最后一个拦截器开始执行的            for (int i = interceptors.length - 1; i &gt;= 0; i--) {                HandlerInterceptor interceptor = interceptors[i];                //postHandle()能获取到ModelAndView对象，拦截器可以对mv对象进行后处理                interceptor.postHandle(request, response, this.handler, mv);            }        }    }</code></pre><h4 id="triggerAfterCompletion-方法"><a href="#triggerAfterCompletion-方法" class="headerlink" title="triggerAfterCompletion()方法"></a>triggerAfterCompletion()方法</h4><pre><code class="java">void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex)            throws Exception {        HandlerInterceptor[] interceptors = getInterceptors();        if (!ObjectUtils.isEmpty(interceptors)) {            //从成员变量interceptorIndex记录的指针值，开始倒序遍历            for (int i = this.interceptorIndex; i &gt;= 0; i--) {                HandlerInterceptor interceptor = interceptors[i];                try {                    interceptor.afterCompletion(request, response, this.handler, ex);                }                catch (Throwable ex2) {                    logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);                }            }        }    }</code></pre><h3 id="拦截器集合-interceptorList如何组装"><a href="#拦截器集合-interceptorList如何组装" class="headerlink" title="拦截器集合 interceptorList如何组装"></a>拦截器集合 <code>interceptorList</code>如何组装</h3><p>我们都看到上面三个方法都有一个公用的方法<code>getInterceptors()</code>。</p><pre><code class="java">    @Nullable    public HandlerInterceptor[] getInterceptors() {        if (this.interceptors == null &amp;&amp; this.interceptorList != null) {            this.interceptors = this.interceptorList.toArray(new HandlerInterceptor[0]);        }        return this.interceptors;    }</code></pre><p>关键是这个<code>interceptorList</code>是在哪里把拦截器<code>add()</code>进去的呢？<br>其实很简单，经过一路顺藤摸瓜，我们看到<code>AbstractHandlerMapping</code>的<code>getHandlerExecutionChain()</code>方法：</p><pre><code class="java">    protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {        HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?                (HandlerExecutionChain) handler : new HandlerExecutionChain(handler));        String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);        for (HandlerInterceptor interceptor : this.adaptedInterceptors) {            //判断是否继承拦截器父类            if (interceptor instanceof MappedInterceptor) {                MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;                if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) {                    //添加拦截器                    chain.addInterceptor(mappedInterceptor.getInterceptor());                }            }            else {                //添加拦截器                chain.addInterceptor(interceptor);            }        }        //返回调用链        return chain;    }</code></pre><p>那么上面这个方法又在什么时候被调用呢？我们一直往上找调用方。<br>首先是<code>AbstractHandlerMapping</code>的<code>getHandler()</code>方法</p><pre><code class="java">    @Override    @Nullable    public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {        //获取调用链        HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);        //省略        return executionChain;    }</code></pre><p>然后到了<code>DispatcherServlet</code>的<code>getHandler()</code>方法</p><pre><code class="java">    @Nullable    protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {        if (this.handlerMappings != null) {            for (HandlerMapping hm : this.handlerMappings) {                //省略                //获取调用链                HandlerExecutionChain handler = hm.getHandler(request);                if (handler != null) {                    //不为null则返回                    return handler;                }            }        }        return null;    }</code></pre><p>最后回到了<code>DispatcherServlet</code>的<code>doDispatch()</code>方法</p><pre><code class="java">    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                // 获取调用链方法！！！                mappedHandler = getHandler(processedRequest);                //省略                }            }        }    }</code></pre><p>哈哈~~真相大白了！是在<code>doDispatch()</code>方法里，获取调用链<code>getHandler()</code>方法中组装好<code>interceptorList</code>拦截器集合的！</p><h3 id="SpringMVC拦截器执行流程图解"><a href="#SpringMVC拦截器执行流程图解" class="headerlink" title="SpringMVC拦截器执行流程图解"></a>SpringMVC拦截器执行流程图解</h3><p>用张图总结一下，就是这样，我用不同的颜色分步骤从浅到深标记了(<strong>求点赞</strong>)：<br><img src="https://static.lovebilibili.com/SringMVC_tujie.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="最后说多几句"><a href="#最后说多几句" class="headerlink" title="最后说多几句"></a>最后说多几句</h1><p>除了<code>SpringMVC</code>外，其实还有很多框架都使用了责任链模式，比如<code>Servlet</code>的<code>Filter</code>，还有<code>Struts2</code>的<code>Interceptor</code>等等。有兴趣的同学可以去看看源码，其实都大同小异，思想懂了之后，源码看起来就没那么费劲了。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong><br><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote><blockquote><p>学之，则难者亦易矣。不学，则易者亦难矣。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式与SpringMVC</title>
    <link href="/2020/05/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8ESpringMVC/"/>
    <url>/2020/05/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8ESpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>适配器模式是将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>用生活中的例子就是充电器的转接头或者数据线转接头，也就是两个类不兼容的情况下，通过适配器类来做到兼容。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>我看了网上很多人的博客，关于适配器模式的一些例子，主要有两种，一种叫类适配器，一种叫对象适配器。写完这两个例子后，我有种恍然大悟的感觉！</p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>首先有一个接口是目标接口<code>PayService</code>，目标方法<code>pay()</code>。</p><pre><code class="java">public interface PayService {    String pay(String channel, String amount) throws Exception;}</code></pre><p>然后有一个被适配的类<code>CheckHelper</code>，适配方法<code>checkedPay()</code></p><pre><code class="java">public class CheckHelper {    //检查支付渠道和支付金额    public boolean checkedPay(String channel, String amount) {        try {            //字符串转成数字，如果出现转换异常返回fasle            int mount = Integer.parseInt(amount);            //PayEnum定义了一些支付渠道，比如支付宝、微信、银联等等            List&lt;String&gt; channelList = Arrays.stream(PayEnum.values())                .map(PayEnum::getChannel)                .collect(Collectors.toList());            //包含在支付渠道中，并且金额大于0，返回true，否则返回false            return channelList.contains(channel) &amp;&amp; mount &gt; 0;        } catch (Exception e) {            return false;        }    }}</code></pre><p>需求是要使得在接口<code>PayService</code>调用<code>CheckHelper</code>的<code>checkedPay()</code>方法，现在使用类适配器的方式演示：</p><pre><code class="java">public class PayAdapter extends CheckHelper implements PayService {    @Override    public String pay(String channel, String amount) throws Exception {        boolean checked = super.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>其实就是使用继承的方式来完成，适配器类继承<code>CheckHelper</code>类，然后使用<code>super</code>来调用被适配类</p><p><code>CheckHelper</code>的<code>checkedPay()</code>方法，一目了然了。</p><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>明显使用类适配器的方式不太灵活，因为<code>java</code>是单继承，所以我们可以改成成员变量的方式，也就是对象适配器。代码如下：</p><pre><code class="java">public class PayAdapter implements PayService {    //使用成员变量    private CheckHelper checkHelper = new CheckHelper();    @Override    public String pay(String channel, String amount) throws Exception {        //调用CheckHelper的checkedPay()方法        boolean checked = checkHelper.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>那么肯定有人会说，你这样直接<code>new</code>一个对象不好，可以使用<code>SpringIOC</code>注入，于是又可以写成这样：</p><pre><code class="java">//注册到Spring容器中@Component(&quot;checkHelper&quot;)public class CheckHelper {}</code></pre><pre><code class="java">public class PayAdapter implements PayService {    @Resource(name = &quot;checkHelper&quot;)    private CheckHelper checkHelper;    @Override    public String pay(String channel, String amount) throws Exception {        boolean checked = checkHelper.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>然后有人可能已经开始察觉了，这不就是平时我们使用的依赖注入吗？没错！所以我开始就说了，写完这两个例子后，我恍然大悟了。原来适配器模式我们一直都在用，只是没认出来罢了。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>那么我们用适配器模式有什么优点呢？为什么要这样写：</p><p>1.解耦，降低了对象与对象之间的耦合性。</p><p>2.增加了类的复用，这点是比较重要的。</p><p>3.灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。这点我待会在下面<code>SpringMVC</code>的应用中详细说明。</p><h2 id="在SpringMVC中的应用"><a href="#在SpringMVC中的应用" class="headerlink" title="在SpringMVC中的应用"></a>在SpringMVC中的应用</h2><p>我们都知道<code>SpringMVC</code>定义一个映射的方式很简单，使用<code>@RequestMapping</code>注解，如下所示：</p><pre><code class="java">@RestControllerpublic class PayController {    @RequestMapping(&quot;/pay&quot;)    public String pay(String channel,String amount)throws Exception{        return &quot;&quot;;    }}</code></pre><p>实际上除了上面这种常用的方式外，还有其他的方式定义：</p><blockquote><p>实现<code>Controller</code>接口</p></blockquote><pre><code class="java">@org.springframework.stereotype.Controller(&quot;/path&quot;)public class TestController implements Controller {    @Override    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {        return null;    }}</code></pre><blockquote><p>实现<code>HttpRequestHandler</code>接口</p></blockquote><pre><code class="java">@Controller(&quot;/httpPath&quot;)public class HttpController implements HttpRequestHandler {    @Override    public void handleRequest(HttpServletRequest request,                              HttpServletResponse response    ) throws ServletException, IOException {        //业务处理，页面跳转，返回响应结果等等    }}</code></pre><blockquote><p>实现<code>Servlet</code>接口</p></blockquote><pre><code class="java">@Controller(&quot;/servletPath&quot;)public class ServletController implements Servlet {    //Servlet生命周期函数    //重写init()方法      //重写getServletConfig()方法    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {        //业务处理    }    //重写getServletInfo()方法    //重写destroy()方法}</code></pre><p>还要配置一个<code>SimpleServletHandlerAdapter</code>适配器的<code>bean</code>，因为默认只加载前面三种适配器，所以这种适配器需要自己手动添加。从这里也可以看出<code>SpringMVC</code>已经不推荐这种创建方式。</p><pre><code class="java">@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter {    @Bean    public SimpleServletHandlerAdapter simpleServletHandlerAdapter() {        return new SimpleServletHandlerAdapter();    }}</code></pre><blockquote><p><code>HandlerFunction</code>接口，关于响应式接口的开发</p></blockquote><p>最后一种是使用<code>HandlerFunction</code>函数式接口，这是<code>Spring5.0</code>后引入的方式，主要用于做响应式接口的开发，这里就不举例子了。后面我会写一篇文章再详述。</p><p><strong>问题：</strong>以上就有五种方式定义<code>Mapping</code>映射，那么<code>SpringMVC</code>是如何去适配的呢？并且具有良好的扩展性和维护性呢？</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先我们把目光放在<code>DispatcherServlet</code>类的<code>doDispatch()</code>方法</p><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        boolean multipartRequestParsed = false;        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                processedRequest = checkMultipart(request);                multipartRequestParsed = (processedRequest != request);                // Determine handler for the current request.                mappedHandler = getHandler(processedRequest);                if (mappedHandler == null) {                    noHandlerFound(processedRequest, response);                    return;                }                //重点： 获取到对应的适配器                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());                //省略...                //重点： 调用HandlerAdapter接口的handle()方法，得到ModelAndView结果                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                //省略...            }            catch (Exception ex) {                //省略...            }            catch (Throwable err) {                //省略..            }        }    }</code></pre><p>先不要慌张，其实学过策略模式你一眼就可以看出来，实际上这里就是运用了类似于策略模式的方式，根据不同的对象获取到对应的适配器，然后执行<code>HandlerAdapter</code>接口的<code>handle()</code>方法得到结果。</p><p>关键是这个<code>getHandlerAdapter()</code>方法，是怎么获取到对应的<code>HandlerAdapter</code>。</p><pre><code class="java">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {        if (this.handlerAdapters != null) {            //这个handlerAdapters有全部的适配器，遍历handlerAdapters集合            for (HandlerAdapter adapter : this.handlerAdapters) {                //如果匹配                if (adapter.supports(handler)) {                    //就返回这个适配器                    return adapter;                }            }        }        throw new ServletException(&quot;No adapter for handler [&quot; + handler +                &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);    }</code></pre><p>那么你看到上面这个<code>this.handlerAdapters</code>肯定会有疑问，<code>handlerAdapters</code>集合里面的适配器是什么时候初始化的？哪里初始化？继续看。</p><p>在<code>DispatcherServlet</code>的<code>initStrategies()</code>方法中有一堆初始化方法。</p><pre><code class="java">protected void initStrategies(ApplicationContext context) {        initMultipartResolver(context);        initLocaleResolver(context);        initThemeResolver(context);        initHandlerMappings(context);        //这个就是初始化适配器的方法，handlerAdapters就是在这里初始化的        initHandlerAdapters(context);        initHandlerExceptionResolvers(context);        initRequestToViewNameTranslator(context);        initViewResolvers(context);        initFlashMapManager(context);    }</code></pre><p>接着我们看<code>initHandlerAdapters()</code>方法</p><pre><code class="java">private void initHandlerAdapters(ApplicationContext context) {        this.handlerAdapters = null;        //省略...        //如果为null，刚开始当然为null，所以加载handlerAdapters集合        if (this.handlerAdapters == null) {            //关键又在于getDefaultStrategies方法            this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);            if (logger.isDebugEnabled()) {                logger.debug(&quot;No HandlerAdapters found in servlet &#39;&quot; + getServletName() + &quot;&#39;: using default&quot;);            }        }    }</code></pre><p>然后我们又去<code>getDefaultStrategies()</code>方法中看你会发现：</p><pre><code class="java">    protected &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) {        String key = strategyInterface.getName();        //defaultStrategies中获取值，key就是HandlerAdapter.class对象        String value = defaultStrategies.getProperty(key);        //省略...    }</code></pre><p>然后重点就在于这个<code>defaultStrategies</code>对象。我们继续看，很快看到了。</p><pre><code class="java">    //DispatcherServlet.properties文件名    private static final String DEFAULT_STRATEGIES_PATH = &quot;DispatcherServlet.properties&quot;;    //Properties对象，全局变量    private static final Properties defaultStrategies;    static {        try {            ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);            //加载DispatcherServlet.properties文件            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);        }        catch (IOException ex) {            throw new IllegalStateException(&quot;Could not load &#39;&quot; + DEFAULT_STRATEGIES_PATH + &quot;&#39;: &quot; + ex.getMessage());        }    }</code></pre><p>所以明显可以看到所有的适配器类都是写在<code>DispatcherServlet.properties</code>文件里了！默认加载这三种适配器。</p><pre><code class="properties">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\    org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</code></pre><h3 id="得到结论："><a href="#得到结论：" class="headerlink" title="得到结论："></a>得到结论：</h3><p>适配器实现类是从<code>DispatcherServlet.properties</code>文件加载到内存中的。</p><h2 id="HandlerAdapter接口"><a href="#HandlerAdapter接口" class="headerlink" title="HandlerAdapter接口"></a>HandlerAdapter接口</h2><p>所以关键在于<code>HandlerAdapter</code>接口，接口信息如下：</p><pre><code class="java">public interface HandlerAdapter {    //子类去实现，用于判断上级接口    boolean supports(Object handler);    //子类实现这个方法，返回响应的结果    @Nullable    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;    //判断是否使用浏览器缓存，返回-1表示不使用浏览器缓存    long getLastModified(HttpServletRequest request, Object handler);}</code></pre><p>学过策略模式的应该很清楚了，上面讲过有5种方式定义<code>Mapping</code>。</p><p>所以应该可以猜测<code>HandlerAdapter</code>接口有五个子类。打开类图：</p><p><img src="https://static.lovebilibili.com/HandlerAdapter.png" srcset="/img/loading.gif" alt=""></p><p>果然是有五个实现的子类分别对应五种方式！</p><p>那么我们找其中一个实现类，比如最简单的<code>SimpleControllerHandlerAdapter</code>，来分析一下：</p><pre><code class="java">public class SimpleControllerHandlerAdapter implements HandlerAdapter {    @Override    //getHandlerAdapter()方法就会调用这个方法判断，然后返回对应的适配器实现类    //这里返回的就是SimpleControllerHandlerAdapter适配器    public boolean supports(Object handler) {        return (handler instanceof Controller);    }    @Override    @Nullable    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception {        //执行Controller接口的handleRequest，也就是mapping映射的方法        return ((Controller) handler).handleRequest(request, response);    }    //判断是否使用浏览器缓存，返回-1表示不使用浏览器缓存    @Override    public long getLastModified(HttpServletRequest request, Object handler) {        if (handler instanceof LastModified) {            return ((LastModified) handler).getLastModified(request);        }        return -1L;    }}</code></pre><p>下面画一张图来总结一下以上的分析过程：</p><p><img src="https://static.lovebilibili.com/adapterProcessPic.png" srcset="/img/loading.gif" alt=""></p><p>这不就像策略模式吗…只能解释为设计模式有很多都比较类似。假设<code>SpringMVC</code>要增加一种定义<code>Mapping</code>的方式，那就很容易了，增加对应的适配器实现类，对原有的代码没有任何的侵入，这就非常符合开闭原则。接下来我们就对适配器进行扩展，自定义一个适配器。</p><h2 id="自定义SpringMVC适配器"><a href="#自定义SpringMVC适配器" class="headerlink" title="自定义SpringMVC适配器"></a>自定义SpringMVC适配器</h2><p>首先要定义一个适配器<code>MyHandlerAdapter</code>，实现<code>HandlerAdapter</code>接口。</p><pre><code class="java">public class MyHandlerAdapter implements HandlerAdapter {    @Override    public boolean supports(Object handler) {        return handler instanceof MyController;    }    @Override    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        return ((MyController) handler).handleRequest(request, response);    }    @Override    public long getLastModified(HttpServletRequest request, Object handler) {        //不使用浏览器缓存，返回-1        return -1;    }}</code></pre><p>接着定义一个<code>MyController</code>接口。</p><pre><code class="java">public interface MyController {    /**     * 处理请求     */    @Nullable    ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;}</code></pre><p>注册适配器到<code>Spring</code>容器中。</p><pre><code class="java">@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter {    //注册自定义的适配器    @Bean    public MyHandlerAdapter myHandlerAdapter() {        return new MyHandlerAdapter();    }}</code></pre><p>最后创建一个<code>MyTestController</code>实现<code>MyController</code>进行测试。</p><pre><code class="java">@Controller(&quot;/myTest&quot;)public class MyTestController implements MyController {    @Override    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {        response.getWriter().println(&quot;MyTestController Test success!!!&quot;);        return null;    }}</code></pre><p>启动项目，然后在浏览器输入访问地址，即可看到。</p><p><img src="https://static.lovebilibili.com/adapter_test.png" srcset="/img/loading.gif" alt=""></p><p>当你理解透彻之后，你就可以这样自定义一个适配器，来加深一下理解，验证之前的分析的正确性。</p><p>沉下心学习，才能跑得更快！</p><p>以上就是适配器模式的学习，更多的java技术分享，就关注<strong>java技术爱好者</strong>吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次高级java面试</title>
    <link href="/2020/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E7%BA%A7java%E9%9D%A2%E8%AF%95/"/>
    <url>/2020/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E7%BA%A7java%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一次高级JAVA开发面试题目"><a href="#记录一次高级JAVA开发面试题目" class="headerlink" title="记录一次高级JAVA开发面试题目"></a>记录一次高级JAVA开发面试题目</h1><p>面试时间大概40多分钟，问了有十几个问题，回忆一下记录下来，总结经验，以供参考。</p><a id="more"></a><p><strong>1、 static关键字的作用，平时开发用在什么地方？</strong><br>答：主要有三种用法。<br>①修饰成员变量，用static修饰的成员变量就成为静态变量，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。<br>②static修饰方法，该方法就被定义为静态方法，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。<br>③用static修饰代码块，该代码块就被定义为静态代码块，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。</p><p><strong>2、static修饰的成员变量和非static修饰的成员变量有什么区别？分别存在什么区域？</strong><br>答：静态成员变量在内存中只会存在一份，是通过类名访问，存在于静态区中。非静态成员变量是随着对象的创建而存在的，可以有多份，通过创建的对象访问，存在于堆内存中。</p><p><strong>3、说一下类初始化的顺序。</strong><br>答：静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。</p><p><strong>4、常用的集合类型有哪些？</strong><br>答：有Map、Set、List是比较常用的。</p><p><strong>5、List常用的实现类有哪些？ArrayList和LinkedList底层实现原理是什么？</strong><br>答：List常用的实现类有ArrayList和LinkedList。ArrayList底层原理是数组+动态扩容机制实现的，LinkedList底层原理是用Node结点形成的链表实现的。</p><p><strong>6、在开发中如何选择使用ArrayList和LinkedList？</strong><br>答：ArrayList是数组实现，所以通过下标访问效率最快，但是缺点是如果增删比较频繁的情况下，需要经常扩容，性能不是很好。LinkedList在增删的情况下，效率较高，但是访问集合中的元素时都需要从第一个元素开始遍历，效率较低。所以如果增删的情况较多的时候，可以使用LinkedList。查询较多时使用ArrayList。</p><p> <strong>7、List集合如果要排序有哪些实现方式？</strong><br>①使用List接口定义的sort()方法。</p><pre><code class="java">list.sort(Comparator.comparingInt(User::getAge));</code></pre><p>②使用Collections的sort()方法，排序的对象需要实现Comparable接口，重写compareTo()方法。</p><pre><code class="java">//实现Comparable接口public class User implements Comparable&lt;User&gt; {    //重写compareTo方法    @Override    public int compareTo(User user) {            return Integer.compare(this.getAge(), user.getAge());    }}</code></pre><p>使用Collections的sort()方法</p><pre><code class="java">Collections.sort(list);//如果不想实现Comparable接口，也可以使用这个方法Collections.sort(list,Comparator.comparingInt(User::getAge));</code></pre><p>③使用Stream流操作的sort()方法，传入一个Comparator接口。</p><pre><code class="java">list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList());</code></pre><p> <strong>8、ArrayList是线程安全的吗？有什么方式可以让ArrayList变成线程安全的？</strong><br>答：不是线程安全的。<br>使用Collections的synchronizedList()方法包装可获得线程安全的ArrayList。</p><pre><code class="java">List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code></pre><p><strong>9、你是怎么在项目中使用redis的？</strong><br>答：这其实是考了“redis常用的应用场景”这个问题。<br>①利用redis读写速度快的特点，可以做热点数据的储存，降低数据库查询的压力。<br>②利用redis键值设置有效期的特性，做一些限时的业务。比如手机验证码。<br>③利用setnx命令的特性，可以实现分布式锁。</p><p><strong>10、使用Redis实现分布式锁的原理是什么？</strong><br>答： 利用setnx命令的特性。使用setnx一个lockKey字符串作为键，当前的时间+上锁时间作为value。如果返回是0，表示已经被上锁了，需要等待锁持有者释放锁；如果返回1，则表示获得了锁。客户端释放锁的话执行del命令删除lockKey对应的键值。</p><p><strong>11、如果使用分布式锁加锁后，由于一些异常的原因没有执行解锁的操作，怎么办？</strong><br>答：一般解锁操作会放在finally代码块中执行。如果有极端情况下没有执行到解锁的操作，可以通过key对应的时间戳判断是否超时，然后使用GETSET命令去进行解锁，通过判断返回的时间戳是否是超时的key对应的时间戳，确认是否成功上锁。</p><p><strong>12、如果加分布式锁的时候，业务操作时间比较长，造成长时间的阻塞，有什么解决方案？</strong><br>答：可以在加锁时启动一个watch dog(看门狗)线程，每隔10秒检查一下，如果客户端还持有锁则加长lockKey的生存时间。或者可以考虑用zookeeper实现的分布式锁，因为zk实现原理是基于事件监听的方式来实现。</p><p><strong>13、MySQL性能优化的策略有哪些？</strong><br>①复杂的多表查询可以拆成多句简单查询。<br>②返回尽量少的列，按需返回，严禁使用select *。<br>③尽量使用索引列做查询条件和排序条件。<br>④使用复合索引要遵循最左匹配原则。</p><p><strong>14、MySQL索引创建的原则是什么？</strong><br>①对于查询频率高的字段，创建索引。<br>②对排序、分组、联合查询频率高的字段创建索引。<br>③如果多个列都需要设置索引，可以考虑创建复合索引。<br>④尽量选择数据量较少的列作为索引。<br>⑤一个表的索引数量不宜过多，会降低查询的效率。</p><p><strong>15、雪花算法是什么原理？</strong><br>答：使用一个 64 bit 的 long 型的数字作为全局唯一 id。是由时间戳、机房id、机器id、序号组成的。结合了UUID的全局唯一的特点，又具有自增有顺序的特点。</p><p><strong>16、为什么雪花算法生成的主键有字符串类型和long类型两种类型？</strong><br>答：因为后端返回给前端一个long类型时，会有可能产生丢失精度的问题，所以会有字符串的类型，弥补这个问题。</p><p><strong>17、谈一谈MySQL锁机制。</strong><br>主要有以下几种锁：<br>表锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>行锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>在MySQL中只有InnoDB存储引擎可以使用行锁。行锁又分为以下两种形式：<br>读锁(共享锁)：当读取一条数据时，会加上读锁，其他事务如果要读取是可以的，如果要修改则要等事务释放才可以。<br>写锁(排他锁)：这个比较简单，当有一个事务要修改数据时，就会给这些行加上写锁。在加锁期间，不允许其他事务加上任何的锁，只有当这个事务释放了，才可以加锁操作。</p><p>在这次面试中，其实也不是特别难，大部分都回答得不错，但是有两个问题不是很好。雪花算法为什么主键生成有两种类型这个问题没有答出来，还有分布式锁长时间阻塞的解决方案没有详细展开讲。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式在实战中的应用</title>
    <link href="/2020/05/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>比如有些人喜欢写文章，但是如果从头到尾原创的话太麻烦了，那么他可以上网去搜索，找一篇写得不错的文章，然后复制下来，做一些修改，最后发布就是自己的文章了。这其实就使用了原型模式的设计模式，创建一个对象过于麻烦的时候，我们只需要创建一次，后面再创建的话只需要对原对象进行克隆即可。</p><h2 id="不使用原型模式的问题"><a href="#不使用原型模式的问题" class="headerlink" title="不使用原型模式的问题"></a>不使用原型模式的问题</h2><p>假设我们有一个用户<code>User</code>的类，类里面有很多字段，当我们创建对象时，就会像这样子：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setAge(18);        user.setJob(&quot;程序员&quot;);        user.setSchool(&quot;家里蹲大学&quot;);        user.setNation(&quot;汉族&quot;);        //0-男 1-女        user.setGender((byte)0);        user.setPhone(&quot;110&quot;);        user.setPoliticalFeatures(&quot;群众&quot;);        user.setEducation(&quot;大学本科&quot;);        //第二个用户，跟第一个用户只有id，name，phone这三个字段不同        User user1 = new User();        user1.setId(2);        user1.setName(&quot;李四&quot;);        user1.setAge(18);        user1.setJob(&quot;程序员&quot;);        user1.setSchool(&quot;家里蹲大学&quot;);        user1.setNation(&quot;汉族&quot;);        //0-男 1-女        user1.setGender((byte)0);        user1.setPhone(&quot;111&quot;);        user1.setPoliticalFeatures(&quot;群众&quot;);        user1.setEducation(&quot;大学本科&quot;);    }}</code></pre><p>不难看出上面的代码有以下问题：</p><p>1.<code>user</code>对象有10个字段，明显在创建第二个<code>user</code>对象的时候有很多重复的设值的操作。在实际项目中，肯定还不止设置10个字段，那么就会显得很难看。</p><p>2.创建对象如果消耗资源很多的话，这样多次去创建设值肯定会造成资源浪费。</p><p>对于以上的问题，我们可以使用原型模式进行优化。</p><h2 id="使用Cloneable接口优化"><a href="#使用Cloneable接口优化" class="headerlink" title="使用Cloneable接口优化"></a>使用Cloneable接口优化</h2><p><code>java</code>提供了一个<code>Cloneable</code>接口，可以实现克隆对象的用途，怎么实现，请看以下代码：</p><pre><code class="java">//实现Cloneable接口public class User implements Cloneable {    //省略了字段    //省略了字段的Get、Set方法    //重写clone()方法    @Override    public User clone() throws CloneNotSupportedException {        return (User) super.clone();    }}</code></pre><p>然后就可以把<code>main()</code>方法的代码改成以下这样：</p><pre><code class="java">public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setAge(18);        user.setJob(&quot;程序员&quot;);        user.setSchool(&quot;家里蹲大学&quot;);        user.setNation(&quot;汉族&quot;);        //0-男 1-女        user.setGender((byte)0);        user.setPhone(&quot;110&quot;);        user.setPoliticalFeatures(&quot;群众&quot;);        user.setEducation(&quot;大学本科&quot;);        //调用克隆方法，复制第一个user对象        User user1 = user.clone();        user1.setId(2);        user1.setName(&quot;李四&quot;);        user1.setPhone(&quot;111&quot;);        System.out.println(user1);        //控制台打印结果        //User{id=2, name=&#39;李四&#39;, phone=&#39;111&#39;, nation=&#39;汉族&#39;...}}</code></pre><p>你是不是有疑问，这两个<code>user</code>对象内存地址是否一致呢？我们可以打印出来看看：</p><pre><code class="java">com.yehongzhi.httpclient.model.User@4c873330com.yehongzhi.httpclient.model.User@119d7047</code></pre><p>内存地址是不一样的，所以我们可以得出一个结论：<strong>克隆出来的对象是一个新的对象。</strong></p><p><strong>问题：</strong>克隆方法的底层是不是调用了构造器创建了一个对象的呢？</p><p>我们可以在构造器上面加一些打印语句来验证一下：</p><pre><code class="java">public class User implements Cloneable {    //其他非重点代码省略    //构造器，如果以下语句打印了两次，则证明clone调用了构造器创建对象    public User() {        System.out.println(&quot;调用了无参构造器&quot;);    }    //克隆方法    @Override    public User clone() throws CloneNotSupportedException {        System.out.println(&quot;调用了clone()方法&quot;);        return (User) super.clone();    }}</code></pre><p>我们运行<code>main()</code>方法后，可以看到控制台打印信息如下：</p><pre><code class="java">// 调用了无参构造器// 调用了clone()方法</code></pre><p>只调用了一次构造器，我们可以得出结论：</p><blockquote><p>clone()方法不是调用了构造器创建对象的。</p></blockquote><p>如果你刨根究底，究竟clone()方法是怎么创建对象的，其实也很简单，打开源码：</p><pre><code class="java">public class Object {    private static native void registerNatives();    static {        registerNatives();    }    //最终会调用Object的克隆方法，是一个native修饰的方法    protected native Object clone() throws CloneNotSupportedException;}</code></pre><p>native修饰的方法是什么意思呢？意思就是这个方法的实现不是用<code>java</code>，而是<code>C/C++</code>实现。这个native关键字我们可以单独写一篇文章细讲，这里就不深入展开。底层的实现逻辑就是拷贝一份数据，开辟一块新的内存。所以拷贝出来的对象，打印的内存地址和原来的对象不一样。</p><h2 id="使用Cloneable接口的问题"><a href="#使用Cloneable接口的问题" class="headerlink" title="使用Cloneable接口的问题"></a>使用Cloneable接口的问题</h2><p>使用<code>Cloneable</code>接口是不是就完美的呢，其实并不是，因为如果一个对象的字段也是一个对象，是一个引用数据类型时，那就会有问题。请看以下代码：</p><p>我们增加一个对象<code>IdCard</code>类</p><pre><code class="java">public class IdCard {    private String cardNo;    private Integer validityPeriod;    private Date createDate;    //省略getter、setter方法}</code></pre><pre><code class="java">public class User implements Cloneable {    //其他字段省略    //身份证对象    private IdCard idCard;    //省略getter、setter方法}</code></pre><p>然后我们在<code>main()</code>方法赋值：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        //省略其他字段的赋值        //创建一个IdCard对象        IdCard idCard = new IdCard();        //身份证号码        idCard.setCardNo(&quot;111111&quot;);        //创建日期        idCard.setCreateDate(new Date());        //身份证有效期        idCard.setValidityPeriod(10);        //user对象设置身份证对象        user.setIdCard(idCard);        //user克隆，得到user1        User user1 = user.clone();        //打印user、user1的IdCard对象的内存地址，内存地址一样！        System.out.println(user.getIdCard());//IdCard@4c873330        System.out.println(user1.getIdCard());//IdCard@4c873330        //当改变克隆体user1的IdCard里面的字段值        user1.getIdCard().setCardNo(&quot;222222&quot;);        //源对象user的IdCard里面的字段值也跟着一起改变了        System.out.println(user.getIdCard().getCardNo());//222222    }}</code></pre><p>明显这样的克隆是有巨大的问题的，因为项目中不可能只有基本数据类型。那怎么解决呢？</p><pre><code class="java">//IdCard对象也要实现Cloneable接口public class IdCard implements Cloneable{    //也需要重写clone()方法    @Override    protected IdCard clone() throws CloneNotSupportedException {        return (IdCard)super.clone();    }}</code></pre><pre><code class="java">public class User implements Cloneable {    @Override    public User clone() throws CloneNotSupportedException {        User user = (User) super.clone();        //获取idCard源对象        IdCard idCard = user.getIdCard();        //克隆一个idCard对象。然后set值到user对象中        user.setIdCard(idCard.clone());        return user;    }}</code></pre><p>最后我们再调用<code>main()</code>方法：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        //创建一个IdCard对象        IdCard idCard = new IdCard();        //身份证号码        idCard.setCardNo(&quot;111111&quot;);        //user对象设置身份证对象        user.setIdCard(idCard);        //克隆user对象，得到user1对象        User user1 = user.clone();        //打印user、user1的IdCard对象的内存地址，内存地址不一样了！        System.out.println(user.getIdCard());//IdCard@4c873330        System.out.println(user1.getIdCard());//IdCard@119d7047        //当改变克隆体user1的IdCard里面的字段值        user1.getIdCard().setCardNo(&quot;222222&quot;);        //源对象user的IdCard里面的字段值也跟着一起改变了        System.out.println(user.getIdCard().getCardNo());//111111    }}</code></pre><h2 id="使用序列化实现深克隆"><a href="#使用序列化实现深克隆" class="headerlink" title="使用序列化实现深克隆"></a>使用序列化实现深克隆</h2><p>上面使用<code>Cloneable</code>接口的方式，被称为浅克隆，如果你想要克隆的源对象里面又有对象时，里面的对象也要实现<code>Cloneable</code>接口，然后修改源对象的<code>clone()</code>方法，这样就非常麻烦，而且当扩展时会破坏开闭原则。</p><p>解决方法，我们可以采用序列化对象的方式，实现深克隆呢？请看以下代码：</p><p><code>User</code>对象实现<code>Serializable</code>接口:</p><pre><code class="java">public class User implements Serializable {    private static final long serialVersionUID = 8656071024384993135L;}</code></pre><p><code>IdCard</code>对象实现<code>Serializable</code>接口：</p><pre><code class="java">public class IdCard implements Serializable {    private static final long serialVersionUID = -422430076410272813L;}</code></pre><p>创建一个工具类<code>CloneUtil</code>实现深克隆：</p><pre><code class="java">public class CloneUtil {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T&gt; T depthClone(T t, Class&lt;T&gt; clazz) throws Exception {        ByteArrayOutputStream baos = null;        ObjectOutputStream ous = null;        ByteArrayInputStream bais = null;        ObjectInputStream ois = null;        try {            //将源对象序列化，写入流中，写入流的对象是一个拷贝的对象，原对象还在JVM中            baos = new ByteArrayOutputStream();            ous = new ObjectOutputStream(baos);            ous.writeObject(t);            //把流中的对象再读取到内存中，就获得了克隆后的对象            bais = new ByteArrayInputStream(baos.toByteArray());            ois = new ObjectInputStream(bais);            return (T) ois.readObject();        } catch (Exception e) {            e.printStackTrace();            throw new RuntimeException(&quot;深克隆出现异常&quot;);        } finally {            if (ous != null) {ous.close();}            if (baos != null) {baos.close();}            if (bais != null) {bais.close();}            if (ois != null) {ois.close();}        }    }}</code></pre><p>验证是否深克隆，在<code>main()</code>方法中打印内存地址查看即可：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        User user = new User();        user.setIdCard(new IdCard());        User user1 = CloneUtil.depthClone(user, User.class);        //内存地址都不相同，达到了深克隆的效果        System.out.println(user);//User@3d075dc0        System.out.println(user1);//User@2ef1e4fa        System.out.println(user.getIdCard());//IdCard@214c265e        System.out.println(user1.getIdCard());//IdCard@306a30c7    }}</code></pre><p>用序列化实现深克隆的优点就是，对源代码侵入性很低，只需要实现<code>Serializable</code>接口，不需要一层一层去实现<code>Cloneable</code>接口，还有重写<code>clone()</code>方法。</p><p><strong>问题：</strong>如果这个实体类是在<code>jar</code>包中的呢，我们没法去修改实体类的代码，那怎么实现克隆呢？</p><h2 id="使用反射实现克隆"><a href="#使用反射实现克隆" class="headerlink" title="使用反射实现克隆"></a>使用反射实现克隆</h2><p>利用反射，实际上我们可以拿到源对象的任何值，所以就可以实现克隆，请看以下代码：</p><p>我们创建一个<code>copyProperties()</code>方法，具体实现看以下代码：</p><pre><code class="java">public class CloneUtil {    public static void copyProperties(Object source, Object target) throws Exception {        //获取源对象的属性描述器        PropertyDescriptor[] sourceDescriptors = Introspector                .getBeanInfo(source.getClass())                .getPropertyDescriptors();        //获取目标对象的字段名称集合        List&lt;String&gt; targetFieldNames = Arrays                .stream(target.getClass().getDeclaredFields())                .map(Field::getName)                .collect(Collectors.toList());        for (PropertyDescriptor sourceProperty : sourceDescriptors) {            //获取源对象的属性名称            String name = sourceProperty.getName();            //源对象的getter方法            Method readMethod = sourceProperty.getReadMethod();            if (!readMethod.isAccessible()) {                //设置方法的可访问权限                readMethod.setAccessible(true);            }            //调用源对象的getter方法，获取到里面的每一个值            Object value = readMethod.invoke(source);            //如果源对象的属性名称包含在目标对象的字段名称集合中            if (targetFieldNames.contains(name)) {                //则通过源对象的属性名称获取目标对象属性的属性描述器                PropertyDescriptor propertyDescriptor = new PropertyDescriptor(name, target.getClass());                //获取目标对象的setter方法                Method writeMethod = propertyDescriptor.getWriteMethod();                writeMethod.setAccessible(true);                //执行setter方法，参数是从源对象getter方法获取到的值                writeMethod.invoke(target, value);            }        }    }}</code></pre><p>测试：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setIdCard(new IdCard());        User user1 = new User();        CloneUtil.copyProperties(user, user1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三        System.out.println(user.getIdCard());//IdCard@b81eda8        System.out.println(user1.getIdCard());//IdCard@b81eda8    }</code></pre><p>这样实现的不是深克隆的效果，所以<code>IdCard</code>对象的内存地址还是一样的。为了避免这样的结果，我们可以在使用时注意一下：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setName(&quot;张三&quot;);        IdCard idCard = new IdCard();        user.setIdCard(idCard);        User user1 = new User();        //创建一个新的IdCard对象        IdCard idCard1 = new IdCard();        CloneUtil.copyProperties(user, user1);        //复制idCard的值到idCard1里        CloneUtil.copyProperties(idCard,idCard1);        //再设置idCard1到user1中        user1.setIdCard(idCard1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三        System.out.println(user.getIdCard());//IdCard@68de145        //内存地址不同        System.out.println(user1.getIdCard());//IdCard@27fa135a    }</code></pre><p>这样就避免产生内存地址一样的情况了。</p><h2 id="Spring的copyProperties"><a href="#Spring的copyProperties" class="headerlink" title="Spring的copyProperties()"></a>Spring的copyProperties()</h2><p>实际上在<code>Spring</code>框架中，已经提供了<code>copyProperties()</code>方法：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setName(&quot;张三&quot;);        User user1 = new User();        //Spring的copyProperties()方法        BeanUtils.copyProperties(user,user1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三    }</code></pre><p>一般在实际项目中，我们采用<code>copyProperties()</code>方法实现原型模式会更好，因为这样不会破坏开闭原则，即使是<code>jar</code>包中定义的实体类，也可以使用。缺点就是如果对象层级比较多的话，会比较麻烦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现原型模式的三种方式：实现<code>Cloneable</code>接口、序列化对象、反射机制。</p><p>原型模式的优点：</p><ol><li>提高了创建对象的性能，避免了调用构造器创建对象。</li><li>对于创建一个对象需要很多资源的情况，可以减少资源的浪费。</li></ol><p>原型模式的缺点：</p><ol><li>如果使用<code>Cloneable</code>接口的方式，需要实现<code>Cloneable</code>接口，对代码有一定的侵入性。</li><li>如果使用序列化方式，则需要实现<code>Serializable</code>接口，对代码也有一定的侵入性。</li><li>如果使用反射机制，层级较多时会比较难维护。</li></ol><p>以上就是原型模式的学习，更多的java技术分享，就关注<strong>java技术爱好者</strong>吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰者模式与IO流</title>
    <link href="/2020/05/04/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8EIO%E6%B5%81/"/>
    <url>/2020/05/04/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8EIO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>装饰者模式是一种<strong>对象结构型</strong>模式。<strong>动态</strong>地给一个对象添加一些<strong>额外的</strong>职责，就增加功能来说，装饰者模式比生成子类更为灵活。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>上面的定义在网上是随处可见的描述，怎么解释呢。比如：我前几天和女朋友去买戒指，珠宝店的销售给我推荐了一种<strong>自由搭配</strong>的原创戒指。他跟我介绍戒指的元素需要选择材质(黄金，铂金，彩金)、表面工艺(拉丝，磨砂，光滑，铸造)、镶钻(内嵌，外嵌)、指环大小等等，然后组成一个戒指。这种就是装饰者模式的应用，原型是一个戒指，不断地给对象添加额外的职责，然后得到最终想要的产品。这样就可以通过不同的搭配产生很多不同类型的戒指。</p><p>后面那句<strong>装饰者模式比生成子类更为灵活</strong>怎么理解。如果用子类去描述的话，要把每一种搭配的结果都变成一个子类，也就是要穷举，就会产生很多子类，也就是造成<strong>“类爆炸”</strong>。所以就会说装饰者模式更加灵活。</p><h2 id="来个例子"><a href="#来个例子" class="headerlink" title="来个例子"></a>来个例子</h2><p>现在有一个需求，要求做一个加密的工具类，对传入的字符串加密。加密的算法有很多，有<strong>MD5、AES、DES等等</strong>，一般加密都不是单独使用一种加密算法，而是多种混合一起使用，这样可以提高安全性。</p><p>现在有三种算法：<code>MD5、AES、DES</code>。做一个工具类，给系统提供加密的服务，要求可以自由搭配使用。</p><h2 id="使用继承的方式实现"><a href="#使用继承的方式实现" class="headerlink" title="使用继承的方式实现"></a>使用继承的方式实现</h2><p>我们就创建一个抽象类<code>EncryptionBase</code>，每一种组合方式就创建一个子类继承<code>EncryptionBase</code>，现在有三种加密方式，很容易我们可以穷举完，总共有6种组合。请看以下代码：</p><p>首先创建一个抽象类<code>EncryptionBase</code>：</p><pre><code class="java">public abstract class EncryptionBase {    public abstract String encrypt(String string,String password);}</code></pre><p>接着创建子类继承抽象类，并且实现其方法。以其中一个为例，其他实现类都类似：</p><pre><code class="java">public class AESandDESandMD5Encryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        //网上可以找具体加密的代码，我这里篇幅受限就不展示了        //AES加密        byte[] encryptByAES = AESUtil.encrypt(string, password);        //DES加密        byte[] encryptByDES = DESUtil.encrypt(encryptByAES, password);        //MD5加密        return MD5Util.encryptByMD5(new String(encryptByDES) + password);    }}</code></pre><p>我们就可以实现以下效果，有6个实现类分别实现了3种加密算法的不同顺序。</p><pre><code class="java">public static void main(String[] args) {        String string = &quot;需要加密的字符串&quot;;        //秘钥        String password = &quot;12345678&quot;;        //第一种加密顺序：AES-&gt;DES-&gt;MD5        EncryptionBase AESandDESandMD5 = new AESandDESandMD5Encryption();        //第二种加密顺序：AES-&gt;MD5-&gt;DES        EncryptionBase AESandMD5andDES = new AESandMD5andDESEncryption();        //第三种加密顺序：DES-&gt;AES-&gt;MD5        EncryptionBase DESandAESandMD5 = new DESandAESandMD5Encryption();        //第四种加密顺序：DES-&gt;MD5-&gt;AES        EncryptionBase DESandMD5andAES = new DESandMD5andAESEncryption();        //第五种加密顺序：MD5-&gt;DES-&gt;AES        EncryptionBase MD5andDESandAES = new MD5andDESandAESEncryption();        //第六种加密顺序：MD5-&gt;AES-&gt;DES        EncryptionBase MD5andAESandDES = new MD5andAESandDESEncryption();    }</code></pre><p>以上就是使用继承的方式来完成这个需求。看起来没什么问题，但是仔细思考你会发现几个问题。</p><ol><li><strong>会创建很多子类。</strong>为什么3种算法是6个类呢？这是根据数学的排列组合<code>3*2*1=6</code>，假设再多两种算法呢？那就是<code>5*4*3*2*1=120</code>，那就是120个类了！这就是<strong>“类爆炸”</strong>。</li><li><strong>不符合开闭原则。</strong>假设增加了新的算法，那就要修改原来的类，不利于代码的维护。</li><li>假如其中一种加密算法要用两次，比如双重<code>MD5</code>加密，那也是很难扩展的。</li></ol><p>如果你不会装饰者模式，那估计要加班加点去写代码，创建很多类。如果你会装饰者模式，那问题就很简单了，那怎么做呢？请继续看下去。</p><h2 id="使用装饰者模式实现"><a href="#使用装饰者模式实现" class="headerlink" title="使用装饰者模式实现"></a>使用装饰者模式实现</h2><p>首先创建三种算法的基础类，继承<code>EncryptionBase</code>，实现三种加密算法。</p><p>MD5加密</p><pre><code class="java">public class MD5Encryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用MD5加密，得到基础密文&quot;);        return MD5Util.encryptByMD5(string + password);    }}</code></pre><p>AES加密</p><pre><code class="java">public class AESEncryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用AES加密，得到基础密文&quot;);        return new String(AESUtil.encrypt(string, password));    }}</code></pre><p>DES加密</p><pre><code class="java">public class DESEncryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用DES加密，得到基础密文&quot;);        return new String(DESUtil.encrypt(string.getBytes(), password));    }}</code></pre><p>接着创建一个装饰抽象类<code>EncryptionDecorator</code>，需要继承<code>EncryptionBase</code></p><pre><code class="java">public abstract class EncryptionDecorator extends EncryptionBase {    //定义一个父类的成员变量，用来存储其他装饰类，或者基础加密类    private EncryptionBase encryption;    public EncryptionDecorator(EncryptionBase encryption) {        this.encryption = encryption;    }    @Override    public String encrypt(String string, String password) throws Exception{        return encryption.encrypt(string, password);    }}</code></pre><p>然后实现三种加密的装饰者实现类，需要继承抽象装饰者类<code>EncryptionDecorator</code>。</p><p>MD5加密装饰者实现类<code>MD5EncryptionDecorator</code></p><pre><code class="java">public class MD5EncryptionDecorator extends EncryptionDecorator {    public MD5EncryptionDecorator(EncryptionBase encryption) {        //有参构造器获取到参数，调用父类的有参构造器，        //当下面encrypt()方法里调用父类的加密算法就会调用传入的算法实现类的加密算法        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用MD5加密&quot;);        //得到的密文，再用MD5算法加密，返回        return MD5Util.encryptByMD5(encrypt + password);    }}</code></pre><p>AES加密装饰者实现类<code>AESEncryptionDecorator</code></p><pre><code class="java">public class AESEncryptionDecorator extends EncryptionDecorator {    public AESEncryptionDecorator(EncryptionBase encryption) {        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用AES加密&quot;);        //得到的密文，再用AES算法加密，返回        return new String(AESUtil.encrypt(encrypt, password),&quot;UTF-8&quot;);    }}</code></pre><p>DES加密装饰者实现类<code>DESEncryptionDecorator</code></p><pre><code class="java">public class DESEncryptionDecorator extends EncryptionDecorator {    public DESEncryptionDecorator(EncryptionBase encryption) {        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用DES加密&quot;);        //得到的密文，再用DES算法加密，返回        return new String(DESUtil.encrypt(encrypt.getBytes(), password),&quot;UTF-8&quot;);    }}</code></pre><p>大功告成！我们用<code>main()</code>方法测试一下：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception{        String string = &quot;需要加密的字符串&quot;;        String password = &quot;12345678&quot;;        //第一种加密顺序：AES-&gt;DES-&gt;MD5        EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption()));        encryptionBase.encrypt(string, password);    }}</code></pre><p>控制台打印结果：</p><pre><code class="java">/**使用AES加密，得到基础密文使用DES加密使用MD5加密*/</code></pre><p>我们可以看到结果是很完美地实现了，你可以任意搭配加密算法，即使加多N种算法，我们也不会呈指数增加类的数量，只需要增加M*N个类即可，M是基础构件数量，N是具体装饰类数量。</p><p>原理是什么呢？我们不能说只学到形式，而不明白原理。接下来看类图。</p><p>在IDEA可以选中类名，然后右键，选中“Diagrams”，再选中“show Diagrams…”，就可以打开类图。</p><img src="https://static.lovebilibili.com/MD5EncryptionDecorator.png" srcset="/img/loading.gif"/><pre><code class="java">//MD5(DES(AES))，最顶层的父类是AES，所以先执行，第二层是DES，第二执行，最外层是MD5第三执行EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption()));encryptionBase.encrypt(string, password);</code></pre><p>以上面这句代码为例，那么调用顺序就是：AES-&gt;DES-&gt;MD5</p><img src="https://static.lovebilibili.com/decorator1.png" srcset="/img/loading.gif" style="width:100%;"/><p>这就是装饰者模式的原理，其实很简单的，很容易就可以看清楚。</p><h2 id="装饰者模式与I-O流"><a href="#装饰者模式与I-O流" class="headerlink" title="装饰者模式与I/O流"></a>装饰者模式与I/O流</h2><p>看了上面的代码，很容易我们能联想到IO流也有类似的创建方式，比如我们要用文件缓冲输入流，那就要这样创建：</p><pre><code class="java">InputStream inputStream     = new BufferedInputStream(new FileInputStream(new File(&quot;/D:abc.text&quot;)));</code></pre><p>可以看出IO流使用了装饰者模式。</p><p>如果我们打开源码，查看<code>BufferedInputStream</code>，我们可以看到：</p><pre><code class="java">public class BufferedInputStream extends FilterInputStream {    //有参构造器    public BufferedInputStream(InputStream in, int size) {        //调用父类构造器，这是关键        //通过上面我们学过的例子，可以知道BufferedInputStream是装饰实现类        super(in);        if (size &lt;= 0) {            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);        }        buf = new byte[size];    }}</code></pre><p>关键在<code>FilterInputStream</code>这个类，这是装饰者模式的基类。查看源码：</p><pre><code class="java">public class FilterInputStream extends InputStream {    /**     * The input stream to be filtered.     */    protected volatile InputStream in;    protected FilterInputStream(InputStream in) {        this.in = in;    }    public int read() throws IOException {        return in.read();    }}</code></pre><p><code>FilterInputStream</code>类似于加密算法例子的<code>EncryptionDecorator</code>类。我们可以通过加密算法的例子和这个作对比，就可以很容易地看出他们的关系。类图如下：</p><img src="https://static.lovebilibili.com/FilterInputStream.png" srcset="/img/loading.gif" style="width:100%;"/><p><code>FileInputStream</code>就是基础构件类，可以通过<code>FilterInputStream</code>的子类去做扩展，增加额外的功能，比如可以使用<code>BufferedInputStream</code>增加缓冲的作用。</p><p>接着我们真正理解了IO流的装饰者模式的应用后，我们可以写一个扩展类，实现一个功能：读取磁盘的文件，把所有字母变成大写的字母。代码如下：</p><pre><code class="java">public class CapitalizaInputStream extends FilterInputStream {    public CapitalizaInputStream(InputStream in) {        super(in);    }    @Override    public int read(byte[] b, int off, int len) throws IOException {        int result = super.read(b, off, len);        for (int i = off; i &lt; off + result; i++){            //如果是小写字母，转成大写，其他不是小写字母的不变            if(Character.isLetter((char)b[i])){                b[i] = (byte) Character.toUpperCase((char) b[i]);            }        }        return result;    }}</code></pre><p>abc.txt文件内容：</p><pre><code class="yaml">abcdefghijklmnopqrstuvwxyz</code></pre><p>Main方法测试代码：</p><pre><code class="java">public static void main(String[] args) throws Exception {        InputStream inputStream             = new CapitalizaInputStream(new FileInputStream(new File(&quot;D://abc.txt&quot;)));        byte[] bytes = new byte[1024 * 2];        int c;        while ((c = inputStream.read(bytes, 0, bytes.length)) != -1) {            System.out.println(new String(bytes, 0, c));        }        inputStream.close();    }</code></pre><p>控制台打印结果：</p><pre><code class="yaml">ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre><p>以上就是IO流关于装饰者模式的扩展，能够加深我们对装饰者模式的理解。很多博客写不清楚，讲得很复杂，或者讲得很简单，很大原因是我们只看，而没有动手去做，动手去自己写，自己琢磨，就很容易能理解。这是学习方法，不是关注了公众号，看几篇文章就能轻松学会的，学习总是要自己动手才会理解深刻。看我的文章可以提供一些思路，更容易去上手。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰者模式的优点：</p><ol><li>可以动态地扩展类的功能，不会相互耦合。</li><li>符合开闭原则，利于代码维护。</li><li>比继承扩展的方式要更加灵活。</li></ol><p>缺点：多层装饰，代码结构变得复杂。</p><p>更多的java技术分享，就关注java技术爱好者吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式以及实际项目应用</title>
    <link href="/2020/05/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式（Observer），又叫<strong>发布-订阅模式（Publish/Subscribe）</strong>，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>比如我们在宿舍打斗地主，我们要找个人来“放风”，这个人在门口观察，如果有宿管过了检查，那么就通知宿舍其他的小伙伴停止斗地主回床上睡觉。这种模式就被称为观察者模式。</p><p>从这个例子看，“宿管是否过来宿舍”是订阅的主题，观察者是放风的人，订阅者是打斗地主的小伙伴，被观察者就是宿管。</p><h2 id="不使用观察者模式的问题"><a href="#不使用观察者模式的问题" class="headerlink" title="不使用观察者模式的问题"></a>不使用观察者模式的问题</h2><p>假设我们基于之前在策略模式讲的电子支付的例子，支付完成后要发送消息，发送的消息有：短信，公众号消息，APP站内消息，邮箱。如果不使用观察者模式，怎么做呢？看代码：</p><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        //发送短信        System.out.println(&quot;发送短信：&quot;+msg);        //发送微信公众号消息        System.out.println(&quot;发送微信公众号消息：&quot;+msg);        //发送邮件        System.out.println(&quot;发送邮件：&quot;+msg);        //发送APP系统信息        System.out.println(&quot;发送APP系统信息：&quot;+msg);        return msg;    }</code></pre><p>启动项目是没有问题的，我们调用接口后可以看到控制台打印以下信息：</p><pre><code class="java">/**发送短信：使用 支付宝支付 ,消费了 100 元发送微信公众号消息：使用 支付宝支付 ,消费了 100 元发送邮件：使用 支付宝支付 ,消费了 100 元发送APP系统信息：使用 支付宝支付 ,消费了 100 元*/</code></pre><p><strong>但是我们很明显可以看出有以下的问题：</strong></p><ul><li>每次支付如果需要新增一种消息通知方式，则要修改原来的类，不利于维护。</li><li>违反了开闭原则，对拓展开放，对修改关闭。</li><li>违反了单一职责原则，支付不应该糅杂消息通知的功能。</li></ul><p>上面就从代码演示了为什么要使用观察者模式，很多文章说不清楚，单纯地抛出一个概念和一些简单的例子，实际项目中肯定是没有那么简单。</p><h2 id="使用观察者模式优化"><a href="#使用观察者模式优化" class="headerlink" title="使用观察者模式优化"></a>使用观察者模式优化</h2><p>这里的话，我不使用<code>java</code>自带的<code>Observer</code>和<code>Observable</code>来做，因为实际项目中一般都会使用<code>Spring</code>框架，<code>Spring</code>框架有一个事件机制，也是使用观察者模式的这种设计模式，而且在实际项目中我们往往会采用这种成熟度更高的框架，就像代理模式我们也很少会直接使用原生的<code>JDK动态代理</code>，而是采用<code>SpringAOP</code>来实现。</p><h2 id="创建支付的事件"><a href="#创建支付的事件" class="headerlink" title="创建支付的事件"></a>创建支付的事件</h2><pre><code class="java">//继承ApplicationEvent类public class PayEvent extends ApplicationEvent {    //消息体    private Map&lt;String,String&gt; map;    //订阅主题    private String topic;    public PayEvent(Object source, Map&lt;String, String&gt; map, String topic) {        //调用父类的构造器        super(source);        this.map = map;        this.topic = topic;    }    public Map&lt;String, String&gt; getMap() {        return map;    }    public void setMap(Map&lt;String, String&gt; map) {        this.map = map;    }    public String getTopic() {        return topic;    }    public void setTopic(String topic) {        this.topic = topic;    }}</code></pre><h2 id="创建事件监听类"><a href="#创建事件监听类" class="headerlink" title="创建事件监听类"></a>创建事件监听类</h2><pre><code class="java">//短信监听，实现ApplicationListener接口，重写onApplicationEvent()方法@Componentpublic class SmsListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        //订阅主题        String topic = payEvent.getTopic();        //消息体        Map&lt;String, String&gt; map = payEvent.getMap();        //发送短信        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送短信:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//公众号监听@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//邮箱监听@Componentpublic class MailListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送邮件:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//App站内消息监听@Componentpublic class AppListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送App站内消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><h2 id="重构PayServiceImpl类"><a href="#重构PayServiceImpl类" class="headerlink" title="重构PayServiceImpl类"></a>重构PayServiceImpl类</h2><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,msg);        //创建一个支付事件        PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;);        //获取Spring的ApplicationContext容器，发布事件，监听类监听到事件后就会发送消息        SpringContextUtil.getApplicationContext().publishEvent(payEvent);        return msg;    }</code></pre><p>然后我们启动项目，调用接口，控制台就可以打印的信息：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送公众号消息:使用 支付宝支付 ,消费了 100 元*/</code></pre><h2 id="异步监听事件，实现解耦"><a href="#异步监听事件，实现解耦" class="headerlink" title="异步监听事件，实现解耦"></a>异步监听事件，实现解耦</h2><p>改造之后是否就一劳永逸了呢，实际上并非如此。因为上面的消息发送的监听类是同步的，也就是如果发送消息出现异常，那就会导致支付的接口无法正常返回。请看以下代码：</p><pre><code class="java">@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        //在发送微信公众号消息的逻辑中制造异常        System.out.println(10 / 0);        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,msg);        //创建一个支付事件        PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;);        //获取Spring的ApplicationContext容器，发布事件        SpringContextUtil.getApplicationContext().publishEvent(payEvent);        //发送消息后的逻辑，打印日志到控制台        System.out.println(&quot;发送消息后的逻辑代码...&quot;);        return msg;    }</code></pre><p>我们在发送公众号消息的逻辑里制造了一个异常，然后在<code>pay()</code>方法中加了一个打印日志在发布支付的事件后面，接下来调用接口，结果是：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/</code></pre><p>发送消息后的逻辑是没有被执行。这样显然是不符合业务要求的，因为在很多时候，发送消息失败是不能影响支付流程的，应该异步进行。怎么异步进行发送消息呢？</p><p>很简单，只需要两个步骤。</p><p><strong>第一步</strong>:在监听类或者方法上添加<code>@Async</code>注解，例如：</p><pre><code class="java">@Component@Async//加上异步执行的注解public class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(10 / 0);        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><p><strong>第二步</strong>：在<code>SpringBoot</code>启动类上添加<code>@EnableAsync</code>注解，例如：</p><pre><code class="java">@SpringBootApplication@EnableAsync//添加启用异步的注解public class StrategyApplication {    public static void main(String[] args) {        SpringApplication.run(StrategyApplication.class, args);    }}</code></pre><p>然后就可以实现异步监听了，调用接口，我们可以看到控制台打印的日志如下：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元发送消息后的逻辑代码...使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/</code></pre><p>明显可以看到支付后的逻辑也能正常执行下去，证明实现了异步监听！</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在<code>Spring</code>里提供了许多的监听器，这里只是介绍了其中一种。</p><p>还有一种叫<code>SpringApplicationRunListener</code>也是很常用的监听器，可以监听<code>SpringBoot</code>项目启动的事件，用于在启动项目时加载一些配置。</p><p>还有一种叫<code>SmartApplicationListener</code>，这种监听器可以设置优先级。假设发送消息需要按顺序先发送短信，再发送公众号，再发送邮箱…，那就可以使用这种监听器实现，这里就不多做介绍了，小伙伴有兴趣的话，我可以再写一篇文章详细介绍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过重构之后，我们可以明显看到，如果以后要增加一种新的消息通知方式，是不需要修改<code>PayServiceImpl</code>的，我们只需要再增加一个监听类即可，这就符合了<code>开闭原则</code>。有利于代码的维护。而且最重要是解耦，支付的业务逻辑和发送消息的业务逻辑不会再糅合在一起了，符合<code>职责单一</code>原则。</p><p>在很多框架中，观察者模式都有应用，对于学习很多例如<code>zookeeper</code>、<code>消息中间件</code>、<code>微服务注册中心</code>等知识是有很大帮助的。在实际项目中，观察者模式也是一种很常用的设计模式。比如有一种业务场景，通讯录的部门里有员工离职，需要通知其他依赖于通讯录的应用都要同步部门的员工，那就可以使用这种方式来实现。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你用构建者(生成器)模式优雅地创建对象</title>
    <link href="/2020/04/27/%E6%95%99%E4%BD%A0%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85-%E7%94%9F%E6%88%90%E5%99%A8-%E6%A8%A1%E5%BC%8F%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/04/27/%E6%95%99%E4%BD%A0%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85-%E7%94%9F%E6%88%90%E5%99%A8-%E6%A8%A1%E5%BC%8F%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要用构建者模式"><a href="#为什么要用构建者模式" class="headerlink" title="为什么要用构建者模式"></a>为什么要用构建者模式</h1><p>很多博客文章上来就先抛出一个定义，我们不妨反过来问一句为什么要用构建者模式。<br>首先我们创建一个<code>User</code>类，然后采用有参构造器的方式创建对象。</p><pre><code class="java">public class User {    private String id;    private String name;    private String gender;    private String address;    private Integer age;    private String phone;    //省略无参构造器，有参构造器，getter，setter方法...}</code></pre><pre><code class="java">public static void main(String[] args) throws Exception {    String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);    User user = new User(id, &quot;张三&quot;, &quot;男&quot;, &quot;广州天河&quot;, 20, &quot;135461852xx&quot;);}</code></pre><p>我们通过有参构造器创建对象，并且赋值，看起来没什么问题，因为我们经常看到有人是这样写的。<br>事实上，如果<code>User</code>对象里面有更多的字段，通过有参构造器去创建对象是很难一眼看出字段具体是什么意思，我们经常要看着<code>User构造器</code>的代码，然后对照顺序才能看出字段的代表什么意思。</p><pre><code class="java">public User(String id, String name, String gender, String address, Integer age, String phone) {    this.id = id;    this.name = name;    this.gender = gender;    this.address = address;    this.age = age;    this.phone = phone;}</code></pre><p>比如通过上面这个，我们可以知道第一个参数是id，第二个参数是名字，第三个是性别…</p><h2 id="使用有参构造器的缺点："><a href="#使用有参构造器的缺点：" class="headerlink" title="使用有参构造器的缺点："></a>使用有参构造器的缺点：</h2><p>这显然不利于代码的维护性，对于不熟悉业务的新入职的员工，如果看到这种方式构建一个对象，估计要看上一会，有些项目我遇过一个构造器十几个参数的，更加离谱。而且一般老代码还不敢乱动他的这个构造器，一不小心你动了构造器里面的一个参数的顺序，直接GG；或者你在他原有的构造器后面加多一个参数，你会发现他很多地方都引用了这个有参构造器，你很多地方都要去修改，是真的恶心。</p><h2 id="解决方法一-使用无参构造器，通过setter方法设置属性值"><a href="#解决方法一-使用无参构造器，通过setter方法设置属性值" class="headerlink" title="解决方法一 使用无参构造器，通过setter方法设置属性值"></a>解决方法一 使用无参构造器，通过setter方法设置属性值</h2><pre><code class="java">public static void main(String[] args) throws Exception {    User user = new User();    user.setId(UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;));    user.setName(&quot;张三&quot;);    user.setAge(20);    user.setGender(&quot;男&quot;);    user.setPhone(&quot;135461852xx&quot;);    user.setAddress(&quot;广州天河&quot;);    out.println(user);}</code></pre><p>上面这样，显然比直接用有参构造器要好很多，因为这样就可以创建对象和赋值分开进行，一眼就可以看出对什么属性值赋值，而且如果加一个字段，我们不需要再每一处都去修改，因为用的是<strong>无参构造器</strong>，是不是这样写就是万全之计呢？<br>也不是，因为这样创建对象和赋值是分开的，各个参数的初始化被放到了不同的方法中调用，这会导致严重的线程不安全问题(使用构造器则不会有这个问题)，对象在一连串的set方法中，可能会出现状态不一致的情况，这是应该尽量避免的。</p><h2 id="解决方法二-通过构建者模式，链式调用构建方法设置属性值"><a href="#解决方法二-通过构建者模式，链式调用构建方法设置属性值" class="headerlink" title="解决方法二 通过构建者模式，链式调用构建方法设置属性值"></a>解决方法二 通过构建者模式，链式调用构建方法设置属性值</h2><p>什么是链式编程，就是调用一个方法，返回值是他本身，可以继续调用下一个方法，返回又是他本身，如此调用下去，看上去就像一条链子一样。典型的例子可以看<code>java8</code>新特性的<code>Stream</code>流操作。我们可以使用构建者模式，也能达到这种效果，并且线程安全，而且能直观地看到属性值的意思。总得来说，既保证线程安全，也很具有代码的可读性。先看结果代码：</p><pre><code class="java">public static void main(String[] args) throws Exception {    String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);    User user = UserBuilder.getInstance()            .newPojo()            .addId(id)            .addName(&quot;张三&quot;)            .addGender(&quot;男&quot;)            .addAge(20)            .addPhone(&quot;135461852xx&quot;)            .addAddress(&quot;广州天河&quot;)            .build();}</code></pre><p>怎么实现呢？其实很简单，我们只需要创建一个<code>UserBuilder</code>类即可。代码如下：</p><pre><code class="java">public class UserBuilder {    private User user;    private UserBuilder() {    }    public static UserBuilder getInstance() {        return new UserBuilder();    }    public UserBuilder newPojo() {        this.user = new User();        //返回本身        return this;    }    public UserBuilder addId(String id) {        this.user.setId(id);        //返回本身        return this;    }    public UserBuilder addName(String name) {        this.user.setName(name);        return this;    }    public UserBuilder addGender(String gender) {        this.user.setGender(gender);        return this;    }    public UserBuilder addAge(Integer age) {        this.user.setAge(age);        return this;    }    public UserBuilder addAddress(String address) {        this.user.setAddress(address);        return this;    }    public UserBuilder addPhone(String phone) {        this.user.setPhone(phone);        return this;    }    public User build() {        return this.user;    }}</code></pre><p>那么是不是这种方式就是万全之计呢，就一定没有缺点吗？</p><h3 id="构造者模式的缺点还是有的"><a href="#构造者模式的缺点还是有的" class="headerlink" title="构造者模式的缺点还是有的"></a>构造者模式的缺点还是有的</h3><p>1.代码冗长。如果一个对象的属性很多，那我们在创建一个对象时，链式就会变得很长，但是这也没有办法，无论采用构造器还是builder模式都会很长。如果非要变得简洁一点，那就只有采用原型模式(克隆)等其他方式了。<br>2.会产生很多<code>Builder</code>类。我们可以放在一个包下统一管理应该问题不大。<br>第二个缺点实际上可以使用<code>Lombok</code>插件，然后在实体类上使用<code>@Builder</code>注解，就不会产生过多的<code>Builder</code>类了。但是有些公司的技术总监不太建议使用<code>Lombok</code>，那就莫得办法了…</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>有很多博客的示范代码，<code>Builder</code>类的<code>addXXX</code>方法会写成<code>setXXX</code>方法，这是一个隐患。因为很多框架，对Setter方法比较敏感，往往会对<code>Setter</code>方法做一些处理，所以<code>Builder</code>类里的设置属性值方法尽量不要用<code>setXXX</code>命名，防止出现一些不明原因的错误。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>一般我们在项目中创建复杂的对象时，建议采用这种构建者模式创建对象。这样可以使代码可读性更好。<br>在java源码中，我们也可以看到构建者模式的应用。比如在<code>StringBuilder</code>类中：</p><pre><code class="java">@Overridepublic StringBuilder append(CharSequence s) {    super.append(s);    return this;}/** * @throws     IndexOutOfBoundsException {@inheritDoc} */@Overridepublic StringBuilder append(CharSequence s, int start, int end) {    super.append(s, start, end);    return this;}@Overridepublic StringBuilder append(char[] str) {    super.append(str);    return this;}</code></pre><p><code>StringBuilder</code>的<code>append()</code>方法也是通过返回<code>this</code>对象实现链式构建对象，人们经常说这个<code>StringBuilder</code>类线程不安全是因为<code>append()</code>方法没有用<code>synchronized</code>修饰。<code>StringBuffer</code>则用了<code>synchronized</code>修饰，所以就是线程安全的。<br>还有<code>Mybatis</code>框架中，构建<code>SqlSessionFactory</code>对象是使用<code>SqlSessionFactoryBuilder</code>类进行构建，构建者模式运用非常广泛，非常值得学习。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式以及应用</title>
    <link href="/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><strong>代理模式的定义：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</p><a id="more"></a><p>通俗点说，就是一个中介，比如有一个广州人，是个本地人，有两套房，他要租出去收租，但是除了收租，他还要去找租客，带租客看房，还要准备租房合同，核算水电费等等，很麻烦。这个本地人他也不想这么折腾，他只想<strong>完成他的核心业务(收钱)</strong>,其他杂七杂八的事情就不想管，但是总要有人去做，那就找<strong>租房中介</strong>，也就是二手房东。二手房东就代理这个广州本地人把房子租给租客。这个道理就是这么简单。</p><p>他们这些在广州有房子的本地人都可以找中介公司去代理租房是一样的。因为很多广州本地人都有这个需求，干脆就搞一个中介公司来专门去做租房子的事情。</p><p><strong>代理模式，运用在编程里，也是这个道理，有一些非核心业务的代码，在很多地方都需要用到的逻辑，可以交给代理对象完成，程序员只需要关心核心业务的逻辑即可。</strong></p><h1 id="实现代理模式的三种方式"><a href="#实现代理模式的三种方式" class="headerlink" title="实现代理模式的三种方式"></a>实现代理模式的三种方式</h1><p>项目就基于上一篇<code>模板模式</code>的文章的项目进行试验。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假设原来有一个接口<code>UserService</code>，controller层调用<code>userService</code>的<code>getAllUser()</code>方法。如下所示：</p><pre><code class="java">public interface UserService {    /**     * 获取所有用户信息     *     * @return List     * @author Ye hongzhi     * @date 2020/4/12     */    List&lt;User&gt; getAllUser() throws Exception;}</code></pre><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return userService.getAllUser();    }}</code></pre><p>如果用静态代理实现记录日志信息，怎么记录呢？</p><p>首先创建一个代理类<code>UserServiceProxy</code>，实现<code>UserService</code>接口，然后在<code>UserServiceProxy</code>里面创建一个成员变量<code>userService</code>，再写一个有参构造器来初始化<code>userService</code>。代码如下：</p><pre><code class="java">public class UserServiceProxy implements UserService {    private UserService userService;    public UserServiceProxy(UserService userService) {        this.userService = userService;    }    @Override    public List&lt;User&gt; getAllUser() throws Exception {        System.out.println(&quot;记录日志：执行getAllUser()方法前&quot;);        List&lt;User&gt; userList = userService.getAllUser();        System.out.println(userList);        System.out.println(&quot;记录日志：执行getAllUser()方法后&quot;);        return userList;    }}</code></pre><p>所以在controller层调用的方式就要改一下，是用代理类<code>UserServiceProxy</code>调用<code>getAllUser()</code>方法。如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return new UserServiceProxy(userService).getAllUser();    }}</code></pre><p>然后启动项目，调用一下接口，就可以看到控制台打印如下日志：</p><pre><code class="java">/*记录日志：执行getAllUser()方法前[User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser()方法后*/</code></pre><p>这就是静态代理的实现思路，很简单。但是一般我们肯定是不用这种方式。因为这种方式太笨了，很容易就可以看出几个缺点。</p><p><strong>1.要实现接口，也就是目标的方法要定义一个接口方法，实际上是运用了java多态的特性</strong></p><p><strong>2.第一点还不是致命的，因为JDK动态代理也是必须要定义接口；致命的是每一个你想代理的接口你都要去创建一个代理类去实现，假设有很多要代理的接口，那就创建很多代理类，这样显得很臃肿</strong></p><p>假设还是不理解为什么要动态代理，不妨我们再多加一个支付接口<code>PayService</code>，这个支付接口我们也要加上日志记录。</p><p>用静态代理怎么做？很简单呀，再创建一个<code>PayServiceProxy</code>类不就完了吗，如果还有<code>OrderService</code>(订单),</p><p><code>WarehouseService</code>(仓库)等等。那就要创建很多<code>XXXServiceProxy</code>类。如果使用动态代理，就没必要创建这么多代理类，创建一个代理类就够了！</p><blockquote><p>动态代理就是为了解决静态代理的这个缺点产生的。</p></blockquote><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK本身就带有动态代理，必须要满足一个条件，就是要有接口。原理其实和静态代理是一样的，也是用代理类去实现接口，但是代理类不是一开始就写好的，而是在程序运行时通过反射创建字节码文件然后加载到JVM。也就是动态生成的代理类对象。</p><p>下面就是用<code>JDK动态代理</code>实现代理模式。</p><pre><code class="java">public class LogRecordProxy&lt;T&gt; implements InvocationHandler {    private T target;    public LogRecordProxy(T t) {        this.target = t;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前&quot;);        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后&quot;);        return result;    }    /**     * 获取代理对象的方法     * */    @SuppressWarnings(&quot;unchecked&quot;)    public &lt;T&gt; T getProxy() throws Exception {        return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }}</code></pre><p>在controller层，就要改成这样。</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        //获取代理对象        UserService userServiceProxy = new LogRecordProxy&lt;&gt;(userService).getProxy();        return userServiceProxy.getAllUser();    }}</code></pre><p>假设有一个<code>PayService</code>也要做日志记录，就可以直接使用。</p><pre><code class="java">    @Resource(name = &quot;payService&quot;)    private PayService payService;        @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        //获取代理对象，实际上就在构造器上改一下传入的参数即可        PayService payServiceProxy = new LogRecordProxy&lt;&gt;(payService).getProxy();        return payServiceProxy.pay(channel,amount);    }</code></pre><p>很多文章给的例子都不带泛型，也可以，就是获取的代理对象需要强转一下，强转成对应的接口类。</p><p><strong>注意：这里一定要用接口接收代理对象，不能用实现类！</strong></p><p>因为返回的对象已经不是实现类的对象，而是和实现类有共同的接口类的代理类对象，所以当然只能用接口类去接收。</p><blockquote><p>这也是为什么一再强调要面向接口编程的原因，因为面向接口编程可以做更多的扩展。假设是面向实现类去编程，那就不能用JDK动态代理去扩展了！</p></blockquote><h2 id="CGLB动态代理"><a href="#CGLB动态代理" class="headerlink" title="CGLB动态代理"></a>CGLB动态代理</h2><p>那如果有些场景真的没有接口呢，我们怎么运用代理模式？</p><p>首先引入maven配置</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后创建一个方法拦截器<code>LogRecordInterceptor</code>，要实现<code>MethodInterceptor</code>类，如下：</p><pre><code class="java">public class LogRecordInterceptor implements MethodInterceptor {    private Object target;    public LogRecordInterceptor(Object target) {        this.target = target;    }    @Override    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前,参数：&quot; + Arrays.toString(args));        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后,参数：&quot; + Arrays.toString(args));        return result;    }}</code></pre><p>然后再创建一个工厂类<code>InterceptorFactory</code>，用于创建代理对象。</p><pre><code class="java">public class InterceptorFactory {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T&gt; T getInterceptor(Class&lt;T&gt; clazz, MethodInterceptor methodInterceptor) {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(clazz);        enhancer.setCallback(methodInterceptor);        return (T) enhancer.create();    }}</code></pre><p>接着我们就可以创建一个没有接口的类，我这里就创建一个数学工具类进行测试</p><pre><code class="java">public class MathUtil {    /**     * 获取一个数的平方     * */    public String getSquare(int num) {        return String.valueOf(num * num);    }}</code></pre><p>然后在controller层定义一个接口来测试</p><pre><code class="java">@RequestMapping(&quot;/getSquare&quot;)    public String getSquare(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception {        MathUtil mathUtil = InterceptorFactory.getInterceptor(MathUtil.class, new LogRecordInterceptor(new MathUtil()));        return mathUtil.getSquare(num);    }</code></pre><p>用浏览器或者<code>POSTMAN</code>工具调用接口，就可以在控制台看到以下输出：</p><pre><code class="java">/*记录日志：执行getSquare方法前,参数：[2]4记录日志：执行getSquare方法后,参数：[2]*/</code></pre><p>这样就实现没有定义接口也可以实现动态代理！</p><p>实际上，定义接口的也可以用这种方法来进行扩展，比如上面的<code>userService</code>接口</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        UserServiceImpl userServiceProxy = InterceptorFactory            .getInterceptor(UserServiceImpl.class,                            new LogRecordInterceptor(userService));        return userServiceProxy.getAllUser();    }}</code></pre><p>调用接口我们在控制台也是可以看到以下输出日志：</p><pre><code class="java">/*记录日志：执行getAllUser方法前,参数：[][User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser方法后,参数：[]*/</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>以上就是代理模式的一些通俗的解释，还有三种实现的方式的学习</strong></p><p>多说几句，我们都知道<code>Spring</code>框架有两个核心技术，一个叫控制反转<code>IOC</code>，另一个叫切面编程<code>AOP</code>。切面编程大家都很熟悉，用的就是代理模式，那么<code>AOP</code>实现的代理模式用的是<code>JDK动态代理</code>还是<code>CLB动态代理</code>？</p><p>答曰：<strong>两个都用！</strong></p><p>最简单的，我们看<code>Spring</code>的事务管理，就是用代理模式实现的，如果有兴趣，其实我们自己也可以通过<code>JDK动态代理</code>手写实现事务管理，其实不是很难。篇幅有限，以后可以单独写一篇文章详细说明<code>Spring</code>的事务管理，敬请期待。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板模式以及实战应用</title>
    <link href="/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>上一篇讲了策略模式，知道了可以使用策略模式对多重if-else进行优化，而且符合开闭原则。那么除了策略模式，还有什么设计模式比较好用而且常用的呢。这就是今天要讲的模板模式。</p><a id="more"></a><p>模板模式解决什么问题呢？</p><h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><p>首先我们使用SpringBoot来搭建一个工程。</p><pre><code class="xml">    &lt;!-- maven配置 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;commons-lang&lt;/groupId&gt;        &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;        &lt;version&gt;2.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><p>application.yml配置如下：</p><pre><code class="yaml">server:  port: 8888spring:  datasource:    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8    username: 账号    password: 密码    driver-class-name: com.mysql.jdbc.Driver</code></pre><p>创建一个全局配置类<code>GlobalProperties</code>，我们通过这个类可以获取yml的配置信息</p><pre><code class="java">@Component(&quot;globalProperties&quot;)public class GlobalProperties {    @Value(&quot;${spring.datasource.driver-class-name}&quot;)    private String driverClass;    @Value(&quot;${spring.datasource.url}&quot;)    private String url;    @Value(&quot;${spring.datasource.username}&quot;)    private String username;    @Value(&quot;${spring.datasource.password}&quot;)    private String password;    //字段对应的getter、setter方法...</code></pre><p>创建一个连接工厂类<code>ConnectFactory</code>，获取数据库连接</p><pre><code class="java">public class ConnectFactory {    public static Connection getConnection() throws Exception{        //获取yml文件的配置，SpringContextUtil工具类在上一篇文章有介绍，可以参考上一篇文章的代码        GlobalProperties properties = SpringContextUtil                .getBean(&quot;globalProperties&quot;, GlobalProperties.class);        //加载数据驱动        Class.forName(properties.getDriverClass());        //获取数据库连接，返回数据库连接对象        return DriverManager.getConnection(properties.getUrl(),                properties.getUsername(), properties.getPassword());    }}</code></pre><p>创建实体类<code>User</code></p><pre><code class="java">public class User {    private Integer id;    private String name;    private Integer age;    private String job;    //字段对应的getter、setter方法...</code></pre><p>接着在mysql对应的数据库创建数据表<code>tb_user</code>，sql语句如下：</p><pre><code class="sql">CREATE TABLE `tb_user` (  `id` bigint(10) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,  `name` varchar(255) NOT NULL COMMENT &#39;名称&#39;,  `age` tinyint(4) NOT NULL COMMENT &#39;年龄&#39;,  `job` varchar(255) DEFAULT NULL COMMENT &#39;工作&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4</code></pre><p>插入一些测试数据</p><pre><code class="sql">INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大司马&#39;,36,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;朴老师&#39;,36,&#39;主播&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;王刚&#39;,30,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大sao&#39;,32,&#39;美食up主&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;姚大秋&#39;,35,&#39;主持人&#39;);</code></pre><p>假设我们有一张user表，我们通过原生的JDBC来进行数据库操作，那么需要在dao层完成以下几步。</p><p>1.装载相应的数据库的JDBC驱动并进行初始化</p><p>2.建立JDBC和数据库之间的Connection连接</p><p>3.创建Statement或者PreparedStatement接口，执行SQL语句</p><p>4.处理和显示结果</p><p>5.释放资源</p><p>例子如下：</p><pre><code class="java">    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        User user = new User();        //获取数据连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement             .executeQuery(String.format(GET_USER_BY_NAME_SQL, name))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        User user = new User();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet =             statement.executeQuery(String.format(GET_USER_BY_ID_SQL, id))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }</code></pre><p>PS:这里为了简单一点就直接把参数拼接sql语句，不采用预编译来处理sql的参数。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过上面的代码，我们很明显可以看到是有很大的问题的。</p><p>1.每次在进行数据库操作都需要获取<code>Connection</code>对象，创建<code>Statement</code>对象。</p><p>2.每次获取结果后，都要进行结果处理，而且如果是同一张表的查询，会很重复。每次都需要把结果值set回到对象的字段中。</p><p>模板模式就可以解决这个问题！</p><h2 id="使用模板模式重构代码"><a href="#使用模板模式重构代码" class="headerlink" title="使用模板模式重构代码"></a>使用模板模式重构代码</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>创建一个模板类<code>DaoTemplate</code>，如下：</p><pre><code class="java">/** * @author Ye Hongzhi * @program DaoTemplate * @description * @date 2020-04-12 17:04 **/@Componentpublic class DaoTemplate {    public &lt;T&gt; T query(String sql, Class&lt;T&gt; clazz) throws Exception {        //通过clazz创建返回值对象        T t = clazz.newInstance();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement.executeQuery(sql)        ) {            while (resultSet.next()) {                //获取所有字段                Field[] fields = clazz.getDeclaredFields();                //获取所有方法                Method[] methods = clazz.getDeclaredMethods();                Map&lt;String, Method&gt; methodNameMap = Arrays.stream(methods)                        .collect(Collectors.toMap(Method::getName, Function.identity()));                //把数据库对应的列的值赋值给 泛型T对象的 对应的字段                for (Field field : fields) {                    //获取字段名                    String fieldName = field.getName();                    //获取set方法                    Method method = methodNameMap.get(&quot;set&quot; + change(fieldName));                    //获取数据库的列的值                    Object fieldValue = null;                    if (field.getType() == String.class) {                        fieldValue = resultSet.getString(fieldName);                    }                    if (field.getType() == Integer.class) {                        fieldValue = resultSet.getInt(fieldName);                    }                    if (field.getType() == Boolean.class) {                        fieldValue = resultSet.getBoolean(fieldName);                    }                    if (field.getType() == Long.class) {                        fieldValue = resultSet.getLong(fieldName);                    }                    if(field.getType() == Double.class){                        fieldValue = resultSet.getDouble(fieldName);                    }                    if(field.getType() == BigDecimal.class){                        fieldValue = resultSet.getBigDecimal(fieldName);                    }                    if (field.getType() == Date.class) {                        fieldValue = resultSet.getDate(fieldName);                    }                    //设置更多的字段类型...                    //利用反射执行对象的set方法，把数据库的值设置到对象的字段中                    method.invoke(t, fieldValue);                }            }        } catch (Exception e) {            e.printStackTrace();        }        return t;    }    /**     * 将一个字符串首字母大写，其它字母小写     *     * @param str 字符串     * @return     */    private static String change(String str) {        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();    }}</code></pre><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>创建模板后，可以在<code>DAO</code>层引入模板，然后使用。如下：</p><pre><code class="java">    //引入模板        @Resource    private DaoTemplate daoTemplate;    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_ID_SQL, id), User.class);    }    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_NAME_SQL, name), User.class);    }</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><h1 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h1><p>实际上在Spring框架就有提供<code>JDBC</code>模板</p><p>我们可以在<code>MAVEN</code>中引入以下配置：</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>创建一个映射类<code>UserRowMapper</code></p><pre><code class="java">public class UserRowMapper implements RowMapper&lt;User&gt; {    @Override    public User mapRow(ResultSet resultSet, int i) throws SQLException {        User user = new User();        user.setId(resultSet.getInt(&quot;id&quot;));        user.setName(resultSet.getString(&quot;name&quot;));        user.setAge(resultSet.getInt(&quot;age&quot;));        user.setJob(resultSet.getString(&quot;job&quot;));        return user;    }}</code></pre><p>然后在<code>DAO</code>层的<code>UserDaoImpl</code>，我们就可以引入<code>JdbcTemplate</code></p><pre><code class="java">    @Resource    private JdbcTemplate jdbcTemplate;    //使用jdbcTemplate查询    @Override    public User getUserByName(String name) throws Exception {        return jdbcTemplate.queryForObject(String.format(GET_USER_BY_NAME_SQL, name), new UserRowMapper());    }</code></pre><p>从这里可以看出实际上<code>Spring</code>框架就是采用这种思想来实现<code>JdbcTemplate</code>模板。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>所以在实际项目的开发中，我们有时候遇到某些代码块的前后都有重复操作时，可以采用模板模式去重构代码，使代码更加简洁，容易维护。</p><p>更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你用策略模式解决多重if-else</title>
    <link href="/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/"/>
    <url>/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>很多人可能在公司就是做普通的CRUD的业务，对于设计模式，即使学了好像也用处不大，顶多就在面试的时候能说上几种常见的单例模式，工厂模式。而在实际开发中，设计模式似乎很难用起来。</p><p>在现在的环境下，程序员的竞争已经非常激烈了，要体现出自身的价值，最直接的体现当然是差异化。这无需多说，我认为在实际开发中能运用设计模式，是很能体现差异化的。设计模式是一些前人总结的较好的方法，使程序能有更好的扩展性，可读性，维护性。</p><p>下面举个例子，使用策略模式解决多重if-else的代码结构。想学习更多的设计模式的实战经验，那就点个关注吧，谢谢大佬。</p><h1 id="使用if-else"><a href="#使用if-else" class="headerlink" title="使用if-else"></a>使用if-else</h1><p>假设我们要开发一个支付接口，要对接多种支付方式，通过渠道码区分各种的支付方式。于是定义一个枚举<code>PayEnum</code>，如下：</p><pre><code class="java">public enum PayEnum {    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;);    /**渠道*/    private String channel;    /**描述*/    private String description;    PayEnum(String channel, String description) {        this.channel = channel;        this.description = description;    }    /**以下省略字段的get、set方法*/</code></pre><p>创建一个<code>PayController</code>类，代码如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class PayController {    @Resource(name = &quot;payService&quot;)    private PayService payService;    /**    * 支付接口    * @param channel 渠道    * @param amount  消费金额    * @return String 返回消费结果    * @author Ye hongzhi    * @date 2020/4/5    */    @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        return payService.pay(channel,amount);    }}</code></pre><p>再创建一个<code>PayService</code>接口以及实现类<code>PayServiceImpl</code></p><pre><code class="java">public interface PayService {    /**    * 支付接口    * @param channel 渠道    * @param amount  金额    * @return String    * @author Ye hongzhi    * @date 2020/4/5    */    String pay(String channel,String amount)throws Exception;}</code></pre><pre><code class="java">@Service(&quot;payService&quot;)public class PayServiceImpl implements PayService {    private static String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    @Override    public String pay(String channel, String amount) throws Exception {        if (PayEnum.ALI_PAY.getChannel().equals(channel)) {            //支付宝            //业务代码...            return String.format(MSG,PayEnum.ALI_PAY.getDescription(),amount);        }else if(PayEnum.WECHAT_PAY.getChannel().equals(channel)){            //微信支付            //业务代码...            return String.format(MSG,PayEnum.WECHAT_PAY.getDescription(),amount);        }else if(PayEnum.UNION_PAY.getChannel().equals(channel)){            //银联支付            //业务代码...            return         String.format(MSG,PayEnum.UNION_PAY.getDescription(),amount);        }else if(PayEnum.XIAO_MI_PAY.getChannel().equals(channel)){            //小米支付            //业务代码...            return String.format(MSG,PayEnum.XIAO_MI_PAY.getDescription(),amount);        }else{            return &quot;输入渠道码有误&quot;;        }    }}</code></pre><p>然后通过浏览器，我们可以看到效果</p><p><img src="https://static.lovebilibili.com/01.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/02.png" srcset="/img/loading.gif" alt=""></p><p>这样看，以上代码的确可以实现需求，通过渠道码区分支付方式，可是看到上面那么多达4个的<code>if-else</code>的代码结构，已经开始显示出问题了。假设有更多的支付方式，那么这段代码就要写更多的<code>else if</code>去判断，这显然会不利于代码的扩展，这样会导致这个支付的方法越写越长。</p><p>在设计模式六大原则中，其中一个原则叫做<code>开闭原则</code>，对扩展开放，对修改关闭，应尽量在不修改原有代码的情况下进行扩展。</p><p>基于上面提到的<code>开闭原则</code>，我们可以使用策略模式进行重构。</p><h1 id="使用策略模式重构代码"><a href="#使用策略模式重构代码" class="headerlink" title="使用策略模式重构代码"></a>使用策略模式重构代码</h1><p>定义一个策略接口类<code>PayStrategy</code></p><pre><code class="java">public interface PayStrategy {    String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    String pay(String channel,String amount)throws Exception;}</code></pre><p>然后再创建四种策略实现类实现接口</p><pre><code class="java">@Component(&quot;aliPayStrategy&quot;)public class AliPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.ALI_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;wechatPayStrategy&quot;)public class WechatPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.WECHAT_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;unionPayStrategy&quot;)public class UnionPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.UNION_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;xiaomiPayStrategy&quot;)public class XiaomiPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.XIAO_MI_PAY.getDescription(),amount);    }}</code></pre><p>看到这里实际上已经很清晰了，思路就是通过渠道码，动态获取到具体的实现类，这样就可以实现不需要<code>if else</code>判断。怎么通过渠道码获取实现类呢？</p><p>在<code>PayEnum</code>枚举加上<code>BeanName</code>字段，然后增加一个通过渠道码获取<code>BeanName</code>的方法</p><pre><code class="java">    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;,&quot;aliPayStrategy&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;,&quot;wechatPayStrategy&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;,&quot;unionPayStrategy&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;,&quot;xiaomiPayStrategy&quot;);    /**策略实现类对应的 beanName*/    private String beanName;    /**     * 通过渠道码获取枚举     * */    public static PayEnum findPayEnumBychannel(String channel){        PayEnum[] enums = PayEnum.values();        for (PayEnum payEnum : enums){            if(payEnum.getChannel().equals(channel)){                return payEnum;            }        }        return null;    }    //构造器    PayEnum(String channel, String description, String beanName) {        this.channel = channel;        this.description = description;        this.beanName = beanName;    }</code></pre><p>这时候还差一个获取Spring上下文对象的工具类，于是我们创建一个<code>SpringContextUtil</code>类</p><pre><code class="java">@Componentpublic class SpringContextUtil implements ApplicationContextAware {    /**     * 上下文对象实例     */    private static ApplicationContext applicationContext;    /**     * 获取applicationContext     */    private static ApplicationContext getApplicationContext() {        return applicationContext;    }    /**     * 通过name获取Bean     * */    public static Object getBean(String name){        return getApplicationContext().getBean(name);    }    /**     * 通过name,以及Clazz返回指定的Bean     * */    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz){        return getApplicationContext().getBean(name,clazz);    }    @Override    @Autowired    public void setApplicationContext(ApplicationContext applicationContext) throws         BeansException {        SpringContextUtil.applicationContext = applicationContext;    }</code></pre><p>接着定义一个工厂类，通过渠道码获取对应的策略实现类</p><pre><code class="java">public class PayStrategyFactory {    /**     * 通过渠道码获取支付策略具体实现类     * */    public static PayStrategy getPayStrategy(String channel){        PayEnum payEnum = PayEnum.findPayEnumBychannel(channel);        if(payEnum == null){            return null;        }        return SpringContextUtil.getBean(payEnum.getBeanName(),PayStrategy.class);    }}</code></pre><p>最后我们再改造一下原来的<code>PayServiceImpl</code>的<code>pay</code>方法</p><pre><code class="java">@Overridepublic String pay(String channel, String amount) throws Exception {    PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);    if(payStrategy == null){        return &quot;输入渠道码有误&quot;;    }    return payStrategy.pay(channel,amount);}</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><blockquote><p>假设需要增加新的支付方式，就不需要再使用else if 去判断，而是在枚举中定义一个新的枚举对象，然后再增加一个策略实现类，实现对应的方法，那就可以很轻松地扩展。也实现了开闭原则。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>设计模式运用得熟练的话，很多代码可以写得很优雅。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot系列之自定义spring-boot-starter</title>
    <link href="/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/"/>
    <url>/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>传统的 Maven项目一般将需要被复用的组件做成 Module来进行管理，以便二次调用；而在 Spring Boot项目中我们则可以使用更加优雅的 Spring Boot Starter来完成这一切。</p><a id="more"></a><p>这个开箱即用的魔法特性很大程度上来源于各式各样 Spring Boot Starter的加持，而且随着版本的迭代 Starter家族成员日益庞大，而且各种优秀开源作者也提供了很多非常好用的Spring Boot Starter。</p><p>本文尝试自定义一个Spring Boot Starter用于图片链接转换BASE64编码。</p><h1 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h1><ol><li>在GItHub上创建base64util-spring-boot-starter项目，然后clone下来本地进行开发。</li></ol><p><img src="https://static.lovebilibili.com/Github_Create.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>pom.xml文件配置如下</li></ol><pre><code class="xml">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;&lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;0.0.1&lt;/version&gt;&lt;dependencies&gt;    &lt;!-- 引入SpringBoot自动配置jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ol start="3"><li>业务代码</li></ol><pre><code class="java">import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL;/** * @author Ye Hongzhi * @program Base64Util * @description * @date 2020-02-17 14:04 **/public class Base64Util {    /**     * 本地图片转为BASE64编码     *     * @param imgFile 本地图片地址     * @return BASE64 解码后的字符串编码     * @description: 根据图片地址转换为base64编码字符串     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static String getImageFile(String imgFile) {        byte[] data = null;        try (InputStream inputStream = new FileInputStream(imgFile)) {            data = new byte[inputStream.available()];            int length = inputStream.read(data);            if (length == -1) {                return null;            }        } catch (Exception e) {            e.printStackTrace();        }        // 加密        BASE64Encoder encoder = new BASE64Encoder();        if (data != null) {            return encoder.encode(data);        } else {            return null;        }    }    public static String image2Base64(String imgUrl) throws Exception {        URL url = new URL(imgUrl);        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();        try(InputStream inputStream = urlConnection.getInputStream();            ByteArrayOutputStream baos = new ByteArrayOutputStream()) {            urlConnection.connect();            byte[] buffer = new byte[1024];            int len;            //使用一个输入流从buffer里把数据读取出来            while ((len = inputStream.read(buffer)) != -1) {                //用输出流往buffer里写入数据，中间参数代表从哪个位置开始读，len代表读取的长度                baos.write(buffer, 0, len);            }            // 对字节数组Base64编码            return Base64.encode(baos.toByteArray());        } catch (Exception e) {            e.printStackTrace();        } finally {            if (urlConnection != null) {                urlConnection.disconnect();            }        }        return imgUrl;    }    /**     * BASE64编码转为图片     * 注意：&quot;data:image/jpeg;base64,&quot; 解码之前得去掉。     *     * @param imgStr base64编码字符串     * @param path   图片路径-具体到文件     * @return 是否转换成功     * @description: 将base64编码字符串转换为图片     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static boolean generateImage(String imgStr, String path) {        if (imgStr == null) {            return false;        }        try (OutputStream out = new FileOutputStream(path)) {            BASE64Decoder decoder = new BASE64Decoder();            // 解密            byte[] b = decoder.decodeBuffer(imgStr);            // 处理数据            for (int i = 0; i &lt; b.length; ++i) {                if (b[i] &lt; 0) {                    b[i] += 256;                }            }            out.write(b);            out.flush();            return true;        } catch (Exception e) {            e.printStackTrace();            return false;        }    }}</code></pre><ol start="4"><li>创建一个service调用，这里为了简单，就不定义为接口的形式</li></ol><pre><code class="java">public class Base64Service {    /**     * 本地图片转为BASE64编码     */    public String getImageFile(String imgFile) {        return Base64Util.getImageFile(imgFile);    }    /**     * BASE64编码转为图片     * */    public boolean generateImage(String imgStr, String path) {        return Base64Util.generateImage(imgStr,path);    }    /**     * 在线图片转为BASE64编码     * */    public String image2Base64(String imgUrl) throws Exception{        return Base64Util.image2Base64(imgUrl);    }}</code></pre><ol start="5"><li>关键的一步，使用配置类，把service定义成bean，加入到spring容器中管理</li></ol><pre><code class="java">@Configurationpublic class Base64AutoConfiguration {    @Bean    Base64Service base64Service(){        return new Base64Service();    }}</code></pre><ol start="6"><li>最关键一步在于需要在resources文件夹下创建<code>META-INF/spring.factories</code>，<code>spring.factories</code>里的代码如下:</li></ol><pre><code class="yaml">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.lovebilibili.me.config.Base64AutoConfiguration</code></pre><p>这一步是重点，因为Spring Boot应用在启动过程中会通过 <code>SpringFactoriesLoader</code> 加载所有 <code>META-INF/spring.factories</code> 文件，通过一系列的处理流程最终将 spring.factories 文件中的定义的各种 <code>beans</code> 装载入 ApplicationContext容器。</p><blockquote><p>至此，自定义的用于base64转码工具的spring-boot-starter就完成了</p><p>可以通过使用maven命令<code>mvn install</code>打包，传到私有/公有Maven仓库使用。</p><p>形成一个公共的模块，供有需要的项目使用。</p></blockquote><ol start="7"><li>完成后把代码推送到Github仓库中，方便以后继续优化。</li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li>在其他项目中的pom文件加入以下依赖：</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;    &lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.0.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在Controller层中，我们可以引入base64Service。</li></ol><pre><code class="java">@Resourceprivate Base64Service base64Service;</code></pre><ol start="3"><li>然后在Controller层中的@RequestMapping对应的方法中使用</li></ol><pre><code class="java">//把在线图片转为BASE64编码String base64 = base64Service.image2Base64(imgUrl);</code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要创建个人博客</title>
    <link href="/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>很高兴你能点进来看我的第一篇文章。</p><p>内容也和标题一样无聊，为什么要创建个人博客，既然我已经创建了还要找什么理由呢。但是你点进来很大原因是因为你还没有个人博客，所以想来听听我创建个人博客的理由，以此来驱动自己去创建个人博客。这非常好，证明你已经有冲动了，只差行动起来。</p><p>我的理由有以下几点：</p><ol><li>想要记录下一些自己的技术学习的过程。比记录在有道云笔记自己看更加有价值，因为博客是可以分享，可以传播，知识需要传播起来才有力量。这是最大的一个原因。</li><li>通过输出博客文章提升自己的技术水平。因为输出就是最好的学习，输出一篇好的技术文章，往往就是最好的学习方式。</li><li>通过这个博客和网友互相学习。毕竟外面的世界很大，可以通过博客这个窗口和网上的开发者互相学习讨论，不失为一种乐趣。</li><li>记录一些生活感想、读书笔记、美食经历等等。</li></ol><p>这就是我的理由。如果你想要创建个人博客的话，马上去做吧。</p><p>教程的话可以参考</p><p>B站up主“CodeSheep”的视频<a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></p><p>我的hexo主题使用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">fluid</a>,如果你觉得不错也可以使用哦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
