<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记一次高级java面试</title>
    <link href="/2020/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E7%BA%A7java%E9%9D%A2%E8%AF%95/"/>
    <url>/2020/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E7%BA%A7java%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一次高级JAVA开发面试题目"><a href="#记录一次高级JAVA开发面试题目" class="headerlink" title="记录一次高级JAVA开发面试题目"></a>记录一次高级JAVA开发面试题目</h1><p>面试时间大概40多分钟，问了有十几个问题，回忆一下记录下来，总结经验，以供参考。</p><a id="more"></a><p><strong>1、 static关键字的作用，平时开发用在什么地方？</strong><br>答：主要有三种用法。<br>①修饰成员变量，用static修饰的成员变量就成为静态变量，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。<br>②static修饰方法，该方法就被定义为静态方法，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。<br>③用static修饰代码块，该代码块就被定义为静态代码块，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。</p><p><strong>2、static修饰的成员变量和非static修饰的成员变量有什么区别？分别存在什么区域？</strong><br>答：静态成员变量在内存中只会存在一份，是通过类名访问，存在于静态区中。非静态成员变量是随着对象的创建而存在的，可以有多份，通过创建的对象访问，存在于堆内存中。</p><p><strong>3、说一下类初始化的顺序。</strong><br>答：静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。</p><p><strong>4、常用的集合类型有哪些？</strong><br>答：有Map、Set、List是比较常用的。</p><p><strong>5、List常用的实现类有哪些？ArrayList和LinkedList底层实现原理是什么？</strong><br>答：List常用的实现类有ArrayList和LinkedList。ArrayList底层原理是数组+动态扩容机制实现的，LinkedList底层原理是用Node结点形成的链表实现的。</p><p><strong>6、在开发中如何选择使用ArrayList和LinkedList？</strong><br>答：ArrayList是数组实现，所以通过下标访问效率最快，但是缺点是如果增删比较频繁的情况下，需要经常扩容，性能不是很好。LinkedList在增删的情况下，效率较高，但是访问集合中的元素时都需要从第一个元素开始遍历，效率较低。所以如果增删的情况较多的时候，可以使用LinkedList。查询较多时使用ArrayList。</p><p> <strong>7、List集合如果要排序有哪些实现方式？</strong><br>①使用List接口定义的sort()方法。</p><pre><code class="java">list.sort(Comparator.comparingInt(User::getAge));</code></pre><p>②使用Collections的sort()方法，排序的对象需要实现Comparable接口，重写compareTo()方法。</p><pre><code class="java">//实现Comparable接口public class User implements Comparable&lt;User&gt; {    //重写compareTo方法    @Override    public int compareTo(User user) {            return Integer.compare(this.getAge(), user.getAge());    }}</code></pre><p>使用Collections的sort()方法</p><pre><code class="java">Collections.sort(list);//如果不想实现Comparable接口，也可以使用这个方法Collections.sort(list,Comparator.comparingInt(User::getAge));</code></pre><p>③使用Stream流操作的sort()方法，传入一个Comparator接口。</p><pre><code class="java">list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList());</code></pre><p> <strong>8、ArrayList是线程安全的吗？有什么方式可以让ArrayList变成线程安全的？</strong><br>答：不是线程安全的。<br>使用Collections的synchronizedList()方法包装可获得线程安全的ArrayList。</p><pre><code class="java">List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code></pre><p><strong>9、你是怎么在项目中使用redis的？</strong><br>答：这其实是考了“redis常用的应用场景”这个问题。<br>①利用redis读写速度快的特点，可以做热点数据的储存，降低数据库查询的压力。<br>②利用redis键值设置有效期的特性，做一些限时的业务。比如手机验证码。<br>③利用setnx命令的特性，可以实现分布式锁。</p><p><strong>10、使用Redis实现分布式锁的原理是什么？</strong><br>答： 利用setnx命令的特性。使用setnx一个lockKey字符串作为键，当前的时间+上锁时间作为value。如果返回是0，表示已经被上锁了，需要等待锁持有者释放锁；如果返回1，则表示获得了锁。客户端释放锁的话执行del命令删除lockKey对应的键值。</p><p><strong>11、如果使用分布式锁加锁后，由于一些异常的原因没有执行解锁的操作，怎么办？</strong><br>答：一般解锁操作会放在finally代码块中执行。如果有极端情况下没有执行到解锁的操作，可以通过key对应的时间戳判断是否超时，然后使用GETSET命令去进行解锁，通过判断返回的时间戳是否是超时的key对应的时间戳，确认是否成功上锁。</p><p><strong>12、如果加分布式锁的时候，业务操作时间比较长，造成长时间的阻塞，有什么解决方案？</strong><br>答：可以在加锁时启动一个watch dog(看门狗)线程，每隔10秒检查一下，如果客户端还持有锁则加长lockKey的生存时间。或者可以考虑用zookeeper实现的分布式锁，因为zk实现原理是基于事件监听的方式来实现。</p><p><strong>13、MySQL性能优化的策略有哪些？</strong><br>①复杂的多表查询可以拆成多句简单查询。<br>②返回尽量少的列，按需返回，严禁使用select *。<br>③尽量使用索引列做查询条件和排序条件。<br>④使用复合索引要遵循最左匹配原则。</p><p><strong>14、MySQL索引创建的原则是什么？</strong><br>①对于查询频率高的字段，创建索引。<br>②对排序、分组、联合查询频率高的字段创建索引。<br>③如果多个列都需要设置索引，可以考虑创建复合索引。<br>④尽量选择数据量较少的列作为索引。<br>⑤一个表的索引数量不宜过多，会降低查询的效率。</p><p><strong>15、雪花算法是什么原理？</strong><br>答：使用一个 64 bit 的 long 型的数字作为全局唯一 id。是由时间戳、机房id、机器id、序号组成的。结合了UUID的全局唯一的特点，又具有自增有顺序的特点。</p><p><strong>16、为什么雪花算法生成的主键有字符串类型和long类型两种类型？</strong><br>答：因为后端返回给前端一个long类型时，会有可能产生丢失精度的问题，所以会有字符串的类型，弥补这个问题。</p><p><strong>17、谈一谈MySQL锁机制。</strong><br>主要有以下几种锁：<br>表锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>行锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>在MySQL中只有InnoDB存储引擎可以使用行锁。行锁又分为以下两种形式：<br>读锁(共享锁)：当读取一条数据时，会加上读锁，其他事务如果要读取是可以的，如果要修改则要等事务释放才可以。<br>写锁(排他锁)：这个比较简单，当有一个事务要修改数据时，就会给这些行加上写锁。在加锁期间，不允许其他事务加上任何的锁，只有当这个事务释放了，才可以加锁操作。</p><p>在这次面试中，其实也不是特别难，大部分都回答得不错，但是有两个问题不是很好。雪花算法为什么主键生成有两种类型这个问题没有答出来，还有分布式锁长时间阻塞的解决方案没有详细展开讲。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式在实战中的应用</title>
    <link href="/2020/05/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>比如有些人喜欢写文章，但是如果从头到尾原创的话太麻烦了，那么他可以上网去搜索，找一篇写得不错的文章，然后复制下来，做一些修改，最后发布就是自己的文章了。这其实就使用了原型模式的设计模式，创建一个对象过于麻烦的时候，我们只需要创建一次，后面再创建的话只需要对原对象进行克隆即可。</p><h2 id="不使用原型模式的问题"><a href="#不使用原型模式的问题" class="headerlink" title="不使用原型模式的问题"></a>不使用原型模式的问题</h2><p>假设我们有一个用户<code>User</code>的类，类里面有很多字段，当我们创建对象时，就会像这样子：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setAge(18);        user.setJob(&quot;程序员&quot;);        user.setSchool(&quot;家里蹲大学&quot;);        user.setNation(&quot;汉族&quot;);        //0-男 1-女        user.setGender((byte)0);        user.setPhone(&quot;110&quot;);        user.setPoliticalFeatures(&quot;群众&quot;);        user.setEducation(&quot;大学本科&quot;);        //第二个用户，跟第一个用户只有id，name，phone这三个字段不同        User user1 = new User();        user1.setId(2);        user1.setName(&quot;李四&quot;);        user1.setAge(18);        user1.setJob(&quot;程序员&quot;);        user1.setSchool(&quot;家里蹲大学&quot;);        user1.setNation(&quot;汉族&quot;);        //0-男 1-女        user1.setGender((byte)0);        user1.setPhone(&quot;111&quot;);        user1.setPoliticalFeatures(&quot;群众&quot;);        user1.setEducation(&quot;大学本科&quot;);    }}</code></pre><p>不难看出上面的代码有以下问题：</p><p>1.<code>user</code>对象有10个字段，明显在创建第二个<code>user</code>对象的时候有很多重复的设值的操作。在实际项目中，肯定还不止设置10个字段，那么就会显得很难看。</p><p>2.创建对象如果消耗资源很多的话，这样多次去创建设值肯定会造成资源浪费。</p><p>对于以上的问题，我们可以使用原型模式进行优化。</p><h2 id="使用Cloneable接口优化"><a href="#使用Cloneable接口优化" class="headerlink" title="使用Cloneable接口优化"></a>使用Cloneable接口优化</h2><p><code>java</code>提供了一个<code>Cloneable</code>接口，可以实现克隆对象的用途，怎么实现，请看以下代码：</p><pre><code class="java">//实现Cloneable接口public class User implements Cloneable {    //省略了字段    //省略了字段的Get、Set方法    //重写clone()方法    @Override    public User clone() throws CloneNotSupportedException {        return (User) super.clone();    }}</code></pre><p>然后就可以把<code>main()</code>方法的代码改成以下这样：</p><pre><code class="java">public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setAge(18);        user.setJob(&quot;程序员&quot;);        user.setSchool(&quot;家里蹲大学&quot;);        user.setNation(&quot;汉族&quot;);        //0-男 1-女        user.setGender((byte)0);        user.setPhone(&quot;110&quot;);        user.setPoliticalFeatures(&quot;群众&quot;);        user.setEducation(&quot;大学本科&quot;);        //调用克隆方法，复制第一个user对象        User user1 = user.clone();        user1.setId(2);        user1.setName(&quot;李四&quot;);        user1.setPhone(&quot;111&quot;);        System.out.println(user1);        //控制台打印结果        //User{id=2, name=&#39;李四&#39;, phone=&#39;111&#39;, nation=&#39;汉族&#39;...}}</code></pre><p>你是不是有疑问，这两个<code>user</code>对象内存地址是否一致呢？我们可以打印出来看看：</p><pre><code class="java">com.yehongzhi.httpclient.model.User@4c873330com.yehongzhi.httpclient.model.User@119d7047</code></pre><p>内存地址是不一样的，所以我们可以得出一个结论：<strong>克隆出来的对象是一个新的对象。</strong></p><p><strong>问题：</strong>克隆方法的底层是不是调用了构造器创建了一个对象的呢？</p><p>我们可以在构造器上面加一些打印语句来验证一下：</p><pre><code class="java">public class User implements Cloneable {    //其他非重点代码省略    //构造器，如果以下语句打印了两次，则证明clone调用了构造器创建对象    public User() {        System.out.println(&quot;调用了无参构造器&quot;);    }    //克隆方法    @Override    public User clone() throws CloneNotSupportedException {        System.out.println(&quot;调用了clone()方法&quot;);        return (User) super.clone();    }}</code></pre><p>我们运行<code>main()</code>方法后，可以看到控制台打印信息如下：</p><pre><code class="java">// 调用了无参构造器// 调用了clone()方法</code></pre><p>只调用了一次构造器，我们可以得出结论：</p><blockquote><p>clone()方法不是调用了构造器创建对象的。</p></blockquote><p>如果你刨根究底，究竟clone()方法是怎么创建对象的，其实也很简单，打开源码：</p><pre><code class="java">public class Object {    private static native void registerNatives();    static {        registerNatives();    }    //最终会调用Object的克隆方法，是一个native修饰的方法    protected native Object clone() throws CloneNotSupportedException;}</code></pre><p>native修饰的方法是什么意思呢？意思就是这个方法的实现不是用<code>java</code>，而是<code>C/C++</code>实现。这个native关键字我们可以单独写一篇文章细讲，这里就不深入展开。底层的实现逻辑就是拷贝一份数据，开辟一块新的内存。所以拷贝出来的对象，打印的内存地址和原来的对象不一样。</p><h2 id="使用Cloneable接口的问题"><a href="#使用Cloneable接口的问题" class="headerlink" title="使用Cloneable接口的问题"></a>使用Cloneable接口的问题</h2><p>使用<code>Cloneable</code>接口是不是就完美的呢，其实并不是，因为如果一个对象的字段也是一个对象，是一个引用数据类型时，那就会有问题。请看以下代码：</p><p>我们增加一个对象<code>IdCard</code>类</p><pre><code class="java">public class IdCard {    private String cardNo;    private Integer validityPeriod;    private Date createDate;    //省略getter、setter方法}</code></pre><pre><code class="java">public class User implements Cloneable {    //其他字段省略    //身份证对象    private IdCard idCard;    //省略getter、setter方法}</code></pre><p>然后我们在<code>main()</code>方法赋值：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        //省略其他字段的赋值        //创建一个IdCard对象        IdCard idCard = new IdCard();        //身份证号码        idCard.setCardNo(&quot;111111&quot;);        //创建日期        idCard.setCreateDate(new Date());        //身份证有效期        idCard.setValidityPeriod(10);        //user对象设置身份证对象        user.setIdCard(idCard);        //user克隆，得到user1        User user1 = user.clone();        //打印user、user1的IdCard对象的内存地址，内存地址一样！        System.out.println(user.getIdCard());//IdCard@4c873330        System.out.println(user1.getIdCard());//IdCard@4c873330        //当改变克隆体user1的IdCard里面的字段值        user1.getIdCard().setCardNo(&quot;222222&quot;);        //源对象user的IdCard里面的字段值也跟着一起改变了        System.out.println(user.getIdCard().getCardNo());//222222    }}</code></pre><p>明显这样的克隆是有巨大的问题的，因为项目中不可能只有基本数据类型。那怎么解决呢？</p><pre><code class="java">//IdCard对象也要实现Cloneable接口public class IdCard implements Cloneable{    //也需要重写clone()方法    @Override    protected IdCard clone() throws CloneNotSupportedException {        return (IdCard)super.clone();    }}</code></pre><pre><code class="java">public class User implements Cloneable {    @Override    public User clone() throws CloneNotSupportedException {        User user = (User) super.clone();        //获取idCard源对象        IdCard idCard = user.getIdCard();        //克隆一个idCard对象。然后set值到user对象中        user.setIdCard(idCard.clone());        return user;    }}</code></pre><p>最后我们再调用<code>main()</code>方法：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        //创建一个IdCard对象        IdCard idCard = new IdCard();        //身份证号码        idCard.setCardNo(&quot;111111&quot;);        //user对象设置身份证对象        user.setIdCard(idCard);        //克隆user对象，得到user1对象        User user1 = user.clone();        //打印user、user1的IdCard对象的内存地址，内存地址不一样了！        System.out.println(user.getIdCard());//IdCard@4c873330        System.out.println(user1.getIdCard());//IdCard@119d7047        //当改变克隆体user1的IdCard里面的字段值        user1.getIdCard().setCardNo(&quot;222222&quot;);        //源对象user的IdCard里面的字段值也跟着一起改变了        System.out.println(user.getIdCard().getCardNo());//111111    }}</code></pre><h2 id="使用序列化实现深克隆"><a href="#使用序列化实现深克隆" class="headerlink" title="使用序列化实现深克隆"></a>使用序列化实现深克隆</h2><p>上面使用<code>Cloneable</code>接口的方式，被称为浅克隆，如果你想要克隆的源对象里面又有对象时，里面的对象也要实现<code>Cloneable</code>接口，然后修改源对象的<code>clone()</code>方法，这样就非常麻烦，而且当扩展时会破坏开闭原则。</p><p>解决方法，我们可以采用序列化对象的方式，实现深克隆呢？请看以下代码：</p><p><code>User</code>对象实现<code>Serializable</code>接口:</p><pre><code class="java">public class User implements Serializable {    private static final long serialVersionUID = 8656071024384993135L;}</code></pre><p><code>IdCard</code>对象实现<code>Serializable</code>接口：</p><pre><code class="java">public class IdCard implements Serializable {    private static final long serialVersionUID = -422430076410272813L;}</code></pre><p>创建一个工具类<code>CloneUtil</code>实现深克隆：</p><pre><code class="java">public class CloneUtil {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T&gt; T depthClone(T t, Class&lt;T&gt; clazz) throws Exception {        ByteArrayOutputStream baos = null;        ObjectOutputStream ous = null;        ByteArrayInputStream bais = null;        ObjectInputStream ois = null;        try {            //将源对象序列化，写入流中，写入流的对象是一个拷贝的对象，原对象还在JVM中            baos = new ByteArrayOutputStream();            ous = new ObjectOutputStream(baos);            ous.writeObject(t);            //把流中的对象再读取到内存中，就获得了克隆后的对象            bais = new ByteArrayInputStream(baos.toByteArray());            ois = new ObjectInputStream(bais);            return (T) ois.readObject();        } catch (Exception e) {            e.printStackTrace();            throw new RuntimeException(&quot;深克隆出现异常&quot;);        } finally {            if (ous != null) {ous.close();}            if (baos != null) {baos.close();}            if (bais != null) {bais.close();}            if (ois != null) {ois.close();}        }    }}</code></pre><p>验证是否深克隆，在<code>main()</code>方法中打印内存地址查看即可：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        User user = new User();        user.setIdCard(new IdCard());        User user1 = CloneUtil.depthClone(user, User.class);        //内存地址都不相同，达到了深克隆的效果        System.out.println(user);//User@3d075dc0        System.out.println(user1);//User@2ef1e4fa        System.out.println(user.getIdCard());//IdCard@214c265e        System.out.println(user1.getIdCard());//IdCard@306a30c7    }}</code></pre><p>用序列化实现深克隆的优点就是，对源代码侵入性很低，只需要实现<code>Serializable</code>接口，不需要一层一层去实现<code>Cloneable</code>接口，还有重写<code>clone()</code>方法。</p><p><strong>问题：</strong>如果这个实体类是在<code>jar</code>包中的呢，我们没法去修改实体类的代码，那怎么实现克隆呢？</p><h2 id="使用反射实现克隆"><a href="#使用反射实现克隆" class="headerlink" title="使用反射实现克隆"></a>使用反射实现克隆</h2><p>利用反射，实际上我们可以拿到源对象的任何值，所以就可以实现克隆，请看以下代码：</p><p>我们创建一个<code>copyProperties()</code>方法，具体实现看以下代码：</p><pre><code class="java">public class CloneUtil {    public static void copyProperties(Object source, Object target) throws Exception {        //获取源对象的属性描述器        PropertyDescriptor[] sourceDescriptors = Introspector                .getBeanInfo(source.getClass())                .getPropertyDescriptors();        //获取目标对象的字段名称集合        List&lt;String&gt; targetFieldNames = Arrays                .stream(target.getClass().getDeclaredFields())                .map(Field::getName)                .collect(Collectors.toList());        for (PropertyDescriptor sourceProperty : sourceDescriptors) {            //获取源对象的属性名称            String name = sourceProperty.getName();            //源对象的getter方法            Method readMethod = sourceProperty.getReadMethod();            if (!readMethod.isAccessible()) {                //设置方法的可访问权限                readMethod.setAccessible(true);            }            //调用源对象的getter方法，获取到里面的每一个值            Object value = readMethod.invoke(source);            //如果源对象的属性名称包含在目标对象的字段名称集合中            if (targetFieldNames.contains(name)) {                //则通过源对象的属性名称获取目标对象属性的属性描述器                PropertyDescriptor propertyDescriptor = new PropertyDescriptor(name, target.getClass());                //获取目标对象的setter方法                Method writeMethod = propertyDescriptor.getWriteMethod();                writeMethod.setAccessible(true);                //执行setter方法，参数是从源对象getter方法获取到的值                writeMethod.invoke(target, value);            }        }    }}</code></pre><p>测试：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setIdCard(new IdCard());        User user1 = new User();        CloneUtil.copyProperties(user, user1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三        System.out.println(user.getIdCard());//IdCard@b81eda8        System.out.println(user1.getIdCard());//IdCard@b81eda8    }</code></pre><p>这样实现的不是深克隆的效果，所以<code>IdCard</code>对象的内存地址还是一样的。为了避免这样的结果，我们可以在使用时注意一下：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setName(&quot;张三&quot;);        IdCard idCard = new IdCard();        user.setIdCard(idCard);        User user1 = new User();        //创建一个新的IdCard对象        IdCard idCard1 = new IdCard();        CloneUtil.copyProperties(user, user1);        //复制idCard的值到idCard1里        CloneUtil.copyProperties(idCard,idCard1);        //再设置idCard1到user1中        user1.setIdCard(idCard1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三        System.out.println(user.getIdCard());//IdCard@68de145        //内存地址不同        System.out.println(user1.getIdCard());//IdCard@27fa135a    }</code></pre><p>这样就避免产生内存地址一样的情况了。</p><h2 id="Spring的copyProperties"><a href="#Spring的copyProperties" class="headerlink" title="Spring的copyProperties()"></a>Spring的copyProperties()</h2><p>实际上在<code>Spring</code>框架中，已经提供了<code>copyProperties()</code>方法：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setName(&quot;张三&quot;);        User user1 = new User();        //Spring的copyProperties()方法        BeanUtils.copyProperties(user,user1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三    }</code></pre><p>一般在实际项目中，我们采用<code>copyProperties()</code>方法实现原型模式会更好，因为这样不会破坏开闭原则，即使是<code>jar</code>包中定义的实体类，也可以使用。缺点就是如果对象层级比较多的话，会比较麻烦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现原型模式的三种方式：实现<code>Cloneable</code>接口、序列化对象、反射机制。</p><p>原型模式的优点：</p><ol><li>提高了创建对象的性能，避免了调用构造器创建对象。</li><li>对于创建一个对象需要很多资源的情况，可以减少资源的浪费。</li></ol><p>原型模式的缺点：</p><ol><li>如果使用<code>Cloneable</code>接口的方式，需要实现<code>Cloneable</code>接口，对代码有一定的侵入性。</li><li>如果使用序列化方式，则需要实现<code>Serializable</code>接口，对代码也有一定的侵入性。</li><li>如果使用反射机制，层级较多时会比较难维护。</li></ol><p>以上就是原型模式的学习，更多的java技术分享，就关注<strong>java技术爱好者</strong>吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰者模式与IO流</title>
    <link href="/2020/05/04/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8EIO%E6%B5%81/"/>
    <url>/2020/05/04/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8EIO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>装饰者模式是一种<strong>对象结构型</strong>模式。<strong>动态</strong>地给一个对象添加一些<strong>额外的</strong>职责，就增加功能来说，装饰者模式比生成子类更为灵活。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>上面的定义在网上是随处可见的描述，怎么解释呢。比如：我前几天和女朋友去买戒指，珠宝店的销售给我推荐了一种<strong>自由搭配</strong>的原创戒指。他跟我介绍戒指的元素需要选择材质(黄金，铂金，彩金)、表面工艺(拉丝，磨砂，光滑，铸造)、镶钻(内嵌，外嵌)、指环大小等等，然后组成一个戒指。这种就是装饰者模式的应用，原型是一个戒指，不断地给对象添加额外的职责，然后得到最终想要的产品。这样就可以通过不同的搭配产生很多不同类型的戒指。</p><p>后面那句<strong>装饰者模式比生成子类更为灵活</strong>怎么理解。如果用子类去描述的话，要把每一种搭配的结果都变成一个子类，也就是要穷举，就会产生很多子类，也就是造成<strong>“类爆炸”</strong>。所以就会说装饰者模式更加灵活。</p><h2 id="来个例子"><a href="#来个例子" class="headerlink" title="来个例子"></a>来个例子</h2><p>现在有一个需求，要求做一个加密的工具类，对传入的字符串加密。加密的算法有很多，有<strong>MD5、AES、DES等等</strong>，一般加密都不是单独使用一种加密算法，而是多种混合一起使用，这样可以提高安全性。</p><p>现在有三种算法：<code>MD5、AES、DES</code>。做一个工具类，给系统提供加密的服务，要求可以自由搭配使用。</p><h2 id="使用继承的方式实现"><a href="#使用继承的方式实现" class="headerlink" title="使用继承的方式实现"></a>使用继承的方式实现</h2><p>我们就创建一个抽象类<code>EncryptionBase</code>，每一种组合方式就创建一个子类继承<code>EncryptionBase</code>，现在有三种加密方式，很容易我们可以穷举完，总共有6种组合。请看以下代码：</p><p>首先创建一个抽象类<code>EncryptionBase</code>：</p><pre><code class="java">public abstract class EncryptionBase {    public abstract String encrypt(String string,String password);}</code></pre><p>接着创建子类继承抽象类，并且实现其方法。以其中一个为例，其他实现类都类似：</p><pre><code class="java">public class AESandDESandMD5Encryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        //网上可以找具体加密的代码，我这里篇幅受限就不展示了        //AES加密        byte[] encryptByAES = AESUtil.encrypt(string, password);        //DES加密        byte[] encryptByDES = DESUtil.encrypt(encryptByAES, password);        //MD5加密        return MD5Util.encryptByMD5(new String(encryptByDES) + password);    }}</code></pre><p>我们就可以实现以下效果，有6个实现类分别实现了3种加密算法的不同顺序。</p><pre><code class="java">public static void main(String[] args) {        String string = &quot;需要加密的字符串&quot;;        //秘钥        String password = &quot;12345678&quot;;        //第一种加密顺序：AES-&gt;DES-&gt;MD5        EncryptionBase AESandDESandMD5 = new AESandDESandMD5Encryption();        //第二种加密顺序：AES-&gt;MD5-&gt;DES        EncryptionBase AESandMD5andDES = new AESandMD5andDESEncryption();        //第三种加密顺序：DES-&gt;AES-&gt;MD5        EncryptionBase DESandAESandMD5 = new DESandAESandMD5Encryption();        //第四种加密顺序：DES-&gt;MD5-&gt;AES        EncryptionBase DESandMD5andAES = new DESandMD5andAESEncryption();        //第五种加密顺序：MD5-&gt;DES-&gt;AES        EncryptionBase MD5andDESandAES = new MD5andDESandAESEncryption();        //第六种加密顺序：MD5-&gt;AES-&gt;DES        EncryptionBase MD5andAESandDES = new MD5andAESandDESEncryption();    }</code></pre><p>以上就是使用继承的方式来完成这个需求。看起来没什么问题，但是仔细思考你会发现几个问题。</p><ol><li><strong>会创建很多子类。</strong>为什么3种算法是6个类呢？这是根据数学的排列组合<code>3*2*1=6</code>，假设再多两种算法呢？那就是<code>5*4*3*2*1=120</code>，那就是120个类了！这就是<strong>“类爆炸”</strong>。</li><li><strong>不符合开闭原则。</strong>假设增加了新的算法，那就要修改原来的类，不利于代码的维护。</li><li>假如其中一种加密算法要用两次，比如双重<code>MD5</code>加密，那也是很难扩展的。</li></ol><p>如果你不会装饰者模式，那估计要加班加点去写代码，创建很多类。如果你会装饰者模式，那问题就很简单了，那怎么做呢？请继续看下去。</p><h2 id="使用装饰者模式实现"><a href="#使用装饰者模式实现" class="headerlink" title="使用装饰者模式实现"></a>使用装饰者模式实现</h2><p>首先创建三种算法的基础类，继承<code>EncryptionBase</code>，实现三种加密算法。</p><p>MD5加密</p><pre><code class="java">public class MD5Encryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用MD5加密，得到基础密文&quot;);        return MD5Util.encryptByMD5(string + password);    }}</code></pre><p>AES加密</p><pre><code class="java">public class AESEncryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用AES加密，得到基础密文&quot;);        return new String(AESUtil.encrypt(string, password));    }}</code></pre><p>DES加密</p><pre><code class="java">public class DESEncryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用DES加密，得到基础密文&quot;);        return new String(DESUtil.encrypt(string.getBytes(), password));    }}</code></pre><p>接着创建一个装饰抽象类<code>EncryptionDecorator</code>，需要继承<code>EncryptionBase</code></p><pre><code class="java">public abstract class EncryptionDecorator extends EncryptionBase {    //定义一个父类的成员变量，用来存储其他装饰类，或者基础加密类    private EncryptionBase encryption;    public EncryptionDecorator(EncryptionBase encryption) {        this.encryption = encryption;    }    @Override    public String encrypt(String string, String password) throws Exception{        return encryption.encrypt(string, password);    }}</code></pre><p>然后实现三种加密的装饰者实现类，需要继承抽象装饰者类<code>EncryptionDecorator</code>。</p><p>MD5加密装饰者实现类<code>MD5EncryptionDecorator</code></p><pre><code class="java">public class MD5EncryptionDecorator extends EncryptionDecorator {    public MD5EncryptionDecorator(EncryptionBase encryption) {        //有参构造器获取到参数，调用父类的有参构造器，        //当下面encrypt()方法里调用父类的加密算法就会调用传入的算法实现类的加密算法        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用MD5加密&quot;);        //得到的密文，再用MD5算法加密，返回        return MD5Util.encryptByMD5(encrypt + password);    }}</code></pre><p>AES加密装饰者实现类<code>AESEncryptionDecorator</code></p><pre><code class="java">public class AESEncryptionDecorator extends EncryptionDecorator {    public AESEncryptionDecorator(EncryptionBase encryption) {        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用AES加密&quot;);        //得到的密文，再用AES算法加密，返回        return new String(AESUtil.encrypt(encrypt, password),&quot;UTF-8&quot;);    }}</code></pre><p>DES加密装饰者实现类<code>DESEncryptionDecorator</code></p><pre><code class="java">public class DESEncryptionDecorator extends EncryptionDecorator {    public DESEncryptionDecorator(EncryptionBase encryption) {        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用DES加密&quot;);        //得到的密文，再用DES算法加密，返回        return new String(DESUtil.encrypt(encrypt.getBytes(), password),&quot;UTF-8&quot;);    }}</code></pre><p>大功告成！我们用<code>main()</code>方法测试一下：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception{        String string = &quot;需要加密的字符串&quot;;        String password = &quot;12345678&quot;;        //第一种加密顺序：AES-&gt;DES-&gt;MD5        EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption()));        encryptionBase.encrypt(string, password);    }}</code></pre><p>控制台打印结果：</p><pre><code class="java">/**使用AES加密，得到基础密文使用DES加密使用MD5加密*/</code></pre><p>我们可以看到结果是很完美地实现了，你可以任意搭配加密算法，即使加多N种算法，我们也不会呈指数增加类的数量，只需要增加M*N个类即可，M是基础构件数量，N是具体装饰类数量。</p><p>原理是什么呢？我们不能说只学到形式，而不明白原理。接下来看类图。</p><p>在IDEA可以选中类名，然后右键，选中“Diagrams”，再选中“show Diagrams…”，就可以打开类图。</p><img src="https://static.lovebilibili.com/MD5EncryptionDecorator.png" srcset="/img/loading.gif"/><pre><code class="java">//MD5(DES(AES))，最顶层的父类是AES，所以先执行，第二层是DES，第二执行，最外层是MD5第三执行EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption()));encryptionBase.encrypt(string, password);</code></pre><p>以上面这句代码为例，那么调用顺序就是：AES-&gt;DES-&gt;MD5</p><img src="https://static.lovebilibili.com/decorator1.png" srcset="/img/loading.gif" style="width:100%;"/><p>这就是装饰者模式的原理，其实很简单的，很容易就可以看清楚。</p><h2 id="装饰者模式与I-O流"><a href="#装饰者模式与I-O流" class="headerlink" title="装饰者模式与I/O流"></a>装饰者模式与I/O流</h2><p>看了上面的代码，很容易我们能联想到IO流也有类似的创建方式，比如我们要用文件缓冲输入流，那就要这样创建：</p><pre><code class="java">InputStream inputStream     = new BufferedInputStream(new FileInputStream(new File(&quot;/D:abc.text&quot;)));</code></pre><p>可以看出IO流使用了装饰者模式。</p><p>如果我们打开源码，查看<code>BufferedInputStream</code>，我们可以看到：</p><pre><code class="java">public class BufferedInputStream extends FilterInputStream {    //有参构造器    public BufferedInputStream(InputStream in, int size) {        //调用父类构造器，这是关键        //通过上面我们学过的例子，可以知道BufferedInputStream是装饰实现类        super(in);        if (size &lt;= 0) {            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);        }        buf = new byte[size];    }}</code></pre><p>关键在<code>FilterInputStream</code>这个类，这是装饰者模式的基类。查看源码：</p><pre><code class="java">public class FilterInputStream extends InputStream {    /**     * The input stream to be filtered.     */    protected volatile InputStream in;    protected FilterInputStream(InputStream in) {        this.in = in;    }    public int read() throws IOException {        return in.read();    }}</code></pre><p><code>FilterInputStream</code>类似于加密算法例子的<code>EncryptionDecorator</code>类。我们可以通过加密算法的例子和这个作对比，就可以很容易地看出他们的关系。类图如下：</p><img src="https://static.lovebilibili.com/FilterInputStream.png" srcset="/img/loading.gif" style="width:100%;"/><p><code>FileInputStream</code>就是基础构件类，可以通过<code>FilterInputStream</code>的子类去做扩展，增加额外的功能，比如可以使用<code>BufferedInputStream</code>增加缓冲的作用。</p><p>接着我们真正理解了IO流的装饰者模式的应用后，我们可以写一个扩展类，实现一个功能：读取磁盘的文件，把所有字母变成大写的字母。代码如下：</p><pre><code class="java">public class CapitalizaInputStream extends FilterInputStream {    public CapitalizaInputStream(InputStream in) {        super(in);    }    @Override    public int read(byte[] b, int off, int len) throws IOException {        int result = super.read(b, off, len);        for (int i = off; i &lt; off + result; i++){            //如果是小写字母，转成大写，其他不是小写字母的不变            if(Character.isLetter((char)b[i])){                b[i] = (byte) Character.toUpperCase((char) b[i]);            }        }        return result;    }}</code></pre><p>abc.txt文件内容：</p><pre><code class="yaml">abcdefghijklmnopqrstuvwxyz</code></pre><p>Main方法测试代码：</p><pre><code class="java">public static void main(String[] args) throws Exception {        InputStream inputStream             = new CapitalizaInputStream(new FileInputStream(new File(&quot;D://abc.txt&quot;)));        byte[] bytes = new byte[1024 * 2];        int c;        while ((c = inputStream.read(bytes, 0, bytes.length)) != -1) {            System.out.println(new String(bytes, 0, c));        }        inputStream.close();    }</code></pre><p>控制台打印结果：</p><pre><code class="yaml">ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre><p>以上就是IO流关于装饰者模式的扩展，能够加深我们对装饰者模式的理解。很多博客写不清楚，讲得很复杂，或者讲得很简单，很大原因是我们只看，而没有动手去做，动手去自己写，自己琢磨，就很容易能理解。这是学习方法，不是关注了公众号，看几篇文章就能轻松学会的，学习总是要自己动手才会理解深刻。看我的文章可以提供一些思路，更容易去上手。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰者模式的优点：</p><ol><li>可以动态地扩展类的功能，不会相互耦合。</li><li>符合开闭原则，利于代码维护。</li><li>比继承扩展的方式要更加灵活。</li></ol><p>缺点：多层装饰，代码结构变得复杂。</p><p>更多的java技术分享，就关注java技术爱好者吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式以及实际项目应用</title>
    <link href="/2020/05/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式（Observer），又叫<strong>发布-订阅模式（Publish/Subscribe）</strong>，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>比如我们在宿舍打斗地主，我们要找个人来“放风”，这个人在门口观察，如果有宿管过了检查，那么就通知宿舍其他的小伙伴停止斗地主回床上睡觉。这种模式就被称为观察者模式。</p><p>从这个例子看，“宿管是否过来宿舍”是订阅的主题，观察者是放风的人，订阅者是打斗地主的小伙伴，被观察者就是宿管。</p><h2 id="不使用观察者模式的问题"><a href="#不使用观察者模式的问题" class="headerlink" title="不使用观察者模式的问题"></a>不使用观察者模式的问题</h2><p>假设我们基于之前在策略模式讲的电子支付的例子，支付完成后要发送消息，发送的消息有：短信，公众号消息，APP站内消息，邮箱。如果不使用观察者模式，怎么做呢？看代码：</p><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        //发送短信        System.out.println(&quot;发送短信：&quot;+msg);        //发送微信公众号消息        System.out.println(&quot;发送微信公众号消息：&quot;+msg);        //发送邮件        System.out.println(&quot;发送邮件：&quot;+msg);        //发送APP系统信息        System.out.println(&quot;发送APP系统信息：&quot;+msg);        return msg;    }</code></pre><p>启动项目是没有问题的，我们调用接口后可以看到控制台打印以下信息：</p><pre><code class="java">/**发送短信：使用 支付宝支付 ,消费了 100 元发送微信公众号消息：使用 支付宝支付 ,消费了 100 元发送邮件：使用 支付宝支付 ,消费了 100 元发送APP系统信息：使用 支付宝支付 ,消费了 100 元*/</code></pre><p><strong>但是我们很明显可以看出有以下的问题：</strong></p><ul><li>每次支付如果需要新增一种消息通知方式，则要修改原来的类，不利于维护。</li><li>违反了开闭原则，对拓展开放，对修改关闭。</li><li>违反了单一职责原则，支付不应该糅杂消息通知的功能。</li></ul><p>上面就从代码演示了为什么要使用观察者模式，很多文章说不清楚，单纯地抛出一个概念和一些简单的例子，实际项目中肯定是没有那么简单。</p><h2 id="使用观察者模式优化"><a href="#使用观察者模式优化" class="headerlink" title="使用观察者模式优化"></a>使用观察者模式优化</h2><p>这里的话，我不使用<code>java</code>自带的<code>Observer</code>和<code>Observable</code>来做，因为实际项目中一般都会使用<code>Spring</code>框架，<code>Spring</code>框架有一个事件机制，也是使用观察者模式的这种设计模式，而且在实际项目中我们往往会采用这种成熟度更高的框架，就像代理模式我们也很少会直接使用原生的<code>JDK动态代理</code>，而是采用<code>SpringAOP</code>来实现。</p><h2 id="创建支付的事件"><a href="#创建支付的事件" class="headerlink" title="创建支付的事件"></a>创建支付的事件</h2><pre><code class="java">//继承ApplicationEvent类public class PayEvent extends ApplicationEvent {    //消息体    private Map&lt;String,String&gt; map;    //订阅主题    private String topic;    public PayEvent(Object source, Map&lt;String, String&gt; map, String topic) {        //调用父类的构造器        super(source);        this.map = map;        this.topic = topic;    }    public Map&lt;String, String&gt; getMap() {        return map;    }    public void setMap(Map&lt;String, String&gt; map) {        this.map = map;    }    public String getTopic() {        return topic;    }    public void setTopic(String topic) {        this.topic = topic;    }}</code></pre><h2 id="创建事件监听类"><a href="#创建事件监听类" class="headerlink" title="创建事件监听类"></a>创建事件监听类</h2><pre><code class="java">//短信监听，实现ApplicationListener接口，重写onApplicationEvent()方法@Componentpublic class SmsListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        //订阅主题        String topic = payEvent.getTopic();        //消息体        Map&lt;String, String&gt; map = payEvent.getMap();        //发送短信        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送短信:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//公众号监听@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//邮箱监听@Componentpublic class MailListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送邮件:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//App站内消息监听@Componentpublic class AppListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送App站内消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><h2 id="重构PayServiceImpl类"><a href="#重构PayServiceImpl类" class="headerlink" title="重构PayServiceImpl类"></a>重构PayServiceImpl类</h2><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,msg);        //创建一个支付事件        PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;);        //获取Spring的ApplicationContext容器，发布事件，监听类监听到事件后就会发送消息        SpringContextUtil.getApplicationContext().publishEvent(payEvent);        return msg;    }</code></pre><p>然后我们启动项目，调用接口，控制台就可以打印的信息：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送公众号消息:使用 支付宝支付 ,消费了 100 元*/</code></pre><h2 id="异步监听事件，实现解耦"><a href="#异步监听事件，实现解耦" class="headerlink" title="异步监听事件，实现解耦"></a>异步监听事件，实现解耦</h2><p>改造之后是否就一劳永逸了呢，实际上并非如此。因为上面的消息发送的监听类是同步的，也就是如果发送消息出现异常，那就会导致支付的接口无法正常返回。请看以下代码：</p><pre><code class="java">@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        //在发送微信公众号消息的逻辑中制造异常        System.out.println(10 / 0);        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,msg);        //创建一个支付事件        PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;);        //获取Spring的ApplicationContext容器，发布事件        SpringContextUtil.getApplicationContext().publishEvent(payEvent);        //发送消息后的逻辑，打印日志到控制台        System.out.println(&quot;发送消息后的逻辑代码...&quot;);        return msg;    }</code></pre><p>我们在发送公众号消息的逻辑里制造了一个异常，然后在<code>pay()</code>方法中加了一个打印日志在发布支付的事件后面，接下来调用接口，结果是：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/</code></pre><p>发送消息后的逻辑是没有被执行。这样显然是不符合业务要求的，因为在很多时候，发送消息失败是不能影响支付流程的，应该异步进行。怎么异步进行发送消息呢？</p><p>很简单，只需要两个步骤。</p><p><strong>第一步</strong>:在监听类或者方法上添加<code>@Async</code>注解，例如：</p><pre><code class="java">@Component@Async//加上异步执行的注解public class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(10 / 0);        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><p><strong>第二步</strong>：在<code>SpringBoot</code>启动类上添加<code>@EnableAsync</code>注解，例如：</p><pre><code class="java">@SpringBootApplication@EnableAsync//添加启用异步的注解public class StrategyApplication {    public static void main(String[] args) {        SpringApplication.run(StrategyApplication.class, args);    }}</code></pre><p>然后就可以实现异步监听了，调用接口，我们可以看到控制台打印的日志如下：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元发送消息后的逻辑代码...使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/</code></pre><p>明显可以看到支付后的逻辑也能正常执行下去，证明实现了异步监听！</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在<code>Spring</code>里提供了许多的监听器，这里只是介绍了其中一种。</p><p>还有一种叫<code>SpringApplicationRunListener</code>也是很常用的监听器，可以监听<code>SpringBoot</code>项目启动的事件，用于在启动项目时加载一些配置。</p><p>还有一种叫<code>SmartApplicationListener</code>，这种监听器可以设置优先级。假设发送消息需要按顺序先发送短信，再发送公众号，再发送邮箱…，那就可以使用这种监听器实现，这里就不多做介绍了，小伙伴有兴趣的话，我可以再写一篇文章详细介绍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过重构之后，我们可以明显看到，如果以后要增加一种新的消息通知方式，是不需要修改<code>PayServiceImpl</code>的，我们只需要再增加一个监听类即可，这就符合了<code>开闭原则</code>。有利于代码的维护。而且最重要是解耦，支付的业务逻辑和发送消息的业务逻辑不会再糅合在一起了，符合<code>职责单一</code>原则。</p><p>在很多框架中，观察者模式都有应用，对于学习很多例如<code>zookeeper</code>、<code>消息中间件</code>、<code>微服务注册中心</code>等知识是有很大帮助的。在实际项目中，观察者模式也是一种很常用的设计模式。比如有一种业务场景，通讯录的部门里有员工离职，需要通知其他依赖于通讯录的应用都要同步部门的员工，那就可以使用这种方式来实现。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你用构建者(生成器)模式优雅地创建对象</title>
    <link href="/2020/04/27/%E6%95%99%E4%BD%A0%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85-%E7%94%9F%E6%88%90%E5%99%A8-%E6%A8%A1%E5%BC%8F%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/04/27/%E6%95%99%E4%BD%A0%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85-%E7%94%9F%E6%88%90%E5%99%A8-%E6%A8%A1%E5%BC%8F%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要用构建者模式"><a href="#为什么要用构建者模式" class="headerlink" title="为什么要用构建者模式"></a>为什么要用构建者模式</h1><p>很多博客文章上来就先抛出一个定义，我们不妨反过来问一句为什么要用构建者模式。<br>首先我们创建一个<code>User</code>类，然后采用有参构造器的方式创建对象。</p><pre><code class="java">public class User {    private String id;    private String name;    private String gender;    private String address;    private Integer age;    private String phone;    //省略无参构造器，有参构造器，getter，setter方法...}</code></pre><pre><code class="java">public static void main(String[] args) throws Exception {    String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);    User user = new User(id, &quot;张三&quot;, &quot;男&quot;, &quot;广州天河&quot;, 20, &quot;135461852xx&quot;);}</code></pre><p>我们通过有参构造器创建对象，并且赋值，看起来没什么问题，因为我们经常看到有人是这样写的。<br>事实上，如果<code>User</code>对象里面有更多的字段，通过有参构造器去创建对象是很难一眼看出字段具体是什么意思，我们经常要看着<code>User构造器</code>的代码，然后对照顺序才能看出字段的代表什么意思。</p><pre><code class="java">public User(String id, String name, String gender, String address, Integer age, String phone) {    this.id = id;    this.name = name;    this.gender = gender;    this.address = address;    this.age = age;    this.phone = phone;}</code></pre><p>比如通过上面这个，我们可以知道第一个参数是id，第二个参数是名字，第三个是性别…</p><h2 id="使用有参构造器的缺点："><a href="#使用有参构造器的缺点：" class="headerlink" title="使用有参构造器的缺点："></a>使用有参构造器的缺点：</h2><p>这显然不利于代码的维护性，对于不熟悉业务的新入职的员工，如果看到这种方式构建一个对象，估计要看上一会，有些项目我遇过一个构造器十几个参数的，更加离谱。而且一般老代码还不敢乱动他的这个构造器，一不小心你动了构造器里面的一个参数的顺序，直接GG；或者你在他原有的构造器后面加多一个参数，你会发现他很多地方都引用了这个有参构造器，你很多地方都要去修改，是真的恶心。</p><h2 id="解决方法一-使用无参构造器，通过setter方法设置属性值"><a href="#解决方法一-使用无参构造器，通过setter方法设置属性值" class="headerlink" title="解决方法一 使用无参构造器，通过setter方法设置属性值"></a>解决方法一 使用无参构造器，通过setter方法设置属性值</h2><pre><code class="java">public static void main(String[] args) throws Exception {    User user = new User();    user.setId(UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;));    user.setName(&quot;张三&quot;);    user.setAge(20);    user.setGender(&quot;男&quot;);    user.setPhone(&quot;135461852xx&quot;);    user.setAddress(&quot;广州天河&quot;);    out.println(user);}</code></pre><p>上面这样，显然比直接用有参构造器要好很多，因为这样就可以创建对象和赋值分开进行，一眼就可以看出对什么属性值赋值，而且如果加一个字段，我们不需要再每一处都去修改，因为用的是<strong>无参构造器</strong>，是不是这样写就是万全之计呢？<br>也不是，因为这样创建对象和赋值是分开的，各个参数的初始化被放到了不同的方法中调用，这会导致严重的线程不安全问题(使用构造器则不会有这个问题)，对象在一连串的set方法中，可能会出现状态不一致的情况，这是应该尽量避免的。</p><h2 id="解决方法二-通过构建者模式，链式调用构建方法设置属性值"><a href="#解决方法二-通过构建者模式，链式调用构建方法设置属性值" class="headerlink" title="解决方法二 通过构建者模式，链式调用构建方法设置属性值"></a>解决方法二 通过构建者模式，链式调用构建方法设置属性值</h2><p>什么是链式编程，就是调用一个方法，返回值是他本身，可以继续调用下一个方法，返回又是他本身，如此调用下去，看上去就像一条链子一样。典型的例子可以看<code>java8</code>新特性的<code>Stream</code>流操作。我们可以使用构建者模式，也能达到这种效果，并且线程安全，而且能直观地看到属性值的意思。总得来说，既保证线程安全，也很具有代码的可读性。先看结果代码：</p><pre><code class="java">public static void main(String[] args) throws Exception {    String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);    User user = UserBuilder.getInstance()            .newPojo()            .addId(id)            .addName(&quot;张三&quot;)            .addGender(&quot;男&quot;)            .addAge(20)            .addPhone(&quot;135461852xx&quot;)            .addAddress(&quot;广州天河&quot;)            .build();}</code></pre><p>怎么实现呢？其实很简单，我们只需要创建一个<code>UserBuilder</code>类即可。代码如下：</p><pre><code class="java">public class UserBuilder {    private User user;    private UserBuilder() {    }    public static UserBuilder getInstance() {        return new UserBuilder();    }    public UserBuilder newPojo() {        this.user = new User();        //返回本身        return this;    }    public UserBuilder addId(String id) {        this.user.setId(id);        //返回本身        return this;    }    public UserBuilder addName(String name) {        this.user.setName(name);        return this;    }    public UserBuilder addGender(String gender) {        this.user.setGender(gender);        return this;    }    public UserBuilder addAge(Integer age) {        this.user.setAge(age);        return this;    }    public UserBuilder addAddress(String address) {        this.user.setAddress(address);        return this;    }    public UserBuilder addPhone(String phone) {        this.user.setPhone(phone);        return this;    }    public User build() {        return this.user;    }}</code></pre><p>那么是不是这种方式就是万全之计呢，就一定没有缺点吗？</p><h3 id="构造者模式的缺点还是有的"><a href="#构造者模式的缺点还是有的" class="headerlink" title="构造者模式的缺点还是有的"></a>构造者模式的缺点还是有的</h3><p>1.代码冗长。如果一个对象的属性很多，那我们在创建一个对象时，链式就会变得很长，但是这也没有办法，无论采用构造器还是builder模式都会很长。如果非要变得简洁一点，那就只有采用原型模式(克隆)等其他方式了。<br>2.会产生很多<code>Builder</code>类。我们可以放在一个包下统一管理应该问题不大。<br>第二个缺点实际上可以使用<code>Lombok</code>插件，然后在实体类上使用<code>@Builder</code>注解，就不会产生过多的<code>Builder</code>类了。但是有些公司的技术总监不太建议使用<code>Lombok</code>，那就莫得办法了…</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>有很多博客的示范代码，<code>Builder</code>类的<code>addXXX</code>方法会写成<code>setXXX</code>方法，这是一个隐患。因为很多框架，对Setter方法比较敏感，往往会对<code>Setter</code>方法做一些处理，所以<code>Builder</code>类里的设置属性值方法尽量不要用<code>setXXX</code>命名，防止出现一些不明原因的错误。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>一般我们在项目中创建复杂的对象时，建议采用这种构建者模式创建对象。这样可以使代码可读性更好。<br>在java源码中，我们也可以看到构建者模式的应用。比如在<code>StringBuilder</code>类中：</p><pre><code class="java">@Overridepublic StringBuilder append(CharSequence s) {    super.append(s);    return this;}/** * @throws     IndexOutOfBoundsException {@inheritDoc} */@Overridepublic StringBuilder append(CharSequence s, int start, int end) {    super.append(s, start, end);    return this;}@Overridepublic StringBuilder append(char[] str) {    super.append(str);    return this;}</code></pre><p><code>StringBuilder</code>的<code>append()</code>方法也是通过返回<code>this</code>对象实现链式构建对象，人们经常说这个<code>StringBuilder</code>类线程不安全是因为<code>append()</code>方法没有用<code>synchronized</code>修饰。<code>StringBuffer</code>则用了<code>synchronized</code>修饰，所以就是线程安全的。<br>还有<code>Mybatis</code>框架中，构建<code>SqlSessionFactory</code>对象是使用<code>SqlSessionFactoryBuilder</code>类进行构建，构建者模式运用非常广泛，非常值得学习。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式以及应用</title>
    <link href="/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><strong>代理模式的定义：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</p><a id="more"></a><p>通俗点说，就是一个中介，比如有一个广州人，是个本地人，有两套房，他要租出去收租，但是除了收租，他还要去找租客，带租客看房，还要准备租房合同，核算水电费等等，很麻烦。这个本地人他也不想这么折腾，他只想<strong>完成他的核心业务(收钱)</strong>,其他杂七杂八的事情就不想管，但是总要有人去做，那就找<strong>租房中介</strong>，也就是二手房东。二手房东就代理这个广州本地人把房子租给租客。这个道理就是这么简单。</p><p>他们这些在广州有房子的本地人都可以找中介公司去代理租房是一样的。因为很多广州本地人都有这个需求，干脆就搞一个中介公司来专门去做租房子的事情。</p><p><strong>代理模式，运用在编程里，也是这个道理，有一些非核心业务的代码，在很多地方都需要用到的逻辑，可以交给代理对象完成，程序员只需要关心核心业务的逻辑即可。</strong></p><h1 id="实现代理模式的三种方式"><a href="#实现代理模式的三种方式" class="headerlink" title="实现代理模式的三种方式"></a>实现代理模式的三种方式</h1><p>项目就基于上一篇<code>模板模式</code>的文章的项目进行试验。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假设原来有一个接口<code>UserService</code>，controller层调用<code>userService</code>的<code>getAllUser()</code>方法。如下所示：</p><pre><code class="java">public interface UserService {    /**     * 获取所有用户信息     *     * @return List     * @author Ye hongzhi     * @date 2020/4/12     */    List&lt;User&gt; getAllUser() throws Exception;}</code></pre><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return userService.getAllUser();    }}</code></pre><p>如果用静态代理实现记录日志信息，怎么记录呢？</p><p>首先创建一个代理类<code>UserServiceProxy</code>，实现<code>UserService</code>接口，然后在<code>UserServiceProxy</code>里面创建一个成员变量<code>userService</code>，再写一个有参构造器来初始化<code>userService</code>。代码如下：</p><pre><code class="java">public class UserServiceProxy implements UserService {    private UserService userService;    public UserServiceProxy(UserService userService) {        this.userService = userService;    }    @Override    public List&lt;User&gt; getAllUser() throws Exception {        System.out.println(&quot;记录日志：执行getAllUser()方法前&quot;);        List&lt;User&gt; userList = userService.getAllUser();        System.out.println(userList);        System.out.println(&quot;记录日志：执行getAllUser()方法后&quot;);        return userList;    }}</code></pre><p>所以在controller层调用的方式就要改一下，是用代理类<code>UserServiceProxy</code>调用<code>getAllUser()</code>方法。如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return new UserServiceProxy(userService).getAllUser();    }}</code></pre><p>然后启动项目，调用一下接口，就可以看到控制台打印如下日志：</p><pre><code class="java">/*记录日志：执行getAllUser()方法前[User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser()方法后*/</code></pre><p>这就是静态代理的实现思路，很简单。但是一般我们肯定是不用这种方式。因为这种方式太笨了，很容易就可以看出几个缺点。</p><p><strong>1.要实现接口，也就是目标的方法要定义一个接口方法，实际上是运用了java多态的特性</strong></p><p><strong>2.第一点还不是致命的，因为JDK动态代理也是必须要定义接口；致命的是每一个你想代理的接口你都要去创建一个代理类去实现，假设有很多要代理的接口，那就创建很多代理类，这样显得很臃肿</strong></p><p>假设还是不理解为什么要动态代理，不妨我们再多加一个支付接口<code>PayService</code>，这个支付接口我们也要加上日志记录。</p><p>用静态代理怎么做？很简单呀，再创建一个<code>PayServiceProxy</code>类不就完了吗，如果还有<code>OrderService</code>(订单),</p><p><code>WarehouseService</code>(仓库)等等。那就要创建很多<code>XXXServiceProxy</code>类。如果使用动态代理，就没必要创建这么多代理类，创建一个代理类就够了！</p><blockquote><p>动态代理就是为了解决静态代理的这个缺点产生的。</p></blockquote><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK本身就带有动态代理，必须要满足一个条件，就是要有接口。原理其实和静态代理是一样的，也是用代理类去实现接口，但是代理类不是一开始就写好的，而是在程序运行时通过反射创建字节码文件然后加载到JVM。也就是动态生成的代理类对象。</p><p>下面就是用<code>JDK动态代理</code>实现代理模式。</p><pre><code class="java">public class LogRecordProxy&lt;T&gt; implements InvocationHandler {    private T target;    public LogRecordProxy(T t) {        this.target = t;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前&quot;);        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后&quot;);        return result;    }    /**     * 获取代理对象的方法     * */    @SuppressWarnings(&quot;unchecked&quot;)    public &lt;T&gt; T getProxy() throws Exception {        return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }}</code></pre><p>在controller层，就要改成这样。</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        //获取代理对象        UserService userServiceProxy = new LogRecordProxy&lt;&gt;(userService).getProxy();        return userServiceProxy.getAllUser();    }}</code></pre><p>假设有一个<code>PayService</code>也要做日志记录，就可以直接使用。</p><pre><code class="java">    @Resource(name = &quot;payService&quot;)    private PayService payService;        @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        //获取代理对象，实际上就在构造器上改一下传入的参数即可        PayService payServiceProxy = new LogRecordProxy&lt;&gt;(payService).getProxy();        return payServiceProxy.pay(channel,amount);    }</code></pre><p>很多文章给的例子都不带泛型，也可以，就是获取的代理对象需要强转一下，强转成对应的接口类。</p><p><strong>注意：这里一定要用接口接收代理对象，不能用实现类！</strong></p><p>因为返回的对象已经不是实现类的对象，而是和实现类有共同的接口类的代理类对象，所以当然只能用接口类去接收。</p><blockquote><p>这也是为什么一再强调要面向接口编程的原因，因为面向接口编程可以做更多的扩展。假设是面向实现类去编程，那就不能用JDK动态代理去扩展了！</p></blockquote><h2 id="CGLB动态代理"><a href="#CGLB动态代理" class="headerlink" title="CGLB动态代理"></a>CGLB动态代理</h2><p>那如果有些场景真的没有接口呢，我们怎么运用代理模式？</p><p>首先引入maven配置</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后创建一个方法拦截器<code>LogRecordInterceptor</code>，要实现<code>MethodInterceptor</code>类，如下：</p><pre><code class="java">public class LogRecordInterceptor implements MethodInterceptor {    private Object target;    public LogRecordInterceptor(Object target) {        this.target = target;    }    @Override    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前,参数：&quot; + Arrays.toString(args));        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后,参数：&quot; + Arrays.toString(args));        return result;    }}</code></pre><p>然后再创建一个工厂类<code>InterceptorFactory</code>，用于创建代理对象。</p><pre><code class="java">public class InterceptorFactory {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T&gt; T getInterceptor(Class&lt;T&gt; clazz, MethodInterceptor methodInterceptor) {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(clazz);        enhancer.setCallback(methodInterceptor);        return (T) enhancer.create();    }}</code></pre><p>接着我们就可以创建一个没有接口的类，我这里就创建一个数学工具类进行测试</p><pre><code class="java">public class MathUtil {    /**     * 获取一个数的平方     * */    public String getSquare(int num) {        return String.valueOf(num * num);    }}</code></pre><p>然后在controller层定义一个接口来测试</p><pre><code class="java">@RequestMapping(&quot;/getSquare&quot;)    public String getSquare(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception {        MathUtil mathUtil = InterceptorFactory.getInterceptor(MathUtil.class, new LogRecordInterceptor(new MathUtil()));        return mathUtil.getSquare(num);    }</code></pre><p>用浏览器或者<code>POSTMAN</code>工具调用接口，就可以在控制台看到以下输出：</p><pre><code class="java">/*记录日志：执行getSquare方法前,参数：[2]4记录日志：执行getSquare方法后,参数：[2]*/</code></pre><p>这样就实现没有定义接口也可以实现动态代理！</p><p>实际上，定义接口的也可以用这种方法来进行扩展，比如上面的<code>userService</code>接口</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        UserServiceImpl userServiceProxy = InterceptorFactory            .getInterceptor(UserServiceImpl.class,                            new LogRecordInterceptor(userService));        return userServiceProxy.getAllUser();    }}</code></pre><p>调用接口我们在控制台也是可以看到以下输出日志：</p><pre><code class="java">/*记录日志：执行getAllUser方法前,参数：[][User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser方法后,参数：[]*/</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>以上就是代理模式的一些通俗的解释，还有三种实现的方式的学习</strong></p><p>多说几句，我们都知道<code>Spring</code>框架有两个核心技术，一个叫控制反转<code>IOC</code>，另一个叫切面编程<code>AOP</code>。切面编程大家都很熟悉，用的就是代理模式，那么<code>AOP</code>实现的代理模式用的是<code>JDK动态代理</code>还是<code>CLB动态代理</code>？</p><p>答曰：<strong>两个都用！</strong></p><p>最简单的，我们看<code>Spring</code>的事务管理，就是用代理模式实现的，如果有兴趣，其实我们自己也可以通过<code>JDK动态代理</code>手写实现事务管理，其实不是很难。篇幅有限，以后可以单独写一篇文章详细说明<code>Spring</code>的事务管理，敬请期待。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板模式以及实战应用</title>
    <link href="/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>上一篇讲了策略模式，知道了可以使用策略模式对多重if-else进行优化，而且符合开闭原则。那么除了策略模式，还有什么设计模式比较好用而且常用的呢。这就是今天要讲的模板模式。</p><a id="more"></a><p>模板模式解决什么问题呢？</p><h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><p>首先我们使用SpringBoot来搭建一个工程。</p><pre><code class="xml">    &lt;!-- maven配置 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;commons-lang&lt;/groupId&gt;        &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;        &lt;version&gt;2.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><p>application.yml配置如下：</p><pre><code class="yaml">server:  port: 8888spring:  datasource:    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8    username: 账号    password: 密码    driver-class-name: com.mysql.jdbc.Driver</code></pre><p>创建一个全局配置类<code>GlobalProperties</code>，我们通过这个类可以获取yml的配置信息</p><pre><code class="java">@Component(&quot;globalProperties&quot;)public class GlobalProperties {    @Value(&quot;${spring.datasource.driver-class-name}&quot;)    private String driverClass;    @Value(&quot;${spring.datasource.url}&quot;)    private String url;    @Value(&quot;${spring.datasource.username}&quot;)    private String username;    @Value(&quot;${spring.datasource.password}&quot;)    private String password;    //字段对应的getter、setter方法...</code></pre><p>创建一个连接工厂类<code>ConnectFactory</code>，获取数据库连接</p><pre><code class="java">public class ConnectFactory {    public static Connection getConnection() throws Exception{        //获取yml文件的配置，SpringContextUtil工具类在上一篇文章有介绍，可以参考上一篇文章的代码        GlobalProperties properties = SpringContextUtil                .getBean(&quot;globalProperties&quot;, GlobalProperties.class);        //加载数据驱动        Class.forName(properties.getDriverClass());        //获取数据库连接，返回数据库连接对象        return DriverManager.getConnection(properties.getUrl(),                properties.getUsername(), properties.getPassword());    }}</code></pre><p>创建实体类<code>User</code></p><pre><code class="java">public class User {    private Integer id;    private String name;    private Integer age;    private String job;    //字段对应的getter、setter方法...</code></pre><p>接着在mysql对应的数据库创建数据表<code>tb_user</code>，sql语句如下：</p><pre><code class="sql">CREATE TABLE `tb_user` (  `id` bigint(10) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,  `name` varchar(255) NOT NULL COMMENT &#39;名称&#39;,  `age` tinyint(4) NOT NULL COMMENT &#39;年龄&#39;,  `job` varchar(255) DEFAULT NULL COMMENT &#39;工作&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4</code></pre><p>插入一些测试数据</p><pre><code class="sql">INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大司马&#39;,36,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;朴老师&#39;,36,&#39;主播&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;王刚&#39;,30,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大sao&#39;,32,&#39;美食up主&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;姚大秋&#39;,35,&#39;主持人&#39;);</code></pre><p>假设我们有一张user表，我们通过原生的JDBC来进行数据库操作，那么需要在dao层完成以下几步。</p><p>1.装载相应的数据库的JDBC驱动并进行初始化</p><p>2.建立JDBC和数据库之间的Connection连接</p><p>3.创建Statement或者PreparedStatement接口，执行SQL语句</p><p>4.处理和显示结果</p><p>5.释放资源</p><p>例子如下：</p><pre><code class="java">    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        User user = new User();        //获取数据连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement             .executeQuery(String.format(GET_USER_BY_NAME_SQL, name))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        User user = new User();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet =             statement.executeQuery(String.format(GET_USER_BY_ID_SQL, id))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }</code></pre><p>PS:这里为了简单一点就直接把参数拼接sql语句，不采用预编译来处理sql的参数。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过上面的代码，我们很明显可以看到是有很大的问题的。</p><p>1.每次在进行数据库操作都需要获取<code>Connection</code>对象，创建<code>Statement</code>对象。</p><p>2.每次获取结果后，都要进行结果处理，而且如果是同一张表的查询，会很重复。每次都需要把结果值set回到对象的字段中。</p><p>模板模式就可以解决这个问题！</p><h2 id="使用模板模式重构代码"><a href="#使用模板模式重构代码" class="headerlink" title="使用模板模式重构代码"></a>使用模板模式重构代码</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>创建一个模板类<code>DaoTemplate</code>，如下：</p><pre><code class="java">/** * @author Ye Hongzhi * @program DaoTemplate * @description * @date 2020-04-12 17:04 **/@Componentpublic class DaoTemplate {    public &lt;T&gt; T query(String sql, Class&lt;T&gt; clazz) throws Exception {        //通过clazz创建返回值对象        T t = clazz.newInstance();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement.executeQuery(sql)        ) {            while (resultSet.next()) {                //获取所有字段                Field[] fields = clazz.getDeclaredFields();                //获取所有方法                Method[] methods = clazz.getDeclaredMethods();                Map&lt;String, Method&gt; methodNameMap = Arrays.stream(methods)                        .collect(Collectors.toMap(Method::getName, Function.identity()));                //把数据库对应的列的值赋值给 泛型T对象的 对应的字段                for (Field field : fields) {                    //获取字段名                    String fieldName = field.getName();                    //获取set方法                    Method method = methodNameMap.get(&quot;set&quot; + change(fieldName));                    //获取数据库的列的值                    Object fieldValue = null;                    if (field.getType() == String.class) {                        fieldValue = resultSet.getString(fieldName);                    }                    if (field.getType() == Integer.class) {                        fieldValue = resultSet.getInt(fieldName);                    }                    if (field.getType() == Boolean.class) {                        fieldValue = resultSet.getBoolean(fieldName);                    }                    if (field.getType() == Long.class) {                        fieldValue = resultSet.getLong(fieldName);                    }                    if(field.getType() == Double.class){                        fieldValue = resultSet.getDouble(fieldName);                    }                    if(field.getType() == BigDecimal.class){                        fieldValue = resultSet.getBigDecimal(fieldName);                    }                    if (field.getType() == Date.class) {                        fieldValue = resultSet.getDate(fieldName);                    }                    //设置更多的字段类型...                    //利用反射执行对象的set方法，把数据库的值设置到对象的字段中                    method.invoke(t, fieldValue);                }            }        } catch (Exception e) {            e.printStackTrace();        }        return t;    }    /**     * 将一个字符串首字母大写，其它字母小写     *     * @param str 字符串     * @return     */    private static String change(String str) {        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();    }}</code></pre><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>创建模板后，可以在<code>DAO</code>层引入模板，然后使用。如下：</p><pre><code class="java">    //引入模板        @Resource    private DaoTemplate daoTemplate;    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_ID_SQL, id), User.class);    }    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_NAME_SQL, name), User.class);    }</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><h1 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h1><p>实际上在Spring框架就有提供<code>JDBC</code>模板</p><p>我们可以在<code>MAVEN</code>中引入以下配置：</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>创建一个映射类<code>UserRowMapper</code></p><pre><code class="java">public class UserRowMapper implements RowMapper&lt;User&gt; {    @Override    public User mapRow(ResultSet resultSet, int i) throws SQLException {        User user = new User();        user.setId(resultSet.getInt(&quot;id&quot;));        user.setName(resultSet.getString(&quot;name&quot;));        user.setAge(resultSet.getInt(&quot;age&quot;));        user.setJob(resultSet.getString(&quot;job&quot;));        return user;    }}</code></pre><p>然后在<code>DAO</code>层的<code>UserDaoImpl</code>，我们就可以引入<code>JdbcTemplate</code></p><pre><code class="java">    @Resource    private JdbcTemplate jdbcTemplate;    //使用jdbcTemplate查询    @Override    public User getUserByName(String name) throws Exception {        return jdbcTemplate.queryForObject(String.format(GET_USER_BY_NAME_SQL, name), new UserRowMapper());    }</code></pre><p>从这里可以看出实际上<code>Spring</code>框架就是采用这种思想来实现<code>JdbcTemplate</code>模板。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>所以在实际项目的开发中，我们有时候遇到某些代码块的前后都有重复操作时，可以采用模板模式去重构代码，使代码更加简洁，容易维护。</p><p>更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你用策略模式解决多重if-else</title>
    <link href="/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/"/>
    <url>/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>很多人可能在公司就是做普通的CRUD的业务，对于设计模式，即使学了好像也用处不大，顶多就在面试的时候能说上几种常见的单例模式，工厂模式。而在实际开发中，设计模式似乎很难用起来。</p><p>在现在的环境下，程序员的竞争已经非常激烈了，要体现出自身的价值，最直接的体现当然是差异化。这无需多说，我认为在实际开发中能运用设计模式，是很能体现差异化的。设计模式是一些前人总结的较好的方法，使程序能有更好的扩展性，可读性，维护性。</p><p>下面举个例子，使用策略模式解决多重if-else的代码结构。想学习更多的设计模式的实战经验，那就点个关注吧，谢谢大佬。</p><h1 id="使用if-else"><a href="#使用if-else" class="headerlink" title="使用if-else"></a>使用if-else</h1><p>假设我们要开发一个支付接口，要对接多种支付方式，通过渠道码区分各种的支付方式。于是定义一个枚举<code>PayEnum</code>，如下：</p><pre><code class="java">public enum PayEnum {    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;);    /**渠道*/    private String channel;    /**描述*/    private String description;    PayEnum(String channel, String description) {        this.channel = channel;        this.description = description;    }    /**以下省略字段的get、set方法*/</code></pre><p>创建一个<code>PayController</code>类，代码如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class PayController {    @Resource(name = &quot;payService&quot;)    private PayService payService;    /**    * 支付接口    * @param channel 渠道    * @param amount  消费金额    * @return String 返回消费结果    * @author Ye hongzhi    * @date 2020/4/5    */    @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        return payService.pay(channel,amount);    }}</code></pre><p>再创建一个<code>PayService</code>接口以及实现类<code>PayServiceImpl</code></p><pre><code class="java">public interface PayService {    /**    * 支付接口    * @param channel 渠道    * @param amount  金额    * @return String    * @author Ye hongzhi    * @date 2020/4/5    */    String pay(String channel,String amount)throws Exception;}</code></pre><pre><code class="java">@Service(&quot;payService&quot;)public class PayServiceImpl implements PayService {    private static String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    @Override    public String pay(String channel, String amount) throws Exception {        if (PayEnum.ALI_PAY.getChannel().equals(channel)) {            //支付宝            //业务代码...            return String.format(MSG,PayEnum.ALI_PAY.getDescription(),amount);        }else if(PayEnum.WECHAT_PAY.getChannel().equals(channel)){            //微信支付            //业务代码...            return String.format(MSG,PayEnum.WECHAT_PAY.getDescription(),amount);        }else if(PayEnum.UNION_PAY.getChannel().equals(channel)){            //银联支付            //业务代码...            return         String.format(MSG,PayEnum.UNION_PAY.getDescription(),amount);        }else if(PayEnum.XIAO_MI_PAY.getChannel().equals(channel)){            //小米支付            //业务代码...            return String.format(MSG,PayEnum.XIAO_MI_PAY.getDescription(),amount);        }else{            return &quot;输入渠道码有误&quot;;        }    }}</code></pre><p>然后通过浏览器，我们可以看到效果</p><p><img src="https://static.lovebilibili.com/01.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/02.png" srcset="/img/loading.gif" alt=""></p><p>这样看，以上代码的确可以实现需求，通过渠道码区分支付方式，可是看到上面那么多达4个的<code>if-else</code>的代码结构，已经开始显示出问题了。假设有更多的支付方式，那么这段代码就要写更多的<code>else if</code>去判断，这显然会不利于代码的扩展，这样会导致这个支付的方法越写越长。</p><p>在设计模式六大原则中，其中一个原则叫做<code>开闭原则</code>，对扩展开放，对修改关闭，应尽量在不修改原有代码的情况下进行扩展。</p><p>基于上面提到的<code>开闭原则</code>，我们可以使用策略模式进行重构。</p><h1 id="使用策略模式重构代码"><a href="#使用策略模式重构代码" class="headerlink" title="使用策略模式重构代码"></a>使用策略模式重构代码</h1><p>定义一个策略接口类<code>PayStrategy</code></p><pre><code class="java">public interface PayStrategy {    String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    String pay(String channel,String amount)throws Exception;}</code></pre><p>然后再创建四种策略实现类实现接口</p><pre><code class="java">@Component(&quot;aliPayStrategy&quot;)public class AliPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.ALI_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;wechatPayStrategy&quot;)public class WechatPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.WECHAT_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;unionPayStrategy&quot;)public class UnionPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.UNION_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;xiaomiPayStrategy&quot;)public class XiaomiPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.XIAO_MI_PAY.getDescription(),amount);    }}</code></pre><p>看到这里实际上已经很清晰了，思路就是通过渠道码，动态获取到具体的实现类，这样就可以实现不需要<code>if else</code>判断。怎么通过渠道码获取实现类呢？</p><p>在<code>PayEnum</code>枚举加上<code>BeanName</code>字段，然后增加一个通过渠道码获取<code>BeanName</code>的方法</p><pre><code class="java">    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;,&quot;aliPayStrategy&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;,&quot;wechatPayStrategy&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;,&quot;unionPayStrategy&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;,&quot;xiaomiPayStrategy&quot;);    /**策略实现类对应的 beanName*/    private String beanName;    /**     * 通过渠道码获取枚举     * */    public static PayEnum findPayEnumBychannel(String channel){        PayEnum[] enums = PayEnum.values();        for (PayEnum payEnum : enums){            if(payEnum.getChannel().equals(channel)){                return payEnum;            }        }        return null;    }    //构造器    PayEnum(String channel, String description, String beanName) {        this.channel = channel;        this.description = description;        this.beanName = beanName;    }</code></pre><p>这时候还差一个获取Spring上下文对象的工具类，于是我们创建一个<code>SpringContextUtil</code>类</p><pre><code class="java">@Componentpublic class SpringContextUtil implements ApplicationContextAware {    /**     * 上下文对象实例     */    private static ApplicationContext applicationContext;    /**     * 获取applicationContext     */    private static ApplicationContext getApplicationContext() {        return applicationContext;    }    /**     * 通过name获取Bean     * */    public static Object getBean(String name){        return getApplicationContext().getBean(name);    }    /**     * 通过name,以及Clazz返回指定的Bean     * */    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz){        return getApplicationContext().getBean(name,clazz);    }    @Override    @Autowired    public void setApplicationContext(ApplicationContext applicationContext) throws         BeansException {        SpringContextUtil.applicationContext = applicationContext;    }</code></pre><p>接着定义一个工厂类，通过渠道码获取对应的策略实现类</p><pre><code class="java">public class PayStrategyFactory {    /**     * 通过渠道码获取支付策略具体实现类     * */    public static PayStrategy getPayStrategy(String channel){        PayEnum payEnum = PayEnum.findPayEnumBychannel(channel);        if(payEnum == null){            return null;        }        return SpringContextUtil.getBean(payEnum.getBeanName(),PayStrategy.class);    }}</code></pre><p>最后我们再改造一下原来的<code>PayServiceImpl</code>的<code>pay</code>方法</p><pre><code class="java">@Overridepublic String pay(String channel, String amount) throws Exception {    PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);    if(payStrategy == null){        return &quot;输入渠道码有误&quot;;    }    return payStrategy.pay(channel,amount);}</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><blockquote><p>假设需要增加新的支付方式，就不需要再使用else if 去判断，而是在枚举中定义一个新的枚举对象，然后再增加一个策略实现类，实现对应的方法，那就可以很轻松地扩展。也实现了开闭原则。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>设计模式运用得熟练的话，很多代码可以写得很优雅。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot系列之自定义spring-boot-starter</title>
    <link href="/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/"/>
    <url>/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>传统的 Maven项目一般将需要被复用的组件做成 Module来进行管理，以便二次调用；而在 Spring Boot项目中我们则可以使用更加优雅的 Spring Boot Starter来完成这一切。</p><a id="more"></a><p>这个开箱即用的魔法特性很大程度上来源于各式各样 Spring Boot Starter的加持，而且随着版本的迭代 Starter家族成员日益庞大，而且各种优秀开源作者也提供了很多非常好用的Spring Boot Starter。</p><p>本文尝试自定义一个Spring Boot Starter用于图片链接转换BASE64编码。</p><h1 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h1><ol><li>在GItHub上创建base64util-spring-boot-starter项目，然后clone下来本地进行开发。</li></ol><p><img src="https://static.lovebilibili.com/Github_Create.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>pom.xml文件配置如下</li></ol><pre><code class="xml">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;&lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;0.0.1&lt;/version&gt;&lt;dependencies&gt;    &lt;!-- 引入SpringBoot自动配置jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ol start="3"><li>业务代码</li></ol><pre><code class="java">import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL;/** * @author Ye Hongzhi * @program Base64Util * @description * @date 2020-02-17 14:04 **/public class Base64Util {    /**     * 本地图片转为BASE64编码     *     * @param imgFile 本地图片地址     * @return BASE64 解码后的字符串编码     * @description: 根据图片地址转换为base64编码字符串     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static String getImageFile(String imgFile) {        byte[] data = null;        try (InputStream inputStream = new FileInputStream(imgFile)) {            data = new byte[inputStream.available()];            int length = inputStream.read(data);            if (length == -1) {                return null;            }        } catch (Exception e) {            e.printStackTrace();        }        // 加密        BASE64Encoder encoder = new BASE64Encoder();        if (data != null) {            return encoder.encode(data);        } else {            return null;        }    }    public static String image2Base64(String imgUrl) throws Exception {        URL url = new URL(imgUrl);        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();        try(InputStream inputStream = urlConnection.getInputStream();            ByteArrayOutputStream baos = new ByteArrayOutputStream()) {            urlConnection.connect();            byte[] buffer = new byte[1024];            int len;            //使用一个输入流从buffer里把数据读取出来            while ((len = inputStream.read(buffer)) != -1) {                //用输出流往buffer里写入数据，中间参数代表从哪个位置开始读，len代表读取的长度                baos.write(buffer, 0, len);            }            // 对字节数组Base64编码            return Base64.encode(baos.toByteArray());        } catch (Exception e) {            e.printStackTrace();        } finally {            if (urlConnection != null) {                urlConnection.disconnect();            }        }        return imgUrl;    }    /**     * BASE64编码转为图片     * 注意：&quot;data:image/jpeg;base64,&quot; 解码之前得去掉。     *     * @param imgStr base64编码字符串     * @param path   图片路径-具体到文件     * @return 是否转换成功     * @description: 将base64编码字符串转换为图片     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static boolean generateImage(String imgStr, String path) {        if (imgStr == null) {            return false;        }        try (OutputStream out = new FileOutputStream(path)) {            BASE64Decoder decoder = new BASE64Decoder();            // 解密            byte[] b = decoder.decodeBuffer(imgStr);            // 处理数据            for (int i = 0; i &lt; b.length; ++i) {                if (b[i] &lt; 0) {                    b[i] += 256;                }            }            out.write(b);            out.flush();            return true;        } catch (Exception e) {            e.printStackTrace();            return false;        }    }}</code></pre><ol start="4"><li>创建一个service调用，这里为了简单，就不定义为接口的形式</li></ol><pre><code class="java">public class Base64Service {    /**     * 本地图片转为BASE64编码     */    public String getImageFile(String imgFile) {        return Base64Util.getImageFile(imgFile);    }    /**     * BASE64编码转为图片     * */    public boolean generateImage(String imgStr, String path) {        return Base64Util.generateImage(imgStr,path);    }    /**     * 在线图片转为BASE64编码     * */    public String image2Base64(String imgUrl) throws Exception{        return Base64Util.image2Base64(imgUrl);    }}</code></pre><ol start="5"><li>关键的一步，使用配置类，把service定义成bean，加入到spring容器中管理</li></ol><pre><code class="java">@Configurationpublic class Base64AutoConfiguration {    @Bean    Base64Service base64Service(){        return new Base64Service();    }}</code></pre><ol start="6"><li>最关键一步在于需要在resources文件夹下创建<code>META-INF/spring.factories</code>，<code>spring.factories</code>里的代码如下:</li></ol><pre><code class="yaml">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.lovebilibili.me.config.Base64AutoConfiguration</code></pre><p>这一步是重点，因为Spring Boot应用在启动过程中会通过 <code>SpringFactoriesLoader</code> 加载所有 <code>META-INF/spring.factories</code> 文件，通过一系列的处理流程最终将 spring.factories 文件中的定义的各种 <code>beans</code> 装载入 ApplicationContext容器。</p><blockquote><p>至此，自定义的用于base64转码工具的spring-boot-starter就完成了</p><p>可以通过使用maven命令<code>mvn install</code>打包，传到私有/公有Maven仓库使用。</p><p>形成一个公共的模块，供有需要的项目使用。</p></blockquote><ol start="7"><li>完成后把代码推送到Github仓库中，方便以后继续优化。</li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li>在其他项目中的pom文件加入以下依赖：</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;    &lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.0.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在Controller层中，我们可以引入base64Service。</li></ol><pre><code class="java">@Resourceprivate Base64Service base64Service;</code></pre><ol start="3"><li>然后在Controller层中的@RequestMapping对应的方法中使用</li></ol><pre><code class="java">//把在线图片转为BASE64编码String base64 = base64Service.image2Base64(imgUrl);</code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要创建个人博客</title>
    <link href="/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>很高兴你能点进来看我的第一篇文章。</p><p>内容也和标题一样无聊，为什么要创建个人博客，既然我已经创建了还要找什么理由呢。但是你点进来很大原因是因为你还没有个人博客，所以想来听听我创建个人博客的理由，以此来驱动自己去创建个人博客。这非常好，证明你已经有冲动了，只差行动起来。</p><p>我的理由有以下几点：</p><ol><li>想要记录下一些自己的技术学习的过程。比记录在有道云笔记自己看更加有价值，因为博客是可以分享，可以传播，知识需要传播起来才有力量。这是最大的一个原因。</li><li>通过输出博客文章提升自己的技术水平。因为输出就是最好的学习，输出一篇好的技术文章，往往就是最好的学习方式。</li><li>通过这个博客和网友互相学习。毕竟外面的世界很大，可以通过博客这个窗口和网上的开发者互相学习讨论，不失为一种乐趣。</li><li>记录一些生活感想、读书笔记、美食经历等等。</li></ol><p>这就是我的理由。如果你想要创建个人博客的话，马上去做吧。</p><p>教程的话可以参考</p><p>B站up主“CodeSheep”的视频<a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></p><p>我的hexo主题使用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">fluid</a>,如果你觉得不错也可以使用哦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
