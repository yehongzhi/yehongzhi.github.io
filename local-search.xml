<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RabbitMQ如何防止消息丢失</title>
    <link href="/2020/08/08/RabbitMQ%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"/>
    <url>/2020/08/08/RabbitMQ%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://img-blog.csdnimg.cn/20200802232920896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="一、分析数据丢失的原因"><a href="#一、分析数据丢失的原因" class="headerlink" title="一、分析数据丢失的原因"></a>一、分析数据丢失的原因</h1><p>分析RabbitMQ消息丢失的情况，不妨先看看一条消息从生产者发送到消费者消费的过程：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1Yzc2OTVkMDE5MjE?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>可以看出，一条消息整个过程要经历两次的网络传输：<strong>从生产者发送到RabbitMQ服务器，从RabbitMQ服务器发送到消费者</strong>。</p><a id="more"></a><p><strong>在消费者未消费前存储在队列(Queue)中</strong>。</p><p>所以可以知道，有三个场景下是会发生消息丢失的：</p><ul><li>存储在队列中，如果队列没有对消息持久化，RabbitMQ服务器宕机重启会丢失数据。</li><li>生产者发送消息到RabbitMQ服务器过程中，RabbitMQ服务器如果宕机停止服务，消息会丢失。</li><li>消费者从RabbitMQ服务器获取队列中存储的数据消费，但是消费者程序出错或者宕机而没有正确消费，导致数据丢失。</li></ul><p>针对以上三种场景，RabbitMQ提供了三种解决的方式，分别是消息持久化，confirm机制，ACK事务机制。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1ZDVhNjQ1YzNkNDc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><h1 id="二、消息持久化"><a href="#二、消息持久化" class="headerlink" title="二、消息持久化"></a>二、消息持久化</h1><p>RabbitMQ是支持消息持久化的，消息持久化需要设置：Exchange为持久化和Queue持久化，这样当消息发送到RabbitMQ服务器时，消息就会持久化。</p><p>首先看Exchange交换机的类图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1ZjY3MTUyNmVkMmQ?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>看这个类图其实是要说明上一篇文章介绍的四种交换机都是AbstractExchange抽象类的子类，所以根据java的特性，<strong>创建子类的实例会先调用父类的构造器</strong>，父类也就是AbstractExchange的构造器是怎么样的呢？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1ZjhjMGQ1YzhlNTE?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>从上面的注释可以看到<strong>durable参数表示是否持久化。默认是持久化(true)</strong>。创建持久化的Exchange可以这样写：</p><pre><code class="java">    @Bean    public DirectExchange rabbitmqDemoDirectExchange() {        //Direct交换机        return new DirectExchange(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, true, false);    }</code></pre><p>接着是Queue队列，我们先看看Queue的构造器是怎么样的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC9lNTA3ZmU0OTExNWE0MTk5YTFhNjg2ZDIwNWM5OWRlY350cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>也是通过durable参数设置是否持久化，默认是true。所以创建时可以不指定：</p><pre><code class="java">    @Bean    public Queue fanoutExchangeQueueA() {        //只需要指定名称，默认是持久化的        return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A);    }</code></pre><p>这就完成了消息持久化的设置，接下来启动项目，发送几条消息，我们可以看到：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC8zNWFmZjJkNmE0YzU0YjFjYmQ4ODk1NTM2NTExOTAwYn50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""><br>怎么证明是已经持久化了呢，实际上可以找到对应的文件：<br><img src="https://img-blog.csdnimg.cn/20200801205656332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>找到对应磁盘中的目录：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC80NmU1NDIxNTYwM2U0MmIyODI4ODlhYTQxYTVhNjFiOH50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""><br><strong>消息持久化可以防止消息在RabbitMQ Server中不会因为宕机重启而丢失</strong>。</p><h1 id="三、消息确认机制"><a href="#三、消息确认机制" class="headerlink" title="三、消息确认机制"></a>三、消息确认机制</h1><h2 id="3-1-confirm机制"><a href="#3-1-confirm机制" class="headerlink" title="3.1 confirm机制"></a>3.1 confirm机制</h2><p><strong>在生产者发送到RabbitMQ Server时有可能因为网络问题导致投递失败，从而丢失数据</strong>。我们可以使用confirm模式防止数据丢失。工作流程是怎么样的呢，看以下图解：<br><img src="https://img-blog.csdnimg.cn/20200801210244345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>从上图中可以看到是通过两个回调函数<strong>confirm()、returnedMessage()</strong>进行通知。</p><p>一条消息从生产者发送到RabbitMQ，首先会发送到Exchange，对应回调函数<strong>confirm()</strong>。第二步从Exchange路由分配到Queue中，对应回调函数则是<strong>returnedMessage()</strong>。</p><p>代码怎么实现呢，请看演示：</p><p>首先在<strong>application.yml</strong>配置文件中加上如下配置：</p><pre><code class="yml">spring:  rabbitmq:    publisher-confirms: true#    publisher-returns: true    template:      mandatory: true# publisher-confirms：设置为true时。当消息投递到Exchange后，会回调confirm()方法进行通知生产者# publisher-returns：设置为true时。当消息匹配到Queue并且失败时，会通过回调returnedMessage()方法返回消息# spring.rabbitmq.template.mandatory: 设置为true时。指定消息在没有被队列接收时会通过回调returnedMessage()方法退回。</code></pre><p>有个小细节，<strong>publisher-returns和mandatory如果都设置的话，优先级是以mandatory优先</strong>。可以看源码：<br><img src="https://img-blog.csdnimg.cn/20200801212504531.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>接着我们需要定义回调方法：</p><pre><code class="java">@Componentpublic class RabbitmqConfirmCallback implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnCallback {    private Logger logger = LoggerFactory.getLogger(RabbitmqConfirmCallback.class);    /**     * 监听消息是否到达Exchange     *     * @param correlationData 包含消息的唯一标识的对象     * @param ack             true 标识 ack，false 标识 nack     * @param cause           nack 投递失败的原因     */    @Override    public void confirm(CorrelationData correlationData, boolean ack, String cause) {        if (ack) {            logger.info(&quot;消息投递成功~消息Id：{}&quot;, correlationData.getId());        } else {            logger.error(&quot;消息投递失败，Id：{}，错误提示：{}&quot;, correlationData.getId(), cause);        }    }    @Override    public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {        logger.info(&quot;消息没有路由到队列，获得返回的消息&quot;);        Map map = byteToObject(message.getBody(), Map.class);        logger.info(&quot;message body: {}&quot;, map == null ? &quot;&quot; : map.toString());        logger.info(&quot;replyCode: {}&quot;, replyCode);        logger.info(&quot;replyText: {}&quot;, replyText);        logger.info(&quot;exchange: {}&quot;, exchange);        logger.info(&quot;routingKey: {}&quot;, exchange);        logger.info(&quot;------------&gt; end &lt;------------&quot;);    }    @SuppressWarnings(&quot;unchecked&quot;)    private &lt;T&gt; T byteToObject(byte[] bytes, Class&lt;T&gt; clazz) {        T t;        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);             ObjectInputStream ois = new ObjectInputStream(bis)) {            t = (T) ois.readObject();        } catch (Exception e) {            e.printStackTrace();            return null;        }        return t;    }}</code></pre><p>我这里就简单地打印回调方法返回的消息，在实际项目中，可以把返回的消息存储到日志表中，使用定时任务进行进一步的处理。</p><p>我这里是使用<strong>RabbitTemplate</strong>进行发送，所以在Service层的RabbitTemplate需要设置一下：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    @Resource    private RabbitmqConfirmCallback rabbitmqConfirmCallback;    @Resource    private RabbitTemplate rabbitTemplate;    @PostConstruct    public void init() {        //指定 ConfirmCallback        rabbitTemplate.setConfirmCallback(rabbitmqConfirmCallback);        //指定 ReturnCallback        rabbitTemplate.setReturnCallback(rabbitmqConfirmCallback);    }    @Override    public String sendMsg(String msg) throws Exception {        Map&lt;String, Object&gt; message = getMessage(msg);        try {            CorrelationData correlationData = (CorrelationData) message.remove(&quot;correlationData&quot;);            rabbitTemplate.convertAndSend(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING, message, correlationData);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }    private Map&lt;String, Object&gt; getMessage(String msg) {        String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32);        CorrelationData correlationData = new CorrelationData(msgId);        String sendTime = sdf.format(new Date());        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msgId&quot;, msgId);        map.put(&quot;sendTime&quot;, sendTime);        map.put(&quot;msg&quot;, msg);        map.put(&quot;correlationData&quot;, correlationData);        return map;    }}</code></pre><p>大功告成！接下来我们进行测试，发送一条消息，我们可以控制台：<br><img src="https://img-blog.csdnimg.cn/20200801214001880.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>假设发送一条信息没有路由匹配到队列，可以看到如下信息：<br><img src="https://img-blog.csdnimg.cn/20200801214142468.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这就是confirm模式。它的作用是<strong>为了保障生产者投递消息到RabbitMQ不会出现消息丢失</strong>。</p><h2 id="3-2-事务机制-ACK"><a href="#3-2-事务机制-ACK" class="headerlink" title="3.2 事务机制(ACK)"></a>3.2 事务机制(ACK)</h2><p>最开始的那张图已经讲过，<strong>消费者从队列中获取到消息后，会直接确认签收，假设消费者宕机或者程序出现异常，数据没有正常消费，这种情况就会出现数据丢失</strong>。</p><p>所以关键在于把自动签收改成手动签收，正常消费则返回确认签收，如果出现异常，则返回拒绝签收重回队列。<br><img src="https://img-blog.csdnimg.cn/20200801215323179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码怎么实现呢，请看演示：</p><p>首先在消费者的<strong>application.yml</strong>文件中设置事务提交为<strong>manual</strong>手动模式：</p><pre><code class="yml">spring:  rabbitmq:    listener:      simple:        acknowledge-mode: manual # 手动ack模式        concurrency: 1 # 最少消费者数量        max-concurrency: 10 # 最大消费者数量</code></pre><p>然后编写消费者的监听器：</p><pre><code class="java">@Componentpublic class RabbitDemoConsumer {    enum Action {        //处理成功        SUCCESS,        //可以重试的错误，消息重回队列        RETRY,        //无需重试的错误，拒绝消息，并从队列中删除        REJECT    }    @RabbitHandler    @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC))    public void process(String msg, Message message, Channel channel) {        long tag = message.getMessageProperties().getDeliveryTag();        Action action = Action.SUCCESS;        try {            System.out.println(&quot;消费者RabbitDemoConsumer从RabbitMQ服务端消费消息：&quot; + msg);            if (&quot;bad&quot;.equals(msg)) {                throw new IllegalArgumentException(&quot;测试：抛出可重回队列的异常&quot;);            }            if (&quot;error&quot;.equals(msg)) {                throw new Exception(&quot;测试：抛出无需重回队列的异常&quot;);            }        } catch (IllegalArgumentException e1) {            e1.printStackTrace();            //根据异常的类型判断，设置action是可重试的，还是无需重试的            action = Action.RETRY;        } catch (Exception e2) {            //打印异常            e2.printStackTrace();            //根据异常的类型判断，设置action是可重试的，还是无需重试的            action = Action.REJECT;        } finally {            try {                if (action == Action.SUCCESS) {                    //multiple 表示是否批量处理。true表示批量ack处理小于tag的所有消息。false则处理当前消息                    channel.basicAck(tag, false);                } else if (action == Action.RETRY) {                    //Nack，拒绝策略，消息重回队列                    channel.basicNack(tag, false, true);                } else {                    //Nack，拒绝策略，并且从队列中删除                    channel.basicNack(tag, false, false);                }                channel.close();            } catch (Exception e) {                e.printStackTrace();            }        }    }}</code></pre><p>解释一下上面的代码，如果没有异常，则手动确认回复RabbitMQ服务端basicAck(消费成功)。</p><p>如果抛出某些可以重回队列的异常，我们就回复basicNack并且设置重回队列。</p><p>如果是抛出不可重回队列的异常，就回复basicNack并且设置从RabbitMQ的队列中删除。</p><p>接下来进行测试，发送一条普通的消息”hello”：<br><img src="https://img-blog.csdnimg.cn/20200802215129880.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>解释一下ack返回的三个方法的意思。</p><p>①成功确认</p><pre><code class="java">void basicAck(long deliveryTag, boolean multiple) throws IOException;</code></pre><p>消费者成功处理后调用此方法对消息进行确认。</p><ul><li>deliveryTag：该消息的index</li><li>multiple：是否批量.。true：将一次性ack所有小于deliveryTag的消息。</li></ul><p>②失败确认</p><pre><code class="java">void basicNack(long deliveryTag, boolean multiple, boolean requeue) throws IOException;</code></pre><ul><li>deliveryTag：该消息的index。</li><li>multiple：是否批量。true：将一次性拒绝所有小于deliveryTag的消息。</li><li>requeue：被拒绝的是否重新入队列。</li></ul><p>③失败确认</p><pre><code class="java">void basicReject(long deliveryTag, boolean requeue) throws IOException;</code></pre><ul><li>deliveryTag:该消息的index。</li><li>requeue：被拒绝的是否重新入队列。</li></ul><p>basicNack()和basicReject()的区别在于：<strong>basicNack()可以批量拒绝，basicReject()一次只能拒接一条消息</strong>。</p><h1 id="四、遇到的坑"><a href="#四、遇到的坑" class="headerlink" title="四、遇到的坑"></a>四、遇到的坑</h1><h2 id="4-1-启用nack机制后，导致的死循环"><a href="#4-1-启用nack机制后，导致的死循环" class="headerlink" title="4.1 启用nack机制后，导致的死循环"></a>4.1 启用nack机制后，导致的死循环</h2><p>上面的代码我故意写了一个bug。测试发送一条”bad”，然后会抛出重回队列的异常。这就有个问题：重回队列后消费者又消费，消费抛出异常又重回队列，就造成了死循环。<br><img src="https://img-blog.csdnimg.cn/20200802215521688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>那怎么避免这种情况呢？</p><p>既然nack会造成死循环的话，我提供的一个思路是<strong>不使用basicNack()，把抛出异常的消息落库到一张表中，记录抛出的异常，消息体，消息Id。通过定时任务去处理</strong>。</p><p>如果你有什么好的解决方案，也可以留言讨论~</p><h2 id="4-2-double-ack"><a href="#4-2-double-ack" class="headerlink" title="4.2 double ack"></a>4.2 double ack</h2><p>有的时候比较粗心，不小心开启了自动Ack模式，又手动回复了Ack。那就会报这个错误：</p><pre><code class="java">消费者RabbitDemoConsumer从RabbitMQ服务端消费消息：java技术爱好者2020-08-02 22:52:42.148 ERROR 4880 --- [ 127.0.0.1:5672] o.s.a.r.c.CachingConnectionFactory       : Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - unknown delivery tag 1, class-id=60, method-id=80)2020-08-02 22:52:43.102  INFO 4880 --- [cTaskExecutor-1] o.s.a.r.l.SimpleMessageListenerContainer : Restarting Consumer@f4a3a8d: tags=[{amq.ctag-8MJeQ7el_PNbVJxGOOw7Rw=rabbitmq.demo.topic}], channel=Cached Rabbit Channel: AMQChannel(amqp://guest@127.0.0.1:5672/,5), conn: Proxy@782a1679 Shared Rabbit Connection: SimpleConnection@67c5b175 [delegate=amqp://guest@127.0.0.1:5672/, localPort= 56938], acknowledgeMode=AUTO local queue size=0</code></pre><p>出现这个错误，可以检查一下yml文件是否添加了以下配置：</p><pre><code class="yml">spring:  rabbitmq:    listener:      simple:        acknowledge-mode: manual        concurrency: 1        max-concurrency: 10</code></pre><p>如果上面这个配置已经添加了，还是报错，<strong>有可能你使用@Configuration配置了SimpleRabbitListenerContainerFactory，根据SpringBoot的特性，代码优于配置，代码的配置覆盖了yml的配置，并且忘记设置手动manual模式</strong>：</p><pre><code class="java">@Bean    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) {        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();        factory.setConnectionFactory(connectionFactory);        //设置手动ack模式        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);        return factory;    }</code></pre><p>如果你还是有报错，那可能是写错地方了，写在生产者的项目了。以上的配置应该配置在消费者的项目。因为ack模式是针对消费者而言的。我就是写错了，写在生产者，折腾了几个小时，泪目~</p><h2 id="4-3-性能问题"><a href="#4-3-性能问题" class="headerlink" title="4.3 性能问题"></a>4.3 性能问题</h2><p>其实手动ACK相对于自动ACK肯定是会慢很多，我在网上查了一些资料，性能相差大概有10倍。所以一般在实际应用中不太建议开手动ACK模式。不过也不是绝对不可以开，具体情况具体分析，看并发量，还有数据的重要性等等。</p><p>所以<strong>在实际项目中还需要权衡一下并发量和数据的重要性，再决定具体的方案</strong>。</p><h2 id="4-4-启用手动ack模式，如果没有及时回复，会造成队列异常"><a href="#4-4-启用手动ack模式，如果没有及时回复，会造成队列异常" class="headerlink" title="4.4 启用手动ack模式，如果没有及时回复，会造成队列异常"></a>4.4 启用手动ack模式，如果没有及时回复，会造成队列异常</h2><p>如果开启了手动ACK模式，但是由于代码有bug的原因，没有回复RabbitMQ服务端，那么这条消息就会放到Unacked状态的消息堆里，只有等到消费者的连接断开才会转到Ready消息。如果消费者一直没有断开连接，那Unacked的消息就会越来越多，占用内存就越来越大，最后就会出现异常。</p><p>这个问题，我没法用我的电脑演示，我的电脑太卡了。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>通过上面的学习后，总结了RabbitMQ防止数据丢失有三种方式：</p><ul><li>消息持久化</li><li>生产者消息确认机制(confirm模式)</li><li>消费者消息确认模式(ack模式)</li></ul><p>上面所有例子的代码都上传github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>如果你觉得这篇文章对你有用，点个赞吧</strong>~</p><p><strong>你的点赞是我创作的最大动力</strong>~</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzMwLzE3MzA1Y2MwOGE3ZWQ1ZDc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ入门</title>
    <link href="/2020/08/08/RabbitMQ%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/08/RabbitMQ%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/26/17389a94030dbf28?w=729&h=515&f=png&s=44034" srcset="/img/loading.gif" alt=""></p><h1 id="一、什么是消息队列"><a href="#一、什么是消息队列" class="headerlink" title="一、什么是消息队列"></a>一、什么是消息队列</h1><p><strong>消息</strong>指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。</p><p><strong>“消息队列(Message Queue)”是在消息的传输过程中保存消息的容器</strong>。在消息队列中，通常有生产者和消费者两个角色。生产者只负责发送数据到消息队列，谁从消息队列中取出数据处理，他不管。消费者只负责从消息队列中取出数据处理，他不管这是谁发送的数据。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/1736753c4753c6f9?w=436&h=93&f=png&s=8826" srcset="/img/loading.gif" alt=""></p><h1 id="二、为什么使用消息队列"><a href="#二、为什么使用消息队列" class="headerlink" title="二、为什么使用消息队列"></a>二、为什么使用消息队列</h1><p>主要有三个作用：</p><ul><li><strong>解耦</strong>。如图所示。假设有系统B、C、D都需要系统A的数据，于是系统A调用三个方法发送数据到B、C、D。这时，系统D不需要了，那就需要在系统A把相关的代码删掉。假设这时有个新的系统E需要数据，这时系统A又要增加调用系统E的代码。为了降低这种强耦合，就可以使用MQ，<strong>系统A只需要把数据发送到MQ，其他系统如果需要数据，则从MQ中获取即可</strong>。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/173678c7a81cc1c0?w=589&h=254&f=png&s=20463" srcset="/img/loading.gif" alt=""></p><ul><li>异步。如图所示。一个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是800ms。<strong>如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能</strong>。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用MQ。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/17367945a8c4df73?w=570&h=264&f=png&s=13623" srcset="/img/loading.gif" alt=""></p><ul><li>削峰。如图所示。这其实是MQ一个很重要的应用。假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。<strong>如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃</strong>。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/17367a9d902cca4f?w=759&h=335&f=png&s=34834" srcset="/img/loading.gif" alt=""></p><h1 id="三、RabbitMQ的特点"><a href="#三、RabbitMQ的特点" class="headerlink" title="三、RabbitMQ的特点"></a>三、RabbitMQ的特点</h1><p>RabbitMQ是一款使用Erlang语言开发的，实现AMQP(高级消息队列协议)的开源消息中间件。首先要知道一些RabbitMQ的特点，<a href="https://www.rabbitmq.com" target="_blank" rel="noopener">官网</a>可查：</p><ul><li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li><li>灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li><li>支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li><li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li><li>可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li><li>插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li></ul><h1 id="四、RabbitMQ初の体验"><a href="#四、RabbitMQ初の体验" class="headerlink" title="四、RabbitMQ初の体验"></a>四、RabbitMQ初の体验</h1><h2 id="4-1-安装RabbitMQ-Win10系统"><a href="#4-1-安装RabbitMQ-Win10系统" class="headerlink" title="4.1 安装RabbitMQ (Win10系统)"></a>4.1 安装RabbitMQ (Win10系统)</h2><p>由于只是学习需要，所以安装在win10系统，就懒得开虚拟机。如果用Linux系统安装的话，我建议用Docker拉一个RabbitMQ的镜像下来，这样会方便一点。</p><h3 id="4-1-1-安装erLang语言，配置环境变量"><a href="#4-1-1-安装erLang语言，配置环境变量" class="headerlink" title="4.1.1 安装erLang语言，配置环境变量"></a>4.1.1 安装erLang语言，配置环境变量</h3><p>首先到erlang<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">官网</a>下载win10版安装包。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b11e8ce24fc?w=610&h=383&f=png&s=42809" srcset="/img/loading.gif" alt=""></p><p>下载完之后，就得到这个东西：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b35ca09e258?w=120&h=152&f=png&s=3625" srcset="/img/loading.gif" alt=""></p><p>接着双击安装，一直点next(下一步)就行了，安装完之后，配置环境变量。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b5796ccda18?w=648&h=176&f=png&s=12500" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b63e3dd7f73?w=591&h=312&f=png&s=28042" srcset="/img/loading.gif" alt=""></p><p>使用cmd命令，输入 erl -version 验证：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371bac494381d6?w=475&h=50&f=png&s=2778" srcset="/img/loading.gif" alt=""></p><h3 id="4-1-2-安装RabbitMQ服务端"><a href="#4-1-2-安装RabbitMQ服务端" class="headerlink" title="4.1.2 安装RabbitMQ服务端"></a>4.1.2 安装RabbitMQ服务端</h3><p>在RabbitMQ的<a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.3" target="_blank" rel="noopener">gitHub项目</a>中，下载window版本的服务端安装包。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371bf868e203f4?w=394&h=169&f=png&s=19585" srcset="/img/loading.gif" alt=""></p><p>下载后，就得到这个东西：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371c1d6501ab40?w=117&h=153&f=png&s=3533" srcset="/img/loading.gif" alt=""></p><p>接着到双击安装，一直点下一步安装即可，安装完成后，找到安装目录：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371c5bccf4f9d5?w=618&h=280&f=png&s=40338" srcset="/img/loading.gif" alt=""></p><p>在此目录下打开cmd命令，输入rabbitmq-plugins enable rabbitmq_management命令安装管理页面的插件：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371c7989899657?w=718&h=161&f=png&s=11588" srcset="/img/loading.gif" alt=""></p><p>然后双击rabbitmq-server.bat启动脚本，然后打开服务管理可以看到RabbitMQ正在运行：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371ca5f47fce8b?w=1176&h=332&f=png&s=95743" srcset="/img/loading.gif" alt=""></p><p>这时，打开浏览器输入<code>http://localhost:15672</code>，账号密码默认是：guest/guest</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371cb642afc306?w=379&h=170&f=png&s=8715" srcset="/img/loading.gif" alt=""></p><p>到这一步，安装就大功告成了！</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371cc62006368a?w=1296&h=506&f=png&s=65917" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-永远的Hello-Word"><a href="#4-2-永远的Hello-Word" class="headerlink" title="4.2 永远的Hello Word"></a>4.2 永远的Hello Word</h2><p>服务端搭建好了之后肯定要用客户端去操作，接下来就用Java做一个简单的HelloWord演示。</p><p>因为我用的是SpringBoot，所以在<strong>生产者这边</strong>加入对应的starter依赖即可：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>一般需要创建一个公共项目common，共享一些配置，比如队列主题，交换机名称，路由匹配键名称等等。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376a8962ac345e?w=1187&h=422&f=png&s=87972" srcset="/img/loading.gif" alt=""></p><p>首先在application.yml文件加上RabbitMQ的配置信息：</p><pre><code class="yml">spring:    rabbitmq:        host: 127.0.0.1        port: 5672        username: guest        password: guest</code></pre><p>然后在生产者这边，加上common包的maven依赖，然后创建一个Direct交换机以及队列的配置类：</p><pre><code class="java">@Configurationpublic class DirectRabbitConfig {    @Bean    public Queue rabbitmqDemoDirectQueue() {        /**         * 1、name:    队列名称         * 2、durable: 是否持久化         * 3、exclusive: 是否独享、排外的。如果设置为true，定义为排他队列。则只有创建者可以使用此队列。也就是private私有的。         * 4、autoDelete: 是否自动删除。也就是临时队列。当最后一个消费者断开连接后，会自动删除。         * */        return new Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC, true, false, false);    }    @Bean    public DirectExchange rabbitmqDemoDirectExchange() {        //Direct交换机        return new DirectExchange(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, true, false);    }    @Bean    public Binding bindDirect() {        //链式写法，绑定交换机和队列，并设置匹配键        return BindingBuilder                //绑定队列                .bind(rabbitmqDemoDirectQueue())                //到交换机                .to(rabbitmqDemoDirectExchange())                //并设置匹配键                .with(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING);    }}</code></pre><p>然后再创建一个发送消息的Service类：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    //日期格式化    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    @Resource    private RabbitTemplate rabbitTemplate;    @Override    public String sendMsg(String msg) throws Exception {        try {            String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32);            String sendTime = sdf.format(new Date());            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();            map.put(&quot;msgId&quot;, msgId);            map.put(&quot;sendTime&quot;, sendTime);            map.put(&quot;msg&quot;, msg);            rabbitTemplate.convertAndSend(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING, map);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }}</code></pre><p>然后根据业务放在需要用的地方，比如定时任务，或者接口。我这里就简单一点使用Controller层进行发送：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    @Resource    private RabbitMQService rabbitMQService;    /**     * 发送消息     * @author java技术爱好者     */    @PostMapping(&quot;/sendMsg&quot;)    public String sendMsg(@RequestParam(name = &quot;msg&quot;) String msg) throws Exception {        return rabbitMQService.sendMsg(msg);    }}</code></pre><p>生产者写完之后，就写消费者端的代码，消费者很简单。maven依赖，yml文件配置和生产者一样。只需要创建一个类，@RabbitListener注解写上监听队列的名称，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376b4781b8bd8a?w=1198&h=380&f=png&s=66605" srcset="/img/loading.gif" alt=""></p><p><strong>这里有个小坑</strong>，一开始RabbitMQ服务器里还没有创建队列：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bcd4d88602d?w=628&h=287&f=png&s=18084" srcset="/img/loading.gif" alt=""></p><p>这时如果启动消费者，会报错：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bd6f8340df0?w=1241&h=128&f=png&s=34738" srcset="/img/loading.gif" alt=""></p><p>要先启动生产者，发送一条消息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bef5bc1dec1?w=934&h=241&f=png&s=21574" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376c019fa7c8bb?w=778&h=273&f=png&s=27026" srcset="/img/loading.gif" alt=""></p><p>最后再启动消费者，进行消费：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376c132059ba20?w=1164&h=264&f=png&s=95439" srcset="/img/loading.gif" alt=""></p><p>这时候就会持续监听队列的消息，只要生产者发送一条消息到MQ，消费者就消费一条。我这里尝试发送4条：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376c3ca37adf87?w=1139&h=111&f=png&s=36994" srcset="/img/loading.gif" alt=""></p><p>由于队列不存在，启动消费者报错的这个问题。最好的方法是生产者和消费者都尝试创建队列，怎么写呢，有很多方式，我这里用一个相对简单一点的：</p><p>生产者的配置类加点东西：</p><pre><code class="java">//实现BeanPostProcessor类，使用Bean的生命周期函数@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    //这是创建交换机和队列用的rabbitAdmin对象    @Resource    private RabbitAdmin rabbitAdmin;    //初始化rabbitAdmin对象    @Bean    public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory) {        RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory);        // 只有设置为 true，spring 才会加载 RabbitAdmin 这个类        rabbitAdmin.setAutoStartup(true);        return rabbitAdmin;    }    //实例化bean后，也就是Bean的后置处理器    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        //创建交换机        rabbitAdmin.declareExchange(rabbitmqDemoDirectExchange());        //创建队列        rabbitAdmin.declareQueue(rabbitmqDemoDirectQueue());        return null;    }}</code></pre><p>这样启动生产者就会自动创建交换机和队列，不用等到发送消息才创建。</p><p>消费者需要加一点代码：</p><pre><code class="java">@Component//使用queuesToDeclare属性，如果不存在则会创建队列@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC))public class RabbitDemoConsumer {    //...省略}</code></pre><p>这样，无论生产者还是消费者先启动都不会出现问题了~</p><blockquote><p>代码地址：<a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><h1 id="五、RabbitMQ中的组成部分"><a href="#五、RabbitMQ中的组成部分" class="headerlink" title="五、RabbitMQ中的组成部分"></a>五、RabbitMQ中的组成部分</h1><p>从上面的HelloWord例子中，我们大概也能体验到一些，就是RabbitMQ的组成，它是有这几部分：</p><ul><li>Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。</li><li>Exchange：消息队列交换机。<strong>按一定的规则将消息路由转发到某个队列</strong>。</li><li>Queue：消息队列，存储消息的队列。</li><li>Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。</li><li>Consumer：消息消费者。消费队列中存储的消息。</li></ul><p>这些组成部分是如何协同工作的呢，大概的流程如下，请看下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/1737728b72852d77?w=620&h=344&f=png&s=18810" srcset="/img/loading.gif" alt=""></p><ul><li>消息生产者连接到RabbitMQ Broker，创建connection，开启channel。</li><li>生产者声明交换机类型、名称、是否持久化等。</li><li>生产者发送消息，并指定消息是否持久化等属性和routing key。</li><li>exchange收到消息之后，<strong>根据routing key路由到跟当前交换机绑定的相匹配的队列</strong>里面。</li><li>消费者监听接收到消息之后开始业务处理。</li></ul><h1 id="六、Exchange的四种类型以及用法"><a href="#六、Exchange的四种类型以及用法" class="headerlink" title="六、Exchange的四种类型以及用法"></a>六、Exchange的四种类型以及用法</h1><p>从上面的工作流程可以看出，实际上有个关键的组件Exchange，因为<strong>消息发送到RabbitMQ后首先要经过Exchange路由才能找到对应的Queue</strong>。</p><p>实际上Exchange类型有四种，根据不同的类型工作的方式也有所不同。在HelloWord例子中，我们就使用了比较简单的<strong>Direct Exchange</strong>，翻译就是直连交换机。其余三种分别是：<strong>Fanout exchange、Topic exchange、Headers exchange</strong>。</p><h2 id="6-1-Direct-Exchange"><a href="#6-1-Direct-Exchange" class="headerlink" title="6.1 Direct Exchange"></a>6.1 Direct Exchange</h2><p>见文知意，直连交换机意思是此交换机需要绑定一个队列，要求<strong>该消息与一个特定的路由键完全匹配</strong>。简单点说就是一对一的，点对点的发送。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/173773fe45569885?w=468&h=267&f=png&s=65093" srcset="/img/loading.gif" alt=""></p><p>完整的代码就是上面的HelloWord的例子，不再重复代码。</p><h2 id="6-2-Fanout-exchange"><a href="#6-2-Fanout-exchange" class="headerlink" title="6.2 Fanout exchange"></a>6.2 Fanout exchange</h2><p>这种类型的交换机需要将队列绑定到交换机上。<strong>一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上</strong>。很像子网广播，每台子网内的主机都获得了一份复制的消息。简单点说就是发布订阅。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/173774203ee5afd3?w=465&h=299&f=png&s=79778" srcset="/img/loading.gif" alt=""></p><p>代码怎么写呢，演示一下：</p><p>首先要先配置交换机和队列的名称：</p><pre><code class="java">public class RabbitMQConfig {    /**     * RabbitMQ的FANOUT_EXCHANG交换机类型的队列 A 的名称     */    public static final String FANOUT_EXCHANGE_QUEUE_TOPIC_A = &quot;fanout.A&quot;;    /**     * RabbitMQ的FANOUT_EXCHANG交换机类型的队列 B 的名称     */    public static final String FANOUT_EXCHANGE_QUEUE_TOPIC_B = &quot;fanout.B&quot;;    /**     * RabbitMQ的FANOUT_EXCHANG交换机类型的名称     */    public static final String FANOUT_EXCHANGE_DEMO_NAME = &quot;fanout.exchange.demo.name&quot;;}</code></pre><p>再配置FanoutExchange类型的交换机和A、B两个队列，并且绑定。这种类型不需要配置routing key：</p><pre><code class="java">@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    @Resource    private RabbitAdmin rabbitAdmin;    @Bean    public Queue fanoutExchangeQueueA() {        //队列A        return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A, true, false, false);    }    @Bean    public Queue fanoutExchangeQueueB() {        //队列B        return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_B, true, false, false);    }    @Bean    public FanoutExchange rabbitmqDemoFanoutExchange() {        //创建FanoutExchange类型交换机        return new FanoutExchange(RabbitMQConfig.FANOUT_EXCHANGE_DEMO_NAME, true, false);    }    @Bean    public Binding bindFanoutA() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(fanoutExchangeQueueA()).to(rabbitmqDemoFanoutExchange());    }    @Bean    public Binding bindFanoutB() {        //队列B绑定到FanoutExchange交换机        return BindingBuilder.bind(fanoutExchangeQueueB()).to(rabbitmqDemoFanoutExchange());    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        //启动项目即创建交换机和队列        rabbitAdmin.declareExchange(rabbitmqDemoFanoutExchange());        rabbitAdmin.declareQueue(fanoutExchangeQueueB());        rabbitAdmin.declareQueue(fanoutExchangeQueueA());        return null;    }}</code></pre><p>创建service发布消息的方法：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    @Resource    private RabbitTemplate rabbitTemplate;    //发布消息    @Override    public String sendMsgByFanoutExchange(String msg) throws Exception {        Map&lt;String, Object&gt; message = getMessage(msg);        try {            rabbitTemplate.convertAndSend(RabbitMQConfig.FANOUT_EXCHANGE_DEMO_NAME, &quot;&quot;, message);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }    //组装消息体    private Map&lt;String, Object&gt; getMessage(String msg) {        String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32);        String sendTime = sdf.format(new Date());        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msgId&quot;, msgId);        map.put(&quot;sendTime&quot;, sendTime);        map.put(&quot;msg&quot;, msg);        return map;    }}</code></pre><p>Controller接口：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    /**     * 发布消息     *     * @author java技术爱好者     */    @PostMapping(&quot;/publish&quot;)    public String publish(@RequestParam(name = &quot;msg&quot;) String msg) throws Exception {        return rabbitMQService.sendMsgByFanoutExchange(msg);    }}</code></pre><p>接着在消费者项目这边，创建两个队列的监听类，监听队列进行消费：</p><pre><code class="java">@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A))public class FanoutExchangeConsumerA {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列A收到消息：&quot; + map.toString());    }}</code></pre><pre><code class="java">@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_B))public class FanoutExchangeConsumerB {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列B收到消息：&quot; + map.toString());    }}</code></pre><p>然后启动生产者和消费者两个项目，可以看到管理界面创建了一个FanoutExchange交换机和两个队列，并且绑定了：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737c7793f971244?w=647&h=367&f=png&s=27283" srcset="/img/loading.gif" alt=""></p><p>使用POSTMAN进行发送消息，测试：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737c7829f71b8f2?w=944&h=276&f=png&s=22267" srcset="/img/loading.gif" alt=""></p><p>然后可以看到控制台，两个队列同时都收到了相同的消息，形成了发布订阅的效果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737c794ca2a0106?w=961&h=95&f=png&s=32829" srcset="/img/loading.gif" alt=""></p><h2 id="6-3-Topic-Exchange"><a href="#6-3-Topic-Exchange" class="headerlink" title="6.3 Topic Exchange"></a>6.3 Topic Exchange</h2><p>直接翻译的话叫做主题交换机，如果从用法上面翻译可能叫通配符交换机会更加贴切。这种交换机是使用通配符去匹配，路由到对应的队列。通配符有两种：”*” 、 “#”。需要注意的是通配符前面必须要加上”.”符号。</p><p><code>*</code> 符号：有且只匹配一个词。比如 <code>a.*</code>可以匹配到”a.b”、”a.c”，但是匹配不了”a.b.c”。</p><p><code>#</code> 符号：匹配一个或多个词。比如”rabbit.#”既可以匹配到”rabbit.a.b”、”rabbit.a”，也可以匹配到”rabbit.a.b.c”。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737cc2e35abb0c2?w=787&h=472&f=png&s=44593" srcset="/img/loading.gif" alt=""></p><p>废话不多说，代码演示一下：</p><p>依然是配置TopicExchange名称和三个队列的名称：</p><pre><code class="java">    /**     * RabbitMQ的TOPIC_EXCHANGE交换机名称     */    public static final String TOPIC_EXCHANGE_DEMO_NAME = &quot;topic.exchange.demo.name&quot;;    /**     * RabbitMQ的TOPIC_EXCHANGE交换机的队列A的名称     */    public static final String TOPIC_EXCHANGE_QUEUE_A = &quot;topic.queue.a&quot;;    /**     * RabbitMQ的TOPIC_EXCHANGE交换机的队列B的名称     */    public static final String TOPIC_EXCHANGE_QUEUE_B = &quot;topic.queue.b&quot;;    /**     * RabbitMQ的TOPIC_EXCHANGE交换机的队列C的名称     */    public static final String TOPIC_EXCHANGE_QUEUE_C = &quot;topic.queue.c&quot;;</code></pre><p>然后还是老配方，配置交换机和队列，然后绑定，创建：</p><pre><code class="java">@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    //省略...    @Bean    public TopicExchange rabbitmqDemoTopicExchange() {        //配置TopicExchange交换机        return new TopicExchange(RabbitMQConfig.TOPIC_EXCHANGE_DEMO_NAME, true, false);    }    @Bean    public Queue topicExchangeQueueA() {        //创建队列1        return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A, true, false, false);    }    @Bean    public Queue topicExchangeQueueB() {        //创建队列2        return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B, true, false, false);    }    @Bean    public Queue topicExchangeQueueC() {        //创建队列3        return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C, true, false, false);    }    @Bean    public Binding bindTopicA() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(topicExchangeQueueB())                .to(rabbitmqDemoTopicExchange())                .with(&quot;a.*&quot;);    }    @Bean    public Binding bindTopicB() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(topicExchangeQueueC())                .to(rabbitmqDemoTopicExchange())                .with(&quot;a.*&quot;);    }    @Bean    public Binding bindTopicC() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(topicExchangeQueueA())                .to(rabbitmqDemoTopicExchange())                .with(&quot;rabbit.#&quot;);    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        rabbitAdmin.declareExchange(rabbitmqDemoTopicExchange());        rabbitAdmin.declareQueue(topicExchangeQueueA());        rabbitAdmin.declareQueue(topicExchangeQueueB());        rabbitAdmin.declareQueue(topicExchangeQueueC());        return null;    }}</code></pre><p>然后写一个发送消息的service方法：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    @Override    public String sendMsgByTopicExchange(String msg, String routingKey) throws Exception {        Map&lt;String, Object&gt; message = getMessage(msg);        try {            //发送消息            rabbitTemplate.convertAndSend(RabbitMQConfig.TOPIC_EXCHANGE_DEMO_NAME, routingKey, message);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }}</code></pre><p>写一个Controller接口：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    @Resource    private RabbitMQService rabbitMQService;    /**     * 通配符交换机发送消息     *     * @author java技术爱好者     */    @PostMapping(&quot;/topicSend&quot;)    public String topicSend(@RequestParam(name = &quot;msg&quot;) String msg, @RequestParam(name = &quot;routingKey&quot;) String routingKey) throws Exception {        return rabbitMQService.sendMsgByTopicExchange(msg, routingKey);    }}</code></pre><p>生产者这边写完，就写消费端，消费端比较简单，写三个监听类：</p><pre><code class="java">@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A))public class TopicExchangeConsumerA {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A + &quot;]收到消息：&quot; + map.toString());    }}@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B))public class TopicExchangeConsumerB {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B+ &quot;]收到消息：&quot; + map.toString());    }}@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C))public class TopicExchangeConsumerC {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C + &quot;]收到消息：&quot; + map.toString());    }}</code></pre><p>大功告成，然后启动项目开始调试。启动成功后可以看到队列和路由键绑定的关系：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17380fc32fda0fa2?w=518&h=379&f=png&s=26158" srcset="/img/loading.gif" alt=""></p><p>通过POSTMAN进行测试，测试一下 rabbit.# 的路由键是否能够匹配成功：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17380fd5053e38bc?w=934&h=253&f=png&s=23565" srcset="/img/loading.gif" alt=""></p><p>测试成功，队列A消费到消息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17380fe5e090ae23?w=1104&h=46&f=png&s=14452" srcset="/img/loading.gif" alt=""></p><p>接着测试 a.* 路由键，发送 routingKey = a.b ：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17381008ddcc1a5b?w=937&h=233&f=png&s=21310" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/173810049898ae69?w=948&h=51&f=png&s=12864" srcset="/img/loading.gif" alt=""></p><p>比较常用的就是以上三种：直连(DirectExchange)，发布订阅(FanoutExchange)，通配符(TopicExchange)。熟练运用这三种交换机类型，基本上可以解决大部分的业务场景。</p><p>实际上稍微思考一下，可以发现通配符(TopicExchange)这种模式其实是可以达到直连(DirectExchange)和发布订阅(FanoutExchange)这两种的效果的。</p><p>FanoutExchange不需要绑定routingKey，所以性能相对TopicExchange会好一点。</p><h2 id="6-4-Headers-Exchange"><a href="#6-4-Headers-Exchange" class="headerlink" title="6.4 Headers Exchange"></a>6.4 Headers Exchange</h2><p>这种交换机用的相对没这么多。<strong>它跟上面三种有点区别，它的路由不是用routingKey进行路由匹配，而是在匹配请求头中所带的键值进行路由</strong>。如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/1738499671e1955e?w=828&h=252&f=png&s=34357" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/173849a014d576e5?w=799&h=252&f=png&s=34238" srcset="/img/loading.gif" alt=""></p><p>创建队列需要设置绑定的头部信息，有两种模式：<strong>全部匹配和部分匹配</strong>。如上图所示，交换机会根据生产者发送过来的头部信息携带的键值去匹配队列绑定的键值，路由到对应的队列。代码怎么实现呢，往下看演示代码：</p><p>首先还是需要定义交换机名称，队列名称：</p><pre><code class="java">    /**     * HEADERS_EXCHANGE交换机名称     */    public static final String HEADERS_EXCHANGE_DEMO_NAME = &quot;headers.exchange.demo.name&quot;;    /**     * RabbitMQ的HEADERS_EXCHANGE交换机的队列A的名称     */    public static final String HEADERS_EXCHANGE_QUEUE_A = &quot;headers.queue.a&quot;;    /**     * RabbitMQ的HEADERS_EXCHANGE交换机的队列B的名称     */    public static final String HEADERS_EXCHANGE_QUEUE_B = &quot;headers.queue.b&quot;;</code></pre><p>然后设置交换机，队列，进行绑定：</p><pre><code class="java">@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    @Bean    public Queue headersQueueA() {        return new Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A, true, false, false);    }    @Bean    public Queue headersQueueB() {        return new Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B, true, false, false);    }    @Bean    public HeadersExchange rabbitmqDemoHeadersExchange() {        return new HeadersExchange(RabbitMQConfig.HEADERS_EXCHANGE_DEMO_NAME, true, false);    }    @Bean    public Binding bindHeadersA() {        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;key_one&quot;, &quot;java&quot;);        map.put(&quot;key_two&quot;, &quot;rabbit&quot;);        //全匹配        return BindingBuilder.bind(headersQueueA())                .to(rabbitmqDemoHeadersExchange())                .whereAll(map).match();    }    @Bean    public Binding bindHeadersB() {        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;headers_A&quot;, &quot;coke&quot;);        map.put(&quot;headers_B&quot;, &quot;sky&quot;);        //部分匹配        return BindingBuilder.bind(headersQueueB())                .to(rabbitmqDemoHeadersExchange())                .whereAny(map).match();    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        rabbitAdmin.declareExchange(rabbitmqDemoHeadersExchange());        rabbitAdmin.declareQueue(headersQueueA());        rabbitAdmin.declareQueue(headersQueueB());        return null;    }}</code></pre><p>再写一个Service方法发送消息:</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    @Resource    private RabbitTemplate rabbitTemplate;    @Override    public String sendMsgByHeadersExchange(String msg, Map&lt;String, Object&gt; map) throws Exception {        try {            MessageProperties messageProperties = new MessageProperties();            //消息持久化            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);            messageProperties.setContentType(&quot;UTF-8&quot;);            //添加消息            messageProperties.getHeaders().putAll(map);            Message message = new Message(msg.getBytes(), messageProperties);            rabbitTemplate.convertAndSend(RabbitMQConfig.HEADERS_EXCHANGE_DEMO_NAME, null, message);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }}</code></pre><p>再写一个Controller接口：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    @Resource    private RabbitMQService rabbitMQService;    @PostMapping(&quot;/headersSend&quot;)    @SuppressWarnings(&quot;unchecked&quot;)    public String headersSend(@RequestParam(name = &quot;msg&quot;) String msg,                              @RequestParam(name = &quot;json&quot;) String json) throws Exception {        ObjectMapper mapper = new ObjectMapper();        Map&lt;String, Object&gt; map = mapper.readValue(json, Map.class);        return rabbitMQService.sendMsgByHeadersExchange(msg, map);    }}</code></pre><p>生产者这边写完了，再写两个队列的监听类进行消费：</p><pre><code class="java">@Componentpublic class HeadersExchangeConsumerA {    @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A))    public void process(Message message) throws Exception {        MessageProperties messageProperties = message.getMessageProperties();        String contentType = messageProperties.getContentType();        System.out.println(&quot;队列[&quot; + RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A + &quot;]收到消息：&quot; + new String(message.getBody(), contentType));    }}@Componentpublic class HeadersExchangeConsumerB {    @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B))    public void process(Message message) throws Exception {        MessageProperties messageProperties = message.getMessageProperties();        String contentType = messageProperties.getContentType();        System.out.println(&quot;队列[&quot; + RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B + &quot;]收到消息：&quot; + new String(message.getBody(), contentType));    }}</code></pre><p>大功告成~启动项目，打开管理界面，我们可以看到交换机绑定队列的信息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a470aa42de3?w=570&h=364&f=png&s=31572" srcset="/img/loading.gif" alt=""></p><p>跟上面示意图一样~证明没有问题，一切尽在掌握之中。使用POSTMAN发送，测试全匹配的队列A：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a81c6f1551f?w=939&h=264&f=png&s=24756" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a87b820f9f3?w=471&h=63&f=png&s=6969" srcset="/img/loading.gif" alt=""></p><p>再测试部分匹配的队列B：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a9b2293c0e2?w=930&h=258&f=png&s=23945" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a9f8bbab549?w=472&h=76&f=png&s=7341" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章就先写到这里了。回顾一下学了哪些：</p><ul><li>什么是消息队列？为什么使用消息队列？</li><li>RabbitMQ的特点、组成部分、工作流程</li><li>安装RabbitMQ，以及完成一个HelloWord小案例</li><li>RabbitMQ交换机的四种类型的特点，以及使用方法</li></ul><p>实际上RabbitMQ还有事务机制和负载均衡这些还没讲，因为篇幅实在有点长了，差不多5千字了。所以放在下期讲吧，尽请期待一下。</p><p>上面所有例子的代码都上传github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>如果你觉得这篇文章对你有用，点个赞吧</strong>~</p><p><strong>你的点赞是我创作的最大动力</strong>~</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZooKeeper入门</title>
    <link href="/2020/07/26/ZooKeeper%E5%85%A5%E9%97%A8/"/>
    <url>/2020/07/26/ZooKeeper%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/12/17343787ae8f3533?w=538&h=629&f=png&s=42414" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很多时候，我们都可以在各种框架应用中看到ZooKeeper的身影，比如Kafka中间件，Dubbo框架，Hadoop等等。为什么到处都看到ZooKeeper？</p><h1 id="一、什么是ZooKeeper"><a href="#一、什么是ZooKeeper" class="headerlink" title="一、什么是ZooKeeper"></a>一、什么是ZooKeeper</h1><p><strong>ZooKeeper是一个分布式服务协调框架</strong>，提供了分布式数据一致性的解决方案，基于ZooKeeper的<strong>数据结构，Watcher，选举机制</strong>等特点，可以<strong>实现数据的发布/订阅，软负载均衡，命名服务，统一配置管理，分布式锁，集群管理</strong>等等。</p><h1 id="二、为什么使用ZooKeeper"><a href="#二、为什么使用ZooKeeper" class="headerlink" title="二、为什么使用ZooKeeper"></a>二、为什么使用ZooKeeper</h1><p>ZooKeeper能保证：</p><ul><li>更新请求顺序进行。来自同一个client的更新请求按其发送顺序依次执行</li><li>数据更新原子性。一次数据更新要么成功，要么失败</li><li><strong>全局唯一数据视图</strong>。client无论连接到哪个server，数据视图都是一致的</li><li><strong>实时性</strong>。在一定时间范围内，client读到的数据是最新的</li></ul><h1 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h1><p>ZooKeeper的数据结构和Unix文件系统很类似，总体上可以看做是一棵树，每一个节点称之为一个ZNode，每一个ZNode<strong>默认能存储1M的数据</strong>。每一个ZNode可<strong>通过唯一的路径标识</strong>。如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/9/173343f042cc21bf?w=450&h=317&f=png&s=19615" srcset="/img/loading.gif" alt=""></p><p>创建ZNode时，可以指定以下四种类型，包括：</p><ul><li><strong>PERSISTENT，持久性ZNode</strong>。创建后，即使客户端与服务端断开连接也不会删除，只有客户端主动删除才会消失。</li><li><strong>PERSISTENT_SEQUENTIAL，持久性顺序编号ZNode</strong>。和持久性节点一样不会因为断开连接后而删除，并且ZNode的编号会自动增加。</li><li><strong>EPHEMERAL，临时性ZNode</strong>。客户端与服务端断开连接，该ZNode会被删除。</li><li><strong>EPEMERAL_SEQUENTIAL，临时性顺序编号ZNode</strong>。和临时性节点一样，断开连接会被删除，并且ZNode的编号会自动增加。</li></ul><h1 id="四、监听通知机制"><a href="#四、监听通知机制" class="headerlink" title="四、监听通知机制"></a>四、监听通知机制</h1><p>Watcher是基于<strong>观察者模式</strong>实现的一种机制。如果我们需要实现当某个ZNode节点发生变化时收到通知，就可以使用Watcher监听器。</p><p><strong>客户端通过设置监视点（watcher）向 ZooKeeper 注册需要接收通知的 znode，在 znode 发生变化时 ZooKeeper 就会向客户端发送消息</strong>。</p><p><strong>这种通知机制是一次性的</strong>。一旦watcher被触发，ZooKeeper就会从相应的存储中删除。如果需要不断监听ZNode的变化，可以在收到通知后再设置新的watcher注册到ZooKeeper。</p><p>监视点的类型有很多，如<strong>监控ZNode数据变化、监控ZNode子节点变化、监控ZNode 创建或删除</strong>。</p><h1 id="五、选举机制"><a href="#五、选举机制" class="headerlink" title="五、选举机制"></a>五、选举机制</h1><p>ZooKeeper是一个高可用的应用框架，因为ZooKeeper是支持集群的。ZooKeeper在集群状态下，配置文件是不会指定Master和Slave，而是在ZooKeeper服务器初始化时就在内部进行选举，产生一台做为Leader，多台做为Follower，并且遵守半数可用原则。</p><p>由于遵守半数可用原则，所以5台服务器和6台服务器，实际上最大允许宕机数量都是3台，所以为了节约成本，<strong>集群的服务器数量一般设置为奇数</strong>。</p><p>如果在运行时，<strong>如果长时间无法和Leader保持连接的话，则会再次进行选举，产生新的Leader，以保证服务的可用</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339067a2c6c061?w=600&h=185&f=png&s=87756" srcset="/img/loading.gif" alt=""></p><h1 id="六、初の体验"><a href="#六、初の体验" class="headerlink" title="六、初の体验"></a>六、初の体验</h1><p>首先在<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">官网</a>下载ZooKeeper，我这里用的是3.3.6版本。</p><p>然后解压，复制一下/conf目录下的zoo_sample.cfg文件，重命名为zoo.cfg。</p><p>修改zoo.cfg中dataDir的值，并创建对应的目录：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339300106f99c6?w=515&h=245&f=png&s=18915" srcset="/img/loading.gif" alt=""></p><p>最后到/bin目录下启动，我用的是window系统，所以启动zkServer.cmd，双击即可：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/1733937df5bee4e3?w=663&h=180&f=png&s=28318" srcset="/img/loading.gif" alt=""></p><p>启动成功的话就可以看到这个对话框：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339369078c2cc2?w=961&h=407&f=png&s=51377" srcset="/img/loading.gif" alt=""></p><p>可视化界面的话，我推荐使用<code>ZooInspector</code>，操作比较简便：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/173393a9befbac48?w=767&h=156&f=png&s=10149" srcset="/img/loading.gif" alt=""></p><h2 id="6-1-使用java连接ZooKeeper"><a href="#6-1-使用java连接ZooKeeper" class="headerlink" title="6.1 使用java连接ZooKeeper"></a>6.1 使用java连接ZooKeeper</h2><p>首先引入Maven依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>接着我们写一个Main方法，进行操作：</p><pre><code class="java">    //连接地址及端口号    private static final String SERVER_HOST = &quot;127.0.0.1:2181&quot;;    //会话超时时间    private static final int SESSION_TIME_OUT = 2000;    public static void main(String[] args) throws Exception {        //参数一：服务端地址及端口号        //参数二：超时时间        //参数三：监听器        ZooKeeper zooKeeper = new ZooKeeper(SERVER_HOST, SESSION_TIME_OUT, new Watcher() {            @Override            public void process(WatchedEvent watchedEvent) {                //获取事件的状态                Event.KeeperState state = watchedEvent.getState();                //判断是否是连接事件                if (Event.KeeperState.SyncConnected == state) {                    Event.EventType type = watchedEvent.getType();                    if (Event.EventType.None == type) {                        System.out.println(&quot;zk客户端已连接...&quot;);                    }                }            }        });        zooKeeper.create(&quot;/java&quot;, &quot;Hello World&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        System.out.println(&quot;新增ZNode成功&quot;);        zooKeeper.close();    }</code></pre><p>创建一个持久性ZNode，路径是/java，值为”Hello World”：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339630f8746e96?w=443&h=168&f=png&s=10357" srcset="/img/loading.gif" alt=""></p><h1 id="七、API概述"><a href="#七、API概述" class="headerlink" title="七、API概述"></a>七、API概述</h1><h2 id="7-1-创建"><a href="#7-1-创建" class="headerlink" title="7.1 创建"></a>7.1 创建</h2><pre><code class="java">public String create(final String path, byte data[], List&lt;ACL&gt; acl, CreateMode createMode)</code></pre><p>参数解释：</p><ul><li>path ZNode路径</li><li>data ZNode存储的数据</li><li>acl ACL权限控制</li><li>createMode ZNode类型</li></ul><p>ACL权限控制，有三个是ZooKeeper定义的常用权限，在ZooDefs.Ids类中：</p><pre><code class="java">/** * This is a completely open ACL. * 完全开放的ACL，任何连接的客户端都可以操作该属性znode */public final ArrayList&lt;ACL&gt; OPEN_ACL_UNSAFE = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.ALL, ANYONE_ID_UNSAFE)));/** * This ACL gives the creators authentication id&#39;s all permissions. * 只有创建者才有ACL权限 */public final ArrayList&lt;ACL&gt; CREATOR_ALL_ACL = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.ALL, AUTH_IDS)));/** * This ACL gives the world the ability to read. * 只能读取ACL */public final ArrayList&lt;ACL&gt; READ_ACL_UNSAFE = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.READ, ANYONE_ID_UNSAFE)));</code></pre><p>createMode就是前面讲过的四种ZNode类型：</p><pre><code class="java">public enum CreateMode {    /**     * 持久性ZNode     */    PERSISTENT (0, false, false),    /**     * 持久性自动增加顺序号ZNode     */    PERSISTENT_SEQUENTIAL (2, false, true),    /**     * 临时性ZNode     */    EPHEMERAL (1, true, false),    /**     * 临时性自动增加顺序号ZNode     */    EPHEMERAL_SEQUENTIAL (3, true, true);}</code></pre><h2 id="7-2-查询"><a href="#7-2-查询" class="headerlink" title="7.2 查询"></a>7.2 查询</h2><pre><code class="java">//同步获取节点数据public byte[] getData(String path, boolean watch, Stat stat){    ...}//异步获取节点数据public void getData(final String path, Watcher watcher, DataCallback cb, Object ctx){    ...}</code></pre><p>同步getData()方法中的stat参数是用于接收返回的节点描述信息：</p><pre><code class="java">public byte[] getData(final String path, Watcher watcher, Stat stat){    //省略...    GetDataResponse response = new GetDataResponse();    //发送请求到ZooKeeper服务器，获取到response    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (stat != null) {        //把response的Stat赋值到传入的stat中        DataTree.copyStat(response.getStat(), stat);    }}</code></pre><p>使用同步getData()获取数据：</p><pre><code class="java">    //数据的描述信息，包括版本号，ACL权限，子节点信息等等    Stat stat = new Stat();    //返回结果是byte[]数据，getData()方法底层会把描述信息复制到stat对象中    byte[] bytes = zooKeeper.getData(&quot;/java&quot;, false, stat);    //打印结果    System.out.println(&quot;ZNode的数据data:&quot; + new String(bytes));//Hello World    System.out.println(&quot;获取到dataVersion版本号:&quot; + stat.getVersion());//默认数据版本号是0</code></pre><h2 id="7-3-更新"><a href="#7-3-更新" class="headerlink" title="7.3 更新"></a>7.3 更新</h2><pre><code class="java">public Stat setData(final String path, byte data[], int version){    ...}</code></pre><p>值得注意的是第三个参数version，<strong>使用CAS机制，这是为了防止多个客户端同时更新节点数据，所以需要在更新时传入版本号，每次更新都会使版本号+1</strong>，如果服务端接收到版本号，对比发现不一致的话，则会抛出异常。</p><p>所以，在更新前需要先查询获取到版本号，否则你不知道当前版本号是多少，就没法更新：</p><pre><code class="java">    //获取节点描述信息    Stat stat = new Stat();    zooKeeper.getData(&quot;/java&quot;, false, stat);    System.out.println(&quot;更新ZNode数据...&quot;);    //更新操作，传入路径，更新值，版本号三个参数,返回结果是新的描述信息    Stat setData = zooKeeper.setData(&quot;/java&quot;, &quot;fly!!!&quot;.getBytes(), stat.getVersion());    System.out.println(&quot;更新后的版本号为：&quot; + setData.getVersion());//更新后的版本号为：1</code></pre><p>更新后，版本号增加了：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733999126b62716?w=440&h=320&f=png&s=19876" srcset="/img/loading.gif" alt=""></p><p>如果传入的版本参数是”-1”，就是告诉zookeeper服务器，客户端需要基于数据的最新版本进行更新操作。但是-1并不是一个合法的版本号，而是一个标识符。</p><h2 id="7-4-删除"><a href="#7-4-删除" class="headerlink" title="7.4 删除"></a>7.4 删除</h2><pre><code class="java">public void delete(final String path, int version){    ...}</code></pre><ul><li>path 删除节点的路径</li><li>version 版本号</li></ul><p>这里也需要传入版本号，调用getData()方法即可获取到版本号，很简单：</p><pre><code class="java">Stat stat = new Stat();zooKeeper.getData(&quot;/java&quot;, false, stat);//删除ZNodezooKeeper.delete(&quot;/java&quot;, stat.getVersion());</code></pre><h2 id="7-5-watcher机制"><a href="#7-5-watcher机制" class="headerlink" title="7.5 watcher机制"></a>7.5 watcher机制</h2><p>在上面第三点提到，ZooKeeper是可以使用通知监听机制，当ZNode发生变化会收到通知消息，进行处理。基于watcher机制，ZooKeeper能玩出很多花样。怎么使用？</p><p>ZooKeeper的通知监听机制，总的来说可以分为三个过程：</p><p>①客户端注册 Watcher<br>②服务器处理 Watcher<br>③客户端回调 Watcher客户端。</p><p>注册 watcher 有 4 种方法，new ZooKeeper()、getData()、exists()、getChildren()。下面演示一下使用exists()方法注册watcher：</p><p>首先<strong>需要实现Watcher接口</strong>，新建一个监听器：</p><pre><code class="java">public class MyWatcher implements Watcher {    @Override    public void process(WatchedEvent event) {        //获取事件类型        Event.EventType eventType = event.getType();        //通知状态        Event.KeeperState eventState = event.getState();        //节点路径        String eventPath = event.getPath();        System.out.println(&quot;监听到的事件类型:&quot; + eventType.name());        System.out.println(&quot;监听到的通知状态:&quot; + eventState.name());        System.out.println(&quot;监听到的ZNode路径:&quot; + eventPath);    }}</code></pre><p>然后调用exists()方法，注册监听器：</p><pre><code class="java">zooKeeper.exists(&quot;/java&quot;, new MyWatcher());//对ZNode进行更新数据的操作，触发监听器zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), -1);</code></pre><p>然后在控制台就可以看到打印的信息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733cd85f8b2bb10?w=682&h=200&f=png&s=48245" srcset="/img/loading.gif" alt=""></p><p>这里我们可以看到<strong>Event.EventType对象就是事件类型</strong>，我们可以对事件类型进行判断，再配合<strong>Event.KeeperState通知状态</strong>，做相关的业务处理，事件类型有哪些？</p><p>打开EventType、KeeperState的源码查看：</p><pre><code class="java">//事件类型是一个枚举public enum EventType {    None (-1),//无    NodeCreated (1),//Watcher监听的数据节点被创建    NodeDeleted (2),//Watcher监听的数据节点被删除    NodeDataChanged (3),//Watcher监听的数据节点内容发生变更    NodeChildrenChanged (4);//Watcher监听的数据节点的子节点列表发生变更}//通知状态也是一个枚举public enum KeeperState {    Unknown (-1),//属性过期    Disconnected (0),//客户端与服务端断开连接    NoSyncConnected (1),//属性过期    SyncConnected (3),//客户端与服务端正常连接    AuthFailed (4),//身份认证失败    ConnectedReadOnly (5),//返回这个状态给客户端，客户端只能处理读请求    SaslAuthenticated(6),//服务器采用SASL做校验时    Expired (-112);//会话session失效}</code></pre><h3 id="7-5-1-watcher的特性"><a href="#7-5-1-watcher的特性" class="headerlink" title="7.5.1 watcher的特性"></a>7.5.1 watcher的特性</h3><ul><li>一次性。一旦watcher被触发，ZK都会从相应的存储中移除。</li></ul><pre><code class="java">    zooKeeper.exists(&quot;/java&quot;, new Watcher() {        @Override        public void process(WatchedEvent event) {            System.out.println(&quot;我是exists()方法的监听器&quot;);        }    });    //对ZNode进行更新数据的操作，触发监听器    zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), -1);    //企图第二次触发监听器    zooKeeper.setData(&quot;/java&quot;, &quot;spring&quot;.getBytes(), -1);</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733cfc7501b447c?w=476&h=149&f=png&s=27289" srcset="/img/loading.gif" alt=""></p><ul><li>串行执行。客户端Watcher回调的过程是一个串行同步的过程，这是为了保证顺序。<pre><code class="java">  zooKeeper.exists(&quot;/java&quot;, new Watcher() {      @Override      public void process(WatchedEvent event) {          System.out.println(&quot;我是exists()方法的监听器&quot;);      }  });  Stat stat = new Stat();  zooKeeper.getData(&quot;/java&quot;, new Watcher() {      @Override      public void process(WatchedEvent event) {          System.out.println(&quot;我是getData()方法的监听器&quot;);      }  }, stat);  //对ZNode进行更新数据的操作，触发监听器  zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), stat.getVersion());</code></pre>打印结果，说明先调用exists()方法的监听器，再调用getData()方法的监听器。因为exists()方法先注册了。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733cf5f77df73f1?w=541&h=140&f=png&s=27151" srcset="/img/loading.gif" alt=""></p><ul><li>轻量级。WatchedEvent是ZK整个Watcher通知机制的最小通知单元。WatchedEvent包含三部分：<strong>通知状态，事件类型，节点路径</strong>。Watcher通知仅仅告诉客户端发生了什么事情，而不会说明事件的具体内容。</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>我记得B站的UP主李永乐说过，<strong>只有你让更多的人生活变得更美好时，自己的生活才能变得更美好。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733d114535c1c80?w=631&h=127&f=png&s=23550" srcset="/img/loading.gif" alt=""></p><p>这句话也是我今年开始写技术分享的一个动力源泉，希望这篇文章对你有用~</p><p>著名的飞行家<strong>马老师</strong>说过：<strong>回城是收费的，而点赞是免费的~</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从秒杀聊到ZooKeeper分布式锁</title>
    <link href="/2020/07/26/%E4%BB%8E%E7%A7%92%E6%9D%80%E8%81%8A%E5%88%B0ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2020/07/26/%E4%BB%8E%E7%A7%92%E6%9D%80%E8%81%8A%E5%88%B0ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/17365f514c2871a0?w=846&h=397&f=png&s=36190" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过<a href="https://juejin.im/post/5f05e96c5188252e5e22d8f4" target="_blank" rel="noopener">《ZooKeeper入门》</a>后，我们学会了ZooKeeper的基本用法。</p><p>实际上ZooKeeper的应用是非常广泛的，实现分布式锁只是其中一种。接下来我们就ZooKeeper实现分布式锁解决<strong>秒杀超卖问题</strong>进行展开。</p><h1 id="一、什么是秒杀超卖问题"><a href="#一、什么是秒杀超卖问题" class="headerlink" title="一、什么是秒杀超卖问题"></a>一、什么是秒杀超卖问题</h1><p>秒杀活动应该都不陌生，不用过多解释。</p><p>不难想象，在这种”秒杀”的场景中，实际上会出现多个用户争抢”资源”的情况，<strong>也就是多个线程同时并发，这种情况是很容易出现数据不准确，也就是超卖问题</strong>。</p><h2 id="1-1-项目演示"><a href="#1-1-项目演示" class="headerlink" title="1.1 项目演示"></a>1.1 项目演示</h2><p>下面使用程序演示，我使用了<strong>SpringBoot2.0、Mybatis、Mybatis-Plus、SpringMVC</strong>搭建了一个简单的项目，github地址：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p>创建一个商品信息表：</p><pre><code class="sql">CREATE TABLE `tb_commodity_info` (  `id` varchar(32) NOT NULL,  `commodity_name` varchar(512) DEFAULT NULL COMMENT &#39;商品名称&#39;,  `commodity_price` varchar(36) DEFAULT &#39;0&#39; COMMENT &#39;商品价格&#39;,  `number` int(10) DEFAULT &#39;0&#39; COMMENT &#39;商品数量&#39;,  `description` varchar(2048) DEFAULT &#39;&#39; COMMENT &#39;商品描述&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;商品信息表&#39;;</code></pre><p>添加一个商品[<strong>叉烧包</strong>]进去：<br><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e32e530bc75a?w=770&h=45&f=png&s=6596" srcset="/img/loading.gif" alt=""></p><p>核心的代码逻辑是这样的：</p><pre><code class="java">    @Override    public boolean purchaseCommodityInfo(String commodityId, Integer number) throws Exception {        //1.先查询数据库中商品的数量        TbCommodityInfo commodityInfo = commodityInfoMapper.selectById(commodityId);        //2.判断商品数量是否大于0，或者购买的数量大于库存        Integer count = commodityInfo.getNumber();        if (count &lt;= 0 || number &gt; count) {            //商品数量小于或者等于0，或者购买的数量大于库存，则返回false            return false;        }        //3.如果库存数量大于0，并且购买的数量小于或者等于库存。则更新商品数量        count -= number;        commodityInfo.setNumber(count);        boolean bool = commodityInfoMapper.updateById(commodityInfo) == 1;        if (bool) {            //如果更新成功，则打印购买商品成功            System.out.println(&quot;购买商品[ &quot; + commodityInfo.getCommodityName() + &quot; ]成功,数量为：&quot; + number);        }        return bool;    }</code></pre><p>逻辑示意图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e422a298bdef?w=719&h=411&f=png&s=35372" srcset="/img/loading.gif" alt=""></p><p>上面这个逻辑，如果单线程请求的话是没有问题的。</p><p>但是多线程的话就出现问题了。现在我就创建多个线程，通过HttpClient进行请求，看会发生什么：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //请求地址        String url = &quot;http://localhost:8080/mall/commodity/purchase&quot;;        //请求参数，商品ID，数量        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;);        map.put(&quot;number&quot;, &quot;1&quot;);        //创建10个线程通过HttpClient进行发送请求，测试        for (int i = 0; i &lt; 10; i++) {            //这个线程的逻辑仅仅是发送请求            CommodityThread commodityThread = new CommodityThread(url, map);            commodityThread.start();        }    }</code></pre><p>说明一下，叉烧包的数量是100，这里有10个线程同时去购买，假设都购买成功的话，库存数量应该是90。</p><p>实际上，10个线程的确都购买成功了：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e52bcd8c8410?w=348&h=182&f=png&s=10183" srcset="/img/loading.gif" alt=""></p><p>但是数据库的商品库存，却不准确：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e5372723db05?w=777&h=47&f=png&s=7006" srcset="/img/loading.gif" alt=""></p><h1 id="二、尝试使用本地锁"><a href="#二、尝试使用本地锁" class="headerlink" title="二、尝试使用本地锁"></a>二、尝试使用本地锁</h1><p>上面的场景，大概流程如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/16/173576192aaa3672?w=827&h=458&f=png&s=71783" srcset="/img/loading.gif" alt=""></p><p>可以看出问题的<strong>关键在于两个线程”同时”去查询剩余的库存，然后更新库存导致的</strong>。要解决这个问题，其实<strong>只要保证多个线程在这段逻辑是顺序执行即可，也就是加锁</strong>。</p><p>本地锁JDK提供有两种：synchronized和Lock锁。</p><p>两种方式都可以，我这里为了简便，使用synchronized：</p><pre><code class="java">    //使用synchronized修饰方法    @Override    public synchronized boolean purchaseCommodityInfo(String commodityId, Integer number) throws Exception {        //省略...    }</code></pre><p>然后再测试刚刚多线程并发抢购的情况，看看结果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352d90c1ca872c?w=779&h=50&f=png&s=6771" srcset="/img/loading.gif" alt=""></p><p>问题得到解决！！！</p><p>你以为事情就这样结束了吗，看了看进度条，发现事情并不简单。</p><p>我们知道在实际项目中，往往不会只部署一台服务器，所以不妨我们启动两台服务器，端口号分别是8080、8081，模拟实际项目的场景：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352e08465b09fb?w=592&h=391&f=png&s=38702" srcset="/img/loading.gif" alt=""></p><p>写一个交替请求的测试脚本，模拟多台服务器分别处理请求，用户秒杀抢购的场景：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //请求地址        String url = &quot;http://localhost:%s/mall/commodity/purchase&quot;;        //请求参数，商品ID，数量        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;);        map.put(&quot;number&quot;, &quot;1&quot;);        //创建10个线程通过HttpClient进行发送请求，测试        for (int i = 0; i &lt; 10; i++) {            //8080、8081交替请求，每个服务器处理5个请求            String port = &quot;808&quot; + (i % 2);            CommodityThread commodityThread = new CommodityThread(String.format(url, port), map);            commodityThread.start();        }    }</code></pre><p>首先看购买的情况，肯定都是购买成功的:</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352ecdc9af8253?w=615&h=302&f=png&s=36798" srcset="/img/loading.gif" alt=""></p><p>关键是库存数量是否正确：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352edee5171303?w=786&h=50&f=png&s=7086" srcset="/img/loading.gif" alt=""></p><p>有10个请求购买成功，库存应该是90才对，这里库存是95。事实证明<strong>本地锁是不能解决多台服务器秒杀抢购出现超卖的问题</strong>。</p><p>为什么会这样呢，请看示意图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352fc7c52787c9?w=650&h=458&f=png&s=63889" srcset="/img/loading.gif" alt=""></p><p>其实和多线程问题是差不多的原因，<strong>多个服务器去查询数据库，获取到相同的库存，然后更新库存，导致数据不正确</strong>。要保证库存的数量正确，<strong>关键在于多台服务器要保证只能一台服务器在执行这段逻辑</strong>，也就是要加分布式锁。</p><p>这也体现出分布式锁的作用，就是要保证多台服务器只能有一台服务器执行。</p><p>分布式锁有三种实现方式，分别是redis、ZooKeeper、数据库(比如mysql)。</p><h1 id="三、使用ZooKeeper实现分布式锁"><a href="#三、使用ZooKeeper实现分布式锁" class="headerlink" title="三、使用ZooKeeper实现分布式锁"></a>三、使用ZooKeeper实现分布式锁</h1><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h2><p>实际上是利用ZooKeeper的临时顺序节点的特性实现分布式锁。怎么实现呢？</p><p>假设现在有一个客户端A，需要加锁，那么就在”/Lock”路径下创建一个临时顺序节点。然后获取”/Lock”下的节点列表，判断自己的序号是否是最小的，如果是最小的序号，则加锁成功！</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17353229075ad04f?w=698&h=276&f=png&s=23589" srcset="/img/loading.gif" alt=""></p><p>现在又有另一个客户端，客户端B需要加锁，那么也是在”/Lock”路径下创建临时顺序节点。依然获取”/Lock”下的节点列表，判断自己的节点序号是否最小的。发现不是最小的，加锁失败，接着对自己的上一个节点进行监听。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/173532ccde8ed6b4?w=736&h=328&f=png&s=29464" srcset="/img/loading.gif" alt=""></p><p>怎么释放锁呢，其实就是把临时节点删除。假设客户端A释放锁，把节点01删除了。那就会触发节点02的监听事件，客户端就再次获取节点列表，然后判断自己是否是最小的序号，如果是最小序号则加锁。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/16/1735337578204cc5?w=788&h=314&f=png&s=33283" srcset="/img/loading.gif" alt=""></p><p>如果多个客户端其实也是一样，一上来就会创建一个临时节点，然后开始判断自己是否是最小的序号，如果不是就监听上一个节点，形成一种排队的机制。也就形成了锁的效果，保证了多台服务器只有一台执行。</p><p><strong>假设其中有一个客户端宕机了，根据临时节点的特点，ZooKeeper会自动删除对应的临时节点</strong>，相当于自动释放了锁。</p><h2 id="3-2-手写代码实现分布式锁"><a href="#3-2-手写代码实现分布式锁" class="headerlink" title="3.2 手写代码实现分布式锁"></a>3.2 手写代码实现分布式锁</h2><p>首先加入Maven依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.101tec&lt;/groupId&gt;    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;    &lt;version&gt;0.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>接着按照上面分析的思路敲代码，创建ZkLock类：</p><pre><code class="java">public class ZkLock implements Lock {    //计数器，用于加锁失败时，阻塞    private static CountDownLatch cdl = new CountDownLatch(1);    //ZooKeeper服务器的IP端口    private static final String IP_PORT = &quot;127.0.0.1:2181&quot;;    //锁的根路径    private static final String ROOT_NODE = &quot;/Lock&quot;;    //上一个节点的路径    private volatile String beforePath;    //当前上锁的节点路径    private volatile String currPath;    //创建ZooKeeper客户端    private ZkClient zkClient = new ZkClient(IP_PORT);    public ZkLock() {        //判断是否存在根节点        if (!zkClient.exists(ROOT_NODE)) {            //不存在则创建            zkClient.createPersistent(ROOT_NODE);        }    }    //加锁    public void lock() {        if (tryLock()) {            System.out.println(&quot;加锁成功！！&quot;);        } else {            // 尝试加锁失败，进入等待 监听            waitForLock();            // 再次尝试加锁            lock();        }    }    //尝试加锁    public synchronized boolean tryLock() {        // 第一次就进来创建自己的临时节点        if (StringUtils.isBlank(currPath)) {            currPath = zkClient.createEphemeralSequential(ROOT_NODE + &quot;/&quot;, &quot;lock&quot;);        }        // 对节点排序        List&lt;String&gt; children = zkClient.getChildren(ROOT_NODE);        Collections.sort(children);        // 当前的是最小节点就返回加锁成功        if (currPath.equals(ROOT_NODE + &quot;/&quot; + children.get(0))) {            return true;        } else {            // 不是最小节点 就找到自己的前一个 依次类推 释放也是一样            int beforePathIndex = Collections.binarySearch(children, currPath.substring(ROOT_NODE.length() + 1)) - 1;            beforePath = ROOT_NODE + &quot;/&quot; + children.get(beforePathIndex);            //返回加锁失败            return false;        }    }    //解锁    public void unlock() {        //删除节点并关闭客户端        zkClient.delete(currPath);        zkClient.close();    }    //等待上锁，加锁失败进入阻塞，监听上一个节点    private void waitForLock() {        IZkDataListener listener = new IZkDataListener() {            //监听节点更新事件            public void handleDataChange(String s, Object o) throws Exception {            }            //监听节点被删除事件            public void handleDataDeleted(String s) throws Exception {                //解除阻塞                cdl.countDown();            }        };        // 监听上一个节点        this.zkClient.subscribeDataChanges(beforePath, listener);        //判断上一个节点是否存在        if (zkClient.exists(beforePath)) {            //上一个节点存在            try {                System.out.println(&quot;加锁失败 等待&quot;);                //加锁失败，阻塞等待                cdl.await();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        // 释放监听        zkClient.unsubscribeDataChanges(beforePath, listener);    }    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {        return false;    }    public void lockInterruptibly() throws InterruptedException {    }    public Condition newCondition() {        return null;    }}</code></pre><p>在Controller层加上锁：</p><pre><code class="java">    @PostMapping(&quot;/purchase&quot;)    public boolean purchaseCommodityInfo(@RequestParam(name = &quot;commodityId&quot;) String commodityId, @RequestParam(name = &quot;number&quot;) Integer number) throws Exception {        boolean bool;        //获取ZooKeeper分布式锁        ZkLock zkLock = new ZkLock();        try {            //上锁            zkLock.lock();            //调用秒杀抢购的service方法            bool = commodityInfoService.purchaseCommodityInfo(commodityId, number);        } catch (Exception e) {            e.printStackTrace();            bool = false;        } finally {            //解锁            zkLock.unlock();        }        return bool;    }</code></pre><p>测试，依然起两台服务器，8080、8081。然后跑测试脚本：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //请求地址        String url = &quot;http://localhost:%s/mall/commodity/purchase&quot;;        //请求参数，商品ID，数量        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;);        map.put(&quot;number&quot;, &quot;1&quot;);        //创建10个线程通过HttpClient进行发送请求，测试        for (int i = 0; i &lt; 10; i++) {            //8080、8081交替请求            String port = &quot;808&quot; + (i % 2);            CommodityThread commodityThread = new CommodityThread(String.format(url, port), map);            commodityThread.start();        }    }</code></pre><p>结果正确：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/173623e9dd3cc00b?w=776&h=47&f=png&s=7044" srcset="/img/loading.gif" alt=""></p><h2 id="3-3-造好的轮子"><a href="#3-3-造好的轮子" class="headerlink" title="3.3 造好的轮子"></a>3.3 造好的轮子</h2><p>Curator是Apache开源的一个操作ZooKeeper的框架。其中就有实现ZooKeeper分布式锁的功能。</p><p>当然分布式锁的实现只是这个框架的其中一个很小的部分，除此之外还有很多用途，大家可以到<a href="http://curator.apache.org/" target="_blank" rel="noopener">官网</a>去学习。</p><p>首先添加Maven依赖：</p><pre><code class="java">    &lt;dependency&gt;        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;        &lt;version&gt;4.3.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;        &lt;version&gt;4.3.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>还是一样在需要加锁的地方进行加锁：</p><pre><code class="java">    @PostMapping(&quot;/purchase&quot;)    public boolean purchaseCommodityInfo(@RequestParam(name = &quot;commodityId&quot;) String commodityId,                                         @RequestParam(name = &quot;number&quot;) Integer number) throws Exception {        boolean bool = false;        //设置重试策略        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;127.0.0.1:2181&quot;, retryPolicy);        // 启动客户端        client.start();        InterProcessMutex mutex = new InterProcessMutex(client, &quot;/locks&quot;);        try {            //加锁            if (mutex.acquire(3, TimeUnit.SECONDS)) {                //调用抢购秒杀service方法                bool = commodityInfoService.purchaseCommodityInfo(commodityId, number);            }        } catch (Exception e) {            e.printStackTrace();        } finally {            //解锁            mutex.release();            client.close();        }        return bool;    }</code></pre><h1 id="四、遇到的坑"><a href="#四、遇到的坑" class="headerlink" title="四、遇到的坑"></a>四、遇到的坑</h1><p>我尝试用原生的ZooKeeper写分布式锁，有点炸裂。遇到不少坑，最终放弃了，用zkclient的API。可能我太菜了不太会用。</p><p>下面我分享我遇到的一些问题，希望你们在遇到同类型的异常时能迅速定位问题。</p><h2 id="4-1-Session-expired"><a href="#4-1-Session-expired" class="headerlink" title="4.1 Session expired"></a>4.1 Session expired</h2><p>这个错误是使用原生ZooKeeper的API出现的错误。主要是我在进入debug模式进行调试出现的。</p><p>因为原生的ZooKeeper需要设定一个会话超时时间，一般debug模式我们都会卡在一个地方去调试，肯定就超出了设置的会话时间~</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/1736258e60ae7778?w=742&h=434&f=png&s=58282" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-KeeperErrorCode-ConnectionLoss"><a href="#4-2-KeeperErrorCode-ConnectionLoss" class="headerlink" title="4.2 KeeperErrorCode = ConnectionLoss"></a>4.2 KeeperErrorCode = ConnectionLoss</h2><p>这个也是原生ZooKeeper的API的错误，怎么出现的呢？</p><p>主要是创建的ZooKeeper客户端连接服务器时是异步的，由于连接需要时间，还没连接成功，代码已经开始执行create()或者exists()，然后就报这个错误。</p><p>解决方法：使用CountDownLatch计数器阻塞，连接成功后再停止阻塞，然后执行create()或者exists()等操作。</p><h2 id="4-3-并发查询更新出现数据不一致"><a href="#4-3-并发查询更新出现数据不一致" class="headerlink" title="4.3 并发查询更新出现数据不一致"></a>4.3 并发查询更新出现数据不一致</h2><p>这个错误真的太炸裂了~</p><p>一开始我是把分布式锁加在service层，然后以为搞定了。接着启动8080、8081进行并发测试。10个线程都是购买成功，结果居然是不正确！</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/173627032c88e91b?w=876&h=184&f=png&s=26788" srcset="/img/loading.gif" alt=""></p><p>第一反应觉得自己实现的代码有问题，于是换成curator框架实现的分布式锁，开源框架应该没问题了吧。没想到还是不行~</p><p>既然不是锁本身的问题，是不是事务问题。<strong>上一个事务更新库存的操作还没提交，然后下一个请求就进来查询。于是我就把加锁的范围放大一点，放在Controller层</strong>。居然成功了！</p><p>你可能已经注意到，我在上面的例子就是把分布式锁加在Controller层，其实我不太喜欢在Controller层写太多代码。</p><p>也许有更加优雅的方式，可惜本人能力不足，如果你有更好的实现方式，可以分享一下~</p><p>补充：下面评论有位大佬说，在原来的方法外再包裹一层，亲测是可以的。这应该是事务的问题。</p><p>上面放在Controller层可以成功是不是因为Controller层没有事务，原来写在service我是写了一个@Transactional注解在类上，所以整个类里面的都有事务，所以解锁后还没提交事务去更新数据库，然后下一个请求进来就查到了没更新的数据。</p><p>为了优雅一点，就把@Transactional注解放在抢购的service方法上<br><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736c9d98626282d?w=863&h=230&f=png&s=49347" srcset="/img/loading.gif" alt=""></p><p>然后再包裹一个没有事务的方法，用于上锁。<br><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736c993c04ea9e5?w=873&h=378&f=png&s=62335" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736c9a2d2881ae3?w=846&h=248&f=png&s=44367" srcset="/img/loading.gif" alt=""></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>最后，我们回顾总结一下吧：</p><ul><li>首先我们模拟单机多线程的秒杀场景，单机的话可以使用本地锁解决问题。</li><li>接着模拟多服务器多线程的场景，思路是使用ZooKeeper实现分布式锁解决。</li><li>图解ZooKeeper实现分布式锁的原理。</li><li>然后动手写代码，实现分布式锁。</li><li>最后总结遇到的坑。</li></ul><p><strong>希望这篇文章对你有用</strong></p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty进阶之粘包和拆包</title>
    <link href="/2020/07/08/Netty%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/"/>
    <url>/2020/07/08/Netty%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17329e0e4be94869?w=895&h=340&f=png&s=33550" srcset="/img/loading.gif" alt=""></p><h1 id="一、什么是粘包和拆包"><a href="#一、什么是粘包和拆包" class="headerlink" title="一、什么是粘包和拆包"></a>一、什么是粘包和拆包</h1><p>TCP是一种<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。(来自百度百科)</p><p>发送端为了将多个发给接收端的数据包，更有效地发送到接收端，会使用<strong>Nagle算法</strong>。Nagle算法会<strong>将多次时间间隔较小且数据量小的数据合并成一个大的数据块</strong>进行发送。虽然这样的确提高了效率，但是<strong>因为面向流通信，数据是无消息保护边界的</strong>，就会<strong>导致接收端难以分辨出完整的数据包</strong>了。</p><p>所谓的粘包和拆包问题，就是因为TCP消息无保护边界导致的。</p><a id="more"></a><h2 id="1-1-图解粘包和拆包"><a href="#1-1-图解粘包和拆包" class="headerlink" title="1.1 图解粘包和拆包"></a>1.1 图解粘包和拆包</h2><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e5cfafa34ed7?w=774&h=456&f=png&s=36343" srcset="/img/loading.gif" alt=""><br>正常发送消息是三次发送三个数据包，这种情况没有问题。</p><p>粘包，则是其中有多个数据包合并成一个数据包进行发送，也就是上图的第二种情况。</p><p>拆包，则是其中一个数据包被拆成了多段，发送的数据包只包含了一个完整数据包的一部分。也就是上图的第三种情况。</p><h2 id="1-2-程序演示"><a href="#1-2-程序演示" class="headerlink" title="1.2 程序演示"></a>1.2 程序演示</h2><p>首先准备客户端负责发送消息，连续发送5次消息，代码如下：</p><pre><code class="java">    for (int i = 1; i &lt;= 5; i++) {        ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + &quot; &quot;, Charset.forName(&quot;utf-8&quot;));        ctx.writeAndFlush(byteBuf);    }</code></pre><p>然后服务端作为接收方，接收并且打印结果：</p><pre><code class="java">//count变量，用于计数private int count = 0;@Overrideprotected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {    byte[] bytes = new byte[msg.readableBytes()];    //把ByteBuf的数据读到bytes数组中    msg.readBytes(bytes);    String message = new String(bytes, Charset.forName(&quot;utf-8&quot;));    System.out.println(&quot;服务器接收到数据：&quot; + message);    //打印接收的次数    System.out.println(&quot;接收到的数据量是：&quot; + (++this.count));}</code></pre><p>启动服务端，再启动两个客户端发送消息,服务端的控制台可以看到这样：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f27303054a8f?w=719&h=199&f=png&s=28205" srcset="/img/loading.gif" alt=""></p><p>粘包的问题其实是随机的，所以每次结果都不太一样。</p><h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>总体思路可以分为三种：</p><ul><li>在数据的末尾添加特殊的符号标识数据包的边界。通常会加\n\r、\t或者其他的符号。</li><li>在数据的头部声明数据的长度，按长度获取数据。</li><li>规定报文的长度，不足则补空位。读取时按规定好的长度来读取。</li></ul><h2 id="2-1-使用LineBasedFrameDecoder"><a href="#2-1-使用LineBasedFrameDecoder" class="headerlink" title="2.1 使用LineBasedFrameDecoder"></a>2.1 使用LineBasedFrameDecoder</h2><p>这是Netty内置的一个解码器，对应的编码器是LineEncoder。</p><p>原理是上面讲的第一种思路，在数据末尾加上特殊符号以标识边界。默认是使用换行符\n。</p><p>用法很简单，发送方加上编码器：</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //添加编码器，使用默认的符号\n，字符集是UTF-8        ch.pipeline().addLast(new LineEncoder(LineSeparator.DEFAULT, CharsetUtil.UTF_8));        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>接收方加上解码器：</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //解码器需要设置数据的最大长度，我这里设置成1024        ch.pipeline().addLast(new LineBasedFrameDecoder(1024));        //给pipeline管道设置业务处理器        ch.pipeline().addLast(new TcpServerHandler());    }</code></pre><p>然后在发送方，发送消息时在末尾加上标识符：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 5; i++) {            //在末尾加上默认的标识符\n            ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + StringUtil.LINE_FEED, Charset.forName(&quot;utf-8&quot;));            ctx.writeAndFlush(byteBuf);        }    }</code></pre><p>于是我们再次启动服务端和客户端，在服务端的控制台可以看到：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f4a496a5469d?w=505&h=231&f=png&s=42918" srcset="/img/loading.gif" alt=""><br>粘包、拆包的问题就轻松得到解决。</p><p>注意点：<strong>数据末尾一定是分隔符，分隔符后面不要再加上数据</strong>，否则会当做下一条数据的开始部分。下面是错误演示：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 5; i++) {            //在分隔符后面加上一段字符串            ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + StringUtil.LINE_FEED + &quot;[我是分隔符后面的字符串]&quot;, Charset.forName(&quot;utf-8&quot;));            ctx.writeAndFlush(byteBuf);        }    }</code></pre><p>服务端的控制台就会看到这样的打印信息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f7fca99184e9?w=446&h=208&f=png&s=24270" srcset="/img/loading.gif" alt=""></p><h2 id="2-2-使用自定义长度帧解码器"><a href="#2-2-使用自定义长度帧解码器" class="headerlink" title="2.2 使用自定义长度帧解码器"></a>2.2 使用自定义长度帧解码器</h2><p>使用这个解码器解决粘包问题的原理是上面讲的第二种，在数据的头部声明数据的长度，按长度获取数据。这个解码器构造器需要定义5个参数，相对较为复杂一点，先看参数的解释：</p><ul><li>maxFrameLength  发送数据包的最大长度</li><li>lengthFieldOffset  长度域的偏移量。长度域位于整个数据包字节数组中的开始下标。</li><li>lengthFieldLength  长度域的字节数长度。长度域的字节数长度。</li><li>lengthAdjustment  长度域的偏移量矫正。如果长度域的值，除了包含有效数据域的长度外，还包含了其他域（如长度域自身）长度，那么，就需要进行矫正。矫正的值为：包长 - 长度域的值 – 长度域偏移 – 长度域长。</li><li>initialBytesToStrip  丢弃的起始字节数。丢弃处于此索引值前面的字节。</li></ul><p>前面三个参数比较简单，可以用下面这张图进行演示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/6/173249f1dcce734e?w=557&h=342&f=png&s=28445" srcset="/img/loading.gif" alt=""><br>矫正偏移量是什么意思呢？意思是假设你的长度域设置的值除了包括有效数据的长度还有其他域的长度包含在里面，那么就要设置这个值进行矫正，否则解码器拿不到有效数据。矫正值的公式就是上面写着了。</p><p>丢弃的起始字节数。这个比较简单，就是在这个索引值前面的数据都丢弃，只要后面的数据。一般都是丢弃长度域的数据。当然如果你希望得到全部数据，那就设置为0。</p><p>下面就在消息接收端使用自定义长度帧解码器，解决粘包的问题：</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //数据包最大长度是1024        //长度域的起始索引是0        //长度域的数据长度是4        //矫正值为0，因为长度域只有 有效数据的长度的值        //丢弃数据起始值是4，因为长度域长度为4，我要把长度域丢弃，才能得到有效数据        ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>接着编写发送端代码，根据解码器的设置，进行发送：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 5; i++) {            String str = &quot;msg No&quot; + i;            ByteBuf byteBuf = Unpooled.buffer(1024);            byte[] bytes = str.getBytes(Charset.forName(&quot;utf-8&quot;));            //设置长度域的值，为有效数据的长度            byteBuf.writeInt(bytes.length);            //设置有效数据            byteBuf.writeBytes(bytes);            ctx.writeAndFlush(byteBuf);        }    }</code></pre><p>然后启动服务端，客户端，我们可以看到控制台打印结果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/6/17324aa254af3f3f?w=343&h=199&f=png&s=15892" srcset="/img/loading.gif" alt=""><br>可以看到，利用自定义长度帧解码器解决了粘包问题。</p><h2 id="2-3-使用Google-Protobuf编解码器"><a href="#2-3-使用Google-Protobuf编解码器" class="headerlink" title="2.3 使用Google Protobuf编解码器"></a>2.3 使用Google Protobuf编解码器</h2><p>Netty<a href="https://netty.io/" target="_blank" rel="noopener">官网</a>上是明显写着支持Google Protobuf的，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/6/17322cc3e98146fe?w=599&h=343&f=png&s=56992" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-1-Google-Protobuf是什么"><a href="#2-3-1-Google-Protobuf是什么" class="headerlink" title="2.3.1 Google Protobuf是什么"></a>2.3.1 Google Protobuf是什么</h3><blockquote><p>摘自官网的原话：<br>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p></blockquote><p>翻译一下：Protocol buffers是Google公司的<strong>与语言无关、平台无关、可扩展的序列化数据的机制</strong>，类似XML，但是<strong>更小、更快、更简单</strong>。您只需<strong>定义一次数据的结构化方式</strong>，然后就可以使用<strong>特殊生成的源代码</strong>，轻松地<strong>将结构化数据写入和读取到各种数据流中，并支持多种语言</strong>。</p><p><a href="https://developers.google.cn/protocol-buffers/" target="_blank" rel="noopener">Google Protobuf官网</a></p><h3 id="2-3-2-使用Google-Protobuf"><a href="#2-3-2-使用Google-Protobuf" class="headerlink" title="2.3.2 使用Google Protobuf"></a>2.3.2 使用Google Protobuf</h3><p>首先先下载编译器，我使用的是win系统，所以下载的是win版本。<a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.6.1" target="_blank" rel="noopener">下载编译器链接，版本是v3.6.1</a></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17324e5a84010099?w=1041&h=240&f=png&s=31916" srcset="/img/loading.gif" alt=""></p><p>如果官网下载慢的话，我已经下载了一个，并且上传到百度网盘，<a href="https://pan.baidu.com/s/11yckiP4uWXR9I0bKyRBzOQ" target="_blank" rel="noopener">网盘链接</a>，提取码：8b1r。公众号什么的随缘关注吧，哈哈~</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17329eb724fd70a4?w=741&h=364&f=png&s=19605" srcset="/img/loading.gif" alt=""></p><p>以下步骤参考Google Protobuf的github项目的<a href="https://github.com/protocolbuffers/protobuf/tree/master/java" target="_blank" rel="noopener">指南</a>。</p><h4 id="第一步：添加maven依赖"><a href="#第一步：添加maven依赖" class="headerlink" title="第一步：添加maven依赖"></a>第一步：添加maven依赖</h4><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;    &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;    &lt;version&gt;3.6.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="第二步：编写proto文件Message-proto"><a href="#第二步：编写proto文件Message-proto" class="headerlink" title="第二步：编写proto文件Message.proto"></a>第二步：编写proto文件Message.proto</h4><p>如何编写.proto文件的相关文档说明，可以去<a href="https://developers.google.cn/protocol-buffers/docs/proto3#scalar" target="_blank" rel="noopener">官网查看</a></p><p>下面我写一个例子，请看示范：</p><pre><code class="proto">syntax = &quot;proto3&quot;; //版本option java_outer_classname = &quot;MessagePojo&quot;;//生成的外部类名，同时也是文件名message Message {    int32 id = 1;//Message类的一个属性，属性名称是id，序号为1    string content = 2;//Message类的一个属性，属性名称是content，序号为2}</code></pre><h4 id="第三步：使用编译器，通过-proto文件生成代码"><a href="#第三步：使用编译器，通过-proto文件生成代码" class="headerlink" title="第三步：使用编译器，通过.proto文件生成代码"></a>第三步：使用编译器，通过.proto文件生成代码</h4><p>解压前面下载下来的压缩包protoc-3.6.1-win32.zip,然后打开\protoc-3.6.1-win32\bin目录下，可以看到有一个protoc.exe程序。如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/1732508b9c9007ee?w=635&h=108&f=png&s=6967" srcset="/img/loading.gif" alt=""></p><p>然后复制前面写好的Message.proto文件到此目录下，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250997e5b223c?w=638&h=136&f=png&s=10706" srcset="/img/loading.gif" alt=""></p><p>接着在此目录下打开命令行cmd，输入命令：protoc.exe –java_out=. Message.proto</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250bea472e4c7?w=521&h=107&f=png&s=3797" srcset="/img/loading.gif" alt=""></p><p>然后就可以看到生成的MessagePojo.java文件。最后把文件复制到IDEA项目中。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250d5605c8188?w=242&h=179&f=png&s=7294" srcset="/img/loading.gif" alt=""></p><h4 id="第四步：在发送端添加编码器，在接收端添加解码器"><a href="#第四步：在发送端添加编码器，在接收端添加解码器" class="headerlink" title="第四步：在发送端添加编码器，在接收端添加解码器"></a>第四步：在发送端添加编码器，在接收端添加解码器</h4><p>客户端添加编码器，对消息进行编码。</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //在发送端添加Protobuf编码器        ch.pipeline().addLast(new ProtobufEncoder());        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>服务端添加解码器，对消息进行解码。</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //添加Protobuf解码器，构造器需要指定解码具体的对象实例        ch.pipeline().addLast(new ProtobufDecoder(MessagePojo.Message.getDefaultInstance()));        //给pipeline管道设置处理器        ch.pipeline().addLast(new TcpServerHandler());    }</code></pre><h4 id="第五步：发送消息"><a href="#第五步：发送消息" class="headerlink" title="第五步：发送消息"></a>第五步：发送消息</h4><p>客户端发送消息，代码如下：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        //使用的是构建者模式进行创建对象        MessagePojo.Message message = MessagePojo                .Message                .newBuilder()                .setId(1)                .setContent(&quot;芜湖大司马，起飞~&quot;)                .build();        ctx.writeAndFlush(message);    }</code></pre><p>服务端接收到数据，并且打印：</p><pre><code class="java">    @Override    protected void channelRead0(ChannelHandlerContext ctx, MessagePojo.Message messagePojo) throws Exception {        System.out.println(&quot;id:&quot; + messagePojo.getId());        System.out.println(&quot;content:&quot; + messagePojo.getContent());    }</code></pre><p>测试结果正确：<br><img src="https://user-gold-cdn.xitu.io/2020/7/7/17325145051d6e3a?w=364&h=68&f=png&s=2580" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-3-分析Protocol的粘包、拆包"><a href="#2-3-3-分析Protocol的粘包、拆包" class="headerlink" title="2.3.3 分析Protocol的粘包、拆包"></a>2.3.3 分析Protocol的粘包、拆包</h3><p>实际上直接使用Protocol编解码器还是存在粘包问题的。</p><p>证明一下，发送端循环一百次发送100条”大司马，起飞”的消息，请看发送端代码演示：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 100; i++) {            MessagePojo.Message message = MessagePojo                    .Message                    .newBuilder()                    .setId(i)                    .setContent(i + &quot;号大司马，起飞~&quot;)                    .build();            ctx.writeAndFlush(message);        }    }</code></pre><p>这时，启动服务端，客户端后，你会在控制台看到如下错误：</p><blockquote><p>com.google.protobuf.InvalidProtocolBufferException: While parsing a protocol message, the input ended unexpectedly in the middle of a field.  This could mean either that the input has been truncated or that an embedded message misreported its own length.</p></blockquote><p>意思是：分析protocol消息时，输入意外地在字段中间结束。这可能意味着输入被截断，或者嵌入的消息误报了自己的长度。</p><p>其实就是粘包问题，多条数据合并成一条数据了，导致解析出现异常。</p><h3 id="2-3-4-解决Protocol的粘包、拆包问题"><a href="#2-3-4-解决Protocol的粘包、拆包问题" class="headerlink" title="2.3.4 解决Protocol的粘包、拆包问题"></a>2.3.4 解决Protocol的粘包、拆包问题</h3><p>只需要在发送端加上编码器<strong>ProtobufVarint32LengthFieldPrepender</strong></p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());        ch.pipeline().addLast(new ProtobufEncoder());        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>接收方加上解码器<strong>ProtobufVarint32FrameDecoder</strong></p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());        ch.pipeline().addLast(new ProtobufDecoder(MessagePojo.Message.getDefaultInstance()));        //给pipeline管道设置处理器        ch.pipeline().addLast(new TcpServerHandler());    }</code></pre><p>然后再启动服务端和客户端，我们可以看到<strong>马老师成功地起飞了</strong><del>~</del></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17329b2d05572fb7?w=261&h=284&f=png&s=15543" srcset="/img/loading.gif" alt=""></p><p>ProtobufVarint32LengthFieldPrepender编码器的工作如下：</p><pre><code class="java"> * BEFORE ENCODE (300 bytes)       AFTER ENCODE (302 bytes) * +---------------+               +--------+---------------+ * | Protobuf Data |--------------&gt;| Length | Protobuf Data | * |  (300 bytes)  |               | 0xAC02 |  (300 bytes)  | * +---------------+               +--------+---------------+@Sharablepublic class ProtobufVarint32LengthFieldPrepender extends MessageToByteEncoder&lt;ByteBuf&gt; {    @Override    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throws Exception {        int bodyLen = msg.readableBytes();        int headerLen = computeRawVarint32Size(bodyLen);        //写入请求头，消息长度        out.ensureWritable(headerLen + bodyLen);        writeRawVarint32(out, bodyLen);        //写入数据        out.writeBytes(msg, msg.readerIndex(), bodyLen);    }}</code></pre><p>ProtobufVarint32FrameDecoder解码器的工作如下：</p><pre><code class="java"> * BEFORE DECODE (302 bytes)       AFTER DECODE (300 bytes) * +--------+---------------+      +---------------+ * | Length | Protobuf Data |-----&gt;| Protobuf Data | * | 0xAC02 |  (300 bytes)  |      |  (300 bytes)  | * +--------+---------------+      +---------------+public class ProtobufVarint32FrameDecoder extends ByteToMessageDecoder {    @Override    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {        //标记读取的下标位置        in.markReaderIndex();        //获取读取的下标位置        int preIndex = in.readerIndex();        //解码，获取消息的长度,并且移动读取的下标位置        int length = readRawVarint32(in);        //比较解码前和解码后的下标位置，如果相等。表示字节数不够读取，跳到下一轮        if (preIndex == in.readerIndex()) {            return;        }        //如果消息的长度小于0，抛出异常        if (length &lt; 0) {            throw new CorruptedFrameException(&quot;negative length: &quot; + length);        }        //如果不够读取一个完整的数据，reset还原下标位置。        if (in.readableBytes() &lt; length) {            in.resetReaderIndex();        } else {            //否则，把数据写入到out，接收端就拿到了完整的数据了            out.add(in.readRetainedSlice(length));        } }</code></pre><p>总结一下：</p><p>发送端通过编码器在发送的时候在<strong>消息体前面加上一个描述数据长度的数据块</strong>。</p><p>接收方通过<strong>解码器先获取描述数据长度的数据块</strong>，知道完整数据的长度，<strong>然后根据数据长度获取一条完整的数据</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>创作不易</strong>，觉得有用就<strong>关注一下</strong>吧。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty入门</title>
    <link href="/2020/07/04/Netty%E5%85%A5%E9%97%A8/"/>
    <url>/2020/07/04/Netty%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731948029b90fc2?w=755&h=648&f=png&s=53135" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲述Netty框架的一些特性以及重要组件，希望看完之后能对Netty框架有一个比较直观的感受，希望能帮助读者快速入门Netty，减少一些弯路。</p><a id="more"></a><h1 id="一、Netty概述"><a href="#一、Netty概述" class="headerlink" title="一、Netty概述"></a>一、Netty概述</h1><p>官方的介绍：</p><blockquote><p>Netty is <em>an asynchronous event-driven network application framework</em><br>for rapid development of maintainable high performance protocol servers &amp; clients.</p></blockquote><p><strong>Netty</strong>是 一个<strong>异步事件驱动</strong>的网络应用程序框架，用于<strong>快速开发可维护的高性能协议服务器和客户端</strong>。</p><h1 id="二、为什么使用Netty"><a href="#二、为什么使用Netty" class="headerlink" title="二、为什么使用Netty"></a>二、为什么使用Netty</h1><p>从官网上介绍，Netty是一个网络应用程序框架，开发服务器和客户端。也就是用于网络编程的一个框架。既然是网络编程，Socket就不谈了，为什么不用NIO呢？</p><h2 id="2-1-NIO的缺点"><a href="#2-1-NIO的缺点" class="headerlink" title="2.1 NIO的缺点"></a>2.1 NIO的缺点</h2><p>对于这个问题，之前我写了一篇文章<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw" target="_blank" rel="noopener">《NIO入门》</a>对NIO有比较详细的介绍，NIO的主要问题是：</p><ul><li>NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</li><li>需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。</li><li>臭名昭著的epoll bug。它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本依然没得到根本性的解决。</li></ul><h2 id="2-2-Netty的优点"><a href="#2-2-Netty的优点" class="headerlink" title="2.2 Netty的优点"></a>2.2 Netty的优点</h2><p>相对地，Netty的优点有很多：</p><ul><li>API使用简单，学习成本低。</li><li>功能强大，内置了多种解码编码器，支持多种协议。</li><li>性能高，对比其他主流的NIO框架，Netty的性能最优。</li><li>社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。</li><li>Dubbo、Elasticsearch都采用了Netty，质量得到验证。</li></ul><h1 id="三、架构图"><a href="#三、架构图" class="headerlink" title="三、架构图"></a>三、架构图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194d4a8fd419c?w=592&h=348&f=png&s=55075" srcset="/img/loading.gif" alt=""></p><p>上面这张图就是在官网首页的架构图，我们从上到下分析一下。</p><blockquote><p>绿色的部分<strong>Core</strong>核心模块，包括零拷贝、API库、可扩展的事件模型。</p></blockquote><blockquote><p>橙色部分<strong>Protocol Support</strong>协议支持，包括Http协议、webSocket、SSL(安全套接字协议)、谷歌Protobuf协议、zlib/gzip压缩与解压缩、Large File Transfer大文件传输等等。</p></blockquote><blockquote><p>红色的部分<strong>Transport Services</strong>传输服务，包括Socket、Datagram、Http Tunnel等等。</p></blockquote><p>以上可看出Netty的功能、协议、传输方式都比较全，比较强大。</p><h1 id="四、永远的Hello-Word"><a href="#四、永远的Hello-Word" class="headerlink" title="四、永远的Hello Word"></a>四、永远的Hello Word</h1><p>首先搭建一个HelloWord工程，先熟悉一下API，还有为后面的学习做铺垫。以下面这张图为依据：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc0641d4ed5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt=""></p><h2 id="4-1-引入Maven依赖"><a href="#4-1-引入Maven依赖" class="headerlink" title="4.1 引入Maven依赖"></a>4.1 引入Maven依赖</h2><p>使用的版本是4.1.20，相对比较稳定的一个版本。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.netty&lt;/groupId&gt;    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;    &lt;version&gt;4.1.20.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="4-2-创建服务端启动类"><a href="#4-2-创建服务端启动类" class="headerlink" title="4.2 创建服务端启动类"></a>4.2 创建服务端启动类</h2><pre><code class="java">public class MyServer {    public static void main(String[] args) throws Exception {        //创建两个线程组 boosGroup、workerGroup        EventLoopGroup bossGroup = new NioEventLoopGroup();        EventLoopGroup workerGroup = new NioEventLoopGroup();        try {            //创建服务端的启动对象，设置参数            ServerBootstrap bootstrap = new ServerBootstrap();            //设置两个线程组boosGroup和workerGroup            bootstrap.group(bossGroup, workerGroup)                //设置服务端通道实现类型                    .channel(NioServerSocketChannel.class)                //设置线程队列得到连接个数                    .option(ChannelOption.SO_BACKLOG, 128)                //设置保持活动连接状态                    .childOption(ChannelOption.SO_KEEPALIVE, true)                //使用匿名内部类的形式初始化通道对象                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {                        @Override                        protected void initChannel(SocketChannel socketChannel) throws Exception {                            //给pipeline管道设置处理器                            socketChannel.pipeline().addLast(new MyServerHandler());                        }                    });//给workerGroup的EventLoop对应的管道设置处理器            System.out.println(&quot;java技术爱好者的服务端已经准备就绪...&quot;);            //绑定端口号，启动服务端            ChannelFuture channelFuture = bootstrap.bind(6666).sync();            //对关闭通道进行监听            channelFuture.channel().closeFuture().sync();        } finally {            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        }    }}</code></pre><h2 id="4-3-创建服务端处理器"><a href="#4-3-创建服务端处理器" class="headerlink" title="4.3 创建服务端处理器"></a>4.3 创建服务端处理器</h2><pre><code class="java">/** * 自定义的Handler需要继承Netty规定好的HandlerAdapter * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式 **/public class MyServerHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //获取客户端发送过来的消息        ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(&quot;收到客户端&quot; + ctx.channel().remoteAddress() + &quot;发送的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));    }    @Override    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {        //发送消息给客户端        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;服务端已收到消息，并给你发送一个问号?&quot;, CharsetUtil.UTF_8));    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {        //发生异常，关闭通道        ctx.close();    }}</code></pre><h2 id="4-4-创建客户端启动类"><a href="#4-4-创建客户端启动类" class="headerlink" title="4.4 创建客户端启动类"></a>4.4 创建客户端启动类</h2><pre><code class="java">public class MyClient {    public static void main(String[] args) throws Exception {        NioEventLoopGroup eventExecutors = new NioEventLoopGroup();        try {            //创建bootstrap对象，配置参数            Bootstrap bootstrap = new Bootstrap();            //设置线程组            bootstrap.group(eventExecutors)                //设置客户端的通道实现类型                    .channel(NioSocketChannel.class)                //使用匿名内部类初始化通道                .handler(new ChannelInitializer&lt;SocketChannel&gt;() {                        @Override                        protected void initChannel(SocketChannel ch) throws Exception {                            //添加客户端通道的处理器                            ch.pipeline().addLast(new MyClientHandler());                        }                    });            System.out.println(&quot;客户端准备就绪，随时可以起飞~&quot;);            //连接服务端            ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666).sync();            //对通道关闭进行监听            channelFuture.channel().closeFuture().sync();        } finally {            //关闭线程组            eventExecutors.shutdownGracefully();        }    }}</code></pre><h2 id="4-5-创建客户端处理器"><a href="#4-5-创建客户端处理器" class="headerlink" title="4.5 创建客户端处理器"></a>4.5 创建客户端处理器</h2><pre><code class="java">public class MyClientHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        //发送消息到服务端        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;, CharsetUtil.UTF_8));    }    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //接收服务端发送过来的消息        ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(&quot;收到服务端&quot; + ctx.channel().remoteAddress() + &quot;的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));    }}</code></pre><h2 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h2><p>先启动服务端，再启动客户端，就可以看到结果：</p><p>MyServer打印结果:</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194df71b69cc2?w=764&h=65&f=png&s=10322" srcset="/img/loading.gif" alt=""></p><p>MyClient打印结果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194e2409505c1?w=712&h=49&f=png&s=7914" srcset="/img/loading.gif" alt=""></p><h1 id="五、Netty的特性与重要组件"><a href="#五、Netty的特性与重要组件" class="headerlink" title="五、Netty的特性与重要组件"></a>五、Netty的特性与重要组件</h1><h2 id="5-1-taskQueue任务队列"><a href="#5-1-taskQueue任务队列" class="headerlink" title="5.1 taskQueue任务队列"></a>5.1 taskQueue任务队列</h2><p>如果Handler处理器有一些长时间的业务处理，可以交给<strong>taskQueue异步处理</strong>。怎么用呢，请看代码演示：</p><pre><code class="java">public class MyServerHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //获取到线程池eventLoop，添加线程，执行        ctx.channel().eventLoop().execute(new Runnable() {            @Override            public void run() {                try {                    //长时间操作，不至于长时间的业务操作导致Handler阻塞                    Thread.sleep(1000);                    System.out.println(&quot;长时间的业务处理&quot;);                } catch (Exception e) {                    e.printStackTrace();                }            }        });    }}</code></pre><p>我们打一个debug调试，是可以看到添加进去的taskQueue有一个任务。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194f4d1d340fc?w=675&h=233&f=png&s=18480" srcset="/img/loading.gif" alt=""></p><h2 id="5-2-scheduleTaskQueue延时任务队列"><a href="#5-2-scheduleTaskQueue延时任务队列" class="headerlink" title="5.2 scheduleTaskQueue延时任务队列"></a>5.2 scheduleTaskQueue延时任务队列</h2><p>延时任务队列和上面介绍的任务队列非常相似，只是多了一个可延迟一定时间再执行的设置，请看代码演示：</p><pre><code class="java">ctx.channel().eventLoop().schedule(new Runnable() {    @Override    public void run() {        try {            //长时间操作，不至于长时间的业务操作导致Handler阻塞            Thread.sleep(1000);            System.out.println(&quot;长时间的业务处理&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }},5, TimeUnit.SECONDS);//5秒后执行</code></pre><p>依然打开debug进行调试查看，我们可以有一个scheduleTaskQueue任务待执行中</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194f21adfa111?w=705&h=214&f=png&s=17798" srcset="/img/loading.gif" alt=""></p><h2 id="5-3-Future异步机制"><a href="#5-3-Future异步机制" class="headerlink" title="5.3 Future异步机制"></a>5.3 Future异步机制</h2><p>在搭建HelloWord工程的时候，我们看到有一行这样的代码：</p><pre><code class="java">ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666);</code></pre><p>很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？</p><p>ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。请看一段代码演示：</p><pre><code class="java">//添加监听器channelFuture.addListener(new ChannelFutureListener() {    //使用匿名内部类，ChannelFutureListener接口    //重写operationComplete方法    @Override    public void operationComplete(ChannelFuture future) throws Exception {        //判断是否操作成功            if (future.isSuccess()) {            System.out.println(&quot;连接成功&quot;);        } else {            System.out.println(&quot;连接失败&quot;);        }    }});</code></pre><h2 id="5-4-Bootstrap与ServerBootStrap"><a href="#5-4-Bootstrap与ServerBootStrap" class="headerlink" title="5.4 Bootstrap与ServerBootStrap"></a>5.4 Bootstrap与ServerBootStrap</h2><p>Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731950cf2dbd785?w=595&h=296&f=png&s=7746" srcset="/img/loading.gif" alt=""></p><p>可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。</p><p>一般来说，使用Bootstrap创建启动器的步骤可分为以下几步：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731951012e334fc?w=960&h=292&f=png&s=20428" srcset="/img/loading.gif" alt=""></p><h3 id="5-4-1-group"><a href="#5-4-1-group" class="headerlink" title="5.4.1 group()"></a>5.4.1 group()</h3><p>在上一篇文章<a href="https://mp.weixin.qq.com/s/vWbbn1qXRFVva8Y9yET18Q" target="_blank" rel="noopener">《Reactor模式》</a>中，我们就讲过服务端要使用两个线程组：</p><ul><li>bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。</li><li>workerGroup用于处理每一个连接发生的读写事件。</li></ul><p>一般创建线程组直接使用以下new就完事了：</p><pre><code class="java">EventLoopGroup bossGroup = new NioEventLoopGroup();EventLoopGroup workerGroup = new NioEventLoopGroup();</code></pre><p>有点好奇的是，既然是线程组，那线程数默认是多少呢？深入源码：</p><pre><code class="java">    //使用一个常量保存    private static final int DEFAULT_EVENT_LOOP_THREADS;    static {        //NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量        DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(                &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));        if (logger.isDebugEnabled()) {            logger.debug(&quot;-Dio.netty.eventLoopThreads: {}&quot;, DEFAULT_EVENT_LOOP_THREADS);        }    }    protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {        //如果不传入，则使用常量的值，也就是cpu核数的两倍        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);    }</code></pre><p>通过源码可以看到，默认的线程数是cpu核数的两倍。假设想自定义线程数，可以使用有参构造器：</p><pre><code class="java">//设置bossGroup线程数为1EventLoopGroup bossGroup = new NioEventLoopGroup(1);//设置workerGroup线程数为16EventLoopGroup workerGroup = new NioEventLoopGroup(16);</code></pre><h3 id="5-4-2-channel"><a href="#5-4-2-channel" class="headerlink" title="5.4.2 channel()"></a>5.4.2 channel()</h3><p>这个方法用于设置通道类型，当建立连接后，会根据这个设置创建对应的Channel实例。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731951ae3c43228?w=838&h=328&f=png&s=59491" srcset="/img/loading.gif" alt=""></p><p>使用debug模式可以看到</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731951f80b07785?w=495&h=212&f=png&s=16456" srcset="/img/loading.gif" alt=""></p><p>通道类型有以下：</p><p><strong>NioSocketChannel</strong>： 异步非阻塞的客户端 TCP Socket 连接。</p><p><strong>NioServerSocketChannel</strong>： 异步非阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。</p></blockquote><p>OioSocketChannel： 同步阻塞的客户端 TCP Socket 连接。</p><p>OioServerSocketChannel： 同步阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>稍微在本地调试过，用起来和Nio有一些不同，是阻塞的，所以API调用也不一样。因为是阻塞的IO，几乎没什么人会选择使用Oio，所以也很难找到例子。我稍微琢磨了一下，经过几次报错之后，总算调通了。代码如下：</p></blockquote><pre><code class="java">//server端代码，跟上面几乎一样，只需改三个地方//这个地方使用的是OioEventLoopGroupEventLoopGroup bossGroup = new OioEventLoopGroup();ServerBootstrap bootstrap = new ServerBootstrap();bootstrap.group(bossGroup)//只需要设置一个线程组boosGroup        .channel(OioServerSocketChannel.class)//设置服务端通道实现类型//client端代码，只需改两个地方//使用的是OioEventLoopGroupEventLoopGroup eventExecutors = new OioEventLoopGroup();//通道类型设置为OioSocketChannelbootstrap.group(eventExecutors)//设置线程组        .channel(OioSocketChannel.class)//设置客户端的通道实现类型</code></pre><p>NioSctpChannel： 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。<br>NioSctpServerChannel： 异步的 Sctp 服务器端连接。</p><blockquote><p>本地没启动成功，网上看了一些网友的评论，说是只能在linux环境下才可以启动。从报错信息看：SCTP not supported on this platform，不支持这个平台。因为我电脑是window系统，所以网友说的有点道理。</p></blockquote><h3 id="5-4-3-option-与childOption"><a href="#5-4-3-option-与childOption" class="headerlink" title="5.4.3 option()与childOption()"></a>5.4.3 option()与childOption()</h3><p>首先说一下这两个的区别。</p><p>option()设置的是服务端用于接收进来的连接，也就是boosGroup线程。</p><p>childOption()是提供给父管道接收到的连接，也就是workerGroup线程。</p><p>搞清楚了之后，我们看一下常用的一些设置有哪些：</p><p>SocketChannel参数，也就是childOption()常用的参数：</p><blockquote><p><strong>SO_RCVBUF</strong>     Socket参数，TCP数据接收缓冲区大小。<br><strong>TCP_NODELAY</strong>     TCP参数，立即发送数据，默认值为Ture。<br><strong>SO_KEEPALIVE</strong>     Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。</p></blockquote><p>ServerSocketChannel参数，也就是option()常用参数：</p><blockquote><p><strong>SO_BACKLOG</strong>     Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。</p></blockquote><p>由于篇幅限制，其他就不列举了，大家可以去网上找资料看看，了解一下。</p><h3 id="5-4-4-设置流水线-重点"><a href="#5-4-4-设置流水线-重点" class="headerlink" title="5.4.4 设置流水线(重点)"></a>5.4.4 设置流水线(重点)</h3><p>ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。</p><p>在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。代码演示如下：</p><pre><code class="java">//使用匿名内部类的形式初始化通道对象bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {    @Override    protected void initChannel(SocketChannel socketChannel) throws Exception {        //给pipeline管道设置自定义的处理器        socketChannel.pipeline().addLast(new MyServerHandler());    }});</code></pre><p>处理器Handler主要分为两种：</p><blockquote><p>ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器)</p></blockquote><p>入站指的是数据从底层java NIO Channel到Netty的Channel。</p><p>出站指的是通过Netty的Channel来操作底层的java NIO Channel。</p><p><strong>ChannelInboundHandlerAdapter处理器常用的事件有</strong>：</p><ol><li><p>注册事件 fireChannelRegistered。</p></li><li><p>连接建立事件 fireChannelActive。</p></li><li><p>读事件和读完成事件 fireChannelRead、fireChannelReadComplete。</p></li><li><p>异常通知事件 fireExceptionCaught。</p></li><li><p>用户自定义事件 fireUserEventTriggered。</p></li><li><p>Channel 可写状态变化事件 fireChannelWritabilityChanged。</p></li><li><p>连接关闭事件 fireChannelInactive。</p></li></ol><p><strong>ChannelOutboundHandler处理器常用的事件有</strong>：</p><ol><li><p>端口绑定 bind。</p></li><li><p>连接服务端 connect。</p></li><li><p>写事件 write。</p></li><li><p>刷新时间 flush。</p></li><li><p>读事件 read。</p></li><li><p>主动断开连接 disconnect。</p></li><li><p>关闭 channel 事件 close。</p></li></ol><blockquote><p>还有一个类似的handler()，主要用于装配parent通道，也就是bossGroup线程。一般情况下，都用不上这个方法。</p></blockquote><h3 id="5-4-5-bind"><a href="#5-4-5-bind" class="headerlink" title="5.4.5 bind()"></a>5.4.5 bind()</h3><p>提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步。</p><p>有五个同名的重载方法，作用都是用于绑定地址端口号。不一一介绍了。</p><h3 id="5-4-6-优雅地关闭EventLoopGroup"><a href="#5-4-6-优雅地关闭EventLoopGroup" class="headerlink" title="5.4.6 优雅地关闭EventLoopGroup"></a>5.4.6 优雅地关闭EventLoopGroup</h3><pre><code class="java">//释放掉所有的资源，包括创建的线程bossGroup.shutdownGracefully();workerGroup.shutdownGracefully();</code></pre><p>会关闭所有的child Channel。关闭之后，释放掉底层的资源。</p><h2 id="5-5-Channel"><a href="#5-5-Channel" class="headerlink" title="5.5 Channel"></a>5.5 Channel</h2><p>Channel是什么？不妨看一下官方文档的说明：</p><blockquote><p>A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind</p></blockquote><p>翻译大意：一种连接到网络套接字或能进行读、写、连接和绑定等I/O操作的组件。</p><p>如果上面这段说明比较抽象，下面还有一段说明：</p><blockquote><p>A channel provides a user:</p><p>the current state of the channel (e.g. is it open? is it connected?),<br>the configuration parameters of the channel (e.g. receive buffer size),<br>the I/O operations that the channel supports (e.g. read, write, connect, and bind), and<br>the ChannelPipeline which handles all I/O events and requests associated with the channel.</p></blockquote><p>翻译大意：</p><p>channel为用户提供：</p><ol><li><p>通道当前的状态（例如它是打开？还是已连接？）</p></li><li><p>channel的配置参数（例如接收缓冲区的大小）</p></li><li><p>channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。</p></li></ol><h3 id="5-5-1-获取channel的状态"><a href="#5-5-1-获取channel的状态" class="headerlink" title="5.5.1 获取channel的状态"></a>5.5.1 获取channel的状态</h3><pre><code class="java">boolean isOpen(); //如果通道打开，则返回trueboolean isRegistered();//如果通道注册到EventLoop，则返回trueboolean isActive();//如果通道处于活动状态并且已连接，则返回trueboolean isWritable();//当且仅当I/O线程将立即执行请求的写入操作时，返回true。</code></pre><p>以上就是获取channel的四种状态的方法。</p><h3 id="5-5-2-获取channel的配置参数"><a href="#5-5-2-获取channel的配置参数" class="headerlink" title="5.5.2 获取channel的配置参数"></a>5.5.2 获取channel的配置参数</h3><p>获取单条配置信息，使用getOption()，代码演示：</p><pre><code class="java">ChannelConfig config = channel.config();//获取配置参数//获取ChannelOption.SO_BACKLOG参数,Integer soBackLogConfig = config.getOption(ChannelOption.SO_BACKLOG);//因为我启动器配置的是128，所以我这里获取的soBackLogConfig=128</code></pre><p>获取多条配置信息，使用getOptions()，代码演示：</p><pre><code class="java">ChannelConfig config = channel.config();Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = config.getOptions();for (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; entry : options.entrySet()) {    System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue());}/**SO_REUSEADDR : falseWRITE_BUFFER_LOW_WATER_MARK : 32768WRITE_BUFFER_WATER_MARK : WriteBufferWaterMark(low: 32768, high: 65536)SO_BACKLOG : 128以下省略...*/</code></pre><h3 id="5-5-3-channel支持的IO操作"><a href="#5-5-3-channel支持的IO操作" class="headerlink" title="5.5.3 channel支持的IO操作"></a>5.5.3 channel支持的IO操作</h3><p><strong>写操作</strong>，这里演示从服务端写消息发送到客户端：</p><pre><code class="java">@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {    ctx.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;这波啊，这波是肉蛋葱鸡~&quot;, CharsetUtil.UTF_8));}</code></pre><p>客户端控制台：</p><pre><code class="java">//收到服务端/127.0.0.1:6666的消息：这波啊，这波是肉蛋葱鸡~</code></pre><p><strong>连接</strong>操作，代码演示：</p><pre><code class="java">ChannelFuture connect = channelFuture.channel().connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666));//一般使用启动器，这种方式不常用</code></pre><p><strong>通过channel获取ChannelPipeline</strong>，并做相关的处理：</p><pre><code class="java">//获取ChannelPipeline对象ChannelPipeline pipeline = ctx.channel().pipeline();//往pipeline中添加ChannelHandler处理器，装配流水线pipeline.addLast(new MyServerHandler());</code></pre><h2 id="5-6-Selector"><a href="#5-6-Selector" class="headerlink" title="5.6 Selector"></a>5.6 Selector</h2><p>在NioEventLoop中，有一个成员变量selector，这是nio包的Selector，在之前<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw" target="_blank" rel="noopener">《NIO入门》</a>中，我已经讲过Selector了。</p><p>Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731957c1e90bf2a?w=725&h=576&f=png&s=326067" srcset="/img/loading.gif" alt=""></p><h2 id="5-7-PiPeline与ChannelPipeline"><a href="#5-7-PiPeline与ChannelPipeline" class="headerlink" title="5.7 PiPeline与ChannelPipeline"></a>5.7 PiPeline与ChannelPipeline</h2><p>在前面介绍Channel时，我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。</p><p>于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731954229ab93ac?w=719&h=240&f=png&s=8344" srcset="/img/loading.gif" alt=""></p><p>在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。</p><h2 id="5-8-ChannelHandlerContext"><a href="#5-8-ChannelHandlerContext" class="headerlink" title="5.8 ChannelHandlerContext"></a>5.8 ChannelHandlerContext</h2><p>在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。</p><p>于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731954657f33870?w=540&h=230&f=png&s=7746" srcset="/img/loading.gif" alt=""></p><p>通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。</p><p>实际上ChannelHandlerContext在pipeline中是一个链表的形式。看一段源码就明白了：</p><pre><code class="java">//ChannelPipeline实现类DefaultChannelPipeline的构造器方法protected DefaultChannelPipeline(Channel channel) {    this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);    succeededFuture = new SucceededChannelFuture(channel, null);    voidPromise =  new VoidChannelPromise(channel, true);    //设置头结点head，尾结点tail    tail = new TailContext(this);    head = new HeadContext(this);    head.next = tail;    tail.prev = head;}</code></pre><p>下面我用一张图来表示，会更加清晰一点：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731954b31d6c9cf?w=942&h=262&f=png&s=16168" srcset="/img/loading.gif" alt=""></p><h2 id="5-9-EventLoopGroup"><a href="#5-9-EventLoopGroup" class="headerlink" title="5.9 EventLoopGroup"></a>5.9 EventLoopGroup</h2><p>我们先看一下EventLoopGroup的类图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731955081291714?w=738&h=216&f=png&s=6894" srcset="/img/loading.gif" alt=""></p><p>其中包括了常用的实现类NioEventLoopGroup。OioEventLoopGroup在前面的例子中也有使用过。</p><p>从Netty的架构图中，可以知道服务器是需要两个线程组进行配合工作的，而这个线程组的接口就是EventLoopGroup。</p><p>每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。</p><h3 id="5-9-1-轮询机制的实现原理"><a href="#5-9-1-轮询机制的实现原理" class="headerlink" title="5.9.1 轮询机制的实现原理"></a>5.9.1 轮询机制的实现原理</h3><p>我们不妨看一段DefaultEventExecutorChooserFactory的源码：</p><pre><code class="java">private final AtomicInteger idx = new AtomicInteger();private final EventExecutor[] executors;@Overridepublic EventExecutor next() {    //idx.getAndIncrement()相当于idx++，然后对任务长度取模    return executors[idx.getAndIncrement() &amp; executors.length - 1];}</code></pre><p>这段代码可以确定执行的方式是轮询机制，接下来debug调试一下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17319554d4546047?w=1241&h=520&f=png&s=82119" srcset="/img/loading.gif" alt=""></p><p>它这里还有一个判断，如果线程数不是2的N次方，则采用取模算法实现。</p><pre><code class="java">@Overridepublic EventExecutor next() {    return executors[Math.abs(idx.getAndIncrement() % executors.length)];}</code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>参考Netty官网文档：<a href="https://netty.io/4.1/api/index.html" target="_blank" rel="noopener">API文档</a></p><p><strong>创作不易</strong>，觉得有用就<strong>点个赞</strong>吧。</p><p>我不要下次一定，希望<strong>这次一定素质三连</strong>，感谢！</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reactor模式</title>
    <link href="/2020/07/01/Reactor%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/07/01/Reactor%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05ba3465c?w=894&h=436&f=png&s=45997" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="一、Reactor模式介绍"><a href="#一、Reactor模式介绍" class="headerlink" title="一、Reactor模式介绍"></a>一、Reactor模式介绍</h1><p>本文主要参考Doug Lea(大神)的“<strong>Scalable IO in Java</strong>”中讲述的Reactor模式。</p><p>原文地址：<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p>有兴趣的可以看看这本书，受益匪浅！</p><a id="more"></a><h2 id="1-1-什么是Reactor模式"><a href="#1-1-什么是Reactor模式" class="headerlink" title="1.1 什么是Reactor模式"></a>1.1 什么是Reactor模式</h2><p>Reactor模式一般翻译成”<strong>反应器模式</strong>“，也有人称为”<strong>分发者模式</strong>“。它是将客户端请求提交到一个或者多个服务处理程序的设计模式。工作原理是由<strong>一个线程来接收所有的请求</strong>，然后<strong>派发这些请求到相关的工作线程中</strong>。</p><h2 id="1-2-为什么使用Reactor模式"><a href="#1-2-为什么使用Reactor模式" class="headerlink" title="1.2 为什么使用Reactor模式"></a>1.2 为什么使用Reactor模式</h2><p>在java中，没有NIO出现之前都是使用socket编程。socket的接收请求是阻塞的，需要处理完一个请求才能处理下一个请求，所以在面对高并发的服务请求时，性能就会很差。</p><p>那有人就会说使用多线程（如下图所示）。接收到一个请求，就创建一个线程处理，这样就不会阻塞了。实际上这样的确是可以在提升性能上起到一定的作用，<strong>但是当请求很多的时候，就会创建大量的线程，维护线程需要资源的消耗，线程之间的切换也需要消耗性能</strong>。而且系统创建线程的数量也是有限的，所以当高并发时，会直接把系统拖垮。<br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05ef76206?w=736&h=316&f=png&s=203508" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由于以上的问题，提出了Reactor模式。</p><p>基于Java，Doug Lea（Java并发包作者）提出了三种形式，<strong>单Reactor单线程，单Reactor多线程和多Reactor多线程</strong>。</p><h1 id="二、Reactor模式的演进过程"><a href="#二、Reactor模式的演进过程" class="headerlink" title="二、Reactor模式的演进过程"></a>二、Reactor模式的演进过程</h1><p>在介绍三种Reactor模式前，先简单地说明三个角色：</p><blockquote><p><code>Reactor</code>：负责响应事件，将事件分发到绑定了对应事件的Handler，如果是连接事件，则分发到Acceptor。</p></blockquote><blockquote><p><code>Handler</code>：事件处理器。负责执行对应事件对应的业务逻辑。</p></blockquote><blockquote><p><code>Acceptor</code>：绑定了 connect 事件，当客户端发起connect请求时，Reactor会将accept事件分发给Acceptor处理。</p></blockquote><h2 id="2-1-单Reactor单线程"><a href="#2-1-单Reactor单线程" class="headerlink" title="2.1 单Reactor单线程"></a>2.1 单Reactor单线程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05bf6fbe7?w=714&h=310&f=png&s=84409" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>只有一个<code>select</code>循环接收请求，客户端（client）注册进来由<code>Reactor</code>接收注册事件，然后再由reactor分发（dispatch）出去，由下面的处理器（Handler）去处理。</p></blockquote><h3 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>一个餐厅里只有一个既是前台也是服务员的人，负责接待客人，也负责把客人点的菜下达给厨师。</p><h3 id="单Reactor单线程的特点"><a href="#单Reactor单线程的特点" class="headerlink" title="单Reactor单线程的特点"></a>单Reactor单线程的特点</h3><p>单线程的问题实际上是很明显的。只要其中一个Handler方法阻塞了，那就会导致所有的client的Handler都被阻塞了，也会导致注册事件也无法处理，无法接收新的请求。所以这种模式用的比较少，因为不能充分利用到多核的资源。</p><p>这种模式仅仅只能处理Handler比较快速完成的场景。</p><h2 id="2-2-单Reactor多线程"><a href="#2-2-单Reactor多线程" class="headerlink" title="2.2 单Reactor多线程"></a>2.2 单Reactor多线程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05fac64c3?w=721&h=496&f=png&s=181611" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>在<strong>单Reactor多线程</strong>中，注册接收事件都是由<code>Reactor</code>来做，其它的计算，编解码由一个线程池来做。从图中可以看出工作线程是多线程的，监听注册事件的<code>Reactor</code>还是单线程。</p></blockquote><h3 id="通俗解释-1"><a href="#通俗解释-1" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>相当于餐厅里有一个前台，多个服务员。前台只负责接待客人，服务员只负责服务客人。</p><h3 id="单Reactor多线程的特点"><a href="#单Reactor多线程的特点" class="headerlink" title="单Reactor多线程的特点"></a>单Reactor多线程的特点</h3><p>对比<strong>单Reactor单线程</strong>模型，多线程Reactor模式在Handler读写处理时，交给工作线程池处理，不会导致Reactor无法执行，因为Reactor分发和Handler处理是分开的，能充分地利用资源。从而提升应用的性能。</p><p>缺点：<br>Reactor只在主线程中运行，承担所有事件的监听和响应，如果短时间的高并发场景下，依然会造成性能瓶颈。</p><h2 id="2-3-多Reactor多线程"><a href="#2-3-多Reactor多线程" class="headerlink" title="2.3 多Reactor多线程"></a>2.3 多Reactor多线程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05faeebc1?w=686&h=483&f=png&s=121267" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>1、mainReactor负责监听客户端请求，专门处理新连接的建立，将建立好的连接注册到subReactor。<br>2、subReactor 将分配的连接加入到队列进行监听，当有新的事件发生时，会调用连接相对应的Handler进行处理。</p></blockquote><h3 id="通俗解释-2"><a href="#通俗解释-2" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>相当于餐厅里有多个前台和多个服务员，前台只负责接待客人，服务员只负责服务客人。</p><h3 id="多Reactor多线程的特点"><a href="#多Reactor多线程的特点" class="headerlink" title="多Reactor多线程的特点"></a>多Reactor多线程的特点</h3><p>mainReactor 主要是用来处理客户端请求连接建立的操作。<br>subReactor主要做和建立起来的连接做数据交互和事件业务处理操作，每个subReactor一个线程来处理。</p><blockquote><p>这样的模型使得每个模块更加专一，耦合度更低，能支持更高的并发量。许多框架也使用这种模式，比如接下来要讲的Netty框架就采用了这种模式。</p></blockquote><h1 id="三、在Netty中的应用"><a href="#三、在Netty中的应用" class="headerlink" title="三、在Netty中的应用"></a>三、在Netty中的应用</h1><p>Netty可谓是框架中精品中的极品，要用一张图或者一段话来总结概括不太可能，所以下面我仅分析一下Netty框架的架构模型。在下一篇文章再继续深入探究Netty。<br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc0641d4ed5?w=855&h=726&f=png&s=400825" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这个架构实际上跟多Reactor多线程模型比较像。</p><blockquote><p>1、BossGroup相当于mainReactor，负责建立连接并且把连接注册到WorkGroup中。WorkGroup负责处理连接对应的读写事件。</p></blockquote><blockquote><p>2、BossGroup和WorkGroup是两个线程池，里面有多个NioEventGroup(实际上是线程)，默认BossGroup和WorkGroup里的线程数是cpu核数的两倍（源码中有体现）。</p></blockquote><blockquote><p>3、每一个NioEventGroup都是一个无限循环，负责监听相对应的事件。</p></blockquote><blockquote><p>4、Pipeline(通道)里包含多个ChannelHandler(业务处理)，按顺序执行。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>其实上面的这些模型都只是一种思想，很多人可能觉得学习思想不是很重要。实际上要学习一门技术，要先有天上飞的理论才有落地的产品。世界上的事物大多都是如此。</p><p>最后借用大神<strong>Doug Lea</strong>的名言：</p><blockquote><p>分享知识和分享苹果是不一样的，苹果会越分越少，而自己的知识并不会因为给了别人就减少了，知识的分享更能激荡出不一样的火花。</p></blockquote><p><strong>创作不易</strong>，觉得有用就<strong>点个赞</strong>吧。</p><p>下一篇讲Netty框架，想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO入门</title>
    <link href="/2020/06/25/NIO%E5%85%A5%E9%97%A8/"/>
    <url>/2020/06/25/NIO%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/image-20200625230224224.png" srcset="/img/loading.gif" alt="image-20200625230224224"></p><blockquote><p>学如逆水行舟，不进则退</p></blockquote><h1 id="1-NIO概述"><a href="#1-NIO概述" class="headerlink" title="1 NIO概述"></a>1 NIO概述</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p><strong>java.nio</strong>全称<strong>java non-blocking IO</strong>，是指<strong>JDK1.4 及以上</strong>版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供<strong>缓存支持的数据容器</strong>，使用它可以提供<strong>非阻塞式</strong>的高伸缩性网络(来源于百度百科)。</p><a id="more"></a><h2 id="1-2-为什么使用NIO"><a href="#1-2-为什么使用NIO" class="headerlink" title="1.2 为什么使用NIO"></a>1.2 为什么使用NIO</h2><p>在上面的描述中提到，是在JDK1.4以上的版本才提供NIO，那在之前使用的是什么呢？答案很简单，就是<strong>BIO</strong>(阻塞式IO)，也就是我们常用的IO流。</p><p>BIO的问题其实不用多说了，因为在使用BIO时，主线程会进入阻塞状态，这就非常影响程序的性能，<strong>不能充分利用机器资源</strong>。但是这样就会有人提出疑问了，那我<strong>使用多线程</strong>不就可以了吗？</p><p>但是在高并发的情况下，会创建很多线程，线程会占用内存，线程之间的切换也会浪费资源开销。</p><p>而NIO<strong>只有在连接/通道真正有读写事件</strong>发生时(<strong>事件驱动</strong>)，<strong>才会进行读写</strong>，就大大地减少了系统的开销。不必为每一个连接都创建一个线程，也不必去维护多个线程。</p><p><strong>避免了多个线程之间的上下文切换</strong>，导致资源的浪费。</p><h1 id="为什么使用NIO"><a href="#为什么使用NIO" class="headerlink" title="为什么使用NIO"></a>为什么使用NIO</h1><h1 id="2-NIO的三大核心"><a href="#2-NIO的三大核心" class="headerlink" title="2 NIO的三大核心"></a>2 NIO的三大核心</h1><table><thead><tr><th>NIO的核心</th><th>对应的类或接口</th><th>应用</th><th>作用</th></tr></thead><tbody><tr><td>缓冲区</td><td>java.nio.Buffer</td><td>文件IO/网络IO</td><td>存储数据</td></tr><tr><td>通道</td><td>java.nio.channels.Channel</td><td>文件IO/网络IO</td><td>运输</td></tr><tr><td>选择器</td><td>java.nio.channels.Selector</td><td>网络IO</td><td>控制器</td></tr></tbody></table><h2 id="2-1缓冲区-Buffer"><a href="#2-1缓冲区-Buffer" class="headerlink" title="2.1缓冲区(Buffer)"></a>2.1缓冲区(Buffer)</h2><h3 id="2-1-1-什么是缓冲区"><a href="#2-1-1-什么是缓冲区" class="headerlink" title="2.1.1 什么是缓冲区"></a>2.1.1 什么是缓冲区</h3><p>我们先看以下这张类图，可以看到<code>Buffer</code>有七种类型。</p><p><img src="https://static.lovebilibili.com/Buffer.png" srcset="/img/loading.gif" alt=""></p><p><code>Buffer</code>是一个内存块。在<code>NIO</code>中，所有的数据都是用<code>Buffer</code>处理，有读写两种模式。所以NIO和传统的IO的区别就体现在这里。传统IO是面向<code>Stream</code>流，<code>NIO</code>而是面向缓冲区(<code>Buffer</code>)。</p><h3 id="2-1-2-常用的类型ByteBuffer"><a href="#2-1-2-常用的类型ByteBuffer" class="headerlink" title="2.1.2 常用的类型ByteBuffer"></a>2.1.2 常用的类型ByteBuffer</h3><p>一般我们常用的类型是<code>ByteBuffer</code>，把数据转成字节进行处理。实质上是一个<code>byte[]</code>数组。</p><pre><code class="java">public abstract class ByteBuffer extends Buffer implements Comparable&lt;ByteBuffer&gt;{    //存储数据的数组    final byte[] hb;    //构造器方法    ByteBuffer(int mark, int pos, int lim, int cap, byte[] hb, int offset) {        super(mark, pos, lim, cap);        //初始化数组        this.hb = hb;        this.offset = offset;    }}</code></pre><h3 id="2-1-3-创建Buffer的方式"><a href="#2-1-3-创建Buffer的方式" class="headerlink" title="2.1.3 创建Buffer的方式"></a>2.1.3 创建Buffer的方式</h3><p>主要分成两种：JVM堆内内存块Buffer、堆外内存块Buffer。</p><p>创建堆内内存块(非直接缓冲区)的方法是：</p><pre><code class="java">//创建堆内内存块HeapByteBufferByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);String msg = &quot;java技术爱好者&quot;;//包装一个byte[]数组获得一个Buffer，实际类型是HeapByteBufferByteBuffer byteBuffer2 = ByteBuffer.wrap(msg.getBytes());</code></pre><p>创建堆外内存块(直接缓冲区)的方法：</p><pre><code class="java">//创建堆外内存块DirectByteBufferByteBuffer byteBuffer3 = ByteBuffer.allocateDirect(1024);</code></pre><h4 id="2-1-3-1-HeapByteBuffer与DirectByteBuffer的区别"><a href="#2-1-3-1-HeapByteBuffer与DirectByteBuffer的区别" class="headerlink" title="2.1.3.1 HeapByteBuffer与DirectByteBuffer的区别"></a>2.1.3.1 HeapByteBuffer与DirectByteBuffer的区别</h4><p>其实根据类名就可以看出，<code>HeapByteBuffer</code>所创建的字节缓冲区就是在JVM堆中的，即JVM内部所维护的字节数组。而<code>DirectByteBuffer</code>是<strong>直接操作操作系统本地代码</strong>创建的<strong>内存缓冲数组</strong>。</p><p><code>DirectByteBuffer</code>的使用场景：</p><ol><li><p>java程序与本地磁盘、socket传输数据</p></li><li><p>大文件对象，可以使用。不会受到堆内存大小的限制。</p></li><li><p>不需要频繁创建，生命周期较长的情况，能重复使用的情况。</p></li></ol><p><code>HeapByteBuffer</code>的使用场景：</p><p>除了以上的场景外，其他情况还是建议使用<code>HeapByteBuffer</code>，没有达到一定的量级，实际上使用<code>DirectByteBuffer</code>是体现不出优势的。</p><h4 id="2-1-3-2-Buffer的初体验"><a href="#2-1-3-2-Buffer的初体验" class="headerlink" title="2.1.3.2 Buffer的初体验"></a>2.1.3.2 Buffer的初体验</h4><p>接下来，使用<code>ByteBuffer</code>做一个小例子，熟悉一下：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        String msg = &quot;java技术爱好者，起飞！&quot;;        //创建一个固定大小的buffer(返回的是HeapByteBuffer)        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);        byte[] bytes = msg.getBytes();        //写入数据到Buffer中        byteBuffer.put(bytes);        //切换成读模式，关键一步        byteBuffer.flip();        //创建一个临时数组，用于存储获取到的数据        byte[] tempByte = new byte[bytes.length];        int i = 0;        //如果还有数据，就循环。循环判断条件        while (byteBuffer.hasRemaining()) {            //获取byteBuffer中的数据            byte b = byteBuffer.get();            //放到临时数组中            tempByte[i] = b;            i++;        }        //打印结果        System.out.println(new String(tempByte));//java技术爱好者，起飞！    }</code></pre><p>这上面有一个<code>flip()</code>方法是很重要的。意思是切换到读模式。上面已经提到<strong>缓存区是双向的</strong>，<strong>既可以往缓冲区写入数据，也可以从缓冲区读取数据</strong>。但是不能同时进行，需要切换。那么这个切换模式的本质是什么呢？</p><h3 id="2-1-4-三个重要参数"><a href="#2-1-4-三个重要参数" class="headerlink" title="2.1.4 三个重要参数"></a>2.1.4 三个重要参数</h3><pre><code class="java">//位置，默认是从第一个开始private int position = 0;//限制，不能读取或者写入的位置索引private int limit;//容量，缓冲区所包含的元素的数量private int capacity;</code></pre><p>那么我们以上面的例子，一句一句代码进行分析：</p><pre><code class="java">String msg = &quot;java技术爱好者，起飞！&quot;;//创建一个固定大小的buffer(返回的是HeapByteBuffer)ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</code></pre><p>当创建一个缓冲区时，参数的值是这样的：</p><p><img src="https://static.lovebilibili.com/image-20200625122035548.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/image-20200625122337215.png" srcset="/img/loading.gif" alt="image-20200625122337215"></p><p>当执行到<code>byteBuffer.put(bytes)</code>，当<code>put()</code>进入多少数据，position就会增加多少，参数就会发生变化：</p><p><img src="https://static.lovebilibili.com/image-20200625122640979.png" srcset="/img/loading.gif" alt="image-20200625122640979"></p><p><img src="https://static.lovebilibili.com/image-20200625123835657.png" srcset="/img/loading.gif" alt="image-20200625123835657"></p><p>接下来关键一步<code>byteBuffer.flip()</code>，会发生如下变化：</p><p><img src="https://static.lovebilibili.com/image-20200625122931713.png" srcset="/img/loading.gif" alt="image-20200625122931713"></p><p><img src="https://static.lovebilibili.com/image-20200625123004623.png" srcset="/img/loading.gif" alt="image-20200625123004623"></p><p><code>flip()</code>方法的源码如下：</p><pre><code class="java">    public final Buffer flip() {        limit = position;        position = 0;        mark = -1;        return this;    }</code></pre><p>为什么要这样赋值呢？因为下面有一句循环条件判断：</p><pre><code class="java">byteBuffer.hasRemaining();public final boolean hasRemaining() {    //判断position的索引是否小于limit。    //所以可以看出limit的作用就是记录写入数据的位置，那么当读取数据时，就知道读到哪个位置    return position &lt; limit;}</code></pre><p>接下来就是在<code>while</code>循环中<code>get()</code>读取数据，读取完之后。</p><p><img src="https://static.lovebilibili.com/image-20200625123623688.png" srcset="/img/loading.gif" alt="image-20200625123623688"></p><p><img src="https://static.lovebilibili.com/image-20200625123745018.png" srcset="/img/loading.gif" alt="image-20200625123745018"></p><p>最后当<code>position</code>等于<code>limit</code>时，循环判断条件不成立，就跳出循环，读取完毕。</p><p>所以可以看出实质上<code>capacity</code>容量大小是不变的，实际上是通过控制<code>position</code>和<code>limit</code>的值来控制读写的数据。</p><h2 id="2-2-管道-Channel"><a href="#2-2-管道-Channel" class="headerlink" title="2.2 管道(Channel)"></a>2.2 管道(Channel)</h2><p>首先我们看一下Channel有哪些子类：</p><p><img src="https://static.lovebilibili.com/Channel.png" srcset="/img/loading.gif" alt=""></p><p>常用的Channel有这四种：</p><blockquote><p>FileChannel，读写文件中的数据。<br>SocketChannel，通过TCP读写网络中的数据。<br>ServerSockectChannel，监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。<br>DatagramChannel，通过UDP读写网络中的数据。</p></blockquote><p><strong>Channel本身并不存储数据，只是负责数据的运输</strong>。必须要和<code>Buffer</code>一起使用。</p><h3 id="2-2-1-获取通道的方式"><a href="#2-2-1-获取通道的方式" class="headerlink" title="2.2.1 获取通道的方式"></a>2.2.1 获取通道的方式</h3><h4 id="2-2-1-1-FileChannel"><a href="#2-2-1-1-FileChannel" class="headerlink" title="2.2.1.1 FileChannel"></a>2.2.1.1 FileChannel</h4><p>FileChannel的获取方式，下面举个文件复制拷贝的例子进行说明：</p><p><img src="https://static.lovebilibili.com/image-20200625130742262.png" srcset="/img/loading.gif" alt="image-20200625130742262"></p><p>首先准备一个”1.txt”放在项目的根目录下，然后编写一个main方法：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了        ByteBuffer byteBuffer = ByteBuffer.allocate((int)file.length());        //把输入流通道的数据读取到缓冲区        inputStreamChannel.read(byteBuffer);        //切换成读模式        byteBuffer.flip();        //把数据从缓冲区写入到输出流通道        outputStreamChannel.write(byteBuffer);        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }</code></pre><p>执行后，我们就获得一个”2.txt”。执行成功。</p><p><img src="https://static.lovebilibili.com/image-20200625130945572.png" srcset="/img/loading.gif" alt="image-20200625130945572"></p><p>以上的例子，可以用一张示意图表示，是这样的：</p><p><img src="https://static.lovebilibili.com/image-20200625132433945.png" srcset="/img/loading.gif" alt="image-20200625132433945"></p><h4 id="2-2-1-2-SocketChannel"><a href="#2-2-1-2-SocketChannel" class="headerlink" title="2.2.1.2 SocketChannel"></a>2.2.1.2 SocketChannel</h4><p>接下来我们学习获取<code>SocketChannel</code>的方式。</p><p>还是一样，我们通过一个例子来快速上手：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取ServerSocketChannel        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666);        //绑定地址，端口号        serverSocketChannel.bind(address);        //创建一个缓冲区        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);        while (true) {            //获取SocketChannel            SocketChannel socketChannel = serverSocketChannel.accept();            while (socketChannel.read(byteBuffer) != -1){                //打印结果                System.out.println(new String(byteBuffer.array()));                //清空缓冲区                byteBuffer.clear();            }        }    }</code></pre><p>然后运行main()方法，我们可以通过<code>telnet</code>命令进行连接测试：</p><p><img src="https://static.lovebilibili.com/image-20200625134508044.png" srcset="/img/loading.gif" alt="image-20200625134508044"></p><p>通过上面的例子可以知道，通过<code>ServerSocketChannel.open()</code>方法可以获取服务器的通道，然后绑定一个地址端口号，接着<code>accept()</code>方法可获得一个<code>SocketChannel</code>通道，也就是客户端的连接通道。</p><p>最后配合使用<code>Buffer</code>进行读写即可。</p><p>这就是一个简单的例子，实际上上面的例子是阻塞式的。要做到非阻塞还需要使用选择器<code>Selector</code>。</p><h2 id="2-3-选择器-Selector"><a href="#2-3-选择器-Selector" class="headerlink" title="2.3 选择器(Selector)"></a>2.3 选择器(Selector)</h2><p><code>Selector</code>翻译成<strong>选择器</strong>，有些人也会翻译成<strong>多路复用器</strong>，实际上指的是同一样东西。</p><p>只有网络IO才会使用选择器，文件IO是不需要使用的。</p><p>选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。换句话说，也就是事件驱动。以此实现<strong>单线程管理多个Channel</strong>的目的。</p><p><img src="https://static.lovebilibili.com/20180813104125886.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-1-核心API"><a href="#2-3-1-核心API" class="headerlink" title="2.3.1 核心API"></a>2.3.1 核心API</h3><table><thead><tr><th>API方法名</th><th>作用</th></tr></thead><tbody><tr><td>Selector.open()</td><td>打开一个选择器。</td></tr><tr><td>select()</td><td>选择一组键，其相应的通道已为 I/O 操作准备就绪。</td></tr><tr><td>selectedKeys()</td><td>返回此选择器的已选择键集。</td></tr></tbody></table><p>以上的API会在后面的例子用到，先有个印象。</p><h1 id="3-NIO快速入门"><a href="#3-NIO快速入门" class="headerlink" title="3 NIO快速入门"></a>3 NIO快速入门</h1><h2 id="3-1-文件IO"><a href="#3-1-文件IO" class="headerlink" title="3.1 文件IO"></a>3.1 文件IO</h2><h3 id="3-1-1-通道间的数据传输"><a href="#3-1-1-通道间的数据传输" class="headerlink" title="3.1.1 通道间的数据传输"></a>3.1.1 通道间的数据传输</h3><p>这里主要介绍两个通道与通道之间数据传输的方式：</p><p><code>transferTo()</code>：把源通道的数据传输到目的通道中。</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了        ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length());        //把输入流通道的数据读取到输出流的通道        inputStreamChannel.transferTo(0, byteBuffer.limit(), outputStreamChannel);        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }    </code></pre><p><code>transferFrom()</code>：把来自源通道的数据传输到目的通道。</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了        ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length());        //把输入流通道的数据读取到输出流的通道        outputStreamChannel.transferFrom(inputStreamChannel,0,byteBuffer.limit());        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }</code></pre><h3 id="3-1-2-分散读取和聚合写入"><a href="#3-1-2-分散读取和聚合写入" class="headerlink" title="3.1.2 分散读取和聚合写入"></a>3.1.2 分散读取和聚合写入</h3><p>我们先看一下FileChannel的源码：</p><pre><code class="java">public abstract class FileChannel extends AbstractInterruptibleChannel    implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel {   }</code></pre><p>从源码中可以看出实现了GatheringByteChannel, ScatteringByteChannel接口。也就是支持分散读取和聚合写入的操作。怎么使用呢，请看以下例子：</p><p>我们写一个main方法来实现复制1.txt文件，文件内容是：</p><pre><code class="java">abcdefghijklmnopqrstuvwxyz//26个字母</code></pre><p>代码如下：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建三个缓冲区，分别都是5        ByteBuffer byteBuffer1 = ByteBuffer.allocate(5);        ByteBuffer byteBuffer2 = ByteBuffer.allocate(5);        ByteBuffer byteBuffer3 = ByteBuffer.allocate(5);        //创建一个缓冲区数组        ByteBuffer[] buffers = new ByteBuffer[]{byteBuffer1, byteBuffer2, byteBuffer3};        //循环写入到buffers缓冲区数组中，分散读取        long read;        long sumLength = 0;        while ((read = inputStreamChannel.read(buffers)) != -1) {            sumLength += read;            Arrays.stream(buffers)                    .map(buffer -&gt; &quot;posstion=&quot; + buffer.position() + &quot;,limit=&quot; + buffer.limit())                    .forEach(System.out::println);            //切换模式            Arrays.stream(buffers).forEach(Buffer::flip);            //聚合写入到文件输出通道            outputStreamChannel.write(buffers);            //清空缓冲区            Arrays.stream(buffers).forEach(Buffer::clear);        }        System.out.println(&quot;总长度:&quot; + sumLength);        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }</code></pre><p>打印结果：</p><pre><code class="java">posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=1,limit=5总长度:26</code></pre><p>可以看到循环了两次。第一次循环时，三个缓冲区都读取了5个字节，总共读取了15，也就是读满了。还剩下11个字节，于是第二次循环时，前两个缓冲区分配了5个字节，最后一个缓冲区给他分配了1个字节，刚好读完。总共就是26个字节。</p><p>这就是分散读取，聚合写入的过程。</p><p>使用场景就是可以<strong>使用一个缓冲区数组，自动地根据需要去分配缓冲区的大小。可以减少内存消耗</strong>。网络IO也可以使用，这里就不写例子演示了。</p><h3 id="3-1-3-非直接-直接缓冲区"><a href="#3-1-3-非直接-直接缓冲区" class="headerlink" title="3.1.3 非直接/直接缓冲区"></a>3.1.3 非直接/直接缓冲区</h3><p>非直接缓冲区的创建方式：</p><pre><code class="java">static ByteBuffer allocate(int capacity)</code></pre><p>直接缓冲区的创建方式：</p><pre><code class="java">static ByteBuffer allocateDirect(int capacity)</code></pre><p>非直接/直接缓冲区的区别示意图：</p><p><img src="https://static.lovebilibili.com/307536-20170731145300974-520326124.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/307536-20170731145311224-406164516.png" srcset="/img/loading.gif" alt=""></p><p>从示意图中我们可以发现，最大的不同在于直接缓冲区不需要再把文件内容copy到物理内存中。这就大大地提高了性能。其实在介绍Buffer时，我们就有接触到这个概念。直接缓冲区是堆外内存，在本地文件IO效率会更高一点。</p><p>接下来我们来对比一下效率，以一个136 MB的视频文件为例：</p><pre><code class="java">public static void main(String[] args) throws Exception {    long starTime = System.currentTimeMillis();    //获取文件输入流    File file = new File(&quot;D:\\小电影.mp4&quot;);//文件大小136 MB    FileInputStream inputStream = new FileInputStream(file);    //从文件输入流获取通道    FileChannel inputStreamChannel = inputStream.getChannel();    //获取文件输出流    FileOutputStream outputStream = new FileOutputStream(new File(&quot;D:\\test.mp4&quot;));    //从文件输出流获取通道    FileChannel outputStreamChannel = outputStream.getChannel();    //创建一个直接缓冲区    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(5 * 1024 * 1024);    //创建一个非直接缓冲区    //ByteBuffer byteBuffer = ByteBuffer.allocate(5 * 1024 * 1024);    //写入到缓冲区    while (inputStreamChannel.read(byteBuffer) != -1) {        //切换读模式        byteBuffer.flip();        outputStreamChannel.write(byteBuffer);        byteBuffer.clear();    }    //关闭通道    outputStream.close();    inputStream.close();    outputStreamChannel.close();    inputStreamChannel.close();    long endTime = System.currentTimeMillis();    System.out.println(&quot;消耗时间：&quot; + (endTime - starTime) + &quot;毫秒&quot;);}</code></pre><p>结果：</p><p>直接缓冲区的消耗时间：283毫秒</p><p>非直接缓冲区的消耗时间：487毫秒</p><h2 id="3-2-网络IO"><a href="#3-2-网络IO" class="headerlink" title="3.2 网络IO"></a>3.2 网络IO</h2><p>其实NIO的主要用途是网络IO，在NIO之前java要使用网络编程就只有用<code>Socket</code>。而<code>Socket</code>是阻塞的，显然对于高并发的场景是不适用的。所以NIO的出现就是解决了这个痛点。</p><p>主要思想是把Channel通道注册到Selector中，通过Selector去监听Channel中的事件状态，这样就不需要阻塞等待客户端的连接，从主动等待客户端的连接，变成了通过事件驱动。没有监听的事件，服务器可以做自己的事情。</p><h3 id="3-2-1-使用Selector的小例子"><a href="#3-2-1-使用Selector的小例子" class="headerlink" title="3.2.1 使用Selector的小例子"></a>3.2.1 使用Selector的小例子</h3><p>接下来趁热打铁，我们来做一个服务器接受客户端消息的例子：</p><p>首先服务端代码：</p><pre><code class="java">public class NIOServer {    public static void main(String[] args) throws Exception {        //打开一个ServerSocketChannel        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666);        //绑定地址        serverSocketChannel.bind(address);        //设置为非阻塞        serverSocketChannel.configureBlocking(false);        //打开一个选择器        Selector selector = Selector.open();        //serverSocketChannel注册到选择器中,监听连接事件        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        //循环等待客户端的连接        while (true) {            //等待3秒，（返回0相当于没有事件）如果没有事件，则跳过            if (selector.select(3000) == 0) {                System.out.println(&quot;服务器等待3秒，没有连接&quot;);                continue;            }            //如果有事件selector.select(3000)&gt;0的情况,获取事件            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();            //获取迭代器遍历            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();            while (it.hasNext()) {                //获取到事件                SelectionKey selectionKey = it.next();                //判断如果是连接事件                if (selectionKey.isAcceptable()) {                    //服务器与客户端建立连接，获取socketChannel                    SocketChannel socketChannel = serverSocketChannel.accept();                    //设置成非阻塞                    socketChannel.configureBlocking(false);                    //把socketChannel注册到selector中，监听读事件，并绑定一个缓冲区                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));                }                //如果是读事件                if (selectionKey.isReadable()) {                    //获取通道                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();                    //获取关联的ByteBuffer                    ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();                    //打印从客户端获取到的数据                    socketChannel.read(buffer);                    System.out.println(&quot;from 客户端：&quot; + new String(buffer.array()));                }                //从事件集合中删除已处理的事件，防止重复处理                it.remove();            }        }    }}</code></pre><p>客户端代码：</p><pre><code class="java">public class NIOClient {    public static void main(String[] args) throws Exception {        SocketChannel socketChannel = SocketChannel.open();        InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666);        socketChannel.configureBlocking(false);        //连接服务器        boolean connect = socketChannel.connect(address);        //判断是否连接成功        if(!connect){            //等待连接的过程中            while (!socketChannel.finishConnect()){                System.out.println(&quot;连接服务器需要时间，期间可以做其他事情...&quot;);            }        }        String msg = &quot;hello java技术爱好者！&quot;;        ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());        //把byteBuffer数据写入到通道中        socketChannel.write(byteBuffer);        //让程序卡在这个位置，不关闭连接        System.in.read();    }}</code></pre><p>接下来启动服务端，然后再启动客户端，我们可以看到控制台打印以下信息：</p><pre><code class="java">服务器等待3秒，没有连接服务器等待3秒，没有连接from 客户端：hello java技术爱好者！                       服务器等待3秒，没有连接服务器等待3秒，没有连接</code></pre><p>通过这个例子我们引出以下知识点。</p><h3 id="3-2-2-SelectionKey"><a href="#3-2-2-SelectionKey" class="headerlink" title="3.2.2 SelectionKey"></a>3.2.2 SelectionKey</h3><p>在<code>SelectionKey</code>类中有四个常量表示四种事件，来看源码：</p><pre><code class="java">public abstract class SelectionKey {    //读事件    public static final int OP_READ = 1 &lt;&lt; 0; //2^0=1    //写事件    public static final int OP_WRITE = 1 &lt;&lt; 2; // 2^2=4    //连接操作,Client端支持的一种操作    public static final int OP_CONNECT = 1 &lt;&lt; 3; // 2^3=8    //连接可接受操作,仅ServerSocketChannel支持    public static final int OP_ACCEPT = 1 &lt;&lt; 4; // 2^4=16}</code></pre><p>附加的对象(可选)，把通道注册到选择器中时可以附加一个对象。</p><pre><code class="java">public final SelectionKey register(Selector sel, int ops, Object att)</code></pre><p>从<code>selectionKey</code>中获取附件对象可以使用<code>attachment()</code>方法</p><pre><code class="java">public final Object attachment() {    return attachment;}</code></pre><h1 id="4-使用NIO实现多人聊天室"><a href="#4-使用NIO实现多人聊天室" class="headerlink" title="4 使用NIO实现多人聊天室"></a>4 使用NIO实现多人聊天室</h1><p>接下来进行一个实战例子，用NIO实现一个多人运动版本的聊天室。</p><p>服务端代码：</p><pre><code class="java">public class GroupChatServer {    private Selector selector;    private ServerSocketChannel serverSocketChannel;    public static final int PORT = 6667;    //构造器初始化成员变量    public GroupChatServer() {        try {            //打开一个选择器            this.selector = Selector.open();            //打开serverSocketChannel            this.serverSocketChannel = ServerSocketChannel.open();            //绑定地址，端口号            this.serverSocketChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, PORT));            //设置为非阻塞            serverSocketChannel.configureBlocking(false);            //把通道注册到选择器中            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 监听，并且接受客户端消息，转发到其他客户端     */    public void listen() {        try {            while (true) {                //获取监听的事件总数                int count = selector.select(2000);                if (count &gt; 0) {                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                    //获取SelectionKey集合                    Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();                    while (it.hasNext()) {                        SelectionKey key = it.next();                        //如果是获取连接事件                        if (key.isAcceptable()) {                            SocketChannel socketChannel = serverSocketChannel.accept();                            //设置为非阻塞                            socketChannel.configureBlocking(false);                            //注册到选择器中                            socketChannel.register(selector, SelectionKey.OP_READ);                            System.out.println(socketChannel.getRemoteAddress() + &quot;上线了~&quot;);                        }                        //如果是读就绪事件                        if (key.isReadable()) {                            //读取消息，并且转发到其他客户端                            readData(key);                        }                        it.remove();                    }                } else {                    System.out.println(&quot;等待...&quot;);                }            }        } catch (Exception e) {            e.printStackTrace();        }    }    //获取客户端发送过来的消息    private void readData(SelectionKey selectionKey) {        SocketChannel socketChannel = null;        try {            //从selectionKey中获取channel            socketChannel = (SocketChannel) selectionKey.channel();            //创建一个缓冲区            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);            //把通道的数据写入到缓冲区            int count = socketChannel.read(byteBuffer);            //判断返回的count是否大于0，大于0表示读取到了数据            if (count &gt; 0) {                //把缓冲区的byte[]转成字符串                String msg = new String(byteBuffer.array());                //输出该消息到控制台                System.out.println(&quot;from 客户端：&quot; + msg);                //转发到其他客户端                notifyAllClient(msg, socketChannel);            }        } catch (Exception e) {            try {                //打印离线的通知                System.out.println(socketChannel.getRemoteAddress() + &quot;离线了...&quot;);                //取消注册                selectionKey.cancel();                //关闭流                socketChannel.close();            } catch (IOException e1) {                e1.printStackTrace();            }        }    }    /**     * 转发消息到其他客户端     * msg 消息     * noNotifyChannel 不需要通知的Channel     */    private void notifyAllClient(String msg, SocketChannel noNotifyChannel) throws Exception {        System.out.println(&quot;服务器转发消息~&quot;);        for (SelectionKey selectionKey : selector.keys()) {            Channel channel = selectionKey.channel();            //channel的类型实际类型是SocketChannel，并且排除不需要通知的通道            if (channel instanceof SocketChannel &amp;&amp; channel != noNotifyChannel) {                //强转成SocketChannel类型                SocketChannel socketChannel = (SocketChannel) channel;                //通过消息，包裹获取一个缓冲区                ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());                socketChannel.write(byteBuffer);            }        }    }    public static void main(String[] args) throws Exception {        GroupChatServer chatServer = new GroupChatServer();        //启动服务器，监听        chatServer.listen();    }}</code></pre><p>客户端代码：</p><pre><code class="java">public class GroupChatClinet {    private Selector selector;    private SocketChannel socketChannel;    private String userName;    public GroupChatClinet() {        try {            //打开选择器            this.selector = Selector.open();            //连接服务器            socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, GroupChatServer.PORT));            //设置为非阻塞            socketChannel.configureBlocking(false);            //注册到选择器中            socketChannel.register(selector, SelectionKey.OP_READ);            //获取用户名            userName = socketChannel.getLocalAddress().toString().substring(1);            System.out.println(userName + &quot; is ok~&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }    //发送消息到服务端    private void sendMsg(String msg) {        msg = userName + &quot;说：&quot; + msg;        try {            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));        } catch (Exception e) {            e.printStackTrace();        }    }    //读取服务端发送过来的消息    private void readMsg() {        try {            int count = selector.select();            if (count &gt; 0) {                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                while (iterator.hasNext()) {                    SelectionKey selectionKey = iterator.next();                    //判断是读就绪事件                    if (selectionKey.isReadable()) {                        SocketChannel channel = (SocketChannel) selectionKey.channel();                        //创建一个缓冲区                        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);                        //从服务器的通道中读取数据到缓冲区                        channel.read(byteBuffer);                        //缓冲区的数据，转成字符串，并打印                        System.out.println(new String(byteBuffer.array()));                    }                    iterator.remove();                }            }        } catch (Exception e) {            e.printStackTrace();        }    }    public static void main(String[] args) throws Exception {        GroupChatClinet chatClinet = new GroupChatClinet();        //启动线程，读取服务器转发过来的消息        new Thread(() -&gt; {            while (true) {                chatClinet.readMsg();                try {                    Thread.sleep(3000);                } catch (Exception e) {                    e.printStackTrace();                }            }        }).start();        //主线程发送消息到服务器        Scanner scanner = new Scanner(System.in);        while (scanner.hasNextLine()) {            String msg = scanner.nextLine();            chatClinet.sendMsg(msg);        }    }}</code></pre><p>先启动服务端的main方法，再启动两个客户端的main方法：</p><p><img src="https://static.lovebilibili.com/image-20200625225034967.png" srcset="/img/loading.gif" alt="image-20200625225034967"></p><p>然后使用两个客户端开始聊天了~</p><p><img src="https://static.lovebilibili.com/image-20200625225118983.png" srcset="/img/loading.gif" alt="image-20200625225118983"></p><p><img src="https://static.lovebilibili.com/image-20200625225130048.png" srcset="/img/loading.gif" alt="image-20200625225130048"></p><p>以上就是使用NIO<strong>实现多人聊天室</strong>的例子，同学们可以看着我这个例子自己完成一下。要多写代码才好理解这些概念。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>创作不易</strong>，觉得有用就<strong>点个赞</strong>吧。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让别人记住的程序员。我们下期再见！！！</strong></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List集合的坑</title>
    <link href="/2020/06/21/List%E9%9B%86%E5%90%88%E7%9A%84%E5%9D%91/"/>
    <url>/2020/06/21/List%E9%9B%86%E5%90%88%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学如逆水行舟，不进则退</p></blockquote><p>经过几年的工作经验，我发现<code>List</code>有很多坑，之前公司有些实习生一不小心就踩到了，所以我打算写一篇文章总结一下，希望看到这篇文章的人能不再踩到坑，代码没bug。做个快乐的程序员。</p><a id="more"></a><h3 id="迭代时删除元素"><a href="#迭代时删除元素" class="headerlink" title="迭代时删除元素"></a>迭代时删除元素</h3><p>使用<code>for-each</code>迭代遍历时，删除集合中的元素，会报错。</p><pre><code class="java">    private static List&lt;String&gt; list = new ArrayList&lt;&gt;();    static {        //初始化集合        for (int i = 1; i &lt;= 10; i++) {            list.add(String.valueOf(i));        }    }    public static void main(String[] args) {        //使用for-each迭代时删除元素        for (String str : list) {            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }    }</code></pre><p>或者你使用迭代器<code>Iterator</code>遍历时，删除元素。</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        Iterator&lt;String&gt; it = list.iterator();        while (it.hasNext()) {            String str = it.next();            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }    }</code></pre><p>以上两种情况都会报这个错：</p><pre><code class="java">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)    at java.util.ArrayList$Itr.next(ArrayList.java:851)</code></pre><p>这就是不正确的删除姿势，那怎么删呢？</p><p>使用<code>for-i</code>循环遍历删除(亲测有效)：</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        for (int i = 0; i &lt; list.size(); i++) {            String s = list.get(i);            if (&quot;1&quot;.equals(s)) {                list.remove(s);            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>使用<code>for-i</code>循环倒序遍历，删除元素。</p><pre><code class="java">    public static void main(String[] args) {        //使用for-i倒序遍历，删除元素        for (int i = list.size() - 1; i &gt;= 0; i--) {            String str = list.get(i);            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>使用<code>Iterator</code>的<code>remove()</code>方法删除。</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        Iterator&lt;String&gt; it = list.iterator();        while (it.hasNext()) {            String str = it.next();            if (&quot;1&quot;.equals(str)) {                it.remove();            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>要么潇洒一点，用<code>Lambda</code>表达式。在java8中，<code>List</code>增加了一个<code>removeIf()</code>方法用于删除。</p><pre><code class="java">    public static void main(String[] args) {        //使用removeIf()遍历时，删除元素。删除集合中为1的元素        list.removeIf(str -&gt; &quot;1&quot;.equals(str));        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><h3 id="使用asList-获得集合删除-增加"><a href="#使用asList-获得集合删除-增加" class="headerlink" title="使用asList()获得集合删除/增加"></a>使用asList()获得集合删除/增加</h3><p>看代码演示：</p><pre><code class="java">    public static void main(String[] args) {        List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6);        nums.add(7);    }</code></pre><pre><code class="java">    public static void main(String[] args) {        List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6);        nums.remove(1);    }</code></pre><p>如果你进行以上操作，就会看到报错：</p><pre><code class="java">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException    at java.util.AbstractList.remove(AbstractList.java:161)</code></pre><p>为什么会报这个错，看一下源代码就知道了！</p><pre><code class="java">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable {}</code></pre><p><code>ArrayList</code>不是<code>util</code>包的<code>ArrayList</code>，而是<code>Arrays</code>的一个内部类。因为继承了<code>AbstractList</code>抽象类，但是又没有实现<code>add()</code>、<code>remove()</code>方法。所以会调用抽象类的<code>add()</code>和<code>remove()</code>。<br>你猜猜抽象类的<code>add()</code>怎么着？</p><pre><code class="java">    public void add(int index, E element) {        throw new UnsupportedOperationException();    }    public E remove(int index) {        throw new UnsupportedOperationException();    }</code></pre><p>所以不能用<code>asList()</code>得到的集合去增删了！</p><h3 id="通过subList-方法获得集合后增删"><a href="#通过subList-方法获得集合后增删" class="headerlink" title="通过subList()方法获得集合后增删"></a>通过subList()方法获得集合后增删</h3><p>当使用<code>subList()</code>方法获得集合后删除，原(父)集合也会被删除。</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; subList = list.subList(0, 5);        System.out.println(list);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5]        subList.remove(&quot;1&quot;);        System.out.println(list);//[2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[2, 3, 4, 5]    }</code></pre><p>当使用<code>subList()</code>方法获得集合后增加元素，原(父)集合也会增加。</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; subList = list.subList(0, 5);        System.out.println(list);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5]        subList.add(&quot;11&quot;);        System.out.println(list);//[1, 2, 3, 4, 5, 11, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5, 11]    }</code></pre><p>大家看一下源码就知道什么原因了。</p><pre><code class="java">private class SubList extends AbstractList&lt;E&gt; implements RandomAccess {        public void add(int index, E e) {            rangeCheckForAdd(index);            checkForComodification();            //父集合添加元素            parent.add(parentOffset + index, e);            this.modCount = parent.modCount;            this.size++;        }        public E remove(int index) {            rangeCheck(index);            checkForComodification();            //父集合删除元素            E result = parent.remove(parentOffset + index);            this.modCount = parent.modCount;            this.size--;            return result;        }}</code></pre><p>如果希望截取的集合是和原集合互不干扰的话，可以这样：</p><pre><code class="java">List&lt;String&gt; subList = new ArrayList&lt;&gt;(list.subList(0, 5));</code></pre><h3 id="使用Collections-unmodifiableList-创建不可变集合也是可变的。"><a href="#使用Collections-unmodifiableList-创建不可变集合也是可变的。" class="headerlink" title="使用Collections.unmodifiableList()创建不可变集合也是可变的。"></a>使用Collections.unmodifiableList()创建不可变集合也是可变的。</h3><p>当不可变集合的原集合改变时，不可变集合也跟着改变。演示代码：</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(list);        System.out.println(unmodifiableList);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        //删除原集合元素        list.remove(&quot;1&quot;);        System.out.println(unmodifiableList);//[2, 3, 4, 5, 6, 7, 8, 9, 10]    }</code></pre><p>看源码就知道原因了：</p><pre><code class="java">    UnmodifiableList(List&lt;? extends E&gt; list) {        super(list);        this.list = list;    }</code></pre><p><strong>因为不可变集合的成员变量的引用是指向原集合的，所以当原集合改变时，不可变集合也会随之改变</strong>。</p><p>解决方式：使用<code>Guava</code>工具包的<code>ImmutableList.copyOf()</code>方法创建。</p><pre><code class="java">    public static void main(String[] args) throws Exception {        List&lt;String&gt; unmodifiableList = ImmutableList.copyOf(list);        list.remove(&quot;1&quot;);        System.out.println(unmodifiableList);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]    }</code></pre><p>创作不易，觉得有用就<strong>点个赞</strong>吧。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong><br><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
      <tag>经验总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC全局异常处理</title>
    <link href="/2020/06/14/SpringMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2020/06/14/SpringMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC全局异常处理"><a href="#SpringMVC全局异常处理" class="headerlink" title="SpringMVC全局异常处理"></a>SpringMVC全局异常处理</h1><p><code>SpringMVC</code>除了可以做<code>URL映射</code>和<code>请求拦截</code>外，还可以做<code>全局异常</code>的处理。全局异常处理可能我们平时比较少机会接触，但是每个项目都肯定会做这个处理。比如在上一间公司，是前后端分离的架构，所以后端只要有运行时异常就会报“系统异常，请稍后再试”。如果想要走上架构师的话，这个肯定是要学会的。</p><h2 id="SpringMVC全局异常处理机制"><a href="#SpringMVC全局异常处理机制" class="headerlink" title="SpringMVC全局异常处理机制"></a>SpringMVC全局异常处理机制</h2><p>首先，要知道全局异常处理，<code>SpringMVC</code>提供了两种方式：</p><ul><li>实现<code>HandlerExceptionResolver</code>接口，自定义异常处理器。</li><li>使用<code>HandlerExceptionResolver</code>接口的子类，也就是<code>SpringMVC</code>提供的异常处理器。</li></ul><p>所以，总得来说就两种方式，一种是自定义异常处理器，第二种是<code>SpringMVC</code>提供的。接下来先说<code>SpringMVC</code>提供的几种异常处理器的使用方式，然后再讲自定义异常处理器。</p><p><code>SpringMVC</code>提供的异常处理器有哪些呢？我们可以直接看源码的类图。</p><p><img src="https://static.lovebilibili.com/HandlerExceptionResolver.png" srcset="/img/loading.gif" alt=""></p><p>可以看出有四种：</p><ul><li><code>DefaultHandlerExceptionResolver</code>，默认的异常处理器。根据各个不同类型的异常，返回不同的异常视图。</li><li><code>SimpleMappingExceptionResolver</code>，简单映射异常处理器。通过配置异常类和view的关系来解析异常。</li><li><code>ResponseStatusExceptionResolver</code>，状态码异常处理器。解析带有<code>@ResponseStatus</code>注释类型的异常。</li><li><code>ExceptionHandlerExceptionResolver</code>，注解形式的异常处理器。对<code>@ExceptionHandler</code>注解的方法进行异常解析。</li></ul><h3 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h3><p>这个异常处理器是<code>SprngMVC</code>默认的一个处理器，处理一些常见的异常，比如：没有找到请求参数，参数类型转换异常，请求方式不支持等等。</p><p>接着我们看<code>DefaultHandlerExceptionResolver</code>类的<code>doResolveException()</code>方法：</p><pre><code class="java">    @Override    @Nullable    protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response,@Nullable Object handler, Exception ex) {        try {            if (ex instanceof HttpRequestMethodNotSupportedException) {                return handleHttpRequestMethodNotSupported((HttpRequestMethodNotSupportedException) ex, request,                        response, handler);            }            else if (ex instanceof HttpMediaTypeNotSupportedException) {                return handleHttpMediaTypeNotSupported((HttpMediaTypeNotSupportedException) ex, request, response,                        handler);            }            else if (ex instanceof HttpMediaTypeNotAcceptableException) {                return handleHttpMediaTypeNotAcceptable((HttpMediaTypeNotAcceptableException) ex, request, response,                        handler);            }            //省略...以下还有十几种异常的else-if        }catch (Exception handlerException) {            //是否打开日志，如果打开，那就记录日志            if (logger.isWarnEnabled()) {                logger.warn(&quot;Handling of [&quot; + ex.getClass().getName() + &quot;] resulted in Exception&quot;, handlerException);            }        }        return null;    }</code></pre><p>通过<code>if-else</code>判断，判断继承什么异常就显示对应的错误码和错误提示信息。由此可以知道，处理一般有两步，一是设置响应码，二是在响应头设置异常信息。下面是<code>MissingServletRequestPartException</code>的处理的源码：</p><pre><code class="java">    protected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex,            HttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {        //设置响应码，设置异常信息，SC_BAD_REQUEST就是400(bad request)        response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage());        return new ModelAndView();    }    //响应码    public static final int SC_BAD_REQUEST = 400;</code></pre><p>为什么要存在这个异常处理器呢？</p><p>从框架的设计理念来看，这种公共的、常见的异常应该交给框架本身来完成，是一些必需处理的异常。比如参数类型转换异常，如果程序员不处理，还有框架提供默认的处理方式，<strong>不至于出现这种错误而无法排查</strong>。</p><h3 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a>SimpleMappingExceptionResolver</h3><p>这种异常处理器需要提前配置异常类和对应的<code>view</code>视图。一般用于使用<code>JSP</code>的项目中，出现异常则通过这个异常处理器跳转到指定的页面。</p><p>怎么配置？首先搭建<code>JSP</code>项目我就不浪费篇幅介绍了。首先要加载一个<code>XML</code>文件。</p><pre><code class="java">@SpringBootApplication//在启动类，加载配置文件@ImportResource(&quot;classpath:spring-config.xml&quot;)public class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre><p>然后在<code>resources</code>目录下，创建一个<code>spring-config.xml</code>文件，内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;        &lt;!-- 定义默认的异常处理页面 --&gt;        &lt;property name=&quot;defaultErrorView&quot; value=&quot;err&quot;/&gt;        &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt;        &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;        &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常也页名作为值 --&gt;        &lt;property name=&quot;exceptionMappings&quot;&gt;            &lt;props&gt;                &lt;!-- 数组越界异常 --&gt;                &lt;prop key=&quot;java.lang.ArrayIndexOutOfBoundsException&quot;&gt;err/arrayIndexOutOfBounds&lt;/prop&gt;                &lt;!-- 空指针异常 --&gt;                &lt;prop key=&quot;java.lang.NullPointerException&quot;&gt;err/nullPointer&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>然后在<code>webapp</code>也就是存放<code>JSP</code>页面的目录下，创建两个<code>JSP</code>页面。</p><p><code>arrayIndexOutOfBounds.jsp</code>如下：</p><pre><code class="JSP">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;数组越界异常&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;数组越界异常&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%= ex.getMessage() %&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>nullPointer.jsp</code>如下：</p><pre><code class="JSP">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;空指针异常&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;空指针异常&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%=ex.getMessage()%&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>接着创建两个<code>Controller</code>，分别抛出空指针异常和数组越界异常。</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/null&quot;)    public String err() throws Exception{        String str = null;        //抛出空指针异常        int length = str.length();        System.out.println(length);        return &quot;index&quot;;    }    @RequestMapping(&quot;/indexOut&quot;)    public String indexOut() throws Exception{        int[] nums = new int[2];        for (int i = 0; i &lt; 3; i++) {            //抛出数组越界异常            nums[i] = i;            System.out.println(nums[i]);        }        return &quot;index&quot;;    }}</code></pre><p>启动项目后，我们发送两个请求，就可以看到：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_2.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/exceptionResolver_3.png" srcset="/img/loading.gif" alt=""></p><p>通过上述例子可以看出，其实对于现在<strong>前后端分离的项目</strong>来说，<strong>这种异常处理器已经不是很常用了</strong>。</p><h3 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h3><p>这种异常处理器主要用于处理带有<code>@ResponseStatus</code>注释的异常。下面演示一下使用方式。</p><p>首先自定义异常类继承<code>Exception</code>，并且使用<code>@ResponseStatus</code>注解修饰。如下：</p><pre><code class="java">//value需要使用HttpStatus枚举类型，HttpStatus.FORBIDDEN=403。@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;My defined Exception&quot;)public class DefinedException extends Exception{}</code></pre><p>然后再在<code>Controller</code>层抛出此异常。如下：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/myException&quot;)    public String ex(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception {        if (num == 1) {            //抛出自定义异常            throw new DefinedException();        }        return &quot;index&quot;;    }}</code></pre><p>然后启动项目，请求接口，可以看到如下信息：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_4.png" srcset="/img/loading.gif" alt=""></p><p>使用这种异常处理器，需要自定义一个异常，一定要一直往上层抛出异常，如果不往上层抛出，在<code>service</code>或者<code>dao</code>层就<code>try-catch</code>处理掉的话，是不会触发的。</p><h3 id="ExceptionHandlerExceptionResolver"><a href="#ExceptionHandlerExceptionResolver" class="headerlink" title="ExceptionHandlerExceptionResolver"></a>ExceptionHandlerExceptionResolver</h3><p>这个异常处理器才是最重要的，也是最常用，最灵活的，因为是使用注解。首先我们还是简单地演示一下怎么使用：</p><p>首先需要定义一个全局的异常处理器。</p><pre><code class="java">//这里使用了RestControllerAdvice，是@ResponseBody和@ControllerAdvice的结合//会把实体类转成JSON格式的提示返回，符合前后端分离的架构@RestControllerAdvicepublic class GlobalExceptionHandler {    //这里自定义了一个BaseException，当抛出BaseException异常就会被此方法处理    @ExceptionHandler(BaseException.class)    public ErrorInfo errorHandler(HttpServletRequest req, BaseException e) throws Exception {        ErrorInfo r = new ErrorInfo();        r.setMessage(e.getMessage());        r.setCode(ErrorInfo.ERROR);        r.setUrl(req.getRequestURL().toString());        return r;    }}</code></pre><p>然后我们自定义一个自定义异常类<code>BaseException</code>：</p><pre><code class="java">public class BaseException extends Exception {    public BaseException(String message) {        super(message);    }}</code></pre><p>然后在<code>Controller</code>层定义一个方法测试：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/base&quot;)    public String base() throws BaseException {        throw new BaseException(&quot;系统异常，请稍后重试。&quot;);    }}</code></pre><p>老规矩，启动项目，请求接口可以看到结果：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_1.jpg" srcset="/img/loading.gif" alt=""></p><p>你也可以不自定义异常<code>BaseException</code>，而直接拦截常见的各种异常都可以。所以这是一个非常灵活的异常处理器。你也可以做跳转页面，返回<code>ModelAndView</code>即可（以免篇幅过长就不演示了，哈哈）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>经过以上的演示后我们学习了<code>SpringMVC</code>四种异常处理器的工作机制，最后这种作为程序员我觉得是必须掌握的，前面的简单映射异常处理器和状态映射处理器可以选择性掌握，默认的异常处理器了解即可。</p><p>那这么多异常处理器，究竟是如何工作的呢？为什么是设计一个接口，下面有一个抽象类加上四个实现子类呢？接下来我们通过源码分析来揭开谜底！</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码分析从哪里入手呢？在<code>SpringMVC</code>中，其实你想都不用想，肯定在<code>DispatcherServlet</code>类里。经过我顺藤摸瓜，我定位在了<code>processHandlerException()</code>方法。怎么定位的呢？其实很简单，看源码：</p><pre><code class="java">    private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,            @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,            @Nullable Exception exception) throws Exception {        boolean errorView = false;        //异常不为空        if (exception != null) {            if (exception instanceof ModelAndViewDefiningException) {                logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);                mv = ((ModelAndViewDefiningException) exception).getModelAndView();            }            else {                Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);                //关键点：执行异常处理                mv = processHandlerException(request, response, handler, exception);                //省略...            }        }        //省略...    }</code></pre><h3 id="processHandlerException"><a href="#processHandlerException" class="headerlink" title="processHandlerException()"></a>processHandlerException()</h3><p>就是这个直接的一个<code>if-else</code>判断，那个<code>processHandlerException()</code>方法又是怎么处理的呢？</p><pre><code class="java">@Nullableprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,      @Nullable Object handler, Exception ex) throws Exception {   ModelAndView exMv = null;   //判断异常处理器的集合是否为空   if (this.handlerExceptionResolvers != null) {      //不为空则遍历异常处理器       for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {         //调用异常处理器的resolveException()方法进行处理异常         exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);         //判断返回的ModelAndView是否为null，不为null则跳出循环，为null则继续下一个异常处理器         if (exMv != null) {            break;         }      }   }   //如果ModelAndView不为空   if (exMv != null) {      if (exMv.isEmpty()) {         //设置异常信息提示         request.setAttribute(EXCEPTION_ATTRIBUTE, ex);         return null;      }      //如果返回的ModelAndView不包含view      if (!exMv.hasView()) {         //设置一个默认的视图          String defaultViewName = getDefaultViewName(request);         if (defaultViewName != null) {            exMv.setViewName(defaultViewName);         }      }      //省略...      //返回异常的ModelAndView          return exMv;   }   throw ex;}</code></pre><p>这不就是责任链模式吗！提前加载异常处理器到<code>handlerExceptionResolvers</code>集合中，然后遍历去执行，能处理就处理，不能处理就跳到下一个异常处理器处理。</p><p>那接下来我们就有一个问题了，<code>handlerExceptionResolvers</code>集合是怎么加载异常处理器的？这个问题很简单，就是使用<code>DispatcherServlet.properties</code>配置文件。这个文件真的很重要！！！</p><pre><code class="properties">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</code></pre><p>默认是加载以上三种异常处理器到集合中，所以只要带有<code>@ControllerAdvice</code>、<code>@ExceptionHandler</code>、<code>@ResponseStatus</code>注解的都会被扫描。<code>SimpleMappingExceptionResolver</code>则是通过<code>xml</code>文件(当然也可以使用<code>@Configuration</code>)去配置。</p><h3 id="resolveException"><a href="#resolveException" class="headerlink" title="resolveException()"></a>resolveException()</h3><p>其实在<code>resolveException()</code>处理异常的方法中，还使用了模板模式。</p><pre><code class="java">    @Override    @Nullable    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response,            @Nullable Object handler, Exception ex) {            //省略...            //预处理            prepareResponse(ex, response);            //调用了一个抽象方法，抽象方法由子类去实现            ModelAndView result = doResolveException(request, response, handler, ex);            //省略...    }</code></pre><p>抽象方法<code>doResolveException()</code>，由子类实现。</p><pre><code class="java">@Nullableprotected abstract ModelAndView doResolveException(HttpServletRequest request,      HttpServletResponse response, @Nullable Object handler, Exception ex);</code></pre><p>怎么识别模板方法，其实很简单，只要看到抽象类，有个具体方法里面调用了抽象方法，那很大可能就是模板模式。抽象方法就是模板方法，由子类实现。</p><p>子类我们都知道就是那四个异常处理器实现类了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用流程图概括一下：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_5.png" srcset="/img/loading.gif" alt=""></p><p>经过以上的学习后，我们知道只需要把异常处理器加到集合中，就可以执行。所以我们可以使用直接实现<code>HandlerExceptionResolver</code>接口的方式来实现异常处理器。</p><h2 id="实现HandlerExceptionResolver接口实现全局异常处理"><a href="#实现HandlerExceptionResolver接口实现全局异常处理" class="headerlink" title="实现HandlerExceptionResolver接口实现全局异常处理"></a>实现HandlerExceptionResolver接口实现全局异常处理</h2><p>首先自定一个异常类<code>MyException</code>。</p><pre><code class="java">public class MyException extends Exception {    public MyException(String message) {        super(message);    }}</code></pre><p>然后实现<code>HandlerExceptionResolver</code>接口定义一个异常处理器。</p><pre><code class="java">//注册异常处理器到Spring容器中@Componentpublic class MyExceptionHandler implements HandlerExceptionResolver {    @Override    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {        try {            //如果属于MyException异常，则输出异常提示到页面            if (ex instanceof MyException) {                response.setContentType(&quot;text/html;charset=utf-8&quot;);                response.getWriter().println(ex.getMessage());                //这里返回null，不做处理。也可以返回ModelAndView跳转页面                return null;            }        } catch (IOException e) {            e.printStackTrace();        }        return null;    }}</code></pre><p>然后在<code>Controller</code>层定义一个方法测试：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/myEx&quot;)    public String myEx() throws MyException {        System.out.println(&quot;执行myEx()&quot;);        throw new MyException(&quot;自定义异常提示信息&quot;);    }}</code></pre><p>启动项目，请求接口，我们可以看到：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_6.png" srcset="/img/loading.gif" alt=""></p><h1 id="最后说几句"><a href="#最后说几句" class="headerlink" title="最后说几句"></a>最后说几句</h1><p>以上就是我对于<code>SpringMVC</code>全局异常处理机制的理解。更多的<code>java</code>技术分享，可以关注我的公众号“<strong>java技术爱好者</strong>”，后续会不断更新。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringMVC</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题总结-基础篇</title>
    <link href="/2020/06/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2020/06/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="JVM、JRE、JDK有什么联系与区别？"><a href="#JVM、JRE、JDK有什么联系与区别？" class="headerlink" title="JVM、JRE、JDK有什么联系与区别？"></a>JVM、JRE、JDK有什么联系与区别？</h3><p><strong>JVM是java虚拟机</strong>，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。<br><strong>JRE是java运行时环境</strong>，它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。换句话说，JRE包含JVM。<br><strong>JDK是java开发工具包</strong>，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。JDK包含JRE。<br>所以总得来说，<strong>JDK&gt;JRE&gt;JVM</strong>。</p><h3 id="面向对象的特征有哪些？"><a href="#面向对象的特征有哪些？" class="headerlink" title="面向对象的特征有哪些？"></a>面向对象的特征有哪些？</h3><p>有三大特征，继承，封装，多态。</p><h3 id="为什么java可以实现跨平台？"><a href="#为什么java可以实现跨平台？" class="headerlink" title="为什么java可以实现跨平台？"></a>为什么java可以实现跨平台？</h3><p>因为java是编译成.class文件运行在JVM上的。<strong>针对不同的系统有不同的JVM实现，在不同的JVM实现上会映射到不同系统的 API 调用</strong>，从而实现代码的跨平台运行。</p><h3 id="类的加载顺序？"><a href="#类的加载顺序？" class="headerlink" title="类的加载顺序？"></a>类的加载顺序？</h3><p>静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。</p><h3 id="接口和抽象类有什么共同点和不同点？"><a href="#接口和抽象类有什么共同点和不同点？" class="headerlink" title="接口和抽象类有什么共同点和不同点？"></a>接口和抽象类有什么共同点和不同点？</h3><p>共同点：<br>1.都可以定义抽象方法，子类都要实现定义的抽象方法。<br>2.都不能被实例化，但是可以定义抽象类和接口类型的引用。<br>不同点：<br>1.接口没有构造器，抽象类可以定义构造器。<br>2.接口定义具体方法只能定义<strong>default</strong>修饰，抽象类可以直接定义具体方法。<br>3.接口的子类是实现接口，关键字是<strong>implements</strong>，抽象类的子类是继承，关键字是<strong>extends</strong>。<br>4.接口不能定义成员变量，只能定义常量。抽象类可以定义成员变量。</p><h3 id="static关键字有哪些用法？"><a href="#static关键字有哪些用法？" class="headerlink" title="static关键字有哪些用法？"></a>static关键字有哪些用法？</h3><p>①<strong>修饰成员变量，用static修饰的成员变量就成为静态变量</strong>，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。<br>②<strong>static修饰方法，该方法就被定义为静态方法</strong>，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。<br>③<strong>用static修饰代码块，该代码块就被定义为静态代码块</strong>，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。</p><h3 id="Switch能用什么数据类型作为参数？"><a href="#Switch能用什么数据类型作为参数？" class="headerlink" title="Switch能用什么数据类型作为参数？"></a>Switch能用什么数据类型作为参数？</h3><p>JDK1.5前：<strong>byte、short、char、int</strong><br>JDK1.5：枚举<br>JDK1.7：String</p><h3 id="枚举有哪些特点？在项目中如何使用？"><a href="#枚举有哪些特点？在项目中如何使用？" class="headerlink" title="枚举有哪些特点？在项目中如何使用？"></a>枚举有哪些特点？在项目中如何使用？</h3><p>特点：<br>1.枚举的构造器是私有的。<br>2.枚举不能被继承。<br>3.枚举是绝对的单例，即使是反序列化也无法创建多个实例。<br>使用场景：<br>当变量只能从一堆固定的值中取出一个时，那么就应该使用枚举。比如时间的单位，季度等等。</p><h3 id="什么是方法重载？什么是方法重写？"><a href="#什么是方法重载？什么是方法重写？" class="headerlink" title="什么是方法重载？什么是方法重写？"></a>什么是方法重载？什么是方法重写？</h3><p><strong>方法重载</strong>，一个类中允许同时存在一个以上的同名方法，主要体现在方法参数的类型和数量不同，方法名相同，与访问修饰符和返回值类型都是无关的。口诀是”<strong>一同两不同</strong>“。<br><strong>方法重写</strong>一般在继承中，子类重写父类的方法，既然是重写一遍，那么方法名和参数部分一定是相同的。只是实现的功能不同。<strong>声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，声明为 private 的方法不能被重写。</strong></p><h3 id="静态变量和实例变量有什么不同？分别位于内存的什么区域？"><a href="#静态变量和实例变量有什么不同？分别位于内存的什么区域？" class="headerlink" title="静态变量和实例变量有什么不同？分别位于内存的什么区域？"></a>静态变量和实例变量有什么不同？分别位于内存的什么区域？</h3><p>1.静态变量使用static修饰，实例变量不需要。<br>2.静态变量在类被加载时就会分配内存空间，就可以使用。实例变量需要实例对象才会分配内存空间，才可以被引用，是属于实例的。<br>3.静态变量是存在于<strong>静态区(全局区)</strong>的，实例变量位于<strong>堆内存</strong>中。</p><h3 id="java的内部类的分类有哪些？"><a href="#java的内部类的分类有哪些？" class="headerlink" title="java的内部类的分类有哪些？"></a>java的内部类的分类有哪些？</h3><p>实例内部类、静态内部类、局部内部类、匿名内部类。</p><h3 id="break、continue、return-的作用是什么？"><a href="#break、continue、return-的作用是什么？" class="headerlink" title="break、continue、return 的作用是什么？"></a>break、continue、return 的作用是什么？</h3><ul><li>break：结束循环。不仅可以结束其所在的循环，还可结束其外层循环。</li><li>continue：跳过本次循环，开始下一次循环。</li><li>return：不是专用于结束循环，而是用于结束方法。如果在循环中使用return，就会结束整个方法，循环当然也会结束。<h3 id="Object类有哪些常用的方法？"><a href="#Object类有哪些常用的方法？" class="headerlink" title="Object类有哪些常用的方法？"></a>Object类有哪些常用的方法？</h3></li></ul><p><strong>toString()、equals()、hashCode()。</strong></p><ul><li><code>toString()</code>默认输出对象的内存地址，一般不希望输出内存地址可以重写toString()方法。</li><li><code>equals()</code>方法用于比较对象是否相等，默认比较是内存地址，所以要正确比较两个对象是否值相等，此方法必须被重写。</li><li><code>hashCode()</code>方法用来返回其所在对象的物理地址（哈希码值），常会和<code>equals()</code>方法同时重写，确保相等的两个对象拥有相等的<strong>hashCode</strong>。<h3 id="与equals-的区别？"><a href="#与equals-的区别？" class="headerlink" title="==与equals()的区别？"></a>==与equals()的区别？</h3><code>equals()</code>方法属于<code>Object</code>对象的，所以比较基础数据类型是不能使用<code>equals()</code>。必须使用<code>==</code>。</li></ul><p><strong>在默认情况下</strong>，<code>equals()</code>与<code>==</code>是一样的，都是比较内存地址。所以在业务逻辑中，我们一般会重写<code>equals()</code>方法。</p><h3 id="equals-与hashCode-有什么联系？"><a href="#equals-与hashCode-有什么联系？" class="headerlink" title="equals()与hashCode()有什么联系？"></a>equals()与hashCode()有什么联系？</h3><p>1.<code>equals()</code>相等的两个对象他们的<code>hashCode()</code>肯定相等，也就是用<code>equals()</code>对比是绝对可靠的。<br>2.<code>hashCode()</code>相等的两个对象他们的<code>equals()</code>不一定相等，也就是<code>hashCode()</code>不是绝对可靠的。<br>在使用<code>HashSet</code>或者<code>HashMap</code>集合中，比较两个对象是否相等时，会先调用<code>hashCode()</code>比较，如果<code>hashCode()</code>相等，则会继续调用<code>equals()</code>比较，<code>equals()</code>也相等才会认为是同一个对象。如果<code>hashCode()</code>返回不相等，则认为是不相等的对象。<br>所以一般我们会同时重写<code>hashCode()</code>和<code>equals()</code>方法。</p><h3 id="amp-和-amp-amp-有什么区别？"><a href="#amp-和-amp-amp-有什么区别？" class="headerlink" title="&amp; 和 &amp;&amp;有什么区别？"></a>&amp; 和 &amp;&amp;有什么区别？</h3><p><code>&amp;&amp;</code>具有短路的功能，也就是如果<code>&amp;&amp;</code>左边的条件为<code>fasle</code>就不再执行后面的条件判断。<br><code>&amp;</code>则会执行完左右两边的条件判断。</p><h3 id="final、finalize-、finally-分别有什么作用？"><a href="#final、finalize-、finally-分别有什么作用？" class="headerlink" title="final、finalize()、finally{}分别有什么作用？"></a>final、finalize()、finally{}分别有什么作用？</h3><p><code>final</code>修饰类，表明这个类不可被其他类继承。<br><code>final</code>修饰成员变量，表示此变量为常量，只能在初始化时被赋值一次，赋值后不能修改。<br><code>final</code>修饰方法。把方法锁定，不能被子类重写，以防止子类对其进行更改。<br><code>finalize()</code>是<code>Object</code>里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。一个对象的<code>finalize()</code>方法只会被调用一次。<br><code>finally</code>作为异常处理的一部分，它只能用在<code>try/catch</code>语句中，并且附带一个语句块。</p><h3 id="Cloneable接口有什么作用？"><a href="#Cloneable接口有什么作用？" class="headerlink" title="Cloneable接口有什么作用？"></a>Cloneable接口有什么作用？</h3><p><code>Cloneable</code>接口是一个标记接口，实现了此接口，表示可以使用<code>clone()</code>方法，没有实现此接口使用<code>clone()</code>会抛出<code>CloneNotSupportedException</code>异常。</p><h3 id="什么是浅克隆，什么是深克隆？"><a href="#什么是浅克隆，什么是深克隆？" class="headerlink" title="什么是浅克隆，什么是深克隆？"></a>什么是浅克隆，什么是深克隆？</h3><p><strong>浅克隆是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量）</strong>，而不拷贝对象包含的引用指向的对象。</p><p><strong>深克隆不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。</strong></p><h3 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h3><p>序列化：把<strong>对象</strong>转换为<strong>字节序列</strong>的过程称为对象的序列化。<br>反序列化：把<strong>字节序列</strong>恢复为<strong>对象</strong>的过程称为对象的反序列化。</p><h3 id="Serializable接口有什么作用？"><a href="#Serializable接口有什么作用？" class="headerlink" title="Serializable接口有什么作用？"></a>Serializable接口有什么作用？</h3><p><code>Serializable</code>接口是一个标记接口，一个类只有实现了<code>Serializable</code>接口，它的对象才是可序列化的。否则序列化时会报<code>NotSerializableException</code>异常。如果不显性声明<code>serialVersionUID</code>，则会默认生成一个。为了<code>serialVersionUID</code>的确定性，最好是显性声明。</p><h3 id="String、StringBuffer、StringBuilder有什么区别"><a href="#String、StringBuffer、StringBuilder有什么区别" class="headerlink" title="String、StringBuffer、StringBuilder有什么区别?"></a>String、StringBuffer、StringBuilder有什么区别?</h3><ul><li><code>String</code>被声明为<code>final class</code>，是由定义<code>final</code>的字符数组实现的，因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。<ul><li><code>StringBuffer</code>是由定义了临时数据<code>transient</code>的字符数组实现的，提供<code>append()</code>和<code>add()</code>方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列，所有修改数据的方法都加上<code>synchronized</code>。性能相对<code>StringBuilder</code>会差一点。</li></ul></li><li><code>StringBuilder</code>和<code>StringBuffer</code>本质上没什么区别，区别是去掉了保证线程安全的<code>synchronized</code>，减少了开销，性能有所提高。<h3 id="什么是泛型-什么是泛型的上界和下界"><a href="#什么是泛型-什么是泛型的上界和下界" class="headerlink" title="什么是泛型?什么是泛型的上界和下界?"></a>什么是泛型?什么是泛型的上界和下界?</h3>Java 泛型是 JDK1.5中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<br>上界用<code>extends</code>关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。<br>下界用<code>super</code>进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至Object。<h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><strong>Java反射机制</strong>是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在<strong>运行时动态的获取信息以及动态调用对象的方法的功能</strong>称为Java的反射机制。<h3 id="获取Class对象的方式有哪些？"><a href="#获取Class对象的方式有哪些？" class="headerlink" title="获取Class对象的方式有哪些？"></a>获取Class对象的方式有哪些？</h3><ul><li>通过<code>Object</code>类中的<code>getClass()</code>方法，想要用这种方法必须要明确具体的类并且创建该类的对象。</li><li>所有数据类型都具备一个静态的属性<code>.class</code>来获取对应的<code>Class</code>对象。但是还是要明确到类，然后才能调用类中的静态成员。</li><li>通过<code>Class.forName()</code>方法完成，必须要指定类的全限定名，由于前两种方法都是在知道该类的情况下获取该类的字节码对象，因此不会有异常，但是<code>Class.forName()</code>方法如果写错类的路径会报<code>ClassNotFoundException</code>的异常。<h3 id="java中的异常有哪几种异常？"><a href="#java中的异常有哪几种异常？" class="headerlink" title="java中的异常有哪几种异常？"></a>java中的异常有哪几种异常？</h3><code>Throwable</code>类是<code>Java</code>异常类型的顶层父类，<code>Throwable</code>包含了<code>Error</code>和<code>Excetion</code>。<code>Excetion</code>分为两种，一种是<strong>非运行时异常(又称为检查异常)</strong>，另一种是<strong>运行时异常(RuntimeException)</strong>。<h3 id="java是如何处理异常的？"><a href="#java是如何处理异常的？" class="headerlink" title="java是如何处理异常的？"></a>java是如何处理异常的？</h3></li><li><code>Error</code>是程序无法处理的, 比如<code>OutOfMemoryError</code>、<code>OutOfMemoryError</code>等等, 这些异常发生时, <code>JVM</code>一般会终止线程。</li><li>运行时异常(<code>RuntimeException</code>)，如 <code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>等，是在程序运行的时候可能会发生的，所以程序可以捕捉，也可以不捕捉。这些错误一般是由程序的逻辑错误引起的，<strong>程序应该从逻辑角度去尽量避免</strong>。</li><li>非运行时异常是<code>RuntimeException</code>以外的异常，是<code>Exception</code>及其子类，这些异常从程序的角度来说是必须经过捕捉检查处理的，否则不能通过编译。如<code>IOException</code>、<code>SQLException</code>等。<h1 id="java集合、IO流、日期处理等"><a href="#java集合、IO流、日期处理等" class="headerlink" title="java集合、IO流、日期处理等"></a>java集合、IO流、日期处理等</h1><h3 id="常用的集合有哪些？"><a href="#常用的集合有哪些？" class="headerlink" title="常用的集合有哪些？"></a>常用的集合有哪些？</h3>常用集合有<strong>Map、List、Set</strong>。<h3 id="HashMap是线程安全的吗？"><a href="#HashMap是线程安全的吗？" class="headerlink" title="HashMap是线程安全的吗？"></a>HashMap是线程安全的吗？</h3>不是线程安全的。<h3 id="如何使HashMap线程安全？"><a href="#如何使HashMap线程安全？" class="headerlink" title="如何使HashMap线程安全？"></a>如何使HashMap线程安全？</h3>使用<code>Collections</code>类的<code>synchronizedMap()</code>方法包装。<pre><code class="java">Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</code></pre>使用<code>java.util.concurrent</code>包下的<code>ConcurrentHashMap</code>类也可以获得线程安全的Map。<pre><code class="java">ConcurrentHashMap concurrentHashMap = new ConcurrentHashMap();</code></pre>使用<code>Hashtable</code>类，也可以获得线程安全的Map<pre><code class="java">Map&lt;String,Object&gt; hashtable = new Hashtable&lt;&gt;();</code></pre><h3 id="HashMap和Hashtable的区别是什么？"><a href="#HashMap和Hashtable的区别是什么？" class="headerlink" title="HashMap和Hashtable的区别是什么？"></a>HashMap和Hashtable的区别是什么？</h3></li><li><code>Hashtable</code>继承自<code>Dictionary</code>类，而<code>HashMap</code>继承自<code>AbstractMap</code>类。但二者都实现了Map接口。</li><li><code>Hashtable</code>是线程安全的，<code>HashMap</code>是线程不安全的。</li><li><code>Hashtable</code>中，key和value都不允许出现null值。</li><li><code>HashTable</code>在不指定容量的情况下的<strong>默认容量为11，而HashMap为16</strong>，<code>Hashtable</code>不要求底层数组的容量一定要为2的整数次幂，而<code>HashMap</code>则要求一定为2的整数次幂。<code>Hashtable</code>扩容时，将容量变为原来的2倍加1，而<code>HashMap</code>扩容时，将容量变为原来的2倍。<h3 id="HashMap是如何解决哈希冲突的？"><a href="#HashMap是如何解决哈希冲突的？" class="headerlink" title="HashMap是如何解决哈希冲突的？"></a>HashMap是如何解决哈希冲突的？</h3></li><li>在JDK1.8前，<code>HashMap</code>是采用<strong>链表法</strong>解决哈希冲突的。当<code>put()</code>一个值到<code>Map</code>时，会通过<code>Key</code>拿到一个哈希值，通过哈希值获取数组下标，先查询是否存在该<code>hash</code>值。若不存在，则直接以<code>Entry&lt;V,V&gt;</code>的方式存放在数组中。若存在，则再调用<code>equals()</code>方法对比<code>key</code>是否相同，若<code>hashcode()</code>值和<code>key</code>都相同，则替换<code>value</code>，若<code>hashcode()</code>值相同，<code>key</code>不相同，则形成一个单链表，将<code>hashcode()</code>值相同，<code>key</code>不同的元素以<code>Entry&lt;V,V&gt;</code>的方式存放在链表中，这样就解决了哈希冲突。</li><li>JDK1.8以后，当链表的长度达到某个限制值(默认是8)，就会转换成<strong>红黑树</strong>，提高性能。<h3 id="HashMap初始大小是多少？负载因子是多少？"><a href="#HashMap初始大小是多少？负载因子是多少？" class="headerlink" title="HashMap初始大小是多少？负载因子是多少？"></a>HashMap初始大小是多少？负载因子是多少？</h3>默认的数组初始大小是16。负载因子是0.75。</li></ul><strong>（为什么初始值是2的n次方，为什么负载因子取0.75，这两个问题可以网上找资料看看，这里就不详述了）</strong><h3 id="简述一下HashMap的扩容机制？"><a href="#简述一下HashMap的扩容机制？" class="headerlink" title="简述一下HashMap的扩容机制？"></a>简述一下HashMap的扩容机制？</h3><code>HashMap</code>是懒加载的，当调用<code>put()</code>方法时，会先初始化<code>Map</code>的大小，默认数组长度是16，负载因子是0.75，所以阈值是12。当<code>HashMap</code>元素的个数超过阈值时，就会把数组的大小扩展到原来的2倍，然后重新计算每个元素在数组中的位置。<h3 id="List有哪些常用的子类？"><a href="#List有哪些常用的子类？" class="headerlink" title="List有哪些常用的子类？"></a>List有哪些常用的子类？</h3><code>ArrayList</code>和<code>LinkedList</code>。<h3 id="ArrayList和LinkedList有什么区别？"><a href="#ArrayList和LinkedList有什么区别？" class="headerlink" title="ArrayList和LinkedList有什么区别？"></a>ArrayList和LinkedList有什么区别？</h3><ul><li>底层<strong>数据结构不同</strong>。<code>ArrayList</code>基于数组+动态扩容实现的，<code>LinkedList</code>基于双向链表实现。从储存结构上分析，<code>LinkedList</code>更加占内存，因为每个节点除了存储数据外还要<strong>存储指向前节点的引用和指向后节点的引用。</strong></li><li><strong>效率不同</strong>。当随机访问时，<code>ArrayList</code>是基于数组下标访问，<strong>查询效率较高</strong>，但是由于数组的长度是固定的，所以当添加的元素到一定的阈值时会扩容数组，消耗性能，<strong>增删效率偏低</strong>。<code>LinkedList</code>在查询时，需要从前到后依次遍历，所以<strong>查询效率不高</strong>，但是在增删时只需要更改节点的引用，开销较少，所以<strong>增删效率较高</strong>。<h3 id="List集合排序的方式有哪些？"><a href="#List集合排序的方式有哪些？" class="headerlink" title="List集合排序的方式有哪些？"></a>List集合排序的方式有哪些？</h3>使用List接口定义的sort()方法。<pre><code class="java">list.sort(Comparator.comparingInt(User::getAge));</code></pre>使用<code>Collections</code>的<code>sort()</code>方法，排序的对象需要实现<code>Comparable</code>接口，重写<code>compareTo()</code>方法。<pre><code class="java">//实现Comparable接口public class User implements Comparable&lt;User&gt; {//重写compareTo方法@Overridepublic int compareTo(User user) {      return Integer.compare(this.getAge(), user.getAge());}}</code></pre>使用<code>Collections</code>的<code>sort()</code>方法<pre><code class="java">Collections.sort(list);//如果不想实现Comparable接口，也可以使用这个方法Collections.sort(list,Comparator.comparingInt(User::getAge));</code></pre>使用Stream流操作的<code>sort()</code>方法，传入一个<code>Comparator</code>接口。<pre><code class="java">list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList());</code></pre><h3 id="栈和队列的特点分别是什么？在java中有哪些实现的类？"><a href="#栈和队列的特点分别是什么？在java中有哪些实现的类？" class="headerlink" title="栈和队列的特点分别是什么？在java中有哪些实现的类？"></a>栈和队列的特点分别是什么？在java中有哪些实现的类？</h3>栈是<strong>先进后出</strong>，队列是<strong>先进先出</strong>。<br><code>Stack</code>类是栈在java中的实现，继承<code>Vector</code>类，底层是基于数组存储数据。<br><code>Queue</code>接口是队列在java中的代表，<code>Queue</code>接口有几个常用的子类<code>ArrayDeque</code>、<code>LinkedList</code>。<h3 id="IO、NIO有什么区别？"><a href="#IO、NIO有什么区别？" class="headerlink" title="IO、NIO有什么区别？"></a>IO、NIO有什么区别？</h3>IO包括：<code>File</code>、<code>OutputStream</code>、<code>InputStream</code>、<code>Writer</code>，<code>Reader</code>。<br>NIO三大核心：<code>selector</code>（选择器），<code>channel</code>（通道），<code>buffer</code>（缓冲区）<br>NIO与IO区别在于，IO面向流，NIO面向缓冲区。IO是阻塞，NIO是非阻塞。<h3 id="如何进行日期的转换？"><a href="#如何进行日期的转换？" class="headerlink" title="如何进行日期的转换？"></a>如何进行日期的转换？</h3>使用<code>SimpleDateFormat</code>类进行<code>String</code>和<code>Date</code>之间的转换。<h3 id="如何获取上一年的今天的日期？"><a href="#如何获取上一年的今天的日期？" class="headerlink" title="如何获取上一年的今天的日期？"></a>如何获取上一年的今天的日期？</h3>使用<code>Calendar</code>对象。如下所示：<pre><code class="java">//创建Calendar对象Calendar calendar = Calendar.getInstance();//设置年份，当前年份减去一年calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1);//以下是打印结果Date time = calendar.getTime();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);System.out.println(sdf.format(time));//2019-06-08 23:43:14 正确</code></pre><h3 id="BigDecimal类型一定不会失真吗？"><a href="#BigDecimal类型一定不会失真吗？" class="headerlink" title="BigDecimal类型一定不会失真吗？"></a>BigDecimal类型一定不会失真吗？</h3>不一定。<br>参数类型为<code>double</code>的构造方法的结果有一定的不可预知性，是有可能产生失真的。<pre><code class="java">BigDecimal bigDecimal = new BigDecimal(0.99);System.out.println(bigDecimal);//结果如下//0.9899999999999999911182158029987476766109466552734375</code></pre>使用参数类型<code>String</code>构造方法是完全可预知的，不会产生失真。所以在开发中推荐使用参数类型<code>String</code>构造方法。<h1 id="java并发编程"><a href="#java并发编程" class="headerlink" title="java并发编程"></a>java并发编程</h1><h3 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h3></li><li>避免主线程阻塞，可以使用多线程做成异步调用。</li><li>提升性能，充分利用CPU资源。<h3 id="创建线程有哪几种方法？"><a href="#创建线程有哪几种方法？" class="headerlink" title="创建线程有哪几种方法？"></a>创建线程有哪几种方法？</h3></li><li>通过继承<code>Thread</code>类创建线程类。</li><li>通过实现<code>Runnable</code>接口创建线程类。</li><li>通过实现<code>Callable</code>接口创建线程类。<h3 id="如何获取多线程的返回值？"><a href="#如何获取多线程的返回值？" class="headerlink" title="如何获取多线程的返回值？"></a>如何获取多线程的返回值？</h3>使用<code>Callable</code>和<code>FutureTask</code>接口，获取返回值。<pre><code class="java">public static void main(String[] args) throws Exception {  try {      //使用匿名内部类创建Callable      Callable callable = () -&gt; &quot;hello call&quot;;      FutureTask futureTask = new FutureTask(callable);      //执行线程      new Thread(futureTask).start();      if (!futureTask.isDone()) {          //获取返回值          System.out.println(futureTask.get());      }  } catch (Exception e) {      e.printStackTrace();  }}</code></pre><h3 id="多线程的生命周期？"><a href="#多线程的生命周期？" class="headerlink" title="多线程的生命周期？"></a>多线程的生命周期？</h3>新建状态、就绪状态、运行状态、阻塞状态、死亡状态<h3 id="如何进行线程之间的通信？"><a href="#如何进行线程之间的通信？" class="headerlink" title="如何进行线程之间的通信？"></a>如何进行线程之间的通信？</h3></li><li>使用<code>synchronized、wait()、notify()</code></li><li>使用JUC工具类<code>CountDownLatch</code></li><li>使用<code>ReentrantLock</code>结合<code>Condition</code></li><li>基本<code>LockSupport</code>实现线程间的阻塞和唤醒</li></ul></li></ul><p>以上几种方式的具体实现代码，可以网上找一下资料，这里不演示了。</p><h3 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h3><p>相同点：</p><ul><li><code>sleep()</code>方法和<code>wait()</code>方法都用来改变线程的状态，能够让线程从<strong>运行状态</strong>，转变为<strong>休眠状态</strong>。</li></ul><p>不同点：</p><ul><li><code>sleep()</code>方法是<code>Thread</code>类中的静态方法，而<code>wait()</code>方法是<code>Object</code>类中的方法。</li><li><code>sleep()</code>方法可以在任何地方调用，而wait()方法只能在同步代码块或同步方法中使用(即使用<code>synchronized</code>关键字修饰的)。</li><li>这两个方法都在同步代码块或同步方法中使用时，<code>sleep()</code>方法不会释放对象锁。而<code>wait()</code>方法则会释放对象锁。<h3 id="如何停止线程？"><a href="#如何停止线程？" class="headerlink" title="如何停止线程？"></a>如何停止线程？</h3></li><li>使用退出标志，使线程正常退出，也就是当<code>run()</code>方法完成后线程终止。</li><li>使用<code>stop()</code>方法强行终止(不推荐)，可能会出现数据不同步，或者资源未释放等问题。</li><li>使用<code>interrupt()</code>方法中断线程。<h3 id="什么是线程的死锁？如何避免线程死锁？"><a href="#什么是线程的死锁？如何避免线程死锁？" class="headerlink" title="什么是线程的死锁？如何避免线程死锁？"></a>什么是线程的死锁？如何避免线程死锁？</h3>多个线程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进，这种现象称为死锁。</li></ul><p>避免死锁的三种方式：</p><ul><li>加锁顺序（线程按照一定的顺序加锁）</li><li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）<h3 id="线程池的作用？"><a href="#线程池的作用？" class="headerlink" title="线程池的作用？"></a>线程池的作用？</h3></li><li>利用线程池管理并复用线程，减少创建线程和销毁线程的资源消耗。</li><li>实现任务线程队列缓存策略和拒绝机制。</li><li>可以对线程进行统一的分配，监控和调优。</li><li>提供定时执行、最大线程数、并发数控制等功能。<h3 id="创建线程池的重要参数分别代表什么意思？"><a href="#创建线程池的重要参数分别代表什么意思？" class="headerlink" title="创建线程池的重要参数分别代表什么意思？"></a>创建线程池的重要参数分别代表什么意思？</h3></li><li><code>corePoolSize</code>线程池核心线程大小。在没有设置 <code>allowCoreThreadTimeOut</code>为<code>true</code>的情况下，核心线程会在线程池中一直存活，即使处于闲置状态。当向线程池提交一个任务时，若线程池已创建的线程数小于<code>corePoolSize</code>，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于<code>corePoolSize</code>。</li><li><code>maximumPoolSize</code>线程池最大线程数量。线程池所允许的最大线程个数。<strong>当队列满了</strong>，且已创建的线程数小于<code>maximumPoolSize</code>，则线程池会创建新的线程来执行任务。对于无界队列可以忽略此参数。</li><li><code>keepAliveTime</code>线程存活保持时间。当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</li><li><code>unit</code>空间线程存活时间单位。</li><li><code>workQueue</code>任务队列：用于传输和保存等待执行任务的阻塞队列。<br>①<code>ArrayBlockingQueue</code>，基于数组的有界阻塞队列，按FIFO排序。<br>②<code>LinkedBlockingQuene</code>，基于链表的无界阻塞队列（其实最大容量为<code>Interger.MAX</code>），按照FIFO排序。当使用该队列时，<code>maximumPoolSize</code>参数可以忽略。<br>③<code>SynchronousQuene</code>，一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。<br>④<code>PriorityBlockingQueue</code>，具有优先级的无界阻塞队列，优先级通过参数<code>Comparator</code>实现。</li><li><code>threadFactory</code>线程工厂，用于创建新线程。</li><li><code>handler</code>线程饱和策略，当线程池和队列都满了，再加入线程会执行此策略。<h3 id="线程池中submit-和-execute-方法有什么区别？"><a href="#线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中submit() 和 execute()方法有什么区别？"></a>线程池中submit() 和 execute()方法有什么区别？</h3></li><li>参数不同</li></ul><p><code>submit()</code>方法有三个重载方法。</p><pre><code class="java">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);</code></pre><p><code>execute()</code>方法只有一个</p><pre><code class="java">void execute(Runnable command);</code></pre><ul><li><code>execute()</code>没有返回值；而<code>submit()</code>有返回值</li><li><code>submit()</code>的返回值<code>Future</code>调用<code>get()</code>方法时，可以捕获处理异常。而<code>execute()</code>没有返回值不能捕获异常。<h3 id="有哪些常用的线程池？"><a href="#有哪些常用的线程池？" class="headerlink" title="有哪些常用的线程池？"></a>有哪些常用的线程池？</h3><code>Executors.newCacheThreadPool()</code>：<strong>可缓存线程池</strong>，先查看池中有没有已建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务。<br><code>Executors.newFixedThreadPool()</code>：<strong>可重用固定个数的线程池</strong>，以共享的无界队列方式来运行这些线程。<br><code>Executors.newScheduledThreadPool(int n)</code>：<strong>定长线程池</strong>，支持定时及周期性任务执行。<br><code>Executors.newSingleThreadExecutor()</code>：<strong>单线程化的线程池</strong>，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<h3 id="什么是线程安全问题？如何保证线程安全？"><a href="#什么是线程安全问题？如何保证线程安全？" class="headerlink" title="什么是线程安全问题？如何保证线程安全？"></a>什么是线程安全问题？如何保证线程安全？</h3>当<strong>多个线程</strong>同时共享，同一个<strong>全局变量或者静态变量</strong>，做写的操作时，可能会发生数据冲突问题，也就是<strong>线程安全问题</strong>。<h3 id="java的内存模型？"><a href="#java的内存模型？" class="headerlink" title="java的内存模型？"></a>java的内存模型？</h3>java的内存模型规定了所有的变量都<strong>存储在主内存中，每个线程拥有自己的工作内存</strong>，工作内存保存了该线程使用到的变量的主内存拷贝，<strong>线程对变量所有操作，读取，赋值，都必须在工作内存中进行，不能直接写主内存变量</strong>，线程间变量值的传递均需要主内存来完成。<h3 id="volatile关键字有什么作用？volatile一定能保证原子性吗？"><a href="#volatile关键字有什么作用？volatile一定能保证原子性吗？" class="headerlink" title="volatile关键字有什么作用？volatile一定能保证原子性吗？"></a>volatile关键字有什么作用？volatile一定能保证原子性吗？</h3>volatile关键字有什么作用：</li><li>内存<strong>可见性</strong>（Memory Visibility)：所有线程都能看到共享内存的最新状态。</li><li>禁止指令重排。</li></ul><p><code>volatile</code>是Java提供的一种<strong>轻量级的同步机制</strong>，并不能保证原子性。</p><h3 id="什么是指令重排？"><a href="#什么是指令重排？" class="headerlink" title="什么是指令重排？"></a>什么是指令重排？</h3><p>指令重排是指<code>JVM</code>在编译Java代码的时候，或者CPU在执行<code>JVM</code>字节码的时候，对现有的指令顺序进行重新排序。<br>指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。</p><h3 id="synchronized的使用方式？"><a href="#synchronized的使用方式？" class="headerlink" title="synchronized的使用方式？"></a>synchronized的使用方式？</h3><ul><li>修饰实例(非静态方法。被锁对象是类的实例(<code>this</code>)。</li><li>修饰静态方法。被锁对象是类对象。</li><li>同步代码块。有三种形式。<br>①<code>synchronized(this){}</code>，被锁对象是类的实例。<br>②<code>synchronized(XXX.Class)</code>，被锁对象是类对象。<br>③<code>synchronized(new Object())</code>，被锁对象是实例对象<code>object</code>。<h3 id="Lock锁的使用方式？"><a href="#Lock锁的使用方式？" class="headerlink" title="Lock锁的使用方式？"></a>Lock锁的使用方式？</h3></li></ul><p>1.获取锁。2.上锁。3.释放锁。<br>注意点：释放锁最好放在<code>finally{}</code>代码块中，保证能执行释放锁。</p><h3 id="什么是乐观锁、什么是悲观锁？"><a href="#什么是乐观锁、什么是悲观锁？" class="headerlink" title="什么是乐观锁、什么是悲观锁？"></a>什么是乐观锁、什么是悲观锁？</h3><ul><li><strong>悲观锁</strong>：它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。具有强烈的独占和排他特性。</li><li><strong>乐观锁</strong>：乐观锁认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的重提与否进行检测，如果发现冲突了，程序自动去重试。相对于悲观锁，在高并发的场景下有更好的性能表现，通常用”版本号”实现。<h3 id="synchronized与Lock锁的区别？"><a href="#synchronized与Lock锁的区别？" class="headerlink" title="synchronized与Lock锁的区别？"></a>synchronized与Lock锁的区别？</h3></li><li><code>synchronized</code>是java内置关键字，在<code>jvm</code>层面。<code>Lock</code>是个java类。</li><li><code>synchronized</code>无法判断是否获取锁的状态。<code>Lock</code>可以判断是否获取到锁。</li><li><code>synchronized</code>会自动释放锁。<code>Lock</code>锁需要在<code>finally{}</code>代码块中手工释放锁。</li><li><code>synchronized</code>的锁可重入、不可中断、非公平。而<code>Lock</code>锁可重入、可判断、可公平（两者皆可）。<h3 id="有哪些常用的线程安全的集合？"><a href="#有哪些常用的线程安全的集合？" class="headerlink" title="有哪些常用的线程安全的集合？"></a>有哪些常用的线程安全的集合？</h3><code>ConcurrentHashMap</code>、<code>Vector</code>、<code>Hashtable</code>、<code>Stack</code>。还可以使用<code>Collections包装方法</code>获得线程安全的集合。<h3 id="CAS是什么，有什么问题，如何解决？"><a href="#CAS是什么，有什么问题，如何解决？" class="headerlink" title="CAS是什么，有什么问题，如何解决？"></a>CAS是什么，有什么问题，如何解决？</h3><code>CAS</code>是<code>compare and swap</code>的缩写，意思是比较与交换。<code>CAS</code>是乐观锁的一种实现。CAS操作包含三个操作数—内存位置的值（V）、预期原值（A）和新值（B）。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。</li></ul><p><code>CAS</code>有以下缺点：</p><ul><li>ABA问题： 线程C、D。线程D将A修改为B后又修改为A，此时C线程以为A没有改变过。这个问题通常可以使用版本号来解决。</li><li>CPU开销过大。在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很到的压力。</li><li><code>CAS</code>机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用<code>synchronized</code>了。<h3 id="什么是ThreadLocal？"><a href="#什么是ThreadLocal？" class="headerlink" title="什么是ThreadLocal？"></a>什么是ThreadLocal？</h3>这个类提供了线程局部变量也称为线程本地变量，它为变量在每个线程中创建了一个副本，通过这样的方式做到变量在线程间隔离且在方法间共享的场景。<h3 id="ThreadLocal是如何保证线程安全的？"><a href="#ThreadLocal是如何保证线程安全的？" class="headerlink" title="ThreadLocal是如何保证线程安全的？"></a>ThreadLocal是如何保证线程安全的？</h3><code>ThreadLocal</code>存储的值不是线程共享的，而是属于线程的。内部会维护一个<code>ThreadLocalMap</code>，key是当前线程的<code>ThreadLocal</code>，value是存储的值。换句话说，每个线程都有自己的值，当然不会出现线程安全问题了。</li></ul><p>源码如下：</p><pre><code class="java">    public void set(T value) {        //获取当前线程        Thread t = Thread.currentThread();        //通过当前线程获取到ThreadLocalMap        ThreadLocalMap map = getMap(t);        if (map != null)            //key是this，value是需要存储的值            map.set(this, value);        else            //创建一个map            createMap(t, value);    }</code></pre><h1 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h1><h3 id="什么是JVM内存模型？"><a href="#什么是JVM内存模型？" class="headerlink" title="什么是JVM内存模型？"></a>什么是JVM内存模型？</h3><p>Java内存模型（Java Memory Model，简称为<strong>JMM</strong>)，是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p>根据java虚拟机规范，JVM内存共分为<strong>虚拟机栈，堆，方法区，程序计数器，本地方法栈</strong>五个部分。</p><h3 id="栈内存溢出-StackOverflowError-的常见原因有哪些？"><a href="#栈内存溢出-StackOverflowError-的常见原因有哪些？" class="headerlink" title="栈内存溢出(StackOverflowError)的常见原因有哪些？"></a>栈内存溢出(StackOverflowError)的常见原因有哪些？</h3><p>栈溢出原因就是方法执行时创建的栈帧超过了栈的深度。最有可能的就是<strong>方法递归调用</strong>产生这种结果。</p><h3 id="堆内存溢出-OOM-的常见原因有哪些？"><a href="#堆内存溢出-OOM-的常见原因有哪些？" class="headerlink" title="堆内存溢出(OOM)的常见原因有哪些？"></a>堆内存溢出(OOM)的常见原因有哪些？</h3><ul><li><code>OutOfMemoryError: Java heap space</code>。在创建新的对象时, 堆内存中的空间不足以存放新创建的对象时发生。产生原因：程序中出现了死循环，不断创建对象；程序占用内存太多，<strong>超过了JVM堆设置的最大值</strong>。</li><li><code>OutOfMemoryError: unable to create new native thread</code>。产生原因：系统内存耗尽，无法为新线程分配内存；<strong>创建线程数超过了操作系统的限制</strong>。</li><li><code>OutOfMemoryError: PermGen space</code>。永久代溢出，即方法区溢出了，一般<strong>出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况</strong>，因为上述情况会产生大量的Class信息存储于方法区。</li><li><code>OutOfMemoryError：GC overhead limit exceeded</code>。<strong>超过98%的时间都在用来做GC并且回收了不到2%的堆内存</strong>。连续多次的GC，都回收了不到2%的极端情况下才会抛出。</li></ul><h3 id="JVM参数调优有哪些重要的参数？分别有什么作用？"><a href="#JVM参数调优有哪些重要的参数？分别有什么作用？" class="headerlink" title="JVM参数调优有哪些重要的参数？分别有什么作用？"></a>JVM参数调优有哪些重要的参数？分别有什么作用？</h3><ul><li>-Xms  初始堆内存大小。</li><li>-Xmx  最大堆内存大小。</li><li>-Xss  每个线程的栈大小。</li><li>-XX:+PrintGC  每次GC时打印相关信息。</li><li>-XX:Newratio  设置年轻代和老年代的比例，比如值为2，则老年代是年轻代的2倍。</li><li>-XX:Newsize  设置年轻代的初始值大小。</li><li>-XX:Maxnewsize  设置年轻代的最大值大小。</li></ul><h3 id="GC垃圾回收机制，有哪些垃圾回收算法？"><a href="#GC垃圾回收机制，有哪些垃圾回收算法？" class="headerlink" title="GC垃圾回收机制，有哪些垃圾回收算法？"></a>GC垃圾回收机制，有哪些垃圾回收算法？</h3><p>标记-清除算法、复制算法、标记整理算法、分代收集算法。</p><h3 id="JVM如何判断对象是否可以回收？"><a href="#JVM如何判断对象是否可以回收？" class="headerlink" title="JVM如何判断对象是否可以回收？"></a>JVM如何判断对象是否可以回收？</h3><p>会使用可达性分析算法进行判断，原理是从一系列被称为<code>GC ROOT</code>的对象开始，向下搜索，搜索走过的路径称为引用链，当一个对象到<code>GC ROOT</code>之间没有引用链，说明这个对象不可用，那么就会被GC回收。</p><h3 id="什么是强引用、软引用、弱引用、虚引用？"><a href="#什么是强引用、软引用、弱引用、虚引用？" class="headerlink" title="什么是强引用、软引用、弱引用、虚引用？"></a>什么是强引用、软引用、弱引用、虚引用？</h3><p>强引用。一般<code>new</code>出来的对象都是强引用。如果一个对象具有强引用，<code>GC</code>绝不会回收它；当内存空间不足，JVM宁愿抛出<code>OutOfMemoryError</code>错误。</p><pre><code class="java">//强引用Object obj = new Object();</code></pre><p>软引用。如果一个对象只具有软引用。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p><pre><code class="java">//软引用SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(new Object());</code></pre><p>弱引用。如果一个对象具有弱引用，在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存。</p><pre><code class="java">//弱引用WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(new Object());</code></pre><p>虚引用。如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收。</p><pre><code class="java">//虚引用PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(new Object(), new ReferenceQueue&lt;&gt;());</code></pre><h3 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h3><p>Java类加载器是Java运行时环境的一部分，负责动态加载Java类到JVM的内存空间中。</p><h3 id="什么是双亲委派机制？"><a href="#什么是双亲委派机制？" class="headerlink" title="什么是双亲委派机制？"></a>什么是双亲委派机制？</h3><p>双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。</p><h3 id="类的生命周期？"><a href="#类的生命周期？" class="headerlink" title="类的生命周期？"></a>类的生命周期？</h3><p><strong>加载、验证、准备、解析、初始化、使用、卸载</strong>。</p><p>有些资料会把(验证、准备、解析)归纳为连接，于是就变成：<strong>加载、连接、初始化、使用、卸载</strong>。</p><h1 id="设计模式相关"><a href="#设计模式相关" class="headerlink" title="设计模式相关"></a>设计模式相关</h1><h3 id="如何实现单例模式？"><a href="#如何实现单例模式？" class="headerlink" title="如何实现单例模式？"></a>如何实现单例模式？</h3><ul><li>饿汉式单例模式。定义一个静态成员变量，把构造器私有化，只对外暴露一个获取实例的方法。<pre><code class="java">public class SingLeton {  //立即加载  private static SingLeton singLeton = new SingLeton();  //私有化构造器  private SingLeton(){}  //对外暴露获取实例的方法  public static SingLeton getSingLeton(){      return singLeton;  }}</code></pre></li><li>懒汉式单例模式。非线程安全。基本和上面饿汉式实现方式类似，只是在获取时再判断是否创建实例，但是会有线程安全问题。<pre><code class="java">public class SingLeton {  //立即加载  private static SingLeton singLeton;  //私有化构造器  private SingLeton() {  }  //对外暴露获取实例的方法  public static SingLeton getSingLeton() {      if (singLeton == null) {          singLeton = new SingLeton();      }      return singLeton;  }}</code></pre></li><li>使用静态内部类实现<pre><code class="java">public class SingLeton {  //私有化构造器  private SingLeton() {}  //对外暴露获取实例的方法  public static SingLeton getSingLeton() {      return SingLetonHolder.SINGLETON;  }  //私有静态内部类  private static class SingLetonHolder {      private static final SingLeton SINGLETON = new SingLeton();  }}</code></pre></li><li>使用枚举实现<pre><code class="java">public enum SingLeton {  SINGLETON;}</code></pre></li></ul><h3 id="如何实现线程安全的单例模式？"><a href="#如何实现线程安全的单例模式？" class="headerlink" title="如何实现线程安全的单例模式？"></a>如何实现线程安全的单例模式？</h3><p><strong>饿汉式实现、枚举、静态内部类</strong>都是<strong>线程安全</strong>的实现方式。<br>还可以使用<strong>双检锁</strong>的懒汉式方式实现：</p><pre><code class="java">public class SingLeton {    private static volatile SingLeton singLeton;    //私有化构造器    private SingLeton() {}    //对外暴露获取实例的方法    public static SingLeton getSingLeton() {        if (singLeton == null) {            synchronized (SingLeton.class) {                if (singLeton == null) {                    singLeton = new SingLeton();                }            }        }        return singLeton;    }}</code></pre><h3 id="为什么要使用工厂模式创建对象？"><a href="#为什么要使用工厂模式创建对象？" class="headerlink" title="为什么要使用工厂模式创建对象？"></a>为什么要使用工厂模式创建对象？</h3><ul><li><strong>解耦</strong>。把对象的创建和使用的过程分开。</li><li><strong>可以降低代码重复</strong>。如果创建B过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。</li><li><strong>减少了使用者因为创建逻辑导致的错误</strong>。因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可。</li><li><strong>提高了代码的可维护性</strong>。如果发生业务逻辑变化，不需要找到所有需要创建对象的地方去逐个修正，只需要在工厂里修改即可。</li></ul><h3 id="在java中，实现代理模式有哪几种方式？"><a href="#在java中，实现代理模式有哪几种方式？" class="headerlink" title="在java中，实现代理模式有哪几种方式？"></a>在java中，实现代理模式有哪几种方式？</h3><ul><li>静态代理。</li><li>JDK动态代理。</li><li>CGlib动态代理。</li></ul><h3 id="JDK动态代理和CGlib动态代理的区别？"><a href="#JDK动态代理和CGlib动态代理的区别？" class="headerlink" title="JDK动态代理和CGlib动态代理的区别？"></a>JDK动态代理和CGlib动态代理的区别？</h3><p> （1）<code>JDK动态代理</code>只能对实现了接口的类生成代理，而不能针对类。<br> （2）<code>CGLIB</code>是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。<br>   因为是继承，所以该类或方法不能声明成<code>final</code>。</p><h3 id="策略模式的使用场景？"><a href="#策略模式的使用场景？" class="headerlink" title="策略模式的使用场景？"></a>策略模式的使用场景？</h3><ul><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时<strong>动态选择具体要执行的行为</strong>。</li><li>需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</li><li>对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</li></ul><h3 id="装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？"><a href="#装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？" class="headerlink" title="装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？"></a>装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？</h3><p>使用场景：</p><ul><li>扩展一个类的功能。<ul><li>动态增加功能，动态撤销。</li></ul></li></ul><p>java中经典的例子就是I/O流。具体分析过程可以参考我写的这篇文章：<a href="https://blog.csdn.net/yehongzhi1994/article/details/106065136" target="_blank" rel="noopener">装饰者模式与IO流的应用</a>。</p><h1 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h1><h3 id="有哪些经典的排序算法？"><a href="#有哪些经典的排序算法？" class="headerlink" title="有哪些经典的排序算法？"></a>有哪些经典的排序算法？</h3><p>插入排序、冒泡排序、归并排序、快速排序、堆排序、桶排序、基数排序等等。</p><h3 id="冒泡排序的时间复杂度和空间复杂度？"><a href="#冒泡排序的时间复杂度和空间复杂度？" class="headerlink" title="冒泡排序的时间复杂度和空间复杂度？"></a>冒泡排序的时间复杂度和空间复杂度？</h3><p>平均的时间复杂度是<code>O(n^2)</code>，最好的情况是<code>O(n)</code>，最坏的情况是<code>O(n^2)</code>。空间复杂度是<code>O(1)</code>。</p><h3 id="哪一种排序算法的时间复杂度比较稳定？"><a href="#哪一种排序算法的时间复杂度比较稳定？" class="headerlink" title="哪一种排序算法的时间复杂度比较稳定？"></a>哪一种排序算法的时间复杂度比较稳定？</h3><p>归并排序。最好和最坏的情况下，时间复杂度都是<code>O(n*log n)</code>。</p><h3 id="如何实现二分查找？二分查找的时间复杂度？-笔试常见"><a href="#如何实现二分查找？二分查找的时间复杂度？-笔试常见" class="headerlink" title="如何实现二分查找？二分查找的时间复杂度？(笔试常见)"></a>如何实现二分查找？二分查找的时间复杂度？(笔试常见)</h3><p>有两种方式，迭代法和递归法。具体实现代码，可以参考我写的这篇《<a href="https://blog.csdn.net/yehongzhi1994/article/details/105835380" target="_blank" rel="noopener">手把手教你实现二分查找</a>》。时间复杂度是<code>O(log n)</code>。</p><h3 id="跳楼梯的问题。-笔试常见"><a href="#跳楼梯的问题。-笔试常见" class="headerlink" title="跳楼梯的问题。(笔试常见)"></a>跳楼梯的问题。(笔试常见)</h3><p>这是一个经典的斐波那契数列问题。力扣题库第70题。可以看看大佬们的题解。这是我的题解，使用了<code>Map</code>作为缓存，减少一些不必要的递归，效率还不错。执行时间：1 ms。当然你去掉那个<code>Map</code>也是完全没错的，只是运行时间会久一些，可能会超出<code>leetcode</code>的时间限制，没法通过。<br><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/guan-fang-jie-fa-yi-chao-shi-cai-yong-maphuan-cun-/" target="_blank" rel="noopener">我的题解链接</a></p><pre><code class="java">/** * 题目描述： * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？*/class Solution {    private Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    public int climbStairs(int n) {        if (n == 1) {            map.put(n, 1);            return 1;        }        if (n == 2) {            map.put(n, 2);            return 2;        }        if (map.get(n) != null) {            return map.get(n);        } else {            int num = climbStairs(n - 1) + climbStairs(n - 2);            map.put(n, num);            return num;        }    }}</code></pre><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>责任链模式</title>
    <link href="/2020/06/06/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/06/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>各位<strong>java技术爱好者</strong>，我们又见面了！<br>之前我在面试的时候遇到这个问题，当时答不上来。这件事就一直在我心里耿耿于怀。相信很多人面试完都有这种体验，哈哈~<br>不过今日不同往日了，现在我已经搞懂了，其实并不是很难。</p><a id="more"></a><p><img src="https://static.lovebilibili.com/20200606_2211_01.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="开始搞事情"><a href="#开始搞事情" class="headerlink" title="开始搞事情"></a>开始搞事情</h1><p>要学习一种技术，当然要搞清楚能解决什么问题，这是最关键的，否则就像买了一个开瓶器，还是用嘴咬开啤酒瓶盖一样(比喻很巧妙)。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先我们用<code>Request</code>对象，表示一个请求。</p><pre><code class="java">public class Request {    //请求数据    private String data;    public String getData() {        return data;    }    public void setData(String data) {        this.data = data;    }}</code></pre><p>假设<code>data</code>中有很多数据，我们要过滤掉一些关键字，比如<code>水果</code>、<code>蔬菜</code>。<br>如果不用设计模式，直接用<code>if</code>解决，就是这样写：</p><pre><code class="java">public static void main(String[] args) throws Exception {        //创建请求体        String data = &quot;肉蛋葱鸡水果蔬菜千层饼雅俗共赏第五层的马老师&quot;;        Request request = new Request();        request.setData(data);        String requestData = request.getData();        //如果包含水果关键字        if (requestData.contains(&quot;水果&quot;)) {            //过滤水果关键字            requestData = filterByWord(requestData, &quot;水果&quot;);        }        //如果包含蔬菜关键字        if (requestData.contains(&quot;蔬菜&quot;)) {            //过滤蔬菜关键字            requestData = filterByWord(requestData, &quot;蔬菜&quot;);        }        request.setData(requestData);        System.out.println(requestData);//肉蛋葱鸡千层饼雅俗共赏第五层的马老师    }    //过滤关键字的方法    private static String filterByWord(String data, String word) {        StringBuilder sb = new StringBuilder(data);        while (true) {            int index = sb.indexOf(word);            //如果不等于-1，搜索到关键字            if (index != -1) {                for (int i = 0; i &lt; word.length(); i++) {                    //关键字有多长就删多少次，比如水果，在index位置上删两次                    sb.deleteCharAt(index);                }            } else {                //等于-1，没有关键字，跳出循环                break;            }        }        return sb.toString();    }}    </code></pre><p>这样的代码在项目中不要太多，遇事不决来个<code>if</code>，不行就再来一个。一般这种程序员就只看到了<strong>第一层</strong>。<br>问题：<br>1.如果这时候要增加多一些关键字呢，怎么处理？在原来的代码里继续加<code>if</code>的话，那这个方法就越写越长。而且破坏了<code>开闭原则</code>。<br>2.如果要调换顺序呢。难道要剪切复制代码？<br><strong>所以一个好的程序员，实现功能只是基本要求，重要是代码要有好的维护性和扩展性。</strong><br><img src="https://static.lovebilibili.com/20200606_2211_00.png" srcset="/img/loading.gif" alt=""></p><h2 id="怎么优化呢？"><a href="#怎么优化呢？" class="headerlink" title="怎么优化呢？"></a>怎么优化呢？</h2><p>我们可以这样想，把每个过滤关键字的方法<strong>抽成一个类</strong>，然后定义一个<strong>过滤关键字的方法</strong>，因为有很多个类似职责的类，所以<strong>定义一个接口</strong>，<strong>公共的方法</strong>可以定义在接口。<br>第一步：定义<strong>过滤器接口</strong></p><pre><code class="java">public interface Filter {    //接口方法    String doFilter(String data, FilterChain filterChain);    //过滤关键字的方法    default String filterByWord(String data, String word) {        StringBuilder sb = new StringBuilder(data);        while (true) {            int index = sb.indexOf(word);            if (index != -1) {                for (int i = 0; i &lt; word.length(); i++) {                    //关键字有几个字，就删几次。比如水果就在index删两次即可                    sb.deleteCharAt(index);                }            } else {                //如果找不到关键字，就跳出循环                break;            }        }        return sb.toString();    }}</code></pre><p>第二步：定义<strong>水果关键字过滤器</strong></p><pre><code class="java">public class FruitsFilter implements Filter {    @Override    public String doFilter(String data, FilterChain filterChain) {        //过滤水果关键字        data = filterByWord(data, &quot;水果&quot;);        //拿到控制器，继续调用下一个过滤器        return filterChain.preHandleRequest(data);    }}</code></pre><p>第三部：定义<strong>蔬菜关键字过滤器</strong></p><pre><code class="java">public class VegetablesFilter implements Filter {    @Override    public String doFilter(String data, FilterChain filterChain) {        //过滤蔬菜关键字        data = filterByWord(data, &quot;蔬菜&quot;);        //拿到控制器，继续调用下一个过滤器        return filterChain.preHandleRequest(data);    }}</code></pre><p>第四步：定义一个<strong>过滤器的控制器</strong></p><pre><code class="java">public class FilterChain {    //使用List装过滤器，List是有序的    private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();    //过滤器的下标，从0开始，每次调用preHandleRequest方法就+1    private int index = 0;    //添加过滤器    public void addFilter(Filter filter) {        filters.add(filter);    }    //调用过滤器的doFilter()方法，并把指针+1指向下一个过滤器    public String preHandleRequest(String data) {        //如果指针大于集合的size，则return，不再往下调用，相当于递归的终结条件        if (index == filters.size()) {            return data;        }        Filter filter = filters.get(index);        //下标指针+1        index++;        //精髓在这个this，把自己再当做参数传进去，实现了递归        return filter.doFilter(data, this);    }}</code></pre><p>这样就大功告成了，最后我们创建一个Main方法试试吧~</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //创建请求体        String data = &quot;肉蛋葱鸡水果蔬菜千层饼雅俗共赏第五层的马老师&quot;;        Request request = new Request();        request.setData(data);        //创建FilterChain执行链        FilterChain filterChain = new FilterChain();        //添加过滤器        filterChain.addFilter(new FruitsFilter());        filterChain.addFilter(new VegetablesFilter());        //执行预处理        String s = filterChain.preHandleRequest(request.getData());        request.setData(s);        //打印结果，验证        System.out.println(request.getData());//下面是打印结果，结果正确        //肉蛋葱鸡千层饼雅俗共赏第五层的马老师    }}</code></pre><p>这就是责任链模式！下面用一张图来看看调用链的执行顺序。其实没有想得那么难吧。你学会了吗？<br><img src="https://img-blog.csdnimg.cn/20200606120835391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="责任链模式的优点"><a href="#责任链模式的优点" class="headerlink" title="责任链模式的优点"></a>责任链模式的优点</h2><p>我们回过头去看，为什么这么绕呢，直接<code>if</code>不香吗？<br>还真不香，在用<code>if</code>的时候，提到的两个问题，破坏<code>开闭原则</code>，还有调用顺序的问题，用责任链模式都得到解决了。<br><strong>1.如果要加一些过滤的关键字，只需要加一个过滤的类，然后再添加到过滤器的集合中，不需要对原来的代码进行侵入式的开发。符合<code>开闭原则</code>。<br>2.执行顺序要变更的话，也不需要侵入式的改代码，只需要改一下添加过滤器的顺序。在<code>Servlet</code>中，过滤器的顺序就是按<code>xml</code>文件定义的顺序。在<code>SpringMVC</code>则是按注册的顺序。这就非常易于扩展。</strong><br>要多为下一个程序员着想，我为人人，人人为我，世界才会变得更美好！哈哈~~</p><h1 id="SpringMVC的责任链模式"><a href="#SpringMVC的责任链模式" class="headerlink" title="SpringMVC的责任链模式"></a>SpringMVC的责任链模式</h1><p>以上就是一个简单的<code>demo</code>，重要的是学习这种思想。那么我们看实战中是怎么应用的，所谓知其然知其所以然，学习<strong>忌讳浅尝辄止</strong>，趁热打铁，我们看看框架中怎么应用责任链模式。</p><h2 id="SpringMVC拦截器的使用"><a href="#SpringMVC拦截器的使用" class="headerlink" title="SpringMVC拦截器的使用"></a>SpringMVC拦截器的使用</h2><p>很简单，实现<code>HandlerInterceptor</code>接口，接口有三个方法需要重写。</p><ul><li>preHandle()：在业务处理器处理请求之前被调用。预处理。</li><li>postHandle()：在业务处理器处理请求执行完成后，生成视图之前执行。后处理。</li><li>afterCompletion()：在<code>DispatcherServlet</code>完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）；</li></ul><p>我们定义一个关键字过滤器<code>WordInterceptor</code>：</p><pre><code class="java">//定义一个关键字拦截器public class WordInterceptor implements HandlerInterceptor {    //在执行controller定义的请求方法前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;执行WordInterceptor的preHandle()&quot;);        return true;    }    //controller定义的请求方法执行后，但还没渲染页面前，执行    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;执行WordInterceptor的postHandle()&quot;);    }    //在渲染页面完毕后执行，或者preHandle()返回fasle时执行    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(&quot;执行WordInterceptor的afterCompletion()&quot;);    }}</code></pre><p>如法炮制，再定义一个登录拦截器</p><pre><code class="java">public class LoginInterceptor implements HandlerInterceptor {    //在执行controller定义的请求方法前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;执行LoginInterceptor的preHandle()&quot;);        return true;    }    //controller定义的请求方法执行后，但还没渲染页面前，执行    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;执行LoginInterceptor的postHandle()&quot;);    }    //在渲染页面完毕后执行，或者preHandle()返回fasle时执行    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(&quot;执行LoginInterceptor的afterCompletion()&quot;);    }}</code></pre><p>然后再注册到拦截器的集合中。</p><pre><code class="java">@Componentpublic class WebInterceptorConfig implements WebMvcConfigurer {    @Override    public void addInterceptors(InterceptorRegistry registry) {        //先注册关键字拦截器，拦截所有请求        registry.addInterceptor(new WordInterceptor()).addPathPatterns(&quot;/**&quot;);        //再注册登录拦截器，拦截所有请求        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;);    }}</code></pre><p>然后启动项目，发起一个请求，我们就可以在控制台看到调用的顺序了。注意观察：</p><pre><code class="java">//按注册顺序执行preHandle()方法执行WordInterceptor的preHandle()执行LoginInterceptor的preHandle()//按注册顺序，逆序执行postHandle()方法执行LoginInterceptor的postHandle()执行WordInterceptor的postHandle()//从最后一个preHandle()执行的类，逆序执行afterCompletion()执行LoginInterceptor的afterCompletion()执行WordInterceptor的afterCompletion()</code></pre><p>执行的流程图就是这样：<br><img src="https://static.lovebilibili.com/SpringMVC_liuchengtu.png" srcset="/img/loading.gif" alt=""><br>原理是什么呢？我们不妨走进源码去分析。</p><h2 id="SpringMVC拦截器源码分析"><a href="#SpringMVC拦截器源码分析" class="headerlink" title="SpringMVC拦截器源码分析"></a>SpringMVC拦截器源码分析</h2><p>还是要看<code>DispatcherServlet</code>的<code>doDispatch()</code>方法</p><h3 id="doDispatch-调用顺序"><a href="#doDispatch-调用顺序" class="headerlink" title="doDispatch()调用顺序"></a><code>doDispatch()</code>调用顺序</h3><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        //请求对象        HttpServletRequest processedRequest = request;        //定义一个调用链        HandlerExecutionChain mappedHandler = null;        boolean multipartRequestParsed = false;        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                //省略                // 获取调用链                mappedHandler = getHandler(processedRequest);                if (mappedHandler == null) {                    noHandlerFound(processedRequest, response);                    return;                }                //获取对应的适配器                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());                //调用拦截器的preHandle()前处理方法                if (!mappedHandler.applyPreHandle(processedRequest, response)) {                    //如果上面返回fasle,取反就是true，进来这里就return，结束了                    return;                }                //调用Controller的RequestMapping对应的方法                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                //调用拦截器的postHandle()后处理方法                mappedHandler.applyPostHandle(processedRequest, response, mv);                //省略            }catch (Exception ex) {            //如果出现异常还是会执行triggerAfterCompletion()方法            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);        }        catch (Throwable err) {            //如果出现异常还是会执行triggerAfterCompletion()方法            triggerAfterCompletion(processedRequest, response, mappedHandler,                    new NestedServletException(&quot;Handler processing failed&quot;, err));        }        finally {            //省略        }    }</code></pre><p>从上面源码中明显可以知道，拦截器接口的执行顺序:<br><code>applyPreHandle()</code>→<code>handle()</code>→<code>applyPostHandle()</code>→<code>triggerAfterCompletion()</code><br>或者<br><code>applyPreHandle()</code>→<code>triggerAfterCompletion()</code></p><h3 id="关键在于HandlerExecutionChain接口"><a href="#关键在于HandlerExecutionChain接口" class="headerlink" title="关键在于HandlerExecutionChain接口"></a>关键在于<code>HandlerExecutionChain</code>接口</h3><p>其实上面这些方法除了<code>handle()</code>定义在适配器中，其他都是这个接口的。<code>handle()</code>方法我已经在上一篇《适配器模式与SpringMV》讲过了。下面我们看<code>HandlerExecutionChain</code>接口。</p><pre><code class="java">public class HandlerExecutionChain {    //省略    @Nullable    private HandlerInterceptor[] interceptors;    @Nullable//拦截器集合    private List&lt;HandlerInterceptor&gt; interceptorList;    //指针,用来记录applyPreHandle()方法执行到哪一个拦截器    private int interceptorIndex = -1;}</code></pre><p>这不就跟我们的<code>demo</code>类似吗？定义了一个集合封装拦截器，定义一个指针遍历集合。</p><h4 id="applyPreHandle-方法"><a href="#applyPreHandle-方法" class="headerlink" title="applyPreHandle()方法"></a>applyPreHandle()方法</h4><p>那么前置方法<code>applyPreHandle()</code>是怎么样执行的呢？</p><pre><code class="java">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {        //获取拦截器        HandlerInterceptor[] interceptors = getInterceptors();        //判断不为空        if (!ObjectUtils.isEmpty(interceptors)) {            //按顺序遍历，所以拦截器接口定义的preHandle()是按顺序执行的            for (int i = 0; i &lt; interceptors.length; i++) {                //按顺序获取注册的拦截器                HandlerInterceptor interceptor = interceptors[i];                //执行拦截器的preHandle()方法                if (!interceptor.preHandle(request, response, this.handler)) {                    //如果preHandle()返回false,那就调用triggerAfterCompletion()方法                    triggerAfterCompletion(request, response, null);                    //返回false，结束调用                    return false;                }                //如果preHandle()返回true，继续执行                //把下标索引记录到成员变量的指针中，用于后面执行triggerAfterCompletion()方法                this.interceptorIndex = i;            }        }        return true;    }</code></pre><h4 id="applyPostHandle-方法"><a href="#applyPostHandle-方法" class="headerlink" title="applyPostHandle()方法"></a>applyPostHandle()方法</h4><p>然后下一步执行的<code>applyPostHandle()</code>方法，又是怎么执行的呢？</p><pre><code class="java">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)            throws Exception {        HandlerInterceptor[] interceptors = getInterceptors();        if (!ObjectUtils.isEmpty(interceptors)) {            //倒序遍历，所以postHandle()方法是从最后一个拦截器开始执行的            for (int i = interceptors.length - 1; i &gt;= 0; i--) {                HandlerInterceptor interceptor = interceptors[i];                //postHandle()能获取到ModelAndView对象，拦截器可以对mv对象进行后处理                interceptor.postHandle(request, response, this.handler, mv);            }        }    }</code></pre><h4 id="triggerAfterCompletion-方法"><a href="#triggerAfterCompletion-方法" class="headerlink" title="triggerAfterCompletion()方法"></a>triggerAfterCompletion()方法</h4><pre><code class="java">void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex)            throws Exception {        HandlerInterceptor[] interceptors = getInterceptors();        if (!ObjectUtils.isEmpty(interceptors)) {            //从成员变量interceptorIndex记录的指针值，开始倒序遍历            for (int i = this.interceptorIndex; i &gt;= 0; i--) {                HandlerInterceptor interceptor = interceptors[i];                try {                    interceptor.afterCompletion(request, response, this.handler, ex);                }                catch (Throwable ex2) {                    logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);                }            }        }    }</code></pre><h3 id="拦截器集合-interceptorList如何组装"><a href="#拦截器集合-interceptorList如何组装" class="headerlink" title="拦截器集合 interceptorList如何组装"></a>拦截器集合 <code>interceptorList</code>如何组装</h3><p>我们都看到上面三个方法都有一个公用的方法<code>getInterceptors()</code>。</p><pre><code class="java">    @Nullable    public HandlerInterceptor[] getInterceptors() {        if (this.interceptors == null &amp;&amp; this.interceptorList != null) {            this.interceptors = this.interceptorList.toArray(new HandlerInterceptor[0]);        }        return this.interceptors;    }</code></pre><p>关键是这个<code>interceptorList</code>是在哪里把拦截器<code>add()</code>进去的呢？<br>其实很简单，经过一路顺藤摸瓜，我们看到<code>AbstractHandlerMapping</code>的<code>getHandlerExecutionChain()</code>方法：</p><pre><code class="java">    protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {        HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?                (HandlerExecutionChain) handler : new HandlerExecutionChain(handler));        String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);        for (HandlerInterceptor interceptor : this.adaptedInterceptors) {            //判断是否继承拦截器父类            if (interceptor instanceof MappedInterceptor) {                MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;                if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) {                    //添加拦截器                    chain.addInterceptor(mappedInterceptor.getInterceptor());                }            }            else {                //添加拦截器                chain.addInterceptor(interceptor);            }        }        //返回调用链        return chain;    }</code></pre><p>那么上面这个方法又在什么时候被调用呢？我们一直往上找调用方。<br>首先是<code>AbstractHandlerMapping</code>的<code>getHandler()</code>方法</p><pre><code class="java">    @Override    @Nullable    public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {        //获取调用链        HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);        //省略        return executionChain;    }</code></pre><p>然后到了<code>DispatcherServlet</code>的<code>getHandler()</code>方法</p><pre><code class="java">    @Nullable    protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {        if (this.handlerMappings != null) {            for (HandlerMapping hm : this.handlerMappings) {                //省略                //获取调用链                HandlerExecutionChain handler = hm.getHandler(request);                if (handler != null) {                    //不为null则返回                    return handler;                }            }        }        return null;    }</code></pre><p>最后回到了<code>DispatcherServlet</code>的<code>doDispatch()</code>方法</p><pre><code class="java">    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                // 获取调用链方法！！！                mappedHandler = getHandler(processedRequest);                //省略                }            }        }    }</code></pre><p>哈哈~~真相大白了！是在<code>doDispatch()</code>方法里，获取调用链<code>getHandler()</code>方法中组装好<code>interceptorList</code>拦截器集合的！</p><h3 id="SpringMVC拦截器执行流程图解"><a href="#SpringMVC拦截器执行流程图解" class="headerlink" title="SpringMVC拦截器执行流程图解"></a>SpringMVC拦截器执行流程图解</h3><p>用张图总结一下，就是这样，我用不同的颜色分步骤从浅到深标记了(<strong>求点赞</strong>)：<br><img src="https://static.lovebilibili.com/SringMVC_tujie.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="最后说多几句"><a href="#最后说多几句" class="headerlink" title="最后说多几句"></a>最后说多几句</h1><p>除了<code>SpringMVC</code>外，其实还有很多框架都使用了责任链模式，比如<code>Servlet</code>的<code>Filter</code>，还有<code>Struts2</code>的<code>Interceptor</code>等等。有兴趣的同学可以去看看源码，其实都大同小异，思想懂了之后，源码看起来就没那么费劲了。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong><br><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote><blockquote><p>学之，则难者亦易矣。不学，则易者亦难矣。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式与SpringMVC</title>
    <link href="/2020/05/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8ESpringMVC/"/>
    <url>/2020/05/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8ESpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>适配器模式是将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>用生活中的例子就是充电器的转接头或者数据线转接头，也就是两个类不兼容的情况下，通过适配器类来做到兼容。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>我看了网上很多人的博客，关于适配器模式的一些例子，主要有两种，一种叫类适配器，一种叫对象适配器。写完这两个例子后，我有种恍然大悟的感觉！</p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>首先有一个接口是目标接口<code>PayService</code>，目标方法<code>pay()</code>。</p><pre><code class="java">public interface PayService {    String pay(String channel, String amount) throws Exception;}</code></pre><p>然后有一个被适配的类<code>CheckHelper</code>，适配方法<code>checkedPay()</code></p><pre><code class="java">public class CheckHelper {    //检查支付渠道和支付金额    public boolean checkedPay(String channel, String amount) {        try {            //字符串转成数字，如果出现转换异常返回fasle            int mount = Integer.parseInt(amount);            //PayEnum定义了一些支付渠道，比如支付宝、微信、银联等等            List&lt;String&gt; channelList = Arrays.stream(PayEnum.values())                .map(PayEnum::getChannel)                .collect(Collectors.toList());            //包含在支付渠道中，并且金额大于0，返回true，否则返回false            return channelList.contains(channel) &amp;&amp; mount &gt; 0;        } catch (Exception e) {            return false;        }    }}</code></pre><p>需求是要使得在接口<code>PayService</code>调用<code>CheckHelper</code>的<code>checkedPay()</code>方法，现在使用类适配器的方式演示：</p><pre><code class="java">public class PayAdapter extends CheckHelper implements PayService {    @Override    public String pay(String channel, String amount) throws Exception {        boolean checked = super.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>其实就是使用继承的方式来完成，适配器类继承<code>CheckHelper</code>类，然后使用<code>super</code>来调用被适配类</p><p><code>CheckHelper</code>的<code>checkedPay()</code>方法，一目了然了。</p><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>明显使用类适配器的方式不太灵活，因为<code>java</code>是单继承，所以我们可以改成成员变量的方式，也就是对象适配器。代码如下：</p><pre><code class="java">public class PayAdapter implements PayService {    //使用成员变量    private CheckHelper checkHelper = new CheckHelper();    @Override    public String pay(String channel, String amount) throws Exception {        //调用CheckHelper的checkedPay()方法        boolean checked = checkHelper.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>那么肯定有人会说，你这样直接<code>new</code>一个对象不好，可以使用<code>SpringIOC</code>注入，于是又可以写成这样：</p><pre><code class="java">//注册到Spring容器中@Component(&quot;checkHelper&quot;)public class CheckHelper {}</code></pre><pre><code class="java">public class PayAdapter implements PayService {    @Resource(name = &quot;checkHelper&quot;)    private CheckHelper checkHelper;    @Override    public String pay(String channel, String amount) throws Exception {        boolean checked = checkHelper.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>然后有人可能已经开始察觉了，这不就是平时我们使用的依赖注入吗？没错！所以我开始就说了，写完这两个例子后，我恍然大悟了。原来适配器模式我们一直都在用，只是没认出来罢了。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>那么我们用适配器模式有什么优点呢？为什么要这样写：</p><p>1.解耦，降低了对象与对象之间的耦合性。</p><p>2.增加了类的复用，这点是比较重要的。</p><p>3.灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。这点我待会在下面<code>SpringMVC</code>的应用中详细说明。</p><h2 id="在SpringMVC中的应用"><a href="#在SpringMVC中的应用" class="headerlink" title="在SpringMVC中的应用"></a>在SpringMVC中的应用</h2><p>我们都知道<code>SpringMVC</code>定义一个映射的方式很简单，使用<code>@RequestMapping</code>注解，如下所示：</p><pre><code class="java">@RestControllerpublic class PayController {    @RequestMapping(&quot;/pay&quot;)    public String pay(String channel,String amount)throws Exception{        return &quot;&quot;;    }}</code></pre><p>实际上除了上面这种常用的方式外，还有其他的方式定义：</p><blockquote><p>实现<code>Controller</code>接口</p></blockquote><pre><code class="java">@org.springframework.stereotype.Controller(&quot;/path&quot;)public class TestController implements Controller {    @Override    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {        return null;    }}</code></pre><blockquote><p>实现<code>HttpRequestHandler</code>接口</p></blockquote><pre><code class="java">@Controller(&quot;/httpPath&quot;)public class HttpController implements HttpRequestHandler {    @Override    public void handleRequest(HttpServletRequest request,                              HttpServletResponse response    ) throws ServletException, IOException {        //业务处理，页面跳转，返回响应结果等等    }}</code></pre><blockquote><p>实现<code>Servlet</code>接口</p></blockquote><pre><code class="java">@Controller(&quot;/servletPath&quot;)public class ServletController implements Servlet {    //Servlet生命周期函数    //重写init()方法      //重写getServletConfig()方法    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {        //业务处理    }    //重写getServletInfo()方法    //重写destroy()方法}</code></pre><p>还要配置一个<code>SimpleServletHandlerAdapter</code>适配器的<code>bean</code>，因为默认只加载前面三种适配器，所以这种适配器需要自己手动添加。从这里也可以看出<code>SpringMVC</code>已经不推荐这种创建方式。</p><pre><code class="java">@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter {    @Bean    public SimpleServletHandlerAdapter simpleServletHandlerAdapter() {        return new SimpleServletHandlerAdapter();    }}</code></pre><blockquote><p><code>HandlerFunction</code>接口，关于响应式接口的开发</p></blockquote><p>最后一种是使用<code>HandlerFunction</code>函数式接口，这是<code>Spring5.0</code>后引入的方式，主要用于做响应式接口的开发，这里就不举例子了。后面我会写一篇文章再详述。</p><p><strong>问题：</strong>以上就有五种方式定义<code>Mapping</code>映射，那么<code>SpringMVC</code>是如何去适配的呢？并且具有良好的扩展性和维护性呢？</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先我们把目光放在<code>DispatcherServlet</code>类的<code>doDispatch()</code>方法</p><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        boolean multipartRequestParsed = false;        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                processedRequest = checkMultipart(request);                multipartRequestParsed = (processedRequest != request);                // Determine handler for the current request.                mappedHandler = getHandler(processedRequest);                if (mappedHandler == null) {                    noHandlerFound(processedRequest, response);                    return;                }                //重点： 获取到对应的适配器                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());                //省略...                //重点： 调用HandlerAdapter接口的handle()方法，得到ModelAndView结果                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                //省略...            }            catch (Exception ex) {                //省略...            }            catch (Throwable err) {                //省略..            }        }    }</code></pre><p>先不要慌张，其实学过策略模式你一眼就可以看出来，实际上这里就是运用了类似于策略模式的方式，根据不同的对象获取到对应的适配器，然后执行<code>HandlerAdapter</code>接口的<code>handle()</code>方法得到结果。</p><p>关键是这个<code>getHandlerAdapter()</code>方法，是怎么获取到对应的<code>HandlerAdapter</code>。</p><pre><code class="java">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {        if (this.handlerAdapters != null) {            //这个handlerAdapters有全部的适配器，遍历handlerAdapters集合            for (HandlerAdapter adapter : this.handlerAdapters) {                //如果匹配                if (adapter.supports(handler)) {                    //就返回这个适配器                    return adapter;                }            }        }        throw new ServletException(&quot;No adapter for handler [&quot; + handler +                &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);    }</code></pre><p>那么你看到上面这个<code>this.handlerAdapters</code>肯定会有疑问，<code>handlerAdapters</code>集合里面的适配器是什么时候初始化的？哪里初始化？继续看。</p><p>在<code>DispatcherServlet</code>的<code>initStrategies()</code>方法中有一堆初始化方法。</p><pre><code class="java">protected void initStrategies(ApplicationContext context) {        initMultipartResolver(context);        initLocaleResolver(context);        initThemeResolver(context);        initHandlerMappings(context);        //这个就是初始化适配器的方法，handlerAdapters就是在这里初始化的        initHandlerAdapters(context);        initHandlerExceptionResolvers(context);        initRequestToViewNameTranslator(context);        initViewResolvers(context);        initFlashMapManager(context);    }</code></pre><p>接着我们看<code>initHandlerAdapters()</code>方法</p><pre><code class="java">private void initHandlerAdapters(ApplicationContext context) {        this.handlerAdapters = null;        //省略...        //如果为null，刚开始当然为null，所以加载handlerAdapters集合        if (this.handlerAdapters == null) {            //关键又在于getDefaultStrategies方法            this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);            if (logger.isDebugEnabled()) {                logger.debug(&quot;No HandlerAdapters found in servlet &#39;&quot; + getServletName() + &quot;&#39;: using default&quot;);            }        }    }</code></pre><p>然后我们又去<code>getDefaultStrategies()</code>方法中看你会发现：</p><pre><code class="java">    protected &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) {        String key = strategyInterface.getName();        //defaultStrategies中获取值，key就是HandlerAdapter.class对象        String value = defaultStrategies.getProperty(key);        //省略...    }</code></pre><p>然后重点就在于这个<code>defaultStrategies</code>对象。我们继续看，很快看到了。</p><pre><code class="java">    //DispatcherServlet.properties文件名    private static final String DEFAULT_STRATEGIES_PATH = &quot;DispatcherServlet.properties&quot;;    //Properties对象，全局变量    private static final Properties defaultStrategies;    static {        try {            ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);            //加载DispatcherServlet.properties文件            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);        }        catch (IOException ex) {            throw new IllegalStateException(&quot;Could not load &#39;&quot; + DEFAULT_STRATEGIES_PATH + &quot;&#39;: &quot; + ex.getMessage());        }    }</code></pre><p>所以明显可以看到所有的适配器类都是写在<code>DispatcherServlet.properties</code>文件里了！默认加载这三种适配器。</p><pre><code class="properties">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\    org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</code></pre><h3 id="得到结论："><a href="#得到结论：" class="headerlink" title="得到结论："></a>得到结论：</h3><p>适配器实现类是从<code>DispatcherServlet.properties</code>文件加载到内存中的。</p><h2 id="HandlerAdapter接口"><a href="#HandlerAdapter接口" class="headerlink" title="HandlerAdapter接口"></a>HandlerAdapter接口</h2><p>所以关键在于<code>HandlerAdapter</code>接口，接口信息如下：</p><pre><code class="java">public interface HandlerAdapter {    //子类去实现，用于判断上级接口    boolean supports(Object handler);    //子类实现这个方法，返回响应的结果    @Nullable    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;    //判断是否使用浏览器缓存，返回-1表示不使用浏览器缓存    long getLastModified(HttpServletRequest request, Object handler);}</code></pre><p>学过策略模式的应该很清楚了，上面讲过有5种方式定义<code>Mapping</code>。</p><p>所以应该可以猜测<code>HandlerAdapter</code>接口有五个子类。打开类图：</p><p><img src="https://static.lovebilibili.com/HandlerAdapter.png" srcset="/img/loading.gif" alt=""></p><p>果然是有五个实现的子类分别对应五种方式！</p><p>那么我们找其中一个实现类，比如最简单的<code>SimpleControllerHandlerAdapter</code>，来分析一下：</p><pre><code class="java">public class SimpleControllerHandlerAdapter implements HandlerAdapter {    @Override    //getHandlerAdapter()方法就会调用这个方法判断，然后返回对应的适配器实现类    //这里返回的就是SimpleControllerHandlerAdapter适配器    public boolean supports(Object handler) {        return (handler instanceof Controller);    }    @Override    @Nullable    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception {        //执行Controller接口的handleRequest，也就是mapping映射的方法        return ((Controller) handler).handleRequest(request, response);    }    //判断是否使用浏览器缓存，返回-1表示不使用浏览器缓存    @Override    public long getLastModified(HttpServletRequest request, Object handler) {        if (handler instanceof LastModified) {            return ((LastModified) handler).getLastModified(request);        }        return -1L;    }}</code></pre><p>下面画一张图来总结一下以上的分析过程：</p><p><img src="https://static.lovebilibili.com/adapterProcessPic.png" srcset="/img/loading.gif" alt=""></p><p>这不就像策略模式吗…只能解释为设计模式有很多都比较类似。假设<code>SpringMVC</code>要增加一种定义<code>Mapping</code>的方式，那就很容易了，增加对应的适配器实现类，对原有的代码没有任何的侵入，这就非常符合开闭原则。接下来我们就对适配器进行扩展，自定义一个适配器。</p><h2 id="自定义SpringMVC适配器"><a href="#自定义SpringMVC适配器" class="headerlink" title="自定义SpringMVC适配器"></a>自定义SpringMVC适配器</h2><p>首先要定义一个适配器<code>MyHandlerAdapter</code>，实现<code>HandlerAdapter</code>接口。</p><pre><code class="java">public class MyHandlerAdapter implements HandlerAdapter {    @Override    public boolean supports(Object handler) {        return handler instanceof MyController;    }    @Override    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        return ((MyController) handler).handleRequest(request, response);    }    @Override    public long getLastModified(HttpServletRequest request, Object handler) {        //不使用浏览器缓存，返回-1        return -1;    }}</code></pre><p>接着定义一个<code>MyController</code>接口。</p><pre><code class="java">public interface MyController {    /**     * 处理请求     */    @Nullable    ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;}</code></pre><p>注册适配器到<code>Spring</code>容器中。</p><pre><code class="java">@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter {    //注册自定义的适配器    @Bean    public MyHandlerAdapter myHandlerAdapter() {        return new MyHandlerAdapter();    }}</code></pre><p>最后创建一个<code>MyTestController</code>实现<code>MyController</code>进行测试。</p><pre><code class="java">@Controller(&quot;/myTest&quot;)public class MyTestController implements MyController {    @Override    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {        response.getWriter().println(&quot;MyTestController Test success!!!&quot;);        return null;    }}</code></pre><p>启动项目，然后在浏览器输入访问地址，即可看到。</p><p><img src="https://static.lovebilibili.com/adapter_test.png" srcset="/img/loading.gif" alt=""></p><p>当你理解透彻之后，你就可以这样自定义一个适配器，来加深一下理解，验证之前的分析的正确性。</p><p>沉下心学习，才能跑得更快！</p><p>以上就是适配器模式的学习，更多的java技术分享，就关注<strong>java技术爱好者</strong>吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次高级java面试</title>
    <link href="/2020/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E7%BA%A7java%E9%9D%A2%E8%AF%95/"/>
    <url>/2020/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E7%BA%A7java%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一次高级JAVA开发面试题目"><a href="#记录一次高级JAVA开发面试题目" class="headerlink" title="记录一次高级JAVA开发面试题目"></a>记录一次高级JAVA开发面试题目</h1><p>面试时间大概40多分钟，问了有十几个问题，回忆一下记录下来，总结经验，以供参考。</p><a id="more"></a><p><strong>1、 static关键字的作用，平时开发用在什么地方？</strong><br>答：主要有三种用法。<br>①修饰成员变量，用static修饰的成员变量就成为静态变量，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。<br>②static修饰方法，该方法就被定义为静态方法，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。<br>③用static修饰代码块，该代码块就被定义为静态代码块，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。</p><p><strong>2、static修饰的成员变量和非static修饰的成员变量有什么区别？分别存在什么区域？</strong><br>答：静态成员变量在内存中只会存在一份，是通过类名访问，存在于静态区中。非静态成员变量是随着对象的创建而存在的，可以有多份，通过创建的对象访问，存在于堆内存中。</p><p><strong>3、说一下类初始化的顺序。</strong><br>答：静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。</p><p><strong>4、常用的集合类型有哪些？</strong><br>答：有Map、Set、List是比较常用的。</p><p><strong>5、List常用的实现类有哪些？ArrayList和LinkedList底层实现原理是什么？</strong><br>答：List常用的实现类有ArrayList和LinkedList。ArrayList底层原理是数组+动态扩容机制实现的，LinkedList底层原理是用Node结点形成的链表实现的。</p><p><strong>6、在开发中如何选择使用ArrayList和LinkedList？</strong><br>答：ArrayList是数组实现，所以通过下标访问效率最快，但是缺点是如果增删比较频繁的情况下，需要经常扩容，性能不是很好。LinkedList在增删的情况下，效率较高，但是访问集合中的元素时都需要从第一个元素开始遍历，效率较低。所以如果增删的情况较多的时候，可以使用LinkedList。查询较多时使用ArrayList。</p><p> <strong>7、List集合如果要排序有哪些实现方式？</strong><br>①使用List接口定义的sort()方法。</p><pre><code class="java">list.sort(Comparator.comparingInt(User::getAge));</code></pre><p>②使用Collections的sort()方法，排序的对象需要实现Comparable接口，重写compareTo()方法。</p><pre><code class="java">//实现Comparable接口public class User implements Comparable&lt;User&gt; {    //重写compareTo方法    @Override    public int compareTo(User user) {            return Integer.compare(this.getAge(), user.getAge());    }}</code></pre><p>使用Collections的sort()方法</p><pre><code class="java">Collections.sort(list);//如果不想实现Comparable接口，也可以使用这个方法Collections.sort(list,Comparator.comparingInt(User::getAge));</code></pre><p>③使用Stream流操作的sort()方法，传入一个Comparator接口。</p><pre><code class="java">list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList());</code></pre><p> <strong>8、ArrayList是线程安全的吗？有什么方式可以让ArrayList变成线程安全的？</strong><br>答：不是线程安全的。<br>使用Collections的synchronizedList()方法包装可获得线程安全的ArrayList。</p><pre><code class="java">List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code></pre><p><strong>9、你是怎么在项目中使用redis的？</strong><br>答：这其实是考了“redis常用的应用场景”这个问题。<br>①利用redis读写速度快的特点，可以做热点数据的储存，降低数据库查询的压力。<br>②利用redis键值设置有效期的特性，做一些限时的业务。比如手机验证码。<br>③利用setnx命令的特性，可以实现分布式锁。</p><p><strong>10、使用Redis实现分布式锁的原理是什么？</strong><br>答： 利用setnx命令的特性。使用setnx一个lockKey字符串作为键，当前的时间+上锁时间作为value。如果返回是0，表示已经被上锁了，需要等待锁持有者释放锁；如果返回1，则表示获得了锁。客户端释放锁的话执行del命令删除lockKey对应的键值。</p><p><strong>11、如果使用分布式锁加锁后，由于一些异常的原因没有执行解锁的操作，怎么办？</strong><br>答：一般解锁操作会放在finally代码块中执行。如果有极端情况下没有执行到解锁的操作，可以通过key对应的时间戳判断是否超时，然后使用GETSET命令去进行解锁，通过判断返回的时间戳是否是超时的key对应的时间戳，确认是否成功上锁。</p><p><strong>12、如果加分布式锁的时候，业务操作时间比较长，造成长时间的阻塞，有什么解决方案？</strong><br>答：可以在加锁时启动一个watch dog(看门狗)线程，每隔10秒检查一下，如果客户端还持有锁则加长lockKey的生存时间。或者可以考虑用zookeeper实现的分布式锁，因为zk实现原理是基于事件监听的方式来实现。</p><p><strong>13、MySQL性能优化的策略有哪些？</strong><br>①复杂的多表查询可以拆成多句简单查询。<br>②返回尽量少的列，按需返回，严禁使用select *。<br>③尽量使用索引列做查询条件和排序条件。<br>④使用复合索引要遵循最左匹配原则。</p><p><strong>14、MySQL索引创建的原则是什么？</strong><br>①对于查询频率高的字段，创建索引。<br>②对排序、分组、联合查询频率高的字段创建索引。<br>③如果多个列都需要设置索引，可以考虑创建复合索引。<br>④尽量选择数据量较少的列作为索引。<br>⑤一个表的索引数量不宜过多，会降低查询的效率。</p><p><strong>15、雪花算法是什么原理？</strong><br>答：使用一个 64 bit 的 long 型的数字作为全局唯一 id。是由时间戳、机房id、机器id、序号组成的。结合了UUID的全局唯一的特点，又具有自增有顺序的特点。</p><p><strong>16、为什么雪花算法生成的主键有字符串类型和long类型两种类型？</strong><br>答：因为后端返回给前端一个long类型时，会有可能产生丢失精度的问题，所以会有字符串的类型，弥补这个问题。</p><p><strong>17、谈一谈MySQL锁机制。</strong><br>主要有以下几种锁：<br>表锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>行锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>在MySQL中只有InnoDB存储引擎可以使用行锁。行锁又分为以下两种形式：<br>读锁(共享锁)：当读取一条数据时，会加上读锁，其他事务如果要读取是可以的，如果要修改则要等事务释放才可以。<br>写锁(排他锁)：这个比较简单，当有一个事务要修改数据时，就会给这些行加上写锁。在加锁期间，不允许其他事务加上任何的锁，只有当这个事务释放了，才可以加锁操作。</p><p>在这次面试中，其实也不是特别难，大部分都回答得不错，但是有两个问题不是很好。雪花算法为什么主键生成有两种类型这个问题没有答出来，还有分布式锁长时间阻塞的解决方案没有详细展开讲。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式在实战中的应用</title>
    <link href="/2020/05/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>比如有些人喜欢写文章，但是如果从头到尾原创的话太麻烦了，那么他可以上网去搜索，找一篇写得不错的文章，然后复制下来，做一些修改，最后发布就是自己的文章了。这其实就使用了原型模式的设计模式，创建一个对象过于麻烦的时候，我们只需要创建一次，后面再创建的话只需要对原对象进行克隆即可。</p><h2 id="不使用原型模式的问题"><a href="#不使用原型模式的问题" class="headerlink" title="不使用原型模式的问题"></a>不使用原型模式的问题</h2><p>假设我们有一个用户<code>User</code>的类，类里面有很多字段，当我们创建对象时，就会像这样子：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setAge(18);        user.setJob(&quot;程序员&quot;);        user.setSchool(&quot;家里蹲大学&quot;);        user.setNation(&quot;汉族&quot;);        //0-男 1-女        user.setGender((byte)0);        user.setPhone(&quot;110&quot;);        user.setPoliticalFeatures(&quot;群众&quot;);        user.setEducation(&quot;大学本科&quot;);        //第二个用户，跟第一个用户只有id，name，phone这三个字段不同        User user1 = new User();        user1.setId(2);        user1.setName(&quot;李四&quot;);        user1.setAge(18);        user1.setJob(&quot;程序员&quot;);        user1.setSchool(&quot;家里蹲大学&quot;);        user1.setNation(&quot;汉族&quot;);        //0-男 1-女        user1.setGender((byte)0);        user1.setPhone(&quot;111&quot;);        user1.setPoliticalFeatures(&quot;群众&quot;);        user1.setEducation(&quot;大学本科&quot;);    }}</code></pre><p>不难看出上面的代码有以下问题：</p><p>1.<code>user</code>对象有10个字段，明显在创建第二个<code>user</code>对象的时候有很多重复的设值的操作。在实际项目中，肯定还不止设置10个字段，那么就会显得很难看。</p><p>2.创建对象如果消耗资源很多的话，这样多次去创建设值肯定会造成资源浪费。</p><p>对于以上的问题，我们可以使用原型模式进行优化。</p><h2 id="使用Cloneable接口优化"><a href="#使用Cloneable接口优化" class="headerlink" title="使用Cloneable接口优化"></a>使用Cloneable接口优化</h2><p><code>java</code>提供了一个<code>Cloneable</code>接口，可以实现克隆对象的用途，怎么实现，请看以下代码：</p><pre><code class="java">//实现Cloneable接口public class User implements Cloneable {    //省略了字段    //省略了字段的Get、Set方法    //重写clone()方法    @Override    public User clone() throws CloneNotSupportedException {        return (User) super.clone();    }}</code></pre><p>然后就可以把<code>main()</code>方法的代码改成以下这样：</p><pre><code class="java">public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setAge(18);        user.setJob(&quot;程序员&quot;);        user.setSchool(&quot;家里蹲大学&quot;);        user.setNation(&quot;汉族&quot;);        //0-男 1-女        user.setGender((byte)0);        user.setPhone(&quot;110&quot;);        user.setPoliticalFeatures(&quot;群众&quot;);        user.setEducation(&quot;大学本科&quot;);        //调用克隆方法，复制第一个user对象        User user1 = user.clone();        user1.setId(2);        user1.setName(&quot;李四&quot;);        user1.setPhone(&quot;111&quot;);        System.out.println(user1);        //控制台打印结果        //User{id=2, name=&#39;李四&#39;, phone=&#39;111&#39;, nation=&#39;汉族&#39;...}}</code></pre><p>你是不是有疑问，这两个<code>user</code>对象内存地址是否一致呢？我们可以打印出来看看：</p><pre><code class="java">com.yehongzhi.httpclient.model.User@4c873330com.yehongzhi.httpclient.model.User@119d7047</code></pre><p>内存地址是不一样的，所以我们可以得出一个结论：<strong>克隆出来的对象是一个新的对象。</strong></p><p><strong>问题：</strong>克隆方法的底层是不是调用了构造器创建了一个对象的呢？</p><p>我们可以在构造器上面加一些打印语句来验证一下：</p><pre><code class="java">public class User implements Cloneable {    //其他非重点代码省略    //构造器，如果以下语句打印了两次，则证明clone调用了构造器创建对象    public User() {        System.out.println(&quot;调用了无参构造器&quot;);    }    //克隆方法    @Override    public User clone() throws CloneNotSupportedException {        System.out.println(&quot;调用了clone()方法&quot;);        return (User) super.clone();    }}</code></pre><p>我们运行<code>main()</code>方法后，可以看到控制台打印信息如下：</p><pre><code class="java">// 调用了无参构造器// 调用了clone()方法</code></pre><p>只调用了一次构造器，我们可以得出结论：</p><blockquote><p>clone()方法不是调用了构造器创建对象的。</p></blockquote><p>如果你刨根究底，究竟clone()方法是怎么创建对象的，其实也很简单，打开源码：</p><pre><code class="java">public class Object {    private static native void registerNatives();    static {        registerNatives();    }    //最终会调用Object的克隆方法，是一个native修饰的方法    protected native Object clone() throws CloneNotSupportedException;}</code></pre><p>native修饰的方法是什么意思呢？意思就是这个方法的实现不是用<code>java</code>，而是<code>C/C++</code>实现。这个native关键字我们可以单独写一篇文章细讲，这里就不深入展开。底层的实现逻辑就是拷贝一份数据，开辟一块新的内存。所以拷贝出来的对象，打印的内存地址和原来的对象不一样。</p><h2 id="使用Cloneable接口的问题"><a href="#使用Cloneable接口的问题" class="headerlink" title="使用Cloneable接口的问题"></a>使用Cloneable接口的问题</h2><p>使用<code>Cloneable</code>接口是不是就完美的呢，其实并不是，因为如果一个对象的字段也是一个对象，是一个引用数据类型时，那就会有问题。请看以下代码：</p><p>我们增加一个对象<code>IdCard</code>类</p><pre><code class="java">public class IdCard {    private String cardNo;    private Integer validityPeriod;    private Date createDate;    //省略getter、setter方法}</code></pre><pre><code class="java">public class User implements Cloneable {    //其他字段省略    //身份证对象    private IdCard idCard;    //省略getter、setter方法}</code></pre><p>然后我们在<code>main()</code>方法赋值：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        //省略其他字段的赋值        //创建一个IdCard对象        IdCard idCard = new IdCard();        //身份证号码        idCard.setCardNo(&quot;111111&quot;);        //创建日期        idCard.setCreateDate(new Date());        //身份证有效期        idCard.setValidityPeriod(10);        //user对象设置身份证对象        user.setIdCard(idCard);        //user克隆，得到user1        User user1 = user.clone();        //打印user、user1的IdCard对象的内存地址，内存地址一样！        System.out.println(user.getIdCard());//IdCard@4c873330        System.out.println(user1.getIdCard());//IdCard@4c873330        //当改变克隆体user1的IdCard里面的字段值        user1.getIdCard().setCardNo(&quot;222222&quot;);        //源对象user的IdCard里面的字段值也跟着一起改变了        System.out.println(user.getIdCard().getCardNo());//222222    }}</code></pre><p>明显这样的克隆是有巨大的问题的，因为项目中不可能只有基本数据类型。那怎么解决呢？</p><pre><code class="java">//IdCard对象也要实现Cloneable接口public class IdCard implements Cloneable{    //也需要重写clone()方法    @Override    protected IdCard clone() throws CloneNotSupportedException {        return (IdCard)super.clone();    }}</code></pre><pre><code class="java">public class User implements Cloneable {    @Override    public User clone() throws CloneNotSupportedException {        User user = (User) super.clone();        //获取idCard源对象        IdCard idCard = user.getIdCard();        //克隆一个idCard对象。然后set值到user对象中        user.setIdCard(idCard.clone());        return user;    }}</code></pre><p>最后我们再调用<code>main()</code>方法：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        //创建一个IdCard对象        IdCard idCard = new IdCard();        //身份证号码        idCard.setCardNo(&quot;111111&quot;);        //user对象设置身份证对象        user.setIdCard(idCard);        //克隆user对象，得到user1对象        User user1 = user.clone();        //打印user、user1的IdCard对象的内存地址，内存地址不一样了！        System.out.println(user.getIdCard());//IdCard@4c873330        System.out.println(user1.getIdCard());//IdCard@119d7047        //当改变克隆体user1的IdCard里面的字段值        user1.getIdCard().setCardNo(&quot;222222&quot;);        //源对象user的IdCard里面的字段值也跟着一起改变了        System.out.println(user.getIdCard().getCardNo());//111111    }}</code></pre><h2 id="使用序列化实现深克隆"><a href="#使用序列化实现深克隆" class="headerlink" title="使用序列化实现深克隆"></a>使用序列化实现深克隆</h2><p>上面使用<code>Cloneable</code>接口的方式，被称为浅克隆，如果你想要克隆的源对象里面又有对象时，里面的对象也要实现<code>Cloneable</code>接口，然后修改源对象的<code>clone()</code>方法，这样就非常麻烦，而且当扩展时会破坏开闭原则。</p><p>解决方法，我们可以采用序列化对象的方式，实现深克隆呢？请看以下代码：</p><p><code>User</code>对象实现<code>Serializable</code>接口:</p><pre><code class="java">public class User implements Serializable {    private static final long serialVersionUID = 8656071024384993135L;}</code></pre><p><code>IdCard</code>对象实现<code>Serializable</code>接口：</p><pre><code class="java">public class IdCard implements Serializable {    private static final long serialVersionUID = -422430076410272813L;}</code></pre><p>创建一个工具类<code>CloneUtil</code>实现深克隆：</p><pre><code class="java">public class CloneUtil {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T&gt; T depthClone(T t, Class&lt;T&gt; clazz) throws Exception {        ByteArrayOutputStream baos = null;        ObjectOutputStream ous = null;        ByteArrayInputStream bais = null;        ObjectInputStream ois = null;        try {            //将源对象序列化，写入流中，写入流的对象是一个拷贝的对象，原对象还在JVM中            baos = new ByteArrayOutputStream();            ous = new ObjectOutputStream(baos);            ous.writeObject(t);            //把流中的对象再读取到内存中，就获得了克隆后的对象            bais = new ByteArrayInputStream(baos.toByteArray());            ois = new ObjectInputStream(bais);            return (T) ois.readObject();        } catch (Exception e) {            e.printStackTrace();            throw new RuntimeException(&quot;深克隆出现异常&quot;);        } finally {            if (ous != null) {ous.close();}            if (baos != null) {baos.close();}            if (bais != null) {bais.close();}            if (ois != null) {ois.close();}        }    }}</code></pre><p>验证是否深克隆，在<code>main()</code>方法中打印内存地址查看即可：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        User user = new User();        user.setIdCard(new IdCard());        User user1 = CloneUtil.depthClone(user, User.class);        //内存地址都不相同，达到了深克隆的效果        System.out.println(user);//User@3d075dc0        System.out.println(user1);//User@2ef1e4fa        System.out.println(user.getIdCard());//IdCard@214c265e        System.out.println(user1.getIdCard());//IdCard@306a30c7    }}</code></pre><p>用序列化实现深克隆的优点就是，对源代码侵入性很低，只需要实现<code>Serializable</code>接口，不需要一层一层去实现<code>Cloneable</code>接口，还有重写<code>clone()</code>方法。</p><p><strong>问题：</strong>如果这个实体类是在<code>jar</code>包中的呢，我们没法去修改实体类的代码，那怎么实现克隆呢？</p><h2 id="使用反射实现克隆"><a href="#使用反射实现克隆" class="headerlink" title="使用反射实现克隆"></a>使用反射实现克隆</h2><p>利用反射，实际上我们可以拿到源对象的任何值，所以就可以实现克隆，请看以下代码：</p><p>我们创建一个<code>copyProperties()</code>方法，具体实现看以下代码：</p><pre><code class="java">public class CloneUtil {    public static void copyProperties(Object source, Object target) throws Exception {        //获取源对象的属性描述器        PropertyDescriptor[] sourceDescriptors = Introspector                .getBeanInfo(source.getClass())                .getPropertyDescriptors();        //获取目标对象的字段名称集合        List&lt;String&gt; targetFieldNames = Arrays                .stream(target.getClass().getDeclaredFields())                .map(Field::getName)                .collect(Collectors.toList());        for (PropertyDescriptor sourceProperty : sourceDescriptors) {            //获取源对象的属性名称            String name = sourceProperty.getName();            //源对象的getter方法            Method readMethod = sourceProperty.getReadMethod();            if (!readMethod.isAccessible()) {                //设置方法的可访问权限                readMethod.setAccessible(true);            }            //调用源对象的getter方法，获取到里面的每一个值            Object value = readMethod.invoke(source);            //如果源对象的属性名称包含在目标对象的字段名称集合中            if (targetFieldNames.contains(name)) {                //则通过源对象的属性名称获取目标对象属性的属性描述器                PropertyDescriptor propertyDescriptor = new PropertyDescriptor(name, target.getClass());                //获取目标对象的setter方法                Method writeMethod = propertyDescriptor.getWriteMethod();                writeMethod.setAccessible(true);                //执行setter方法，参数是从源对象getter方法获取到的值                writeMethod.invoke(target, value);            }        }    }}</code></pre><p>测试：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setIdCard(new IdCard());        User user1 = new User();        CloneUtil.copyProperties(user, user1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三        System.out.println(user.getIdCard());//IdCard@b81eda8        System.out.println(user1.getIdCard());//IdCard@b81eda8    }</code></pre><p>这样实现的不是深克隆的效果，所以<code>IdCard</code>对象的内存地址还是一样的。为了避免这样的结果，我们可以在使用时注意一下：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setName(&quot;张三&quot;);        IdCard idCard = new IdCard();        user.setIdCard(idCard);        User user1 = new User();        //创建一个新的IdCard对象        IdCard idCard1 = new IdCard();        CloneUtil.copyProperties(user, user1);        //复制idCard的值到idCard1里        CloneUtil.copyProperties(idCard,idCard1);        //再设置idCard1到user1中        user1.setIdCard(idCard1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三        System.out.println(user.getIdCard());//IdCard@68de145        //内存地址不同        System.out.println(user1.getIdCard());//IdCard@27fa135a    }</code></pre><p>这样就避免产生内存地址一样的情况了。</p><h2 id="Spring的copyProperties"><a href="#Spring的copyProperties" class="headerlink" title="Spring的copyProperties()"></a>Spring的copyProperties()</h2><p>实际上在<code>Spring</code>框架中，已经提供了<code>copyProperties()</code>方法：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setName(&quot;张三&quot;);        User user1 = new User();        //Spring的copyProperties()方法        BeanUtils.copyProperties(user,user1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三    }</code></pre><p>一般在实际项目中，我们采用<code>copyProperties()</code>方法实现原型模式会更好，因为这样不会破坏开闭原则，即使是<code>jar</code>包中定义的实体类，也可以使用。缺点就是如果对象层级比较多的话，会比较麻烦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现原型模式的三种方式：实现<code>Cloneable</code>接口、序列化对象、反射机制。</p><p>原型模式的优点：</p><ol><li>提高了创建对象的性能，避免了调用构造器创建对象。</li><li>对于创建一个对象需要很多资源的情况，可以减少资源的浪费。</li></ol><p>原型模式的缺点：</p><ol><li>如果使用<code>Cloneable</code>接口的方式，需要实现<code>Cloneable</code>接口，对代码有一定的侵入性。</li><li>如果使用序列化方式，则需要实现<code>Serializable</code>接口，对代码也有一定的侵入性。</li><li>如果使用反射机制，层级较多时会比较难维护。</li></ol><p>以上就是原型模式的学习，更多的java技术分享，就关注<strong>java技术爱好者</strong>吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰者模式与IO流</title>
    <link href="/2020/05/04/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8EIO%E6%B5%81/"/>
    <url>/2020/05/04/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8EIO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>装饰者模式是一种<strong>对象结构型</strong>模式。<strong>动态</strong>地给一个对象添加一些<strong>额外的</strong>职责，就增加功能来说，装饰者模式比生成子类更为灵活。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>上面的定义在网上是随处可见的描述，怎么解释呢。比如：我前几天和女朋友去买戒指，珠宝店的销售给我推荐了一种<strong>自由搭配</strong>的原创戒指。他跟我介绍戒指的元素需要选择材质(黄金，铂金，彩金)、表面工艺(拉丝，磨砂，光滑，铸造)、镶钻(内嵌，外嵌)、指环大小等等，然后组成一个戒指。这种就是装饰者模式的应用，原型是一个戒指，不断地给对象添加额外的职责，然后得到最终想要的产品。这样就可以通过不同的搭配产生很多不同类型的戒指。</p><p>后面那句<strong>装饰者模式比生成子类更为灵活</strong>怎么理解。如果用子类去描述的话，要把每一种搭配的结果都变成一个子类，也就是要穷举，就会产生很多子类，也就是造成<strong>“类爆炸”</strong>。所以就会说装饰者模式更加灵活。</p><h2 id="来个例子"><a href="#来个例子" class="headerlink" title="来个例子"></a>来个例子</h2><p>现在有一个需求，要求做一个加密的工具类，对传入的字符串加密。加密的算法有很多，有<strong>MD5、AES、DES等等</strong>，一般加密都不是单独使用一种加密算法，而是多种混合一起使用，这样可以提高安全性。</p><p>现在有三种算法：<code>MD5、AES、DES</code>。做一个工具类，给系统提供加密的服务，要求可以自由搭配使用。</p><h2 id="使用继承的方式实现"><a href="#使用继承的方式实现" class="headerlink" title="使用继承的方式实现"></a>使用继承的方式实现</h2><p>我们就创建一个抽象类<code>EncryptionBase</code>，每一种组合方式就创建一个子类继承<code>EncryptionBase</code>，现在有三种加密方式，很容易我们可以穷举完，总共有6种组合。请看以下代码：</p><p>首先创建一个抽象类<code>EncryptionBase</code>：</p><pre><code class="java">public abstract class EncryptionBase {    public abstract String encrypt(String string,String password);}</code></pre><p>接着创建子类继承抽象类，并且实现其方法。以其中一个为例，其他实现类都类似：</p><pre><code class="java">public class AESandDESandMD5Encryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        //网上可以找具体加密的代码，我这里篇幅受限就不展示了        //AES加密        byte[] encryptByAES = AESUtil.encrypt(string, password);        //DES加密        byte[] encryptByDES = DESUtil.encrypt(encryptByAES, password);        //MD5加密        return MD5Util.encryptByMD5(new String(encryptByDES) + password);    }}</code></pre><p>我们就可以实现以下效果，有6个实现类分别实现了3种加密算法的不同顺序。</p><pre><code class="java">public static void main(String[] args) {        String string = &quot;需要加密的字符串&quot;;        //秘钥        String password = &quot;12345678&quot;;        //第一种加密顺序：AES-&gt;DES-&gt;MD5        EncryptionBase AESandDESandMD5 = new AESandDESandMD5Encryption();        //第二种加密顺序：AES-&gt;MD5-&gt;DES        EncryptionBase AESandMD5andDES = new AESandMD5andDESEncryption();        //第三种加密顺序：DES-&gt;AES-&gt;MD5        EncryptionBase DESandAESandMD5 = new DESandAESandMD5Encryption();        //第四种加密顺序：DES-&gt;MD5-&gt;AES        EncryptionBase DESandMD5andAES = new DESandMD5andAESEncryption();        //第五种加密顺序：MD5-&gt;DES-&gt;AES        EncryptionBase MD5andDESandAES = new MD5andDESandAESEncryption();        //第六种加密顺序：MD5-&gt;AES-&gt;DES        EncryptionBase MD5andAESandDES = new MD5andAESandDESEncryption();    }</code></pre><p>以上就是使用继承的方式来完成这个需求。看起来没什么问题，但是仔细思考你会发现几个问题。</p><ol><li><strong>会创建很多子类。</strong>为什么3种算法是6个类呢？这是根据数学的排列组合<code>3*2*1=6</code>，假设再多两种算法呢？那就是<code>5*4*3*2*1=120</code>，那就是120个类了！这就是<strong>“类爆炸”</strong>。</li><li><strong>不符合开闭原则。</strong>假设增加了新的算法，那就要修改原来的类，不利于代码的维护。</li><li>假如其中一种加密算法要用两次，比如双重<code>MD5</code>加密，那也是很难扩展的。</li></ol><p>如果你不会装饰者模式，那估计要加班加点去写代码，创建很多类。如果你会装饰者模式，那问题就很简单了，那怎么做呢？请继续看下去。</p><h2 id="使用装饰者模式实现"><a href="#使用装饰者模式实现" class="headerlink" title="使用装饰者模式实现"></a>使用装饰者模式实现</h2><p>首先创建三种算法的基础类，继承<code>EncryptionBase</code>，实现三种加密算法。</p><p>MD5加密</p><pre><code class="java">public class MD5Encryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用MD5加密，得到基础密文&quot;);        return MD5Util.encryptByMD5(string + password);    }}</code></pre><p>AES加密</p><pre><code class="java">public class AESEncryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用AES加密，得到基础密文&quot;);        return new String(AESUtil.encrypt(string, password));    }}</code></pre><p>DES加密</p><pre><code class="java">public class DESEncryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用DES加密，得到基础密文&quot;);        return new String(DESUtil.encrypt(string.getBytes(), password));    }}</code></pre><p>接着创建一个装饰抽象类<code>EncryptionDecorator</code>，需要继承<code>EncryptionBase</code></p><pre><code class="java">public abstract class EncryptionDecorator extends EncryptionBase {    //定义一个父类的成员变量，用来存储其他装饰类，或者基础加密类    private EncryptionBase encryption;    public EncryptionDecorator(EncryptionBase encryption) {        this.encryption = encryption;    }    @Override    public String encrypt(String string, String password) throws Exception{        return encryption.encrypt(string, password);    }}</code></pre><p>然后实现三种加密的装饰者实现类，需要继承抽象装饰者类<code>EncryptionDecorator</code>。</p><p>MD5加密装饰者实现类<code>MD5EncryptionDecorator</code></p><pre><code class="java">public class MD5EncryptionDecorator extends EncryptionDecorator {    public MD5EncryptionDecorator(EncryptionBase encryption) {        //有参构造器获取到参数，调用父类的有参构造器，        //当下面encrypt()方法里调用父类的加密算法就会调用传入的算法实现类的加密算法        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用MD5加密&quot;);        //得到的密文，再用MD5算法加密，返回        return MD5Util.encryptByMD5(encrypt + password);    }}</code></pre><p>AES加密装饰者实现类<code>AESEncryptionDecorator</code></p><pre><code class="java">public class AESEncryptionDecorator extends EncryptionDecorator {    public AESEncryptionDecorator(EncryptionBase encryption) {        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用AES加密&quot;);        //得到的密文，再用AES算法加密，返回        return new String(AESUtil.encrypt(encrypt, password),&quot;UTF-8&quot;);    }}</code></pre><p>DES加密装饰者实现类<code>DESEncryptionDecorator</code></p><pre><code class="java">public class DESEncryptionDecorator extends EncryptionDecorator {    public DESEncryptionDecorator(EncryptionBase encryption) {        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用DES加密&quot;);        //得到的密文，再用DES算法加密，返回        return new String(DESUtil.encrypt(encrypt.getBytes(), password),&quot;UTF-8&quot;);    }}</code></pre><p>大功告成！我们用<code>main()</code>方法测试一下：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception{        String string = &quot;需要加密的字符串&quot;;        String password = &quot;12345678&quot;;        //第一种加密顺序：AES-&gt;DES-&gt;MD5        EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption()));        encryptionBase.encrypt(string, password);    }}</code></pre><p>控制台打印结果：</p><pre><code class="java">/**使用AES加密，得到基础密文使用DES加密使用MD5加密*/</code></pre><p>我们可以看到结果是很完美地实现了，你可以任意搭配加密算法，即使加多N种算法，我们也不会呈指数增加类的数量，只需要增加M*N个类即可，M是基础构件数量，N是具体装饰类数量。</p><p>原理是什么呢？我们不能说只学到形式，而不明白原理。接下来看类图。</p><p>在IDEA可以选中类名，然后右键，选中“Diagrams”，再选中“show Diagrams…”，就可以打开类图。</p><img src="https://static.lovebilibili.com/MD5EncryptionDecorator.png" srcset="/img/loading.gif"/><pre><code class="java">//MD5(DES(AES))，最顶层的父类是AES，所以先执行，第二层是DES，第二执行，最外层是MD5第三执行EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption()));encryptionBase.encrypt(string, password);</code></pre><p>以上面这句代码为例，那么调用顺序就是：AES-&gt;DES-&gt;MD5</p><img src="https://static.lovebilibili.com/decorator1.png" srcset="/img/loading.gif" style="width:100%;"/><p>这就是装饰者模式的原理，其实很简单的，很容易就可以看清楚。</p><h2 id="装饰者模式与I-O流"><a href="#装饰者模式与I-O流" class="headerlink" title="装饰者模式与I/O流"></a>装饰者模式与I/O流</h2><p>看了上面的代码，很容易我们能联想到IO流也有类似的创建方式，比如我们要用文件缓冲输入流，那就要这样创建：</p><pre><code class="java">InputStream inputStream     = new BufferedInputStream(new FileInputStream(new File(&quot;/D:abc.text&quot;)));</code></pre><p>可以看出IO流使用了装饰者模式。</p><p>如果我们打开源码，查看<code>BufferedInputStream</code>，我们可以看到：</p><pre><code class="java">public class BufferedInputStream extends FilterInputStream {    //有参构造器    public BufferedInputStream(InputStream in, int size) {        //调用父类构造器，这是关键        //通过上面我们学过的例子，可以知道BufferedInputStream是装饰实现类        super(in);        if (size &lt;= 0) {            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);        }        buf = new byte[size];    }}</code></pre><p>关键在<code>FilterInputStream</code>这个类，这是装饰者模式的基类。查看源码：</p><pre><code class="java">public class FilterInputStream extends InputStream {    /**     * The input stream to be filtered.     */    protected volatile InputStream in;    protected FilterInputStream(InputStream in) {        this.in = in;    }    public int read() throws IOException {        return in.read();    }}</code></pre><p><code>FilterInputStream</code>类似于加密算法例子的<code>EncryptionDecorator</code>类。我们可以通过加密算法的例子和这个作对比，就可以很容易地看出他们的关系。类图如下：</p><img src="https://static.lovebilibili.com/FilterInputStream.png" srcset="/img/loading.gif" style="width:100%;"/><p><code>FileInputStream</code>就是基础构件类，可以通过<code>FilterInputStream</code>的子类去做扩展，增加额外的功能，比如可以使用<code>BufferedInputStream</code>增加缓冲的作用。</p><p>接着我们真正理解了IO流的装饰者模式的应用后，我们可以写一个扩展类，实现一个功能：读取磁盘的文件，把所有字母变成大写的字母。代码如下：</p><pre><code class="java">public class CapitalizaInputStream extends FilterInputStream {    public CapitalizaInputStream(InputStream in) {        super(in);    }    @Override    public int read(byte[] b, int off, int len) throws IOException {        int result = super.read(b, off, len);        for (int i = off; i &lt; off + result; i++){            //如果是小写字母，转成大写，其他不是小写字母的不变            if(Character.isLetter((char)b[i])){                b[i] = (byte) Character.toUpperCase((char) b[i]);            }        }        return result;    }}</code></pre><p>abc.txt文件内容：</p><pre><code class="yaml">abcdefghijklmnopqrstuvwxyz</code></pre><p>Main方法测试代码：</p><pre><code class="java">public static void main(String[] args) throws Exception {        InputStream inputStream             = new CapitalizaInputStream(new FileInputStream(new File(&quot;D://abc.txt&quot;)));        byte[] bytes = new byte[1024 * 2];        int c;        while ((c = inputStream.read(bytes, 0, bytes.length)) != -1) {            System.out.println(new String(bytes, 0, c));        }        inputStream.close();    }</code></pre><p>控制台打印结果：</p><pre><code class="yaml">ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre><p>以上就是IO流关于装饰者模式的扩展，能够加深我们对装饰者模式的理解。很多博客写不清楚，讲得很复杂，或者讲得很简单，很大原因是我们只看，而没有动手去做，动手去自己写，自己琢磨，就很容易能理解。这是学习方法，不是关注了公众号，看几篇文章就能轻松学会的，学习总是要自己动手才会理解深刻。看我的文章可以提供一些思路，更容易去上手。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰者模式的优点：</p><ol><li>可以动态地扩展类的功能，不会相互耦合。</li><li>符合开闭原则，利于代码维护。</li><li>比继承扩展的方式要更加灵活。</li></ol><p>缺点：多层装饰，代码结构变得复杂。</p><p>更多的java技术分享，就关注java技术爱好者吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式以及实际项目应用</title>
    <link href="/2020/05/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式（Observer），又叫<strong>发布-订阅模式（Publish/Subscribe）</strong>，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>比如我们在宿舍打斗地主，我们要找个人来“放风”，这个人在门口观察，如果有宿管过了检查，那么就通知宿舍其他的小伙伴停止斗地主回床上睡觉。这种模式就被称为观察者模式。</p><p>从这个例子看，“宿管是否过来宿舍”是订阅的主题，观察者是放风的人，订阅者是打斗地主的小伙伴，被观察者就是宿管。</p><h2 id="不使用观察者模式的问题"><a href="#不使用观察者模式的问题" class="headerlink" title="不使用观察者模式的问题"></a>不使用观察者模式的问题</h2><p>假设我们基于之前在策略模式讲的电子支付的例子，支付完成后要发送消息，发送的消息有：短信，公众号消息，APP站内消息，邮箱。如果不使用观察者模式，怎么做呢？看代码：</p><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        //发送短信        System.out.println(&quot;发送短信：&quot;+msg);        //发送微信公众号消息        System.out.println(&quot;发送微信公众号消息：&quot;+msg);        //发送邮件        System.out.println(&quot;发送邮件：&quot;+msg);        //发送APP系统信息        System.out.println(&quot;发送APP系统信息：&quot;+msg);        return msg;    }</code></pre><p>启动项目是没有问题的，我们调用接口后可以看到控制台打印以下信息：</p><pre><code class="java">/**发送短信：使用 支付宝支付 ,消费了 100 元发送微信公众号消息：使用 支付宝支付 ,消费了 100 元发送邮件：使用 支付宝支付 ,消费了 100 元发送APP系统信息：使用 支付宝支付 ,消费了 100 元*/</code></pre><p><strong>但是我们很明显可以看出有以下的问题：</strong></p><ul><li>每次支付如果需要新增一种消息通知方式，则要修改原来的类，不利于维护。</li><li>违反了开闭原则，对拓展开放，对修改关闭。</li><li>违反了单一职责原则，支付不应该糅杂消息通知的功能。</li></ul><p>上面就从代码演示了为什么要使用观察者模式，很多文章说不清楚，单纯地抛出一个概念和一些简单的例子，实际项目中肯定是没有那么简单。</p><h2 id="使用观察者模式优化"><a href="#使用观察者模式优化" class="headerlink" title="使用观察者模式优化"></a>使用观察者模式优化</h2><p>这里的话，我不使用<code>java</code>自带的<code>Observer</code>和<code>Observable</code>来做，因为实际项目中一般都会使用<code>Spring</code>框架，<code>Spring</code>框架有一个事件机制，也是使用观察者模式的这种设计模式，而且在实际项目中我们往往会采用这种成熟度更高的框架，就像代理模式我们也很少会直接使用原生的<code>JDK动态代理</code>，而是采用<code>SpringAOP</code>来实现。</p><h2 id="创建支付的事件"><a href="#创建支付的事件" class="headerlink" title="创建支付的事件"></a>创建支付的事件</h2><pre><code class="java">//继承ApplicationEvent类public class PayEvent extends ApplicationEvent {    //消息体    private Map&lt;String,String&gt; map;    //订阅主题    private String topic;    public PayEvent(Object source, Map&lt;String, String&gt; map, String topic) {        //调用父类的构造器        super(source);        this.map = map;        this.topic = topic;    }    public Map&lt;String, String&gt; getMap() {        return map;    }    public void setMap(Map&lt;String, String&gt; map) {        this.map = map;    }    public String getTopic() {        return topic;    }    public void setTopic(String topic) {        this.topic = topic;    }}</code></pre><h2 id="创建事件监听类"><a href="#创建事件监听类" class="headerlink" title="创建事件监听类"></a>创建事件监听类</h2><pre><code class="java">//短信监听，实现ApplicationListener接口，重写onApplicationEvent()方法@Componentpublic class SmsListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        //订阅主题        String topic = payEvent.getTopic();        //消息体        Map&lt;String, String&gt; map = payEvent.getMap();        //发送短信        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送短信:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//公众号监听@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//邮箱监听@Componentpublic class MailListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送邮件:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//App站内消息监听@Componentpublic class AppListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送App站内消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><h2 id="重构PayServiceImpl类"><a href="#重构PayServiceImpl类" class="headerlink" title="重构PayServiceImpl类"></a>重构PayServiceImpl类</h2><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,msg);        //创建一个支付事件        PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;);        //获取Spring的ApplicationContext容器，发布事件，监听类监听到事件后就会发送消息        SpringContextUtil.getApplicationContext().publishEvent(payEvent);        return msg;    }</code></pre><p>然后我们启动项目，调用接口，控制台就可以打印的信息：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送公众号消息:使用 支付宝支付 ,消费了 100 元*/</code></pre><h2 id="异步监听事件，实现解耦"><a href="#异步监听事件，实现解耦" class="headerlink" title="异步监听事件，实现解耦"></a>异步监听事件，实现解耦</h2><p>改造之后是否就一劳永逸了呢，实际上并非如此。因为上面的消息发送的监听类是同步的，也就是如果发送消息出现异常，那就会导致支付的接口无法正常返回。请看以下代码：</p><pre><code class="java">@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        //在发送微信公众号消息的逻辑中制造异常        System.out.println(10 / 0);        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,msg);        //创建一个支付事件        PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;);        //获取Spring的ApplicationContext容器，发布事件        SpringContextUtil.getApplicationContext().publishEvent(payEvent);        //发送消息后的逻辑，打印日志到控制台        System.out.println(&quot;发送消息后的逻辑代码...&quot;);        return msg;    }</code></pre><p>我们在发送公众号消息的逻辑里制造了一个异常，然后在<code>pay()</code>方法中加了一个打印日志在发布支付的事件后面，接下来调用接口，结果是：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/</code></pre><p>发送消息后的逻辑是没有被执行。这样显然是不符合业务要求的，因为在很多时候，发送消息失败是不能影响支付流程的，应该异步进行。怎么异步进行发送消息呢？</p><p>很简单，只需要两个步骤。</p><p><strong>第一步</strong>:在监听类或者方法上添加<code>@Async</code>注解，例如：</p><pre><code class="java">@Component@Async//加上异步执行的注解public class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(10 / 0);        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><p><strong>第二步</strong>：在<code>SpringBoot</code>启动类上添加<code>@EnableAsync</code>注解，例如：</p><pre><code class="java">@SpringBootApplication@EnableAsync//添加启用异步的注解public class StrategyApplication {    public static void main(String[] args) {        SpringApplication.run(StrategyApplication.class, args);    }}</code></pre><p>然后就可以实现异步监听了，调用接口，我们可以看到控制台打印的日志如下：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元发送消息后的逻辑代码...使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/</code></pre><p>明显可以看到支付后的逻辑也能正常执行下去，证明实现了异步监听！</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在<code>Spring</code>里提供了许多的监听器，这里只是介绍了其中一种。</p><p>还有一种叫<code>SpringApplicationRunListener</code>也是很常用的监听器，可以监听<code>SpringBoot</code>项目启动的事件，用于在启动项目时加载一些配置。</p><p>还有一种叫<code>SmartApplicationListener</code>，这种监听器可以设置优先级。假设发送消息需要按顺序先发送短信，再发送公众号，再发送邮箱…，那就可以使用这种监听器实现，这里就不多做介绍了，小伙伴有兴趣的话，我可以再写一篇文章详细介绍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过重构之后，我们可以明显看到，如果以后要增加一种新的消息通知方式，是不需要修改<code>PayServiceImpl</code>的，我们只需要再增加一个监听类即可，这就符合了<code>开闭原则</code>。有利于代码的维护。而且最重要是解耦，支付的业务逻辑和发送消息的业务逻辑不会再糅合在一起了，符合<code>职责单一</code>原则。</p><p>在很多框架中，观察者模式都有应用，对于学习很多例如<code>zookeeper</code>、<code>消息中间件</code>、<code>微服务注册中心</code>等知识是有很大帮助的。在实际项目中，观察者模式也是一种很常用的设计模式。比如有一种业务场景，通讯录的部门里有员工离职，需要通知其他依赖于通讯录的应用都要同步部门的员工，那就可以使用这种方式来实现。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你用构建者(生成器)模式优雅地创建对象</title>
    <link href="/2020/04/27/%E6%95%99%E4%BD%A0%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85-%E7%94%9F%E6%88%90%E5%99%A8-%E6%A8%A1%E5%BC%8F%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/04/27/%E6%95%99%E4%BD%A0%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85-%E7%94%9F%E6%88%90%E5%99%A8-%E6%A8%A1%E5%BC%8F%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要用构建者模式"><a href="#为什么要用构建者模式" class="headerlink" title="为什么要用构建者模式"></a>为什么要用构建者模式</h1><p>很多博客文章上来就先抛出一个定义，我们不妨反过来问一句为什么要用构建者模式。<br>首先我们创建一个<code>User</code>类，然后采用有参构造器的方式创建对象。</p><pre><code class="java">public class User {    private String id;    private String name;    private String gender;    private String address;    private Integer age;    private String phone;    //省略无参构造器，有参构造器，getter，setter方法...}</code></pre><pre><code class="java">public static void main(String[] args) throws Exception {    String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);    User user = new User(id, &quot;张三&quot;, &quot;男&quot;, &quot;广州天河&quot;, 20, &quot;135461852xx&quot;);}</code></pre><p>我们通过有参构造器创建对象，并且赋值，看起来没什么问题，因为我们经常看到有人是这样写的。<br>事实上，如果<code>User</code>对象里面有更多的字段，通过有参构造器去创建对象是很难一眼看出字段具体是什么意思，我们经常要看着<code>User构造器</code>的代码，然后对照顺序才能看出字段的代表什么意思。</p><pre><code class="java">public User(String id, String name, String gender, String address, Integer age, String phone) {    this.id = id;    this.name = name;    this.gender = gender;    this.address = address;    this.age = age;    this.phone = phone;}</code></pre><p>比如通过上面这个，我们可以知道第一个参数是id，第二个参数是名字，第三个是性别…</p><h2 id="使用有参构造器的缺点："><a href="#使用有参构造器的缺点：" class="headerlink" title="使用有参构造器的缺点："></a>使用有参构造器的缺点：</h2><p>这显然不利于代码的维护性，对于不熟悉业务的新入职的员工，如果看到这种方式构建一个对象，估计要看上一会，有些项目我遇过一个构造器十几个参数的，更加离谱。而且一般老代码还不敢乱动他的这个构造器，一不小心你动了构造器里面的一个参数的顺序，直接GG；或者你在他原有的构造器后面加多一个参数，你会发现他很多地方都引用了这个有参构造器，你很多地方都要去修改，是真的恶心。</p><h2 id="解决方法一-使用无参构造器，通过setter方法设置属性值"><a href="#解决方法一-使用无参构造器，通过setter方法设置属性值" class="headerlink" title="解决方法一 使用无参构造器，通过setter方法设置属性值"></a>解决方法一 使用无参构造器，通过setter方法设置属性值</h2><pre><code class="java">public static void main(String[] args) throws Exception {    User user = new User();    user.setId(UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;));    user.setName(&quot;张三&quot;);    user.setAge(20);    user.setGender(&quot;男&quot;);    user.setPhone(&quot;135461852xx&quot;);    user.setAddress(&quot;广州天河&quot;);    out.println(user);}</code></pre><p>上面这样，显然比直接用有参构造器要好很多，因为这样就可以创建对象和赋值分开进行，一眼就可以看出对什么属性值赋值，而且如果加一个字段，我们不需要再每一处都去修改，因为用的是<strong>无参构造器</strong>，是不是这样写就是万全之计呢？<br>也不是，因为这样创建对象和赋值是分开的，各个参数的初始化被放到了不同的方法中调用，这会导致严重的线程不安全问题(使用构造器则不会有这个问题)，对象在一连串的set方法中，可能会出现状态不一致的情况，这是应该尽量避免的。</p><h2 id="解决方法二-通过构建者模式，链式调用构建方法设置属性值"><a href="#解决方法二-通过构建者模式，链式调用构建方法设置属性值" class="headerlink" title="解决方法二 通过构建者模式，链式调用构建方法设置属性值"></a>解决方法二 通过构建者模式，链式调用构建方法设置属性值</h2><p>什么是链式编程，就是调用一个方法，返回值是他本身，可以继续调用下一个方法，返回又是他本身，如此调用下去，看上去就像一条链子一样。典型的例子可以看<code>java8</code>新特性的<code>Stream</code>流操作。我们可以使用构建者模式，也能达到这种效果，并且线程安全，而且能直观地看到属性值的意思。总得来说，既保证线程安全，也很具有代码的可读性。先看结果代码：</p><pre><code class="java">public static void main(String[] args) throws Exception {    String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);    User user = UserBuilder.getInstance()            .newPojo()            .addId(id)            .addName(&quot;张三&quot;)            .addGender(&quot;男&quot;)            .addAge(20)            .addPhone(&quot;135461852xx&quot;)            .addAddress(&quot;广州天河&quot;)            .build();}</code></pre><p>怎么实现呢？其实很简单，我们只需要创建一个<code>UserBuilder</code>类即可。代码如下：</p><pre><code class="java">public class UserBuilder {    private User user;    private UserBuilder() {    }    public static UserBuilder getInstance() {        return new UserBuilder();    }    public UserBuilder newPojo() {        this.user = new User();        //返回本身        return this;    }    public UserBuilder addId(String id) {        this.user.setId(id);        //返回本身        return this;    }    public UserBuilder addName(String name) {        this.user.setName(name);        return this;    }    public UserBuilder addGender(String gender) {        this.user.setGender(gender);        return this;    }    public UserBuilder addAge(Integer age) {        this.user.setAge(age);        return this;    }    public UserBuilder addAddress(String address) {        this.user.setAddress(address);        return this;    }    public UserBuilder addPhone(String phone) {        this.user.setPhone(phone);        return this;    }    public User build() {        return this.user;    }}</code></pre><p>那么是不是这种方式就是万全之计呢，就一定没有缺点吗？</p><h3 id="构造者模式的缺点还是有的"><a href="#构造者模式的缺点还是有的" class="headerlink" title="构造者模式的缺点还是有的"></a>构造者模式的缺点还是有的</h3><p>1.代码冗长。如果一个对象的属性很多，那我们在创建一个对象时，链式就会变得很长，但是这也没有办法，无论采用构造器还是builder模式都会很长。如果非要变得简洁一点，那就只有采用原型模式(克隆)等其他方式了。<br>2.会产生很多<code>Builder</code>类。我们可以放在一个包下统一管理应该问题不大。<br>第二个缺点实际上可以使用<code>Lombok</code>插件，然后在实体类上使用<code>@Builder</code>注解，就不会产生过多的<code>Builder</code>类了。但是有些公司的技术总监不太建议使用<code>Lombok</code>，那就莫得办法了…</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>有很多博客的示范代码，<code>Builder</code>类的<code>addXXX</code>方法会写成<code>setXXX</code>方法，这是一个隐患。因为很多框架，对Setter方法比较敏感，往往会对<code>Setter</code>方法做一些处理，所以<code>Builder</code>类里的设置属性值方法尽量不要用<code>setXXX</code>命名，防止出现一些不明原因的错误。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>一般我们在项目中创建复杂的对象时，建议采用这种构建者模式创建对象。这样可以使代码可读性更好。<br>在java源码中，我们也可以看到构建者模式的应用。比如在<code>StringBuilder</code>类中：</p><pre><code class="java">@Overridepublic StringBuilder append(CharSequence s) {    super.append(s);    return this;}/** * @throws     IndexOutOfBoundsException {@inheritDoc} */@Overridepublic StringBuilder append(CharSequence s, int start, int end) {    super.append(s, start, end);    return this;}@Overridepublic StringBuilder append(char[] str) {    super.append(str);    return this;}</code></pre><p><code>StringBuilder</code>的<code>append()</code>方法也是通过返回<code>this</code>对象实现链式构建对象，人们经常说这个<code>StringBuilder</code>类线程不安全是因为<code>append()</code>方法没有用<code>synchronized</code>修饰。<code>StringBuffer</code>则用了<code>synchronized</code>修饰，所以就是线程安全的。<br>还有<code>Mybatis</code>框架中，构建<code>SqlSessionFactory</code>对象是使用<code>SqlSessionFactoryBuilder</code>类进行构建，构建者模式运用非常广泛，非常值得学习。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式以及应用</title>
    <link href="/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><strong>代理模式的定义：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</p><a id="more"></a><p>通俗点说，就是一个中介，比如有一个广州人，是个本地人，有两套房，他要租出去收租，但是除了收租，他还要去找租客，带租客看房，还要准备租房合同，核算水电费等等，很麻烦。这个本地人他也不想这么折腾，他只想<strong>完成他的核心业务(收钱)</strong>,其他杂七杂八的事情就不想管，但是总要有人去做，那就找<strong>租房中介</strong>，也就是二手房东。二手房东就代理这个广州本地人把房子租给租客。这个道理就是这么简单。</p><p>他们这些在广州有房子的本地人都可以找中介公司去代理租房是一样的。因为很多广州本地人都有这个需求，干脆就搞一个中介公司来专门去做租房子的事情。</p><p><strong>代理模式，运用在编程里，也是这个道理，有一些非核心业务的代码，在很多地方都需要用到的逻辑，可以交给代理对象完成，程序员只需要关心核心业务的逻辑即可。</strong></p><h1 id="实现代理模式的三种方式"><a href="#实现代理模式的三种方式" class="headerlink" title="实现代理模式的三种方式"></a>实现代理模式的三种方式</h1><p>项目就基于上一篇<code>模板模式</code>的文章的项目进行试验。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假设原来有一个接口<code>UserService</code>，controller层调用<code>userService</code>的<code>getAllUser()</code>方法。如下所示：</p><pre><code class="java">public interface UserService {    /**     * 获取所有用户信息     *     * @return List     * @author Ye hongzhi     * @date 2020/4/12     */    List&lt;User&gt; getAllUser() throws Exception;}</code></pre><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return userService.getAllUser();    }}</code></pre><p>如果用静态代理实现记录日志信息，怎么记录呢？</p><p>首先创建一个代理类<code>UserServiceProxy</code>，实现<code>UserService</code>接口，然后在<code>UserServiceProxy</code>里面创建一个成员变量<code>userService</code>，再写一个有参构造器来初始化<code>userService</code>。代码如下：</p><pre><code class="java">public class UserServiceProxy implements UserService {    private UserService userService;    public UserServiceProxy(UserService userService) {        this.userService = userService;    }    @Override    public List&lt;User&gt; getAllUser() throws Exception {        System.out.println(&quot;记录日志：执行getAllUser()方法前&quot;);        List&lt;User&gt; userList = userService.getAllUser();        System.out.println(userList);        System.out.println(&quot;记录日志：执行getAllUser()方法后&quot;);        return userList;    }}</code></pre><p>所以在controller层调用的方式就要改一下，是用代理类<code>UserServiceProxy</code>调用<code>getAllUser()</code>方法。如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return new UserServiceProxy(userService).getAllUser();    }}</code></pre><p>然后启动项目，调用一下接口，就可以看到控制台打印如下日志：</p><pre><code class="java">/*记录日志：执行getAllUser()方法前[User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser()方法后*/</code></pre><p>这就是静态代理的实现思路，很简单。但是一般我们肯定是不用这种方式。因为这种方式太笨了，很容易就可以看出几个缺点。</p><p><strong>1.要实现接口，也就是目标的方法要定义一个接口方法，实际上是运用了java多态的特性</strong></p><p><strong>2.第一点还不是致命的，因为JDK动态代理也是必须要定义接口；致命的是每一个你想代理的接口你都要去创建一个代理类去实现，假设有很多要代理的接口，那就创建很多代理类，这样显得很臃肿</strong></p><p>假设还是不理解为什么要动态代理，不妨我们再多加一个支付接口<code>PayService</code>，这个支付接口我们也要加上日志记录。</p><p>用静态代理怎么做？很简单呀，再创建一个<code>PayServiceProxy</code>类不就完了吗，如果还有<code>OrderService</code>(订单),</p><p><code>WarehouseService</code>(仓库)等等。那就要创建很多<code>XXXServiceProxy</code>类。如果使用动态代理，就没必要创建这么多代理类，创建一个代理类就够了！</p><blockquote><p>动态代理就是为了解决静态代理的这个缺点产生的。</p></blockquote><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK本身就带有动态代理，必须要满足一个条件，就是要有接口。原理其实和静态代理是一样的，也是用代理类去实现接口，但是代理类不是一开始就写好的，而是在程序运行时通过反射创建字节码文件然后加载到JVM。也就是动态生成的代理类对象。</p><p>下面就是用<code>JDK动态代理</code>实现代理模式。</p><pre><code class="java">public class LogRecordProxy&lt;T&gt; implements InvocationHandler {    private T target;    public LogRecordProxy(T t) {        this.target = t;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前&quot;);        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后&quot;);        return result;    }    /**     * 获取代理对象的方法     * */    @SuppressWarnings(&quot;unchecked&quot;)    public &lt;T&gt; T getProxy() throws Exception {        return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }}</code></pre><p>在controller层，就要改成这样。</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        //获取代理对象        UserService userServiceProxy = new LogRecordProxy&lt;&gt;(userService).getProxy();        return userServiceProxy.getAllUser();    }}</code></pre><p>假设有一个<code>PayService</code>也要做日志记录，就可以直接使用。</p><pre><code class="java">    @Resource(name = &quot;payService&quot;)    private PayService payService;        @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        //获取代理对象，实际上就在构造器上改一下传入的参数即可        PayService payServiceProxy = new LogRecordProxy&lt;&gt;(payService).getProxy();        return payServiceProxy.pay(channel,amount);    }</code></pre><p>很多文章给的例子都不带泛型，也可以，就是获取的代理对象需要强转一下，强转成对应的接口类。</p><p><strong>注意：这里一定要用接口接收代理对象，不能用实现类！</strong></p><p>因为返回的对象已经不是实现类的对象，而是和实现类有共同的接口类的代理类对象，所以当然只能用接口类去接收。</p><blockquote><p>这也是为什么一再强调要面向接口编程的原因，因为面向接口编程可以做更多的扩展。假设是面向实现类去编程，那就不能用JDK动态代理去扩展了！</p></blockquote><h2 id="CGLB动态代理"><a href="#CGLB动态代理" class="headerlink" title="CGLB动态代理"></a>CGLB动态代理</h2><p>那如果有些场景真的没有接口呢，我们怎么运用代理模式？</p><p>首先引入maven配置</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后创建一个方法拦截器<code>LogRecordInterceptor</code>，要实现<code>MethodInterceptor</code>类，如下：</p><pre><code class="java">public class LogRecordInterceptor implements MethodInterceptor {    private Object target;    public LogRecordInterceptor(Object target) {        this.target = target;    }    @Override    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前,参数：&quot; + Arrays.toString(args));        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后,参数：&quot; + Arrays.toString(args));        return result;    }}</code></pre><p>然后再创建一个工厂类<code>InterceptorFactory</code>，用于创建代理对象。</p><pre><code class="java">public class InterceptorFactory {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T&gt; T getInterceptor(Class&lt;T&gt; clazz, MethodInterceptor methodInterceptor) {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(clazz);        enhancer.setCallback(methodInterceptor);        return (T) enhancer.create();    }}</code></pre><p>接着我们就可以创建一个没有接口的类，我这里就创建一个数学工具类进行测试</p><pre><code class="java">public class MathUtil {    /**     * 获取一个数的平方     * */    public String getSquare(int num) {        return String.valueOf(num * num);    }}</code></pre><p>然后在controller层定义一个接口来测试</p><pre><code class="java">@RequestMapping(&quot;/getSquare&quot;)    public String getSquare(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception {        MathUtil mathUtil = InterceptorFactory.getInterceptor(MathUtil.class, new LogRecordInterceptor(new MathUtil()));        return mathUtil.getSquare(num);    }</code></pre><p>用浏览器或者<code>POSTMAN</code>工具调用接口，就可以在控制台看到以下输出：</p><pre><code class="java">/*记录日志：执行getSquare方法前,参数：[2]4记录日志：执行getSquare方法后,参数：[2]*/</code></pre><p>这样就实现没有定义接口也可以实现动态代理！</p><p>实际上，定义接口的也可以用这种方法来进行扩展，比如上面的<code>userService</code>接口</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        UserServiceImpl userServiceProxy = InterceptorFactory            .getInterceptor(UserServiceImpl.class,                            new LogRecordInterceptor(userService));        return userServiceProxy.getAllUser();    }}</code></pre><p>调用接口我们在控制台也是可以看到以下输出日志：</p><pre><code class="java">/*记录日志：执行getAllUser方法前,参数：[][User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser方法后,参数：[]*/</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>以上就是代理模式的一些通俗的解释，还有三种实现的方式的学习</strong></p><p>多说几句，我们都知道<code>Spring</code>框架有两个核心技术，一个叫控制反转<code>IOC</code>，另一个叫切面编程<code>AOP</code>。切面编程大家都很熟悉，用的就是代理模式，那么<code>AOP</code>实现的代理模式用的是<code>JDK动态代理</code>还是<code>CLB动态代理</code>？</p><p>答曰：<strong>两个都用！</strong></p><p>最简单的，我们看<code>Spring</code>的事务管理，就是用代理模式实现的，如果有兴趣，其实我们自己也可以通过<code>JDK动态代理</code>手写实现事务管理，其实不是很难。篇幅有限，以后可以单独写一篇文章详细说明<code>Spring</code>的事务管理，敬请期待。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板模式以及实战应用</title>
    <link href="/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>上一篇讲了策略模式，知道了可以使用策略模式对多重if-else进行优化，而且符合开闭原则。那么除了策略模式，还有什么设计模式比较好用而且常用的呢。这就是今天要讲的模板模式。</p><a id="more"></a><p>模板模式解决什么问题呢？</p><h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><p>首先我们使用SpringBoot来搭建一个工程。</p><pre><code class="xml">    &lt;!-- maven配置 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;commons-lang&lt;/groupId&gt;        &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;        &lt;version&gt;2.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><p>application.yml配置如下：</p><pre><code class="yaml">server:  port: 8888spring:  datasource:    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8    username: 账号    password: 密码    driver-class-name: com.mysql.jdbc.Driver</code></pre><p>创建一个全局配置类<code>GlobalProperties</code>，我们通过这个类可以获取yml的配置信息</p><pre><code class="java">@Component(&quot;globalProperties&quot;)public class GlobalProperties {    @Value(&quot;${spring.datasource.driver-class-name}&quot;)    private String driverClass;    @Value(&quot;${spring.datasource.url}&quot;)    private String url;    @Value(&quot;${spring.datasource.username}&quot;)    private String username;    @Value(&quot;${spring.datasource.password}&quot;)    private String password;    //字段对应的getter、setter方法...</code></pre><p>创建一个连接工厂类<code>ConnectFactory</code>，获取数据库连接</p><pre><code class="java">public class ConnectFactory {    public static Connection getConnection() throws Exception{        //获取yml文件的配置，SpringContextUtil工具类在上一篇文章有介绍，可以参考上一篇文章的代码        GlobalProperties properties = SpringContextUtil                .getBean(&quot;globalProperties&quot;, GlobalProperties.class);        //加载数据驱动        Class.forName(properties.getDriverClass());        //获取数据库连接，返回数据库连接对象        return DriverManager.getConnection(properties.getUrl(),                properties.getUsername(), properties.getPassword());    }}</code></pre><p>创建实体类<code>User</code></p><pre><code class="java">public class User {    private Integer id;    private String name;    private Integer age;    private String job;    //字段对应的getter、setter方法...</code></pre><p>接着在mysql对应的数据库创建数据表<code>tb_user</code>，sql语句如下：</p><pre><code class="sql">CREATE TABLE `tb_user` (  `id` bigint(10) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,  `name` varchar(255) NOT NULL COMMENT &#39;名称&#39;,  `age` tinyint(4) NOT NULL COMMENT &#39;年龄&#39;,  `job` varchar(255) DEFAULT NULL COMMENT &#39;工作&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4</code></pre><p>插入一些测试数据</p><pre><code class="sql">INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大司马&#39;,36,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;朴老师&#39;,36,&#39;主播&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;王刚&#39;,30,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大sao&#39;,32,&#39;美食up主&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;姚大秋&#39;,35,&#39;主持人&#39;);</code></pre><p>假设我们有一张user表，我们通过原生的JDBC来进行数据库操作，那么需要在dao层完成以下几步。</p><p>1.装载相应的数据库的JDBC驱动并进行初始化</p><p>2.建立JDBC和数据库之间的Connection连接</p><p>3.创建Statement或者PreparedStatement接口，执行SQL语句</p><p>4.处理和显示结果</p><p>5.释放资源</p><p>例子如下：</p><pre><code class="java">    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        User user = new User();        //获取数据连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement             .executeQuery(String.format(GET_USER_BY_NAME_SQL, name))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        User user = new User();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet =             statement.executeQuery(String.format(GET_USER_BY_ID_SQL, id))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }</code></pre><p>PS:这里为了简单一点就直接把参数拼接sql语句，不采用预编译来处理sql的参数。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过上面的代码，我们很明显可以看到是有很大的问题的。</p><p>1.每次在进行数据库操作都需要获取<code>Connection</code>对象，创建<code>Statement</code>对象。</p><p>2.每次获取结果后，都要进行结果处理，而且如果是同一张表的查询，会很重复。每次都需要把结果值set回到对象的字段中。</p><p>模板模式就可以解决这个问题！</p><h2 id="使用模板模式重构代码"><a href="#使用模板模式重构代码" class="headerlink" title="使用模板模式重构代码"></a>使用模板模式重构代码</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>创建一个模板类<code>DaoTemplate</code>，如下：</p><pre><code class="java">/** * @author Ye Hongzhi * @program DaoTemplate * @description * @date 2020-04-12 17:04 **/@Componentpublic class DaoTemplate {    public &lt;T&gt; T query(String sql, Class&lt;T&gt; clazz) throws Exception {        //通过clazz创建返回值对象        T t = clazz.newInstance();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement.executeQuery(sql)        ) {            while (resultSet.next()) {                //获取所有字段                Field[] fields = clazz.getDeclaredFields();                //获取所有方法                Method[] methods = clazz.getDeclaredMethods();                Map&lt;String, Method&gt; methodNameMap = Arrays.stream(methods)                        .collect(Collectors.toMap(Method::getName, Function.identity()));                //把数据库对应的列的值赋值给 泛型T对象的 对应的字段                for (Field field : fields) {                    //获取字段名                    String fieldName = field.getName();                    //获取set方法                    Method method = methodNameMap.get(&quot;set&quot; + change(fieldName));                    //获取数据库的列的值                    Object fieldValue = null;                    if (field.getType() == String.class) {                        fieldValue = resultSet.getString(fieldName);                    }                    if (field.getType() == Integer.class) {                        fieldValue = resultSet.getInt(fieldName);                    }                    if (field.getType() == Boolean.class) {                        fieldValue = resultSet.getBoolean(fieldName);                    }                    if (field.getType() == Long.class) {                        fieldValue = resultSet.getLong(fieldName);                    }                    if(field.getType() == Double.class){                        fieldValue = resultSet.getDouble(fieldName);                    }                    if(field.getType() == BigDecimal.class){                        fieldValue = resultSet.getBigDecimal(fieldName);                    }                    if (field.getType() == Date.class) {                        fieldValue = resultSet.getDate(fieldName);                    }                    //设置更多的字段类型...                    //利用反射执行对象的set方法，把数据库的值设置到对象的字段中                    method.invoke(t, fieldValue);                }            }        } catch (Exception e) {            e.printStackTrace();        }        return t;    }    /**     * 将一个字符串首字母大写，其它字母小写     *     * @param str 字符串     * @return     */    private static String change(String str) {        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();    }}</code></pre><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>创建模板后，可以在<code>DAO</code>层引入模板，然后使用。如下：</p><pre><code class="java">    //引入模板        @Resource    private DaoTemplate daoTemplate;    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_ID_SQL, id), User.class);    }    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_NAME_SQL, name), User.class);    }</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><h1 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h1><p>实际上在Spring框架就有提供<code>JDBC</code>模板</p><p>我们可以在<code>MAVEN</code>中引入以下配置：</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>创建一个映射类<code>UserRowMapper</code></p><pre><code class="java">public class UserRowMapper implements RowMapper&lt;User&gt; {    @Override    public User mapRow(ResultSet resultSet, int i) throws SQLException {        User user = new User();        user.setId(resultSet.getInt(&quot;id&quot;));        user.setName(resultSet.getString(&quot;name&quot;));        user.setAge(resultSet.getInt(&quot;age&quot;));        user.setJob(resultSet.getString(&quot;job&quot;));        return user;    }}</code></pre><p>然后在<code>DAO</code>层的<code>UserDaoImpl</code>，我们就可以引入<code>JdbcTemplate</code></p><pre><code class="java">    @Resource    private JdbcTemplate jdbcTemplate;    //使用jdbcTemplate查询    @Override    public User getUserByName(String name) throws Exception {        return jdbcTemplate.queryForObject(String.format(GET_USER_BY_NAME_SQL, name), new UserRowMapper());    }</code></pre><p>从这里可以看出实际上<code>Spring</code>框架就是采用这种思想来实现<code>JdbcTemplate</code>模板。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>所以在实际项目的开发中，我们有时候遇到某些代码块的前后都有重复操作时，可以采用模板模式去重构代码，使代码更加简洁，容易维护。</p><p>更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你用策略模式解决多重if-else</title>
    <link href="/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/"/>
    <url>/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>很多人可能在公司就是做普通的CRUD的业务，对于设计模式，即使学了好像也用处不大，顶多就在面试的时候能说上几种常见的单例模式，工厂模式。而在实际开发中，设计模式似乎很难用起来。</p><p>在现在的环境下，程序员的竞争已经非常激烈了，要体现出自身的价值，最直接的体现当然是差异化。这无需多说，我认为在实际开发中能运用设计模式，是很能体现差异化的。设计模式是一些前人总结的较好的方法，使程序能有更好的扩展性，可读性，维护性。</p><p>下面举个例子，使用策略模式解决多重if-else的代码结构。想学习更多的设计模式的实战经验，那就点个关注吧，谢谢大佬。</p><h1 id="使用if-else"><a href="#使用if-else" class="headerlink" title="使用if-else"></a>使用if-else</h1><p>假设我们要开发一个支付接口，要对接多种支付方式，通过渠道码区分各种的支付方式。于是定义一个枚举<code>PayEnum</code>，如下：</p><pre><code class="java">public enum PayEnum {    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;);    /**渠道*/    private String channel;    /**描述*/    private String description;    PayEnum(String channel, String description) {        this.channel = channel;        this.description = description;    }    /**以下省略字段的get、set方法*/</code></pre><p>创建一个<code>PayController</code>类，代码如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class PayController {    @Resource(name = &quot;payService&quot;)    private PayService payService;    /**    * 支付接口    * @param channel 渠道    * @param amount  消费金额    * @return String 返回消费结果    * @author Ye hongzhi    * @date 2020/4/5    */    @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        return payService.pay(channel,amount);    }}</code></pre><p>再创建一个<code>PayService</code>接口以及实现类<code>PayServiceImpl</code></p><pre><code class="java">public interface PayService {    /**    * 支付接口    * @param channel 渠道    * @param amount  金额    * @return String    * @author Ye hongzhi    * @date 2020/4/5    */    String pay(String channel,String amount)throws Exception;}</code></pre><pre><code class="java">@Service(&quot;payService&quot;)public class PayServiceImpl implements PayService {    private static String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    @Override    public String pay(String channel, String amount) throws Exception {        if (PayEnum.ALI_PAY.getChannel().equals(channel)) {            //支付宝            //业务代码...            return String.format(MSG,PayEnum.ALI_PAY.getDescription(),amount);        }else if(PayEnum.WECHAT_PAY.getChannel().equals(channel)){            //微信支付            //业务代码...            return String.format(MSG,PayEnum.WECHAT_PAY.getDescription(),amount);        }else if(PayEnum.UNION_PAY.getChannel().equals(channel)){            //银联支付            //业务代码...            return         String.format(MSG,PayEnum.UNION_PAY.getDescription(),amount);        }else if(PayEnum.XIAO_MI_PAY.getChannel().equals(channel)){            //小米支付            //业务代码...            return String.format(MSG,PayEnum.XIAO_MI_PAY.getDescription(),amount);        }else{            return &quot;输入渠道码有误&quot;;        }    }}</code></pre><p>然后通过浏览器，我们可以看到效果</p><p><img src="https://static.lovebilibili.com/01.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/02.png" srcset="/img/loading.gif" alt=""></p><p>这样看，以上代码的确可以实现需求，通过渠道码区分支付方式，可是看到上面那么多达4个的<code>if-else</code>的代码结构，已经开始显示出问题了。假设有更多的支付方式，那么这段代码就要写更多的<code>else if</code>去判断，这显然会不利于代码的扩展，这样会导致这个支付的方法越写越长。</p><p>在设计模式六大原则中，其中一个原则叫做<code>开闭原则</code>，对扩展开放，对修改关闭，应尽量在不修改原有代码的情况下进行扩展。</p><p>基于上面提到的<code>开闭原则</code>，我们可以使用策略模式进行重构。</p><h1 id="使用策略模式重构代码"><a href="#使用策略模式重构代码" class="headerlink" title="使用策略模式重构代码"></a>使用策略模式重构代码</h1><p>定义一个策略接口类<code>PayStrategy</code></p><pre><code class="java">public interface PayStrategy {    String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    String pay(String channel,String amount)throws Exception;}</code></pre><p>然后再创建四种策略实现类实现接口</p><pre><code class="java">@Component(&quot;aliPayStrategy&quot;)public class AliPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.ALI_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;wechatPayStrategy&quot;)public class WechatPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.WECHAT_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;unionPayStrategy&quot;)public class UnionPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.UNION_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;xiaomiPayStrategy&quot;)public class XiaomiPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.XIAO_MI_PAY.getDescription(),amount);    }}</code></pre><p>看到这里实际上已经很清晰了，思路就是通过渠道码，动态获取到具体的实现类，这样就可以实现不需要<code>if else</code>判断。怎么通过渠道码获取实现类呢？</p><p>在<code>PayEnum</code>枚举加上<code>BeanName</code>字段，然后增加一个通过渠道码获取<code>BeanName</code>的方法</p><pre><code class="java">    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;,&quot;aliPayStrategy&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;,&quot;wechatPayStrategy&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;,&quot;unionPayStrategy&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;,&quot;xiaomiPayStrategy&quot;);    /**策略实现类对应的 beanName*/    private String beanName;    /**     * 通过渠道码获取枚举     * */    public static PayEnum findPayEnumBychannel(String channel){        PayEnum[] enums = PayEnum.values();        for (PayEnum payEnum : enums){            if(payEnum.getChannel().equals(channel)){                return payEnum;            }        }        return null;    }    //构造器    PayEnum(String channel, String description, String beanName) {        this.channel = channel;        this.description = description;        this.beanName = beanName;    }</code></pre><p>这时候还差一个获取Spring上下文对象的工具类，于是我们创建一个<code>SpringContextUtil</code>类</p><pre><code class="java">@Componentpublic class SpringContextUtil implements ApplicationContextAware {    /**     * 上下文对象实例     */    private static ApplicationContext applicationContext;    /**     * 获取applicationContext     */    private static ApplicationContext getApplicationContext() {        return applicationContext;    }    /**     * 通过name获取Bean     * */    public static Object getBean(String name){        return getApplicationContext().getBean(name);    }    /**     * 通过name,以及Clazz返回指定的Bean     * */    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz){        return getApplicationContext().getBean(name,clazz);    }    @Override    @Autowired    public void setApplicationContext(ApplicationContext applicationContext) throws         BeansException {        SpringContextUtil.applicationContext = applicationContext;    }</code></pre><p>接着定义一个工厂类，通过渠道码获取对应的策略实现类</p><pre><code class="java">public class PayStrategyFactory {    /**     * 通过渠道码获取支付策略具体实现类     * */    public static PayStrategy getPayStrategy(String channel){        PayEnum payEnum = PayEnum.findPayEnumBychannel(channel);        if(payEnum == null){            return null;        }        return SpringContextUtil.getBean(payEnum.getBeanName(),PayStrategy.class);    }}</code></pre><p>最后我们再改造一下原来的<code>PayServiceImpl</code>的<code>pay</code>方法</p><pre><code class="java">@Overridepublic String pay(String channel, String amount) throws Exception {    PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);    if(payStrategy == null){        return &quot;输入渠道码有误&quot;;    }    return payStrategy.pay(channel,amount);}</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><blockquote><p>假设需要增加新的支付方式，就不需要再使用else if 去判断，而是在枚举中定义一个新的枚举对象，然后再增加一个策略实现类，实现对应的方法，那就可以很轻松地扩展。也实现了开闭原则。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>设计模式运用得熟练的话，很多代码可以写得很优雅。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot系列之自定义spring-boot-starter</title>
    <link href="/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/"/>
    <url>/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>传统的 Maven项目一般将需要被复用的组件做成 Module来进行管理，以便二次调用；而在 Spring Boot项目中我们则可以使用更加优雅的 Spring Boot Starter来完成这一切。</p><a id="more"></a><p>这个开箱即用的魔法特性很大程度上来源于各式各样 Spring Boot Starter的加持，而且随着版本的迭代 Starter家族成员日益庞大，而且各种优秀开源作者也提供了很多非常好用的Spring Boot Starter。</p><p>本文尝试自定义一个Spring Boot Starter用于图片链接转换BASE64编码。</p><h1 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h1><ol><li>在GItHub上创建base64util-spring-boot-starter项目，然后clone下来本地进行开发。</li></ol><p><img src="https://static.lovebilibili.com/Github_Create.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>pom.xml文件配置如下</li></ol><pre><code class="xml">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;&lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;0.0.1&lt;/version&gt;&lt;dependencies&gt;    &lt;!-- 引入SpringBoot自动配置jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ol start="3"><li>业务代码</li></ol><pre><code class="java">import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL;/** * @author Ye Hongzhi * @program Base64Util * @description * @date 2020-02-17 14:04 **/public class Base64Util {    /**     * 本地图片转为BASE64编码     *     * @param imgFile 本地图片地址     * @return BASE64 解码后的字符串编码     * @description: 根据图片地址转换为base64编码字符串     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static String getImageFile(String imgFile) {        byte[] data = null;        try (InputStream inputStream = new FileInputStream(imgFile)) {            data = new byte[inputStream.available()];            int length = inputStream.read(data);            if (length == -1) {                return null;            }        } catch (Exception e) {            e.printStackTrace();        }        // 加密        BASE64Encoder encoder = new BASE64Encoder();        if (data != null) {            return encoder.encode(data);        } else {            return null;        }    }    public static String image2Base64(String imgUrl) throws Exception {        URL url = new URL(imgUrl);        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();        try(InputStream inputStream = urlConnection.getInputStream();            ByteArrayOutputStream baos = new ByteArrayOutputStream()) {            urlConnection.connect();            byte[] buffer = new byte[1024];            int len;            //使用一个输入流从buffer里把数据读取出来            while ((len = inputStream.read(buffer)) != -1) {                //用输出流往buffer里写入数据，中间参数代表从哪个位置开始读，len代表读取的长度                baos.write(buffer, 0, len);            }            // 对字节数组Base64编码            return Base64.encode(baos.toByteArray());        } catch (Exception e) {            e.printStackTrace();        } finally {            if (urlConnection != null) {                urlConnection.disconnect();            }        }        return imgUrl;    }    /**     * BASE64编码转为图片     * 注意：&quot;data:image/jpeg;base64,&quot; 解码之前得去掉。     *     * @param imgStr base64编码字符串     * @param path   图片路径-具体到文件     * @return 是否转换成功     * @description: 将base64编码字符串转换为图片     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static boolean generateImage(String imgStr, String path) {        if (imgStr == null) {            return false;        }        try (OutputStream out = new FileOutputStream(path)) {            BASE64Decoder decoder = new BASE64Decoder();            // 解密            byte[] b = decoder.decodeBuffer(imgStr);            // 处理数据            for (int i = 0; i &lt; b.length; ++i) {                if (b[i] &lt; 0) {                    b[i] += 256;                }            }            out.write(b);            out.flush();            return true;        } catch (Exception e) {            e.printStackTrace();            return false;        }    }}</code></pre><ol start="4"><li>创建一个service调用，这里为了简单，就不定义为接口的形式</li></ol><pre><code class="java">public class Base64Service {    /**     * 本地图片转为BASE64编码     */    public String getImageFile(String imgFile) {        return Base64Util.getImageFile(imgFile);    }    /**     * BASE64编码转为图片     * */    public boolean generateImage(String imgStr, String path) {        return Base64Util.generateImage(imgStr,path);    }    /**     * 在线图片转为BASE64编码     * */    public String image2Base64(String imgUrl) throws Exception{        return Base64Util.image2Base64(imgUrl);    }}</code></pre><ol start="5"><li>关键的一步，使用配置类，把service定义成bean，加入到spring容器中管理</li></ol><pre><code class="java">@Configurationpublic class Base64AutoConfiguration {    @Bean    Base64Service base64Service(){        return new Base64Service();    }}</code></pre><ol start="6"><li>最关键一步在于需要在resources文件夹下创建<code>META-INF/spring.factories</code>，<code>spring.factories</code>里的代码如下:</li></ol><pre><code class="yaml">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.lovebilibili.me.config.Base64AutoConfiguration</code></pre><p>这一步是重点，因为Spring Boot应用在启动过程中会通过 <code>SpringFactoriesLoader</code> 加载所有 <code>META-INF/spring.factories</code> 文件，通过一系列的处理流程最终将 spring.factories 文件中的定义的各种 <code>beans</code> 装载入 ApplicationContext容器。</p><blockquote><p>至此，自定义的用于base64转码工具的spring-boot-starter就完成了</p><p>可以通过使用maven命令<code>mvn install</code>打包，传到私有/公有Maven仓库使用。</p><p>形成一个公共的模块，供有需要的项目使用。</p></blockquote><ol start="7"><li>完成后把代码推送到Github仓库中，方便以后继续优化。</li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li>在其他项目中的pom文件加入以下依赖：</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;    &lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.0.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在Controller层中，我们可以引入base64Service。</li></ol><pre><code class="java">@Resourceprivate Base64Service base64Service;</code></pre><ol start="3"><li>然后在Controller层中的@RequestMapping对应的方法中使用</li></ol><pre><code class="java">//把在线图片转为BASE64编码String base64 = base64Service.image2Base64(imgUrl);</code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要创建个人博客</title>
    <link href="/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>很高兴你能点进来看我的第一篇文章。</p><p>内容也和标题一样无聊，为什么要创建个人博客，既然我已经创建了还要找什么理由呢。但是你点进来很大原因是因为你还没有个人博客，所以想来听听我创建个人博客的理由，以此来驱动自己去创建个人博客。这非常好，证明你已经有冲动了，只差行动起来。</p><p>我的理由有以下几点：</p><ol><li>想要记录下一些自己的技术学习的过程。比记录在有道云笔记自己看更加有价值，因为博客是可以分享，可以传播，知识需要传播起来才有力量。这是最大的一个原因。</li><li>通过输出博客文章提升自己的技术水平。因为输出就是最好的学习，输出一篇好的技术文章，往往就是最好的学习方式。</li><li>通过这个博客和网友互相学习。毕竟外面的世界很大，可以通过博客这个窗口和网上的开发者互相学习讨论，不失为一种乐趣。</li><li>记录一些生活感想、读书笔记、美食经历等等。</li></ol><p>这就是我的理由。如果你想要创建个人博客的话，马上去做吧。</p><p>教程的话可以参考</p><p>B站up主“CodeSheep”的视频<a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></p><p>我的hexo主题使用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">fluid</a>,如果你觉得不错也可以使用哦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
