<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>什么是skywalking？看完这篇你就懂了</title>
    <link href="/2020/11/02/%E4%BB%80%E4%B9%88%E6%98%AFskywalking%EF%BC%9F%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/"/>
    <url>/2020/11/02/%E4%BB%80%E4%B9%88%E6%98%AFskywalking%EF%BC%9F%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/skywalking_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong><a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">skywalking</a></strong>又是一个优秀的国产开源框架，2015年由个人吴晟（华为开发者）开源 ， 2017年加入Apache孵化器。</p><p>skywalking是分布式系统的<strong>应用程序性能监视工具</strong>，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。SkyWalking 是<strong>观察性分析平台和应用性能管理系统</strong>。提供<strong>分布式追踪、服务网格遥测分析、度量聚合和可视化一体化</strong>解决方案（官网介绍）。</p><h1 id="一、OpenTracing规范"><a href="#一、OpenTracing规范" class="headerlink" title="一、OpenTracing规范"></a>一、OpenTracing规范</h1><p><strong>OpenTracing是一种分布式系统链路跟踪的设计原则、规范、标准。</strong></p><p>类似JDBC的规范，主要为了提供一套标准的JDBC API。OpenTracing也是一样，是为了统一提供一套链路追踪的标准API，所制定的一种规范。</p><p>OpenTracing通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现。</p><p>类似于JDBC的规范由各个数据库厂商实现一样，OpenTracing规范也是有很多实现的产品，下面介绍一下落地的产品。</p><h2 id="1-1-实现OpenTracing的产品"><a href="#1-1-实现OpenTracing的产品" class="headerlink" title="1.1 实现OpenTracing的产品"></a>1.1 实现OpenTracing的产品</h2><p><strong>Jaeger</strong>：Jaeger是由Uber公司开源发布的，受到Dapper和OpenZipkin启发。后端使用Go语言，前端(用户界面)使用React 。优点是上传采用的是udp传输，效率高速度快。缺点就是丢包，影响了整条调用链，而且不支持告警和JVM监控。</p><p><strong>Zipkin</strong>：SpringCloud官方推荐，可以<strong>与SpringCloud有良好集成</strong>，实现方式是拦截请求，发送(http)数据到zipkin服务。缺点在于<strong>不支持告警，不支持JVM监控，通信方式使用Http请求向Zipkin上报信息，比较耗性能</strong>。</p><p><strong>SkyWalking</strong>：国人(吴晟)开发，支持dubbo，SpringCloud，SpringBoot集成，<strong>代码无侵入，通信方式采用GRPC，性能较好，实现方式是java探针，支持告警，支持JVM监控，支持全局调用统计</strong>等等，功能较完善。缺点是<strong>依赖较多</strong>，需要ElasticSearch，JDK环境，Nacos注册中心等。</p><h2 id="1-2-skywalking的特点"><a href="#1-2-skywalking的特点" class="headerlink" title="1.2 skywalking的特点"></a>1.2 skywalking的特点</h2><p><img src="https://static.lovebilibili.com/skywalking_1.png" srcset="/img/loading.gif" alt=""></p><p>比较重要的特点，我觉得是轻量高效，对代码无侵入性。对于微服务，支持dubbo，SpringBoot，SpringCloud集成。</p><h1 id="二、安装部署"><a href="#二、安装部署" class="headerlink" title="二、安装部署"></a>二、安装部署</h1><p>环境：CentOS 7.5，MySQL 5.7.26，Nacos 1.3.1（注册中心），JDK 1.8，<strong>skywalking 8.1.0</strong>。</p><p>除了skywalking之外，其他需要用到的组件我就不介绍怎么安装了，比较简单。安装skywalking其实很简单，下面一步一步来讲解。</p><p>第一步，下载。在<a href="http://skywalking.apache.org/downloads/" target="_blank" rel="noopener">官网</a>下载即可，选择8.1.0版本，如果要使用ES作为存储仓库，那就要选择es7的版本。</p><p><img src="https://static.lovebilibili.com/skywalking_2.png" srcset="/img/loading.gif" alt=""></p><p>第二步，解压。找到config目录下的application.yml文件，然后修改配置。</p><p><img src="https://static.lovebilibili.com/skywalking_3.png" srcset="/img/loading.gif" alt=""></p><p>需要修改的配置内容如下：</p><pre><code class="yaml">cluster:  selector: ${SW_CLUSTER:nacos}  #单机模式  standalone:  #使用nacos作为注册中心  nacos:    # 注册到nacos的服务名    serviceName: ${SW_SERVICE_NAME:&quot;SkyWalking_OAP_Cluster&quot;}    #nacos服务端的地址    hostPort: ${SW_CLUSTER_NACOS_HOST_PORT:192.168.0.105:8848}    # Nacos Configuration namespace命名空间    namespace: ${SW_CLUSTER_NACOS_NAMESPACE:&quot;public&quot;}core:  selector: ${SW_CORE:default}  default:    #skywalking服务端的REST绑定的IP    restHost: ${SW_CORE_REST_HOST:192.168.0.107}    #skywalking服务端的REST调用的端口    restPort: ${SW_CORE_REST_PORT:12800}    #skywalking服务端GRPC通信绑定的IP    gRPCHost: ${SW_CORE_GRPC_HOST:192.168.0.107}    #skywalking服务端GRPC通信绑定的端口    gRPCPort: ${SW_CORE_GRPC_PORT:11800}storage:  #选择使用mysql  selector: ${SW_STORAGE:mysql}  #默认使用h2，不会持久化，重启skyWalking之前的数据会丢失  h2:    driver: ${SW_STORAGE_H2_DRIVER:org.h2.jdbcx.JdbcDataSource}    url: ${SW_STORAGE_H2_URL:jdbc:h2:mem:skywalking-oap-db}    user: ${SW_STORAGE_H2_USER:sa}    metadataQueryMaxSize: ${SW_STORAGE_H2_QUERY_MAX_SIZE:5000}  #使用mysql作为持久化存储的仓库  mysql:    properties:      #数据库连接地址      jdbcUrl: ${SW_JDBC_URL:&quot;jdbc:mysql://192.168.0.107:3306/swtest&quot;}      #用户名      dataSource.user: ${SW_DATA_SOURCE_USER:yehongzhi}      #密码      dataSource.password: ${SW_DATA_SOURCE_PASSWORD:Yehongzhi520.}</code></pre><p>默认是web管理界面是8080端口，如果要修改端口号，可以修改webapp目录下的webapp.yml。</p><pre><code class="yaml">#web管理界面的端口server:  port: 8080</code></pre><p>第三步，添加mysql数据驱动包。因为在lib目录下是没有mysql数据驱动包的，所以修改完配置启动是会报错，启动失败的。为什么作者不提前在lib目录下放一个数据驱动包呢，还要我们手动去添加。网上貌似没有这个问题的讨论，我的理解是<strong>因为框架不知道你用的是什么版本的mysql数据库，所以不知道放什么版本的数据库驱动包，使用者用的是什么版本的mysql，就自己放对应的数据库驱动包</strong>。</p><p>我这里用的是5.7.26版本的mysql，所以我下载了一个8.0.17的驱动包，添加到/oap-libs目录下。</p><p><img src="https://static.lovebilibili.com/skywalking_4.png" srcset="/img/loading.gif" alt=""></p><p>第三步，启动。在/bin目录上一级，直接使用<code>./bin/startup.sh</code>启动即可。启动之后，可以使用<code>jps</code>命令查看进程，可以看到这两个java程序在运行状态。</p><p><img src="https://static.lovebilibili.com/skywalking_5.png" srcset="/img/loading.gif" alt=""></p><p>打开配置的Nacos控制台，可以看到服务列表注册了名为“SkyWalking_OAP_Cluster”的服务。</p><p><img src="https://static.lovebilibili.com/skywalking_6.png" srcset="/img/loading.gif" alt=""></p><p>可以看到mysql建了很多表。</p><p><img src="https://static.lovebilibili.com/skywalking_7.png" srcset="/img/loading.gif" alt=""></p><p>说明启动成功了，打开配置对应的地址<a href="http://192.168.0.109:8080/，可以看到skywalking的web界面。" target="_blank" rel="noopener">http://192.168.0.109:8080/，可以看到skywalking的web界面。</a></p><p><img src="https://static.lovebilibili.com/skywalking_8.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、整合SpringCloud工程"><a href="#三、整合SpringCloud工程" class="headerlink" title="三、整合SpringCloud工程"></a>三、整合SpringCloud工程</h1><p>整合其实很简单，不需要引入依赖，也不需要添加任何代码，我们只需要在启动jar包时配置参数即可。</p><pre><code>-javaagent:D:\apache-skywalking-apm-bin-es7\agent\skywalking-agent.jar-Dskywalking.agent.service_name=consumer-Dskywalking.collector.backend_service=192.168.0.109:11800#解释一下上面这三个参数的意思#-javaagent:填的是skywalking-agent.jar的本地磁盘的路径#-Dskywalking.agent.service_name：在skywalking上显示的服务名#-Dskywalking.collector.backend_service：skywalking的collector服务的IP及端口</code></pre><p>我们一般用IDEA开发就这样设置即可。</p><p><img src="https://static.lovebilibili.com/skywalking_9.png" srcset="/img/loading.gif" alt=""></p><p>接下来我按照这个配置，启动一个Consumer工程和Provider工程，并且注册到Nacos注册中心。</p><p><img src="https://static.lovebilibili.com/skywalking_10.png" srcset="/img/loading.gif" alt=""></p><p>然后使用Consumer工程的接口调用Provider工程的接口，可以看到调用链的效果。</p><p><img src="https://static.lovebilibili.com/skywalking_11.png" srcset="/img/loading.gif" alt=""></p><p>非常清晰地看到服务之间调用的情况，耗时等等。其他还有很多功能就不一一介绍了，读者可以自己探索一下。</p><h1 id="四、谈谈架构设计"><a href="#四、谈谈架构设计" class="headerlink" title="四、谈谈架构设计"></a>四、谈谈架构设计</h1><p>可能前面还有一些疑问，比如为什么要设置GRPC的端口号，设置存储仓库为mysql，启动之后有两个java进程等等。不妨看看架构，一切问题都明白了。首先看官网的一张架构图。</p><p><img src="https://static.lovebilibili.com/skywalking_15.png" srcset="/img/loading.gif" alt=""></p><p>可以看到主要有四个部分。</p><p><strong>上面的Agent</strong> ：负责从应用中，收集tracing(调用链数据)和metric(指标)，发送给 SkyWalking OAP 服务器。目前支持 SkyWalking、Zikpin、Jaeger 等提供的 Tracing 数据信息。而我们目前采用的是，SkyWalking Agent 收集 SkyWalking Tracing 数据，传递给SkyWalking OAP 服务器。</p><p><strong>中间的SkyWalking OAP</strong>：负责接收 Agent 发送的 Tracing 和Metric的数据信息，然后进行分析(Analysis Core) ，存储到外部存储器( Storage )，最终提供查询( Query )功能。</p><p><strong>左边的SkyWalking UI</strong>：负责提供web控制台，查看链路，查看各种指标，性能等等。</p><p><strong>右边的Storage</strong>：数据存储。目前支持ES、MySQL、H2等多种存储器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章就介绍到这里，这里仅仅只是入门，简单使用Skywalking，实际上里面还有很多功能我没有介绍，有兴趣的同学可以按照上面的教程安装部署，然后自己探索一下。</p><p>在现在微服务架构比较流行的环境下，如果没有一个调用链追踪框架，会导致很难排查线上服务调用的问题。skywalking是目前发展势头最快的技术框架的技术框架，因为对代码是无侵入性的，所以目前很多公司都采用Skywalking。</p><p><img src="https://static.lovebilibili.com/skywalking_14.png" srcset="/img/loading.gif" alt=""></p><p>这篇文章就讲到这里了，感谢大家的阅读。</p><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>ELK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三千字Apollo配置中心总结</title>
    <link href="/2020/10/21/%E4%B8%89%E5%8D%83%E5%AD%97Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%80%BB%E7%BB%93/"/>
    <url>/2020/10/21/%E4%B8%89%E5%8D%83%E5%AD%97Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/apollo_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用<strong>不同环境、不同集群</strong>的配置，配置修改后能够<strong>实时推送到应用端，并且具备规范的权限、流程治理</strong>等特性。</p><p>目前Apollo在github有22.6k颗星，在官网登记的使用的公司有451家，算是很流行的配置中心的框架技术。所以接下来跟着我一起学习Apollo配置中心吧。</p><p><img src="https://static.lovebilibili.com/apollo_1.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、为什么使用配置中心"><a href="#二、为什么使用配置中心" class="headerlink" title="二、为什么使用配置中心"></a>二、为什么使用配置中心</h1><p>首先，没有配置中心之前传统的配置都是写在配置文件中，比如各种yml、perproties、xml文件。</p><p>写在各种文件里最大的问题在于<strong>如果需要改配置信息，需要重新部署发布应用才能生效</strong>，这是第一个问题。</p><p>后面为了做到动态读取配置信息，后面有人改进一下把配置信息存储在数据库的一张表，程序读取表中的配置信息，这种方式很多公司都还在使用，因为简单，而且灵活(修改配置只需要执行个SQL语句，不需要重新部署发布)。但是也不是最完美的，因为<strong>缺少了权限控制，没有管理界面进行统一配置，没有历史版本的配置信息，不支持回滚(防止误操作)</strong>。</p><p>实际上配置中心在市面上已经有很多，比如Nacos、Consul、spring-cloud-config、Apollo等等。</p><p>相对其他的，我觉得选择Apollo的原因是，界面比较美观，操作简便，部署简单，依赖较少，开箱即用。</p><h1 id="三、安装部署"><a href="#三、安装部署" class="headerlink" title="三、安装部署"></a>三、安装部署</h1><p>首先要讲一下Apollo部署三个服务apollo-configservice，apollo-adminservice，apollo-portal，后面我讲架构设计时会讲一下这三个服务是用来干嘛的。</p><p>这里部署建议不要用官网的Quick Start，我一开始使用QuickStart的方式，搞了几个钟头搞不定，总是在Eureka上多了一个UNKONWN的服务，然后又无法访问8070的管理界面，心态直接崩溃。上github找了一下，如下：</p><p><img src="https://static.lovebilibili.com/apollo_3.png" srcset="/img/loading.gif" alt=""></p><p>作者在下面的回答是这样的。</p><p><img src="https://static.lovebilibili.com/apollo_4.png" srcset="/img/loading.gif" alt=""></p><p>这个问题发现不止有一个issue(#2931)反映了，但是没有解决，作者建议使用标准部署。</p><p><img src="https://static.lovebilibili.com/apollo_5.png" srcset="/img/loading.gif" alt=""></p><p>所以接下来就讲标准部署，也就是分布式部署，有耐心的同学也可以直接去github看作者写的<a href="https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">分布式部署指南</a>。</p><p>先介绍一下环境依赖，Linux服务器(建议CentOS7)，MySQL(版本要求:5.6.5+)，部署的服务器需要安装JDK环境(java 1.8+)。</p><p>这里有两种安装方式，一种是下载安装包，另一种是通过源码构建。一般如果不需要对Apollo定制开发，直接用安装包部署即可。我这里演示的就是安装包部署的方式。</p><h2 id="3-1-获取安装包"><a href="#3-1-获取安装包" class="headerlink" title="3.1 获取安装包"></a>3.1 获取安装包</h2><p>先到<a href="https://github.com/ctripcorp/apollo/releases" target="_blank" rel="noopener">官网</a>下载安装包。</p><p><img src="https://static.lovebilibili.com/apollo_6.png" srcset="/img/loading.gif" alt=""></p><p>下载后解压，如下：</p><p><img src="https://static.lovebilibili.com/apollo_7.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-2-创建数据库"><a href="#3-2-创建数据库" class="headerlink" title="3.2 创建数据库"></a>3.2 创建数据库</h2><p>使用MySQL数据库(版本要求:5.6.5+)。</p><h3 id="3-2-1-创建ApolloPortalDB数据库"><a href="#3-2-1-创建ApolloPortalDB数据库" class="headerlink" title="3.2.1 创建ApolloPortalDB数据库"></a>3.2.1 创建ApolloPortalDB数据库</h3><p>使用<a href="https://github.com/ctripcorp/apollo/blob/master/scripts/sql/apolloportaldb.sql" target="_blank" rel="noopener">github上面的sql脚本</a>创建ApolloPortalDB数据库，导入相关的表以及数据。</p><p><img src="https://static.lovebilibili.com/apollo_8.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-2-2-创建ApolloConfigDB数据库"><a href="#3-2-2-创建ApolloConfigDB数据库" class="headerlink" title="3.2.2 创建ApolloConfigDB数据库"></a>3.2.2 创建ApolloConfigDB数据库</h3><p>使用<a href="https://github.com/ctripcorp/apollo/blob/master/scripts/sql/apolloportaldb.sql" target="_blank" rel="noopener">github上面的sql脚本</a>创建ApolloConfigDB数据库，导入相关的表以及数据。</p><p><img src="https://static.lovebilibili.com/apollo_9.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-3-修改配置"><a href="#3-3-修改配置" class="headerlink" title="3.3 修改配置"></a>3.3 修改配置</h2><p>需要改一下数据库连接信息，路径在/config下。</p><h3 id="3-3-1-apollo-configservice配置"><a href="#3-3-1-apollo-configservice配置" class="headerlink" title="3.3.1 apollo-configservice配置"></a>3.3.1 apollo-configservice配置</h3><p>修改apollo-configservice的数据库连接信息application-github.properties，如下：</p><pre><code class="properties"># DataSourcespring.datasource.url = jdbc:mysql://192.168.0.107:3306/ApolloConfigDB?characterEncoding=utf8spring.datasource.username = 账号spring.datasource.password = 密码</code></pre><h3 id="3-3-2-apollo-adminservice配置"><a href="#3-3-2-apollo-adminservice配置" class="headerlink" title="3.3.2 apollo-adminservice配置"></a>3.3.2 apollo-adminservice配置</h3><p>修改apollo-adminservice的数据库连接信息application-github.properties，如下：</p><pre><code class="properties"># DataSourcespring.datasource.url = jdbc:mysql://192.168.0.107:3306/ApolloConfigDB?characterEncoding=utf8spring.datasource.username = 账号spring.datasource.password = 密码</code></pre><h3 id="3-3-3-apollo-portal配置"><a href="#3-3-3-apollo-portal配置" class="headerlink" title="3.3.3 apollo-portal配置"></a>3.3.3 apollo-portal配置</h3><p>修改apollo-portal的数据库连接信息application-github.properties，如下：</p><pre><code class="properties"># DataSourcespring.datasource.url = jdbc:mysql://192.168.0.107:3306/ApolloPortalDB?characterEncoding=utf8spring.datasource.username = 账号spring.datasource.password = 密码</code></pre><p>再修改apollo-env.properties配置，这是关于环境配置的，如下：</p><pre><code class="properties">local.meta=http://localhost:8080## 开发环境dev.meta=http://192.168.0.107:8080## 不需要配置的环境参考${lpt_meta}配置fat.meta=${fat_meta}uat.meta=${uat_meta}lpt.meta=${lpt_meta}pro.meta=${pro_meta}</code></pre><h2 id="3-4-部署"><a href="#3-4-部署" class="headerlink" title="3.4 部署"></a>3.4 部署</h2><p>然后把三个文件夹都上传到Linux服务器。</p><p><img src="https://static.lovebilibili.com/apollo_10.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-4-1-部署发布apollo-configservice"><a href="#3-4-1-部署发布apollo-configservice" class="headerlink" title="3.4.1 部署发布apollo-configservice"></a>3.4.1 部署发布apollo-configservice</h3><p>部署发布服务有顺序，首先发布apollo-configservice，直接执行scripts/startup.sh。</p><p><img src="https://static.lovebilibili.com/apollo_11.png" srcset="/img/loading.gif" alt=""></p><p>有可能会出现这个错误(我就出现了)，不用担心，实际上进程还没有结束，还在启动，我们可以到日志记录的文件夹(下图来源于startup.sh脚本)查看日志。</p><p><img src="https://static.lovebilibili.com/apollo_12.png" srcset="/img/loading.gif" alt=""></p><p>启动时间比较长，因为这个服务包括启动Eureka注册中心，需要耐心等待。观察apollo-configservice.log文件，当看到如下信息后，表示启动成功。</p><p><img src="https://static.lovebilibili.com/apollo_13.png" srcset="/img/loading.gif" alt=""></p><p>Eureka注册中心启动成功，可以打开<a href="http://192.168.0.107:8080/查看：" target="_blank" rel="noopener">http://192.168.0.107:8080/查看：</a></p><p><img src="https://static.lovebilibili.com/apollo_14.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-4-2-部署发布apollo-adminservice"><a href="#3-4-2-部署发布apollo-adminservice" class="headerlink" title="3.4.2 部署发布apollo-adminservice"></a>3.4.2 部署发布apollo-adminservice</h3><p>接着发布apollo-adminservice，直接执行scripts/startup.sh。查看日志的方式跟上面一样。启动成功后，可以看到Eureka的服务列表中多了一个服务。</p><p><img src="https://static.lovebilibili.com/apollo_15.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-4-3-部署发布apollo-portal"><a href="#3-4-3-部署发布apollo-portal" class="headerlink" title="3.4.3 部署发布apollo-portal"></a>3.4.3 部署发布apollo-portal</h3><p>接着发布apollo-portal，直接执行scripts/startup.sh。portal是提供Web界面的服务，所以启动成功后，可以打开<a href="http://192.168.0.107:8070/登录web界面，默认账号密码是apollo/admin。" target="_blank" rel="noopener">http://192.168.0.107:8070/登录web界面，默认账号密码是apollo/admin。</a></p><p><img src="https://static.lovebilibili.com/apollo_16.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/apollo_17.png" srcset="/img/loading.gif" alt=""></p><p>到此，安装就完成了！</p><h1 id="四、SpringBoot整合Apollo"><a href="#四、SpringBoot整合Apollo" class="headerlink" title="四、SpringBoot整合Apollo"></a>四、SpringBoot整合Apollo</h1><p>接下来，整一个Demo(相当于java客户端)，使用SpringBoot整合Apollo，实现动态读取配置。</p><h2 id="4-1-Mave依赖"><a href="#4-1-Mave依赖" class="headerlink" title="4.1 Mave依赖"></a>4.1 Mave依赖</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt;    &lt;artifactId&gt;apollo-client&lt;/artifactId&gt;    &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="4-2-AppId"><a href="#4-2-AppId" class="headerlink" title="4.2 AppId"></a>4.2 AppId</h2><p>在classpath路径下，创建/META-INF/app.properties文件。如下：</p><pre><code class="properties"># 应用的唯一标识，后面创建工程需要用到app.id=apollo-demo</code></pre><h2 id="4-3-Apollo-Meta-Server"><a href="#4-3-Apollo-Meta-Server" class="headerlink" title="4.3 Apollo Meta Server"></a>4.3 Apollo Meta Server</h2><p>其实就是配置Apollo服务器的地址。官网提供的方式有很多，我这里选其中一种比较简单的方式。在classpath路径下创建apollo-env.properties文件，配置如下：</p><pre><code class="properties">dev.meta=http://192.168.0.107:8080# fat.meta=http://apollo.fat.xxx.com# uat.meta=http://apollo.uat.xxx.com# pro.meta=http://apollo.xxx.com</code></pre><h2 id="4-4-Environment"><a href="#4-4-Environment" class="headerlink" title="4.4 Environment"></a>4.4 Environment</h2><p>其实是配置环境，因为上面可以配置四种环境，这里配置具体选择哪个环境。这里介绍两种方式：</p><p>第一种通过Java System Property。</p><p><img src="https://static.lovebilibili.com/apollo_18.png" srcset="/img/loading.gif" alt=""></p><p>第二种通过配置文件。</p><p><img src="https://static.lovebilibili.com/apollo_19.png" srcset="/img/loading.gif" alt=""></p><p>到相对应的路径下创建server.properties，配置如下：</p><pre><code class="properties">env=DEV</code></pre><h2 id="4-5-EnableApolloConfig"><a href="#4-5-EnableApolloConfig" class="headerlink" title="4.5 @EnableApolloConfig"></a>4.5 @EnableApolloConfig</h2><p>在启动类上加上注解@EnableApolloConfig。</p><pre><code class="java">@SpringBootApplication//开启apollo配置@EnableApolloConfigpublic class ApolloDemoApplication {    public static void main(String[] args) {        SpringApplication.run(ApolloDemoApplication.class, args);    }}</code></pre><h2 id="4-6-测试类"><a href="#4-6-测试类" class="headerlink" title="4.6 测试类"></a>4.6 测试类</h2><p>这样就完成了，接下来再创建一个Controller进行测试一下。</p><pre><code class="java">@RestControllerpublic class ApolloController {    //冒号后面的是默认值    @Value(&quot;${configValue:default}&quot;)    private String configValue;    @RequestMapping(&quot;/apollo/getConfig&quot;)    public String getConfig() {        return configValue;    }}</code></pre><h2 id="4-7-管理界面创建对应的配置"><a href="#4-7-管理界面创建对应的配置" class="headerlink" title="4.7 管理界面创建对应的配置"></a>4.7 管理界面创建对应的配置</h2><p>第一步，创建项目。</p><p><img src="https://static.lovebilibili.com/apollo_21.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/apollo_20.png" srcset="/img/loading.gif" alt=""></p><p>第二步，创建配置。</p><p><img src="https://static.lovebilibili.com/apollo_22.png" srcset="/img/loading.gif" alt=""></p><p>第三步，发布。</p><p><img src="https://static.lovebilibili.com/apollo_23.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-8-测试"><a href="#4-8-测试" class="headerlink" title="4.8 测试"></a>4.8 测试</h2><p>启动项目apollo-demo，然后请求路径<a href="http://localhost:8888/apollo/getConfig，可以看到：" target="_blank" rel="noopener">http://localhost:8888/apollo/getConfig，可以看到：</a></p><p><img src="https://static.lovebilibili.com/apollo_24.png" srcset="/img/loading.gif" alt=""></p><p>控制台可以看到推送配置信息的日志：</p><p><img src="https://static.lovebilibili.com/apollo_25.png" srcset="/img/loading.gif" alt=""></p><h1 id="五、架构设计"><a href="#五、架构设计" class="headerlink" title="五、架构设计"></a>五、架构设计</h1><p>讲完了安装和SpringBoot整合的demo后，我们是时候探究一下原理，为什么要有三个服务，又是如何做到配置信息发布后，客户端实时获取到最新的配置的。继续往下看。</p><p>首先看一张官网的架构设计图。</p><h2 id="5-1-基础模型"><a href="#5-1-基础模型" class="headerlink" title="5.1 基础模型"></a>5.1 基础模型</h2><p>作者在官网上有个基础模型的架构图，忽略掉很多细节后实际上非常简单：</p><p><img src="https://static.lovebilibili.com/apollo_26.png" srcset="/img/loading.gif" alt=""></p><ol><li>用户在配置中心对配置进行修改并发布。</li><li>配置中心通知Apollo客户端有配置更新。</li><li>Apollo客户端从配置中心拉取最新的配置、更新本地配置并通知到应用。</li></ol><h2 id="5-2-架构模块"><a href="#5-2-架构模块" class="headerlink" title="5.2 架构模块"></a>5.2 架构模块</h2><p>如果我们把Apollo配置中心服务端展开的话，架构图如下：</p><p><img src="https://static.lovebilibili.com/apollo_27.png" srcset="/img/loading.gif" alt=""></p><p>看到这里，整个架构看起来就比较清晰了。接下来从上往下简单介绍一下：</p><p><strong>Portal服务</strong>：提供Web界面供用户管理配置，通过MetaServer获取AdminService服务列表（IP+Port），通过IP+Port访问AdminService服务。</p><p><strong>Client</strong>：实际上就是我们创建的SpringBoot项目，引入ApolloClient的maven依赖，为应用提供配置获取、实时更新等功能。</p><p><strong>Meta Server</strong>：从Eureka获取Config Service和Admin Service的服务信息，相当于是一个Eureka Client。主要是为了封装服务发现的细节，对Portal和Client而言，永远通过一个Http接口获取Admin Service和Config Service的服务信息，而不需要关心背后实际的服务注册和发现组件。Meta Server只是一个逻辑角色，在部署时和Config Service是在一个JVM进程中的，所以IP、端口和Config Service一致。</p><p><strong>Eureka</strong>：注册中心。Config Service和Admin Service会向Eureka注册服务。为了简单起见，目前Eureka在部署时和Config Service是在一个JVM进程中的。</p><p><strong>Config Service</strong>：提供配置获取接口。提供配置更新推送接口(基于Http long polling)。服务对象为Apollo客户端(Client)。</p><p><strong>Admin Service</strong>：提供配置管理接口。提供配置发布、修改等接口。服务对象为Portal。</p><h2 id="5-3-配置发布后的实时推送设计"><a href="#5-3-配置发布后的实时推送设计" class="headerlink" title="5.3 配置发布后的实时推送设计"></a>5.3 配置发布后的实时推送设计</h2><p>上面讲完各个角色的用途，那这些角色是怎么配合一起工作的呢，我们来看一张图：</p><p><img src="https://static.lovebilibili.com/apollo_28.png" srcset="/img/loading.gif" alt=""></p><p>上图简要描述了配置发布的大致过程：</p><ol><li>用户在Portal操作配置发布。</li><li>Portal调用Admin Service的接口操作发布。</li><li>Admin Service发布配置后，发送ReleaseMessage给各个Config Service。</li><li>Config Service收到ReleaseMessage后，通知对应的客户端(Client)。</li></ol><p>关键点在于AdminService发送ReleaseMessage给ConfigService，这一步是如何异步发送的呢，一般异步发送我们很容易想到消息队列，但是实际上我们在安装部署时并没有使用到消息队列。</p><p>答案在于：</p><ul><li>Admin Service在配置发布后会往ReleaseMessage表插入一条消息记录，消息内容就是配置发布的AppId+Cluster+Namespace。</li><li>然后Config Service有一个线程会每秒扫描一次ReleaseMessage表，看看是否有新的消息记录。</li><li>Config Service如果发现有新的消息记录，那么就会通知到所有的消息监听器，监听器得到配置发布的AppId+Cluster+Namespace后，会通知对应的客户端。</li></ul><p><img src="https://static.lovebilibili.com/apollo_29.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>在实现上，考虑到Apollo的实际使用场景，以及为了尽可能减少外部依赖，我们没有采用外部的消息中间件，而是通过数据库实现了一个简单的消息队列。—-来自官网</p></blockquote><h2 id="5-4-高可用"><a href="#5-4-高可用" class="headerlink" title="5.4 高可用"></a>5.4 高可用</h2><p>Apollo为了实现高可用，服务端使用了Eureka作为注册中心，这一点在官网也有谈到。</p><p><img src="https://static.lovebilibili.com/apollo_30.png" srcset="/img/loading.gif" alt=""></p><p>除此之外，客户端也做了高可用的一些架构设计，比如本地文件缓存。</p><p><img src="https://static.lovebilibili.com/apollo_31.png" srcset="/img/loading.gif" alt=""></p><p>这个缓存文件默认就放在C:\opt\data\apollo-demo\config-cache路径下：</p><p><img src="https://static.lovebilibili.com/apollo_32.png" srcset="/img/loading.gif" alt=""></p><p>这个文件的作用是，在遇到服务不可用，或网络不通的时候，依然能从本地恢复配置。</p><h1 id="六、絮叨"><a href="#六、絮叨" class="headerlink" title="六、絮叨"></a>六、絮叨</h1><p>这篇文章就讲到这里。其实Apollo配置中心算是一个比较容易上手，架构相对比较清晰的开源项目。目前很多互联网公司都在推行微服务架构，在使用微服务的架构时，配置信息就会成倍数增加，因为配置实际上代表的是“控制”，很多时候程序的运行是靠配置去决定行为的，而且要能实时生效的，所以就必须要有个配置中心。</p><p>有些公司体量大一些会自己公司开发一套配置中心，其实实现起来也不是特别难，我上一间公司就自己实现，使用MQ消息队列+数据库，再自己简单地搭了一个增删改查、刷新配置的web页面，就完成了一个配置中心。</p><p>但是我觉得如果有现成的开源的会更加舒服，不用自己造轮子耗费时间，精力，而且选一些像Apollo这种比较大众主流的技术框架，学习成本也比较低，网上有很多资料。</p><p>那么Apollo配置中心就讲到这里了，上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>分布式</tag>
      
      <tag>配置中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3千字详细讲解OpenFeign的使用姿势</title>
    <link href="/2020/10/13/3%E5%8D%83%E5%AD%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3OpenFeign%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <url>/2020/10/13/3%E5%8D%83%E5%AD%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3OpenFeign%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/fegin_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前在SpringCloud技术栈中，调用服务用得最多的就是OpenFeign，所以这篇文章讲一下OpenFeign，希望对大家有所帮助。</p><h1 id="一、构建工程"><a href="#一、构建工程" class="headerlink" title="一、构建工程"></a>一、构建工程</h1><p>使用Nacos作为注册中心，不会搭建Nacos的话，可以参考上一篇注册中心的文章。</p><p>首先父工程parent引入依赖。</p><pre><code class="xml">&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Finchley.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;            &lt;version&gt;0.2.2.RELEASE&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-openfeign&lt;/artifactId&gt;            &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;&lt;!-- SpringCloud nacos服务发现的依赖 --&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;        &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;        &lt;version&gt;1.2.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>搭建提供者provider工程和消费者consumer工程。</p><p>provider工程继承父工程的pom文件，编写启动类如下：</p><pre><code class="java">@SpringBootApplication@EnableDiscoveryClient//注册中心public class ProviderApplication {    public static void main(String[] args) throws Exception {        SpringApplication.run(ProviderApplication.class, args);    }}</code></pre><p>provider工程的配置文件如下：</p><pre><code class="yaml">server:  port: 8080spring:  application:    name: provider  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8848        service: ${spring.application.name}</code></pre><p>提供接口，Controller如下：</p><pre><code class="java">@RestControllerpublic class ProviderController {    @RequestMapping(&quot;/provider/list&quot;)    public List&lt;String&gt; list() {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;java技术爱好者&quot;);        list.add(&quot;SpringCloud&quot;);        list.add(&quot;没有人比我更懂了&quot;);        return list;    }}</code></pre><p>消费者consumer工程也继承parent的pom文件，加上Feign依赖：</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;!-- 版本在parent的pom文件中指定了 --&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>编写启动类，如下：</p><pre><code class="java">@SpringBootApplication@EnableDiscoveryClient//开启feign接口扫描，指定扫描的包@EnableFeignClients(basePackages = {&quot;com.yehongzhi.springcloud&quot;})public class ConsumerApplication {    public static void main(String[] args) throws Exception {        SpringApplication.run(ConsumerApplication.class, args);    }}</code></pre><p>环境搭建完成后，接下来讲两种实现使用方式。</p><h1 id="二、声明式"><a href="#二、声明式" class="headerlink" title="二、声明式"></a>二、声明式</h1><p>这种很简单，消费者consumer工程增加一个ProviderClient接口。</p><pre><code class="java">@FeignClient(name = &quot;provider&quot;)//会扫描指定包下，标记FeignClient注解的接口//会根据服务名，从注册中心找到对应的IP地址public interface ProviderClient {    //这里跟提供者接口的URL一致    @RequestMapping(&quot;/provider/list&quot;)    String list();}</code></pre><p>然后再用消费者工程的ConsumerController接口来测试。</p><pre><code class="java">@RestControllerpublic class ConsumerController {    //引入Feign客户端    @Resource    private ProviderClient providerClient;    @RequestMapping(&quot;/consumer/callProvider&quot;)    public String callProvider() {        //使用Feign客户端调用其他服务的接口        return providerClient.list();    }}</code></pre><p>最后我们启动提供者工程，消费者工程，注册中心，测试。</p><p><img src="https://static.lovebilibili.com/fegin_1.png" srcset="/img/loading.gif" alt=""></p><p>然后调用消费者的ConsumerController接口。</p><p><img src="https://static.lovebilibili.com/fegin_2.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、继承式"><a href="#三、继承式" class="headerlink" title="三、继承式"></a>三、继承式</h1><p>细心的同学可能发现，其实声明式会写多一次提供者接口的定义，也就是有重复的代码，既然有重复的定义，那我们就可以抽取出来，所以就有了继承式。</p><p>第一步，创建一个普通的Maven项目api工程，把接口定义在api中。</p><p><img src="https://static.lovebilibili.com/fegin_3.png" srcset="/img/loading.gif" alt=""></p><p>第二步，服务提供者工程的ProviderController实现Provider接口。</p><pre><code class="java">@RestControllerpublic class ProviderController implements ProviderApi {    public String list() {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;java技术爱好者&quot;);        list.add(&quot;SpringCloud&quot;);        list.add(&quot;没有人比我更懂了&quot;);        return list.toString();    }}</code></pre><p>第三步，消费者工程的ProviderClient无需定义，只需要继承ProviderApi，然后加上@FeignClient即可。</p><pre><code class="java">@FeignClient(name = &quot;provider&quot;)public interface ProviderClient extends ProviderApi {}</code></pre><p>其他不用变了，最后启动服务提供者，消费者，注册中心测试一下。</p><p><img src="https://static.lovebilibili.com/fegin_4.png" srcset="/img/loading.gif" alt=""></p><p>测试成功！上面继承式的好处就在于，只需要在api工程定义一次接口，服务提供者去实现具体的逻辑，消费者则继承接口贴个注解即可，非常方便快捷。</p><p>缺点就在于如果有人动了api的接口，则会导致很多服务消费者、提供者出现报错，耦合性比较强。api工程相当于一个公共的工程，消费者和服务者都会依赖此工程，所以一般要求不能随便删api上面的接口。</p><h1 id="四、Feign的相关配置"><a href="#四、Feign的相关配置" class="headerlink" title="四、Feign的相关配置"></a>四、Feign的相关配置</h1><p>下面讲一下Feign的一些常用的相关配置。</p><h2 id="4-1-请求超时设置"><a href="#4-1-请求超时设置" class="headerlink" title="4.1 请求超时设置"></a>4.1 请求超时设置</h2><p>Feign底层其实还是使用Ribbon，默认是1秒。所以超过1秒就报错。</p><p>接下来试验一下。我在服务提供者的接口加上一段休眠1.5秒的代码，然后用消费者去消费。</p><pre><code class="java">@RestControllerpublic class ProviderController implements ProviderApi {    public String list() {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;java技术爱好者&quot;);        list.add(&quot;SpringCloud&quot;);        list.add(&quot;没有人比我更懂了&quot;);        try {            //休眠1.5秒            Thread.sleep(1500);        } catch (Exception e) {            e.printStackTrace();        }        return list.toString();    }}</code></pre><p>消费者调用后，由于超过1秒，可以看到控制台报错。</p><p><img src="https://static.lovebilibili.com/fegin_5.png" srcset="/img/loading.gif" alt=""></p><p>如果想调整超时时间，可以在消费者这边，加上配置：</p><pre><code class="yaml">ribbon:  ReadTimeout:  5000 #请求时间5秒  ConnectTimeout: 5000 #连接时间5秒</code></pre><p>为了显示出效果，我们在消费者的代码里加上耗时计算：</p><pre><code class="java">@RestControllerpublic class ConsumerController {    @Resource    private ProviderClient providerClient;    @RequestMapping(&quot;/consumer/callProvider&quot;)    public String callProvider() throws Exception {        long star = System.currentTimeMillis();        String list = providerClient.list();        long end = System.currentTimeMillis();        return &quot;响应结果：&quot; + list + &quot;,耗时：&quot; + (end - star) / 1000 + &quot;秒&quot;;    }}</code></pre><p>最后启动测试，可以看到，超过1秒也能请求成功。</p><p><img src="https://static.lovebilibili.com/fegin_6.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-日志打印功能"><a href="#4-2-日志打印功能" class="headerlink" title="4.2 日志打印功能"></a>4.2 日志打印功能</h2><p>首先需要配置Feign的打印日志的级别。</p><pre><code class="java">@Configurationpublic class FeignConfig {    /**     * NONE：默认的，不显示任何日志     * BASIC：仅记录请求方法、URL、响应状态码及执行时间     * HEADERS：出了BASIC中定义的信息之外，还有请求和响应的头信息     * FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元素     */    @Bean    public Logger.Level feginLoggerLevel() {        return Logger.Level.FULL;    }}</code></pre><p>第二步，需要设置打印的Feign接口。Feign为每个客户端创建一个logger。默认情况下，logger的名称是Feigh接口的完整类名。需要注意的是，<strong>Feign的日志打印只会对DEBUG级别做出响应</strong>。</p><pre><code class="yaml">#与server同级logging:  level:    com.yehongzhi.springcloud.consumer.feign.ProviderClient: debug</code></pre><p>设置完成后，控制台可以看到详细的请求信息。<br><img src="https://static.lovebilibili.com/fegin_7.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-3-Feign实现熔断"><a href="#4-3-Feign实现熔断" class="headerlink" title="4.3 Feign实现熔断"></a>4.3 Feign实现熔断</h2><p>openFeign实际上是已经引入了hystrix的相关jar包，所以可以直接使用，设置超时时间，超时后调用FallBack方法，实现熔断机制。</p><p>首先在消费者工程添加Maven依赖。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>第二步，在配置中开启熔断机制，添加超时时间。</p><pre><code class="yaml">#默认是不支持的，所以这里要开启，设置为truefeign:  hystrix:    enabled: truehystrix:  command:    default:      execution:        isolation:          thread:            timeoutInMilliseconds: 3000</code></pre><p>第三步，编写FallBack类。</p><pre><code class="java">//ProviderClient是贴了@FeignClient注解的接口@Componentpublic class ProviderClientFallBack implements ProviderClient {    @Override    public String list() {        return Arrays.asList(&quot;调用fallBack接口&quot;, &quot;返回未知结果&quot;).toString();    }}</code></pre><p>第四步，在对应的Feign接口添加fallback属性。</p><pre><code class="java">//fallback属性，填写刚刚编写的FallBack回调类@Component@FeignClient(name = &quot;provider&quot;, fallback = ProviderClientFallBack.class)public interface ProviderClient extends ProviderApi {}</code></pre><p>最后可以测试一下，超过设置的3秒，则会熔断，调用FallBack方法返回。</p><p><img src="https://static.lovebilibili.com/fegin_8.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-4-设置负载均衡"><a href="#4-4-设置负载均衡" class="headerlink" title="4.4 设置负载均衡"></a>4.4 设置负载均衡</h2><p>前面说过OpenFeign底层是使用Ribbon，Ribbon是负责做负载均衡的组件。所以是可以通过配置设置负载均衡的策略。</p><p>默认的是轮询策略。如果要换成其他策略，比如随机，怎么换呢。</p><p>很简单，改一下配置即可：</p><pre><code class="yaml">#服务名称provider:  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #配置规则 随机#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #配置规则 轮询#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RetryRule #配置规则 重试#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule #配置规则 响应时间权重#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.BestAvailableRule #配置规则 最空闲连接策略</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>OpenFeign把RestTemplete，Ribbon，Hystrix糅合在了一起，在使用时就可以更加方便，优雅地完成整个服务的暴露，调用等。避免做一些重复的复制粘贴接口URL，或者重复定义接口等。还是非常值得去学习的。</p><p>以前我在的公司搭建的SpringCloud微服务就没有使用Feign，架构师自己写了一个AOP代理类进行服务调用，超时时间5秒写死在代码里，当时有个微服务接口要上传文件，总是超时，又改不了超时时间，一超时就调熔断方法返回服务请求超时，导致非常痛苦。</p><p>如果当时使用Feign，插拔式，可配置的方式，也许就没那么麻烦了。</p><p>那么feign就讲到这里了，上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/example" target="_blank" rel="noopener">https://github.com/yehongzhi/example</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>OpenFeign</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3千字带你搞懂XXL-JOB任务调度平台</title>
    <link href="/2020/10/13/3%E5%8D%83%E5%AD%97%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82XXL-JOB%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0/"/>
    <url>/2020/10/13/3%E5%8D%83%E5%AD%97%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82XXL-JOB%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/xxljob_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在平时的业务场景中，经常有一些场景需要使用定时任务，比如：</p><ul><li>时间驱动的场景：某个时间点发送优惠券，发送短信等等。</li><li>批量处理数据：批量统计上个月的账单，统计上个月销售数据等等。</li><li>固定频率的场景：每隔5分钟需要执行一次。</li></ul><p>所以定时任务在平时开发中并不少见，而且对于现在快速消费的时代，每天都需要发送各种推送，消息都需要依赖定时任务去完成，应用非常广泛。</p><h1 id="二、为什么需要任务调度平台"><a href="#二、为什么需要任务调度平台" class="headerlink" title="二、为什么需要任务调度平台"></a>二、为什么需要任务调度平台</h1><p>在Java中，传统的定时任务实现方案，比如Timer，Quartz等都或多或少存在一些问题：</p><ul><li>不支持集群、不支持统计、没有管理平台、没有失败报警、没有监控等等</li></ul><p>而且在现在分布式的架构中，有一些场景需要分布式任务调度：</p><ul><li>同一个服务多个实例的任务存在互斥时，需要统一的调度。</li><li>任务调度需要支持高可用、监控、故障告警。</li><li>需要统一管理和追踪各个服务节点任务调度的结果，需要记录保存任务属性信息等。</li></ul><p>显然传统的定时任务已经不满足现在的分布式架构，所以需要一个分布式任务调度平台，目前比较主流的是elasticjob和xxl-job。</p><p>elasticjob由当当网开源，目前github有6.5k的Star，使用的公司在官网登记有76家。</p><p><img src="https://static.lovebilibili.com/xxljob_1.png" srcset="/img/loading.gif" alt=""></p><p>跟xxl-job不同的是，<strong>elasticjob是采用zookeeper实现分布式协调</strong>，实现任务高可用以及分片。</p><p><img src="https://static.lovebilibili.com/xxljob_3.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、为什么选择XXL-JOB"><a href="#三、为什么选择XXL-JOB" class="headerlink" title="三、为什么选择XXL-JOB"></a>三、为什么选择XXL-JOB</h1><p>实际上更多公司选择xxl-job，目前<strong>xxl-job的github上有15.7k个star，登记公司有348个</strong>。毫无疑问elasticjob和xxl-job都是非常优秀的技术框架，接下来我们进一步对比讨论，探索一下为什么更多公司会选择xxl-job。</p><p>首先先介绍一下xxl-job，这是出自大众点评许雪里(xxl就是作者名字的拼音首字母)的开源项目，官网上介绍这是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。跟elasticjob不同，xxl-job环境依赖于mysql，不用ZooKeeper，这也是最大的不同。</p><p>elasticjob的初衷是为了面对高并发复杂的业务，即使是在业务量大，服务器多的时候也能做好任务调度，尽可能的利用服务器的资源。使用ZooKeeper使其具有高可用、一致性的，而且还具有良好的扩展性。官网上写<strong>elasticjob是无中心化的，通过ZooKeeper的选举机制选举出主服务器，如果主服务器挂了，会重新选举新的主服务器。因此elasticjob具有良好的扩展性和可用性，但是使用和运维有一定的复杂</strong>。</p><p><img src="https://static.lovebilibili.com/xxljob_4.png" srcset="/img/loading.gif" alt=""></p><p>xxl-job则相反，是通过一个中心式的调度平台，调度多个执行器执行任务，调度中心通过DB锁保证集群分布式调度的一致性，这样扩展执行器会增大DB的压力，但是如果实际上这里数据库只是负责任务的调度执行。但是如果没有大量的执行器的话和任务的情况，是不会造成数据库压力的。实际上大部分公司任务数，执行器并不多(虽然面试经常会问一些高并发的问题)。</p><p>相对来说，xxl-job中心式的调度平台<strong>轻量级，开箱即用，操作简易，上手快，与SpringBoot有非常好的集成</strong>，而且监控界面就集成在调度中心，界面又简洁，对于<strong>企业维护起来成本不高，还有失败的邮件告警</strong>等等。这就使很多企业选择xxl-job做调度平台。</p><h1 id="四、安装"><a href="#四、安装" class="headerlink" title="四、安装"></a>四、安装</h1><h2 id="4-1-拉取源码"><a href="#4-1-拉取源码" class="headerlink" title="4.1 拉取源码"></a>4.1 拉取源码</h2><p>搭建xxl-job很简单，有docker拉取镜像部署和源码编译两种方式，docker部署的方式比较简单，我就讲源码编译的方式。首先到github拉取xxl-job源码到本地。</p><p><img src="https://static.lovebilibili.com/xxljob_5.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-导入IDEA"><a href="#4-2-导入IDEA" class="headerlink" title="4.2 导入IDEA"></a>4.2 导入IDEA</h2><p>拉取源码下来后，可以看到项目结构，如下：</p><p><img src="https://static.lovebilibili.com/xxljob_6.png" srcset="/img/loading.gif" alt=""></p><p>导入到IDEA，配置一下Maven，下载相关的jar包，稍等一下后，就可以看到这样的项目：</p><p><img src="https://static.lovebilibili.com/xxljob_7.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-3-初始化数据库"><a href="#4-3-初始化数据库" class="headerlink" title="4.3 初始化数据库"></a>4.3 初始化数据库</h2><p>前面讲过xxl-job需要依赖mysql，所以需要初始化数据库，在xxl-job\doc\db路径下找到tables_xxl_job.sql文件。在mysql上运行sql文件。</p><p><img src="https://static.lovebilibili.com/xxljob_8.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-4-配置文件"><a href="#4-4-配置文件" class="headerlink" title="4.4 配置文件"></a>4.4 配置文件</h2><p>接着就改一下配置文件，在admin项目下找到application.properties文件。</p><pre><code class="properties">### 调度中心JDBC链接spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=spring.datasource.driver-class-name=com.mysql.jdbc.Driver### 报警邮箱spring.mail.host=smtp.qq.comspring.mail.port=25spring.mail.username=xxx@qq.comspring.mail.password=xxxspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory### 调度中心通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 调度中心国际化配置 [必填]： 默认为 &quot;zh_CN&quot;/中文简体, 可选范围为 &quot;zh_CN&quot;/中文简体, &quot;zh_TC&quot;/中文繁体 and &quot;en&quot;/英文；xxl.job.i18n=zh_CN## 调度线程池最大线程配置【必填】xxl.job.triggerpool.fast.max=200xxl.job.triggerpool.slow.max=100### 调度中心日志表数据保存天数 [必填]：过期日志自动清理；限制大于等于7时生效，否则, 如-1，关闭自动清理功能；xxl.job.logretentiondays=10</code></pre><h2 id="4-5-编译运行"><a href="#4-5-编译运行" class="headerlink" title="4.5 编译运行"></a>4.5 编译运行</h2><p>简单一点直接跑admin项目的main方法启动也行。</p><p><img src="https://static.lovebilibili.com/xxljob_9.png" srcset="/img/loading.gif" alt=""></p><p>如果部署在服务器呢，那我们需要打包成jar包，在IDEA利用Maven插件打包。</p><p><img src="https://static.lovebilibili.com/xxljob_10.png" srcset="/img/loading.gif" alt=""></p><p>然后在xxl-job\xxl-job-admin\target路径下，找到jar包。</p><p><img src="https://static.lovebilibili.com/xxljob_11.png" srcset="/img/loading.gif" alt=""></p><p>然后就得到jar包了，使用java -jar命令就可以启动了。</p><p><img src="https://static.lovebilibili.com/xxljob_12.png" srcset="/img/loading.gif" alt=""></p><p>到这里就已经完成了！打开浏览器，输入<a href="http://localhost:8080/xxl-job-admin进入管理页面。默认账号/密码：admin/123456。" target="_blank" rel="noopener">http://localhost:8080/xxl-job-admin进入管理页面。默认账号/密码：admin/123456。</a></p><p><img src="https://static.lovebilibili.com/xxljob_13.png" srcset="/img/loading.gif" alt=""></p><h1 id="五、永远的HelloWord"><a href="#五、永远的HelloWord" class="headerlink" title="五、永远的HelloWord"></a>五、永远的HelloWord</h1><p>部署了调度中心之后，需要往调度中心注册执行器，添加调度任务。接下来就参考xxl-job写一个简单的例子。</p><p>首先创建一个SpringBoot项目，名字叫”xxljob-demo”，添加依赖。</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;&lt;!-- 官网的demo是2.2.1，中央maven仓库还没有，所以就用2.2.0 --&gt;        &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;        &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;        &lt;version&gt;2.2.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>接着修改application.properties。</p><pre><code class="properties"># web portserver.port=8081# log configlogging.config=classpath:logback.xmlspring.application.name=xxljob-demo### 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin### 执行器通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册xxl.job.executor.appname=xxl-job-demo### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。xxl.job.executor.address=### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；xxl.job.executor.ip=### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；xxl.job.executor.port=9999### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；xxl.job.executor.logretentiondays=10</code></pre><p>接着写一个配置类XxlJobConfig。</p><pre><code class="java">@Configurationpublic class XxlJobConfig {    private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);    @Value(&quot;${xxl.job.admin.addresses}&quot;)    private String adminAddresses;    @Value(&quot;${xxl.job.accessToken}&quot;)    private String accessToken;    @Value(&quot;${xxl.job.executor.appname}&quot;)    private String appname;    @Value(&quot;${xxl.job.executor.address}&quot;)    private String address;    @Value(&quot;${xxl.job.executor.ip}&quot;)    private String ip;    @Value(&quot;${xxl.job.executor.port}&quot;)    private int port;    @Value(&quot;${xxl.job.executor.logpath}&quot;)    private String logPath;    @Value(&quot;${xxl.job.executor.logretentiondays}&quot;)    private int logRetentionDays;    @Bean    public XxlJobSpringExecutor xxlJobExecutor() {        logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;);        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);        xxlJobSpringExecutor.setAppname(appname);        xxlJobSpringExecutor.setAddress(address);        xxlJobSpringExecutor.setIp(ip);        xxlJobSpringExecutor.setPort(port);        xxlJobSpringExecutor.setAccessToken(accessToken);        xxlJobSpringExecutor.setLogPath(logPath);        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);        return xxlJobSpringExecutor;    }}</code></pre><p>接着编写一个任务类XxlJobDemoHandler，使用Bean模式。</p><pre><code class="java">@Componentpublic class XxlJobDemoHandler {    /**     * Bean模式，一个方法为一个任务     * 1、在Spring Bean实例中，开发Job方法，方式格式要求为 &quot;public ReturnT&lt;String&gt; execute(String param)&quot;     * 2、为Job方法添加注解 &quot;@XxlJob(value=&quot;自定义jobhandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)&quot;，注解value值对应的是调度中心新建任务的JobHandler属性的值。     * 3、执行日志：需要通过 &quot;XxlJobLogger.log&quot; 打印执行日志；     */    @XxlJob(&quot;demoJobHandler&quot;)    public ReturnT&lt;String&gt; demoJobHandler(String param) throws Exception {        XxlJobLogger.log(&quot;java, Hello World~~~&quot;);        XxlJobLogger.log(&quot;param:&quot; + param);        return ReturnT.SUCCESS;    }}</code></pre><p>在resources目录下，添加logback.xml文件。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;false&quot; scan=&quot;true&quot; scanPeriod=&quot;1 seconds&quot;&gt;    &lt;contextName&gt;logback&lt;/contextName&gt;    &lt;property name=&quot;log.path&quot; value=&quot;/data/applogs/xxl-job/xxl-job-executor-sample-springboot.log&quot;/&gt;    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;file&gt;${log.path}&lt;/file&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;${log.path}.%d{yyyy-MM-dd}.zip&lt;/fileNamePattern&gt;        &lt;/rollingPolicy&gt;        &lt;encoder&gt;            &lt;pattern&gt;%date %level [%thread] %logger{36} [%file : %line] %msg%n            &lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=&quot;info&quot;&gt;        &lt;appender-ref ref=&quot;console&quot;/&gt;        &lt;appender-ref ref=&quot;file&quot;/&gt;    &lt;/root&gt;&lt;/configuration&gt;</code></pre><p>写完之后启动服务，然后可以打开管理界面，找到执行器管理，添加执行器。</p><p><img src="https://static.lovebilibili.com/xxljob_14.png" srcset="/img/loading.gif" alt=""></p><p>接着到任务管理，添加任务。</p><p><img src="https://static.lovebilibili.com/xxljob_15.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/xxljob_16.png" srcset="/img/loading.gif" alt=""></p><p>最后我们可以到任务管理去测试一下，运行demoJobHandler。</p><p><img src="https://static.lovebilibili.com/xxljob_17.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/xxljob_18.png" srcset="/img/loading.gif" alt=""></p><p>点击保存后，会立即执行。点击查看日志，可以看到任务执行的历史日志记录。</p><p><img src="https://static.lovebilibili.com/xxljob_19.png" srcset="/img/loading.gif" alt=""></p><p>打开刚刚执行的执行日志，我们可以看到，运行成功。</p><p><img src="https://static.lovebilibili.com/xxljob_20.png" srcset="/img/loading.gif" alt=""></p><p>这就是简单的Demo演示，非常简单，上手也快。</p><h1 id="六、谈谈架构设计"><a href="#六、谈谈架构设计" class="headerlink" title="六、谈谈架构设计"></a>六、谈谈架构设计</h1><p>下面简单地说一下xxl-job的架构，我们先看官网提供的一张架构图来分析。</p><p><img src="https://static.lovebilibili.com/xxljob_21.png" srcset="/img/loading.gif" alt=""></p><p>从架构图可以看出，分别有调度中心和执行器两大组成部分</p><ul><li>调度中心。负责<strong>管理调度信息</strong>，按照调度配置发出调度请求，自身不承担业务代码。支持可视化界面，可以在调度中心对任务进行新增，更新，删除，会实时生效。支持监控调度结果，查看执行日志，查看调度任务统计报表，任务失败告警等等。</li><li>执行器。负责接收调度请求，执行调度任务的业务逻辑。执行器启动后需要注册到调度中心。接收调度中心的发出的执行请求，终止请求，日志请求等等。</li></ul><p>接下来我们看一下xxl-job的工作原理。</p><p><img src="https://static.lovebilibili.com/xxljob_22.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>任务执行器根据配置的调度中心的地址，自动注册到调度中心。</p></li><li><p>达到任务触发条件，调度中心下发任务。</p></li><li><p>执行器基于线程池执行任务，并把执行结果放入内存队列中、把执行日志写入日志文件中。</p></li><li><p>执行器的回调线程消费内存队列中的执行结果，主动上报给调度中心。</p></li><li><p>当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情。</p></li></ul><h1 id="絮叨"><a href="#絮叨" class="headerlink" title="絮叨"></a>絮叨</h1><p>看完以上的内容，基本算入门了。实际上，xxl-job还有很多功能，要深入学习，还需要到<a href="https://www.xuxueli.com/" target="_blank" rel="noopener">官网</a>去研究探索。最好就是自己在本地搭建一个xxl-job来玩玩，动手实践是学得最快的学习方式。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>分布式</tag>
      
      <tag>任务调度平台</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务之注册中心</title>
    <link href="/2020/09/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <url>/2020/09/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/zczx_swdt.png" srcset="/img/loading.gif" alt=""></p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>伴随着Eurka2.0版本已停止维护，开始要考虑使用微服务新一代的开源的注册中心替代Eureka。</p><p><img src="https://static.lovebilibili.com/zczx_27.png" srcset="/img/loading.gif" alt=""></p><p>目前据我了解，Consul和Nacos是比较流行的两种替代方案。这篇文章就介绍一下这两种注册中心在微服务中的简单使用，希望对读者有所帮助。</p><a id="more"></a><h1 id="二、注册中心的作用"><a href="#二、注册中心的作用" class="headerlink" title="二、注册中心的作用"></a>二、注册中心的作用</h1><p>注册中心在微服务的架构中相当于一个“服务的通讯录”。当一个服务启动时，需要向注册中心注册服务，注册中心保存了所有服务的服务名称和服务地址的映射关系。当服务A想调用服务D时，则从注册中心获取服务D的服务地址，然后调用。</p><p>我画张图给大家描述会更清楚一点，大概如下：</p><p><img src="https://static.lovebilibili.com/zczx_1.png" srcset="/img/loading.gif" alt=""></p><p>可能会有人问，为什么不直接通过服务地址调用服务D呢，还要从注册中心去获取服务D的服务地址。因为一个服务背后是不止一台机器的，比如服务D可能在实际生产中是由三台机器支持的，对外只暴露一个服务名称，这样可以避免写死服务的IP地址在代码中(写在配置文件里)，在服务扩展时就非常方便了。</p><p>除了<strong>服务注册</strong>之外，注册中心还提供<strong>服务订阅</strong>，当有新的服务注册时，注册中心会实时推送到各个服务。</p><p>还有<strong>服务健康监测</strong>，可以在管理界面看到注册中心中的服务的状态。</p><h1 id="三、Consul"><a href="#三、Consul" class="headerlink" title="三、Consul"></a>三、Consul</h1><p>由Go语言开发，支持多数据中心分布式高可用的服务发布和服务注册，采用ralt算法保证服务的一致性，且支持健康检查。</p><h2 id="3-1-安装-win10版"><a href="#3-1-安装-win10版" class="headerlink" title="3.1 安装(win10版)"></a>3.1 安装(win10版)</h2><p>第一步，上官网下载安装包。</p><p><img src="https://static.lovebilibili.com/zczx_2.png" srcset="/img/loading.gif" alt=""></p><p>第二步，解压zip包，并配置环境变量。</p><p><img src="https://static.lovebilibili.com/zczx_3.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/zczx_4.png" srcset="/img/loading.gif" alt=""></p><p>第三步，唱跳rap篮球键ctrl+R，cmd，输入命令<code>consul</code>：</p><p><img src="https://static.lovebilibili.com/zczx_5.png" srcset="/img/loading.gif" alt=""></p><p>这就安装成功了，超简单！输入consul -version验证一下，会显示版本号：</p><p><img src="https://static.lovebilibili.com/zczx_7.png" srcset="/img/loading.gif" alt=""></p><p>第四步，启动。输入命令<code>consul.exe agent -dev</code>本地启动：</p><p><img src="https://static.lovebilibili.com/zczx_8.png" srcset="/img/loading.gif" alt=""></p><p>第五步，在浏览器中输入<code>http://localhost:8500</code>打开管理界面。</p><p><img src="https://static.lovebilibili.com/zczx_9.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-2-服务注册"><a href="#3-2-服务注册" class="headerlink" title="3.2 服务注册"></a>3.2 服务注册</h2><p>接下来就需要创建两个服务，分别是订单(order)和用户(user)，注册到consul。下面我就演示其中一个user服务。</p><p>首先创建一个SpringBoot工程，Maven配置如下：</p><pre><code class="xml">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;io.github.yehongzhi&lt;/groupId&gt;&lt;artifactId&gt;user&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;&lt;!-- 健康监测的包 --&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;&lt;!-- spring-cloud-consul服务治理的jar包 --&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Finchley.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre><p>然后yml配置文件如下：</p><pre><code class="yaml">server:  port: 8601spring:  application:    name: user  cloud:    consul:      port: 8500      host: 127.0.0.1      discovery:        service-name: user        instance-id: ${spring.application.name}:${spring.cloud.consul.host}:${server.port}        health-check-path: /actuator/health        health-check-interval: 10s        prefer-ip-address: true        heartbeat:          enabled: true</code></pre><p>在启动类加上开启服务注册的注解：</p><pre><code class="java">@SpringBootApplication@EnableDiscoveryClientpublic class UserApplication {    public static void main(String[] args) {        SpringApplication.run(UserApplication.class, args);    }}</code></pre><p>最后启动项目即可，我这里启动两个user，端口号分别是8601，8602：</p><p><img src="https://static.lovebilibili.com/zczx_10.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-3-服务调用"><a href="#3-3-服务调用" class="headerlink" title="3.3 服务调用"></a>3.3 服务调用</h2><p>再创建一个订单项目(order)，和user配置类似，注册服务到consul中。</p><p><img src="https://static.lovebilibili.com/zczx_11.png" srcset="/img/loading.gif" alt=""></p><p>下面演示一下用order服务调用user服务，首先定义user的接口：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/user&quot;)public class UserController {    @RequestMapping(&quot;/list&quot;)    public Map&lt;String, Object&gt; list() throws Exception {        Map&lt;String, Object&gt; userMap = new HashMap&lt;&gt;();        userMap.put(&quot;1号佳丽&quot;, &quot;李嘉欣&quot;);        userMap.put(&quot;2号佳丽&quot;, &quot;袁咏仪&quot;);        userMap.put(&quot;3号佳丽&quot;, &quot;张敏&quot;);        userMap.put(&quot;4号佳丽&quot;, &quot;张曼玉&quot;);        return userMap;    }}</code></pre><p>接着在order服务调用user服务，使用RestTemplate的方式：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/order&quot;)public class OrderController {    @Resource    private LoadBalancerClient loadBalancerClient;    @RequestMapping(&quot;/callUser&quot;)    public String list() throws Exception {        //从注册中心中获取user服务实例，包括服务的IP，端口号等信息        ServiceInstance instance = loadBalancerClient.choose(&quot;user&quot;);        //调用user服务        String userList = new RestTemplate().getForObject(instance.getUri().toString() + &quot;/mall/user/list&quot;, String.class);        return &quot;调用&quot; + instance.getServiceId() + &quot;服务，端口号：&quot; + instance.getPort() + &quot;,返回结果：&quot; + userList;    }}</code></pre><p>启动两个user服务，一个order服务，调用order的接口，可以看到结果：</p><p><img src="https://static.lovebilibili.com/zczx_12.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/zczx_13.png" srcset="/img/loading.gif" alt=""></p><p>负载均衡<strong>默认是轮询访问</strong>，所以交替调用8601和8602的user服务。</p><p>consul的简单入门就讲到这里了，除了<strong>服务治理</strong>之外，consul还可以用于做配置中心，读者有兴趣可以自己探索一下。<strong>我这里用的是dev模式，相当于单机模式，仅用于学习，实际生产的话肯定是集群模式</strong>，后面如果有时间我再专门写一篇演示一下consul集群的搭建。</p><p>下面讲另一款注册中心，阿里出品的Nacos。</p><h1 id="四、Nacos"><a href="#四、Nacos" class="headerlink" title="四、Nacos"></a>四、Nacos</h1><p>以下介绍来源于官网：</p><p>Nacos 致力于帮助您<strong>发现、配置和管理微服务</strong>。Nacos 提供了一组简单易用的特性集，帮助您快速实现<strong>动态服务发现、服务配置、服务元数据及流量管理</strong>。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><p>总结就是，Nacos提供三种功能：服务发现及管理、动态配置服务、动态DNS服务。</p><p>我这里主要讲服务发现，也就是作为<strong>注册中心</strong>的功能。</p><h2 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h2><p>首先<a href="https://github.com/alibaba/nacos/releases/tag/1.3.1" target="_blank" rel="noopener">下载</a>安装包，目前稳定版是1.3.1，推荐在Linux或者Mac系统上使用，我懒得开虚拟机，所以我就直接在win系统安装。</p><p><img src="https://static.lovebilibili.com/zczx_14.png" srcset="/img/loading.gif" alt=""></p><p>我这里仅用于学习，使用单机模式，官网上介绍，双击startup.cmd文件启动即可。</p><p><img src="https://static.lovebilibili.com/zczx_15.png" srcset="/img/loading.gif" alt=""></p><p>实际上，会报错。</p><p><img src="https://static.lovebilibili.com/zczx_17.png" srcset="/img/loading.gif" alt=""></p><p>这个错误，我发现github上有人提出来，再后面加个参数就可以了。</p><p><img src="https://static.lovebilibili.com/zczx_18.png" srcset="/img/loading.gif" alt=""></p><p>但是又有人说后面的版本已经优化了，没有这个错误。反正如果遇到的话，就加个参数启动吧。完整命令是<code>startup.cmd -m standalone</code>。</p><p>如果不想在启动命令后面加参数，可以配置mysql(版本要求：5.6.5+)，初始化mysql数据库，数据库初始化文件：nacos-mysql.sql。</p><p><img src="https://static.lovebilibili.com/zczx_26.png" srcset="/img/loading.gif" alt=""></p><p>修改conf/application.properties文件配置：</p><pre><code class="properties">db.num=1db.url.0=jdbc:mysql://数据库地址:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTCdb.user=账号db.password=密码</code></pre><p>启动成功，命令行窗口可以看到以下提示：</p><p><img src="https://static.lovebilibili.com/zczx_19.png" srcset="/img/loading.gif" alt=""></p><p>启动成功后，可以在浏览器打开<code>http://localhost:8848/nacos/</code>，进入管理界面。账号密码默认都是nacos。</p><p><img src="https://static.lovebilibili.com/zczx_20.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/zczx_21.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-服务注册"><a href="#4-2-服务注册" class="headerlink" title="4.2 服务注册"></a>4.2 服务注册</h2><p>接下来还是一样，创建两个服务注册到nacos，为了跟前面的区分，项目名后缀加上”nacos”。首先添加maven配置，如下：</p><pre><code class="java">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Finchley.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;            &lt;version&gt;0.2.2.RELEASE&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt;    &lt;dependency&gt;&lt;!-- SpringWeb依赖 --&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;&lt;!-- SpringCloud nacos服务发现的依赖 --&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>启动类加上注解@EnableDiscoveryClient。</p><pre><code class="java">@SpringBootApplication@EnableDiscoveryClientpublic class UsernacosApplication {    public static void main(String[] args) {        SpringApplication.run(UsernacosApplication.class, args);    }}</code></pre><p>配置文件application.properties文件加上配置。</p><pre><code class="properties">server.port=8070spring.application.name=usernacosspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848</code></pre><p>创建一个UserController接口，提供给其他微服务调用。</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/userNacos&quot;)public class UserController {    @RequestMapping(&quot;/list&quot;)    public Map&lt;String, Object&gt; list() {        Map&lt;String, Object&gt; userMap = new HashMap&lt;&gt;();        userMap.put(&quot;周杰伦&quot;, &quot;爱在西元前&quot;);        userMap.put(&quot;张学友&quot;, &quot;只想一生跟你走&quot;);        userMap.put(&quot;刘德华&quot;, &quot;忘情水&quot;);        userMap.put(&quot;陈奕迅&quot;, &quot;K歌之王&quot;);        userMap.put(&quot;卫兰&quot;, &quot;就算世界没有童话&quot;);        return userMap;    }}</code></pre><p>运行启动类的main方法，可以看到注册中心多了一个usernacos服务。</p><p><img src="https://static.lovebilibili.com/zczx_22.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-3-服务调用"><a href="#4-3-服务调用" class="headerlink" title="4.3 服务调用"></a>4.3 服务调用</h2><p>相同的配置和方法，再创建一个ordernacos服务，作为消费者。</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/orderNacos&quot;)public class OrderController {    @Resource    private LoadBalancerClient loadBalancerClient;    @RequestMapping(&quot;/callUser&quot;)    public String callUser() {        ServiceInstance instance = loadBalancerClient.choose(&quot;usernacos&quot;);        String url = instance.getUri().toString() + &quot;/mall/userNacos/list&quot;;        RestTemplate restTemplate = new RestTemplate();        //调用usernacos服务        String result = restTemplate.getForObject(url, String.class);        return &quot;调用&quot; + instance.getServiceId() + &quot;服务，端口号：&quot; + instance.getPort() + &quot;,返回结果：&quot; + result;    }}</code></pre><p>启动2个usernacos服务，1个ordernacos服务。</p><p><img src="https://static.lovebilibili.com/zczx_23.png" srcset="/img/loading.gif" alt=""></p><p>测试接口<code>http://localhost:8170/mall/orderNacos/callUser</code>，order能顺利调用user，默认负载均衡策略也是轮询机制。</p><p><img src="https://static.lovebilibili.com/zczx_24.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/zczx_25.png" srcset="/img/loading.gif" alt=""></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>国内用的比较多的是Nacos，我觉得原因有几点：</p><ul><li>因为阿里目前用的就是Nacos，经历过双十一，各种秒杀活动等高并发场景的验证。</li><li>文档比较齐全，关键有中文文档，对于国内很多英文水平不是很好的开发者看起来真的很爽。</li><li>很多从阿里出来的程序员，把阿里的技术带到了各个中小型互联网公司，一般技术选型肯定选自己熟悉的嘛。</li><li>管理界面有中(英)文版本，易于操作。</li><li>还有社区比较活跃，很多问题可以在网上找到解决方案。</li></ul><p>这篇文章主要介绍了SpringCloud微服务关于注册中心的两种流行的实现方案，接下来还会继续介绍其他关于微服务的组件，敬请期待。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>微服务</tag>
      
      <tag>注册中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官问我什么是JMM</title>
    <link href="/2020/09/20/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91%E4%BB%80%E4%B9%88%E6%98%AFJMM/"/>
    <url>/2020/09/20/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91%E4%BB%80%E4%B9%88%E6%98%AFJMM/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/JMM_9.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="面试官：讲讲什么是JMM"><a href="#面试官：讲讲什么是JMM" class="headerlink" title="面试官：讲讲什么是JMM"></a>面试官：讲讲什么是JMM</h1><p>你要是整这个我可就不困了。</p><p><img src="https://static.lovebilibili.com/nishuozhegejiubukunle.jpg" srcset="/img/loading.gif" alt=""></p><p>JMM就是Java内存模型(java memory model)。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以<strong>java内存模型(JMM)屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。</strong></p><p>Java内存模型规定<strong>所有的变量都存储在主内存</strong>中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，<strong>线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行</strong>。<strong>线程不能直接读写主内存中的变量</strong>。</p><p>不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。</p><p>如果听起来抽象的话，我可以画张图给你看看，会直观一点：</p><p><img src="https://static.lovebilibili.com/JMM_1.png" srcset="/img/loading.gif" alt=""></p><p>每个线程的工作内存都是独立的，线程操作数据只能在工作内存中进行，然后刷回到主存。这是 Java 内存模型定义的线程基本工作方式。</p><p>温馨提醒一下，这里有些人会把Java内存模型误解为<strong>Java内存结构</strong>，然后答到堆，栈，GC垃圾回收，最后和面试官想问的问题相差甚远。<strong>实际上一般问到Java内存模型都是想问多线程，Java并发相关的问题</strong>。</p><h1 id="面试官：那JMM定义了什么"><a href="#面试官：那JMM定义了什么" class="headerlink" title="面试官：那JMM定义了什么"></a>面试官：那JMM定义了什么</h1><p>这个简单，整个Java内存模型实际上是围绕着三个特征建立起来的。分别是：原子性，可见性，有序性。这三个特征可谓是整个Java并发的基础。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性指的是一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰。</p><p><strong>面试官拿笔写了段代码，下面这几句代码能保证原子性吗</strong>？</p><pre><code class="java">int i = 2;int j = i;i++;i = i + 1;</code></pre><p>第一句是基本类型赋值操作，必定是原子性操作。</p><p>第二句先读取i的值，再赋值到j，两步操作，不能保证原子性。</p><p>第三和第四句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</p><p>JMM只能保证基本的原子性，如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改了。Java是利用volatile关键字来提供可见性的。 当变量被volatile修饰时，这个变量被修改后会立刻刷新到主内存，当其它线程需要读取该变量时，会去主内存中读取新值。而普通变量则不能保证这一点。</p><p>除了volatile关键字之外，final和synchronized也能实现可见性。</p><p>synchronized的原理是，在执行完，进入unlock之前，必须将共享变量同步到主内存中。</p><p>final修饰的字段，一旦初始化完成，如果没有对象逸出（指对象为初始化完成就可以被别的线程使用），那么对于其他线程都是可见的。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>在Java中，可以使用synchronized或者volatile保证多线程之间操作的有序性。实现原理有些区别：</p><p>volatile关键字是使用内存屏障达到禁止指令重排序，以保证有序性。</p><p>synchronized的原理是，一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized包住的代码块在多线程之间是串行执行的。</p><h1 id="面试官：给我讲一下八种内存交互操作吧"><a href="#面试官：给我讲一下八种内存交互操作吧" class="headerlink" title="面试官：给我讲一下八种内存交互操作吧"></a>面试官：给我讲一下八种内存交互操作吧</h1><p>好的，面试官，内存交互操作有8种，我画张图给你看吧：</p><p><img src="https://static.lovebilibili.com/JMM_2.png" srcset="/img/loading.gif" alt=""></p><ul><li>lock(锁定)，作用于<strong>主内存</strong>中的变量，把变量标识为线程独占的状态。</li><li>read(读取)，作用于<strong>主内存</strong>的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li><li>load(加载)，作用于<strong>工作内存</strong>的变量，把read操作主存的变量放入到工作内存的变量副本中。</li><li>use(使用)，作用于<strong>工作内存</strong>的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)，作用于<strong>工作内存</strong>的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li><li>store(存储)，作用于<strong>工作内存</strong>的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li><li>write(写入)：作用于<strong>主内存</strong>中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ul><p>我再补充一下JMM对8种内存交互操作制定的规则吧：</p><ul><li>不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。</li><li>不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。</li><li>不允许线程将没有assign的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。</li><li>一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。</li></ul><h1 id="面试官：讲一下volatile关键字吧"><a href="#面试官：讲一下volatile关键字吧" class="headerlink" title="面试官：讲一下volatile关键字吧"></a>面试官：讲一下volatile关键字吧</h1><p>内心：这可以重头戏呀，可不能出岔子~</p><p>很多并发编程都使用了volatile关键字，主要的作用包括两点：</p><ol><li><strong>保证线程间变量的可见性。</strong></li><li><strong>禁止CPU进行指令重排序。</strong></li></ol><h2 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h2><p>volatile修饰的变量，当一个线程改变了该变量的值，其他线程是立即可见的。普通变量则需要重新读取才能获得最新值。</p><p>volatile保证可见性的流程大概就是这个一个过程：</p><p><img src="https://static.lovebilibili.com/JMM_3.png" srcset="/img/loading.gif" alt=""></p><h2 id="volatile一定能保证线程安全吗"><a href="#volatile一定能保证线程安全吗" class="headerlink" title="volatile一定能保证线程安全吗"></a>volatile一定能保证线程安全吗</h2><p>先说结论吧，volatile不能一定能保证线程安全。</p><p>怎么证明呢，我们看下面一段代码的运行结果就知道了：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 **/public class VolatileTest extends Thread {    private static volatile int count = 0;    public static void main(String[] args) throws Exception {        Vector&lt;Thread&gt; threads = new Vector&lt;&gt;();        for (int i = 0; i &lt; 100; i++) {            VolatileTest thread = new VolatileTest();            threads.add(thread);            thread.start();        }        //等待子线程全部完成        for (Thread thread : threads) {            thread.join();        }        //输出结果，正确结果应该是1000，实际却是984        System.out.println(count);//984    }    @Override    public void run() {        for (int i = 0; i &lt; 10; i++) {            try {                //休眠500毫秒                Thread.sleep(500);            } catch (Exception e) {                e.printStackTrace();            }            count++;        }    }}</code></pre><p>为什么volatile不能保证线程安全？</p><p>很简单呀，可见性不能保证操作的原子性，前面说过了count++不是原子性操作，会当做三步，先读取count的值，然后+1，最后赋值回去count变量。需要保证线程安全的话，需要使用synchronized关键字或者lock锁，给count++这段代码上锁：</p><pre><code class="java">private static synchronized void add() {    count++;}</code></pre><h2 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h2><p>首先要讲一下as-if-serial语义，不管怎么重排序，（单线程）程序的执行结果不能被改变。</p><p>为了使指令更加符合CPU的执行特性，最大限度的发挥机器的性能，提高程序的执行效率，只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做<strong>指令的重排序</strong>。</p><p>重排序的种类分为三种，分别是：编译器重排序，指令级并行的重排序，内存系统重排序。整个过程如下所示：</p><p><img src="https://static.lovebilibili.com/JMM_5.png" srcset="/img/loading.gif" alt=""></p><p>指令重排序在单线程是没有问题的，不会影响执行结果，而且还提高了性能。但是在多线程的环境下就不能保证一定不会影响执行结果了。</p><p><strong>所以在多线程环境下，就需要禁止指令重排序</strong>。</p><p>volatile关键字禁止指令重排序有两层意思：</p><ul><li><p>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行。</p></li><li><p>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p></li></ul><p>下面举个例子：</p><pre><code class="java">private static int a;//非volatile修饰变量private static int b;//非volatile修饰变量private static volatile int k;//volatile修饰变量private void hello() {    a = 1;  //语句1    b = 2;  //语句2    k = 3;  //语句3    a = 4;  //语句4    b = 5;  //语句5    //以下省略...}</code></pre><p>变量a，b是非volatile修饰的变量，k则使用volatile修饰。所以语句3不能放在语句1、2前，也不能放在语句4、5后。但是语句1、2的顺序是不能保证的，同理，语句4、5也不能保证顺序。</p><p>并且，执行到语句3的时候，语句1，2是肯定执行完毕的，而且语句1,2的执行结果对于语句3,4,5是可见的。</p><h2 id="volatile禁止指令重排序的原理是什么"><a href="#volatile禁止指令重排序的原理是什么" class="headerlink" title="volatile禁止指令重排序的原理是什么"></a>volatile禁止指令重排序的原理是什么</h2><p>首先要讲一下内存屏障，内存屏障可以分为以下几类：</p><ul><li><p>LoadLoad  屏障：对于这样的语句Load1，LoadLoad，Load2。在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p></li><li><p>StoreStore屏障：对于这样的语句Store1， StoreStore， Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p></li><li><p>LoadStore 屏障：对于这样的语句Load1， LoadStore，Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p></li><li><p>StoreLoad 屏障：对于这样的语句Store1， StoreLoad，Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</p></li></ul><p>在每个volatile读操作后插入LoadLoad屏障，在读操作后插入LoadStore屏障。</p><p><img src="https://static.lovebilibili.com/JMM_6.png" srcset="/img/loading.gif" alt=""></p><p>在每个volatile写操作的前面插入一个StoreStore屏障，后面插入一个SotreLoad屏障。</p><p><img src="https://static.lovebilibili.com/JMM_8.png" srcset="/img/loading.gif" alt=""></p><p>大概的原理就是这样。</p><p>面试官：讲得还不错，基本上都讲到了，时间也不早了，今天的面试就到这吧，回去等通知吧~</p><p>啊？就这？</p><img src="https://static.lovebilibili.com/jiuzhe.jpg" srcset="/img/loading.gif" style="zoom:25%;" /><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要学习并发编程，java内存模型是第一站了。原子性，有序性，可见性这三大特征几乎贯穿了并发编程，可谓是基础知识。对于后面要深入学习起到铺垫作用。</p><p>在这篇文章中，如果面试的话，重点是Java内存模型(JMM)的工作方式，三大特征，还有volatile关键字。为什么喜欢问volatile关键字呢，因为<strong>volatile关键字可以扯出很多东西，比如可见性，有序性，还有内存屏障等等</strong>。可以一针见血地看出面试者的技术水平，毕竟面试官也想高效地筛选出符合要求的人才嘛。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八种经典排序算法总结</title>
    <link href="/2020/09/11/%E5%85%AB%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/11/%E5%85%AB%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/sort_swdt.png" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算法和数据结构是一个程序员的内功，所以经常在一些笔试中都会要求手写一些简单的排序算法，以此考验面试者的编程水平。下面我就简单介绍八种常见的排序算法，一起学习一下。</p><a id="more"></a><h1 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h1><p>思路：</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素就是最大的数；</li><li>排除最大的数，接着下一轮继续相同的操作，确定第二大的数…</li><li>重复步骤1-3，直到排序完成。</li></ul><p>动画演示：</p><p><img src="https://static.lovebilibili.com/BubbleSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name BubbleSort * @date 2020-09-05 21:38 **/public class BubbleSort extends BaseSort {    public static void main(String[] args) {        BubbleSort sort = new BubbleSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        for (int i = 0; i &lt; nums.length - 1; i++) {            for (int j = 0; j &lt; nums.length - i - 1; j++) {                if (nums[j] &gt; nums[j + 1]) {                    int temp = nums[j];                    nums[j] = nums[j + 1];                    nums[j + 1] = temp;                }            }        }    }}//10万个数的数组，耗时：21554毫秒</code></pre><p>平均时间复杂度：<strong>O(n²)</strong></p><p>空间复杂度：<strong>O(1)</strong></p><p>算法稳定性：稳定</p><h1 id="二、插入排序"><a href="#二、插入排序" class="headerlink" title="二、插入排序"></a>二、插入排序</h1><p>思路：</p><ol><li><p>从第一个元素开始，该元素可以认为已经被排序；</p></li><li><p>取出下一个元素，在前面已排序的元素序列中，从后向前扫描；</p></li><li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置；</p></li><li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p></li><li><p>将新元素插入到该位置后；</p></li><li><p>重复步骤2~5。</p></li></ol><p>动画演示：</p><p><img src="https://static.lovebilibili.com/InsertionSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name InsertSort * @date 2020-09-05 22:34 **/public class InsertSort extends BaseSort {    public static void main(String[] args) {        BaseSort sort = new InsertSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        for (int i = 0; i &lt; nums.length - 1; i++) {            //当前值            int curr = nums[i + 1];            //上一个数的指针            int preIndex = i;            //在数组中找到一个比当前遍历的数小的第一个数            while (preIndex &gt;= 0 &amp;&amp; curr &lt; nums[preIndex]) {                //把比当前遍历的数大的数字往后移动                nums[preIndex + 1] = nums[preIndex];                //需要插入的数的下标往前移动                preIndex--;            }            //插入到这个数的后面            nums[preIndex + 1] = curr;        }    }}//10万个数的数组，耗时：2051毫秒</code></pre><p>平均时间复杂度：<strong>O(n²)</strong></p><p>空间复杂度：<strong>O(1)</strong></p><p>算法稳定性：稳定</p><h1 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h1><p>思路：</p><p>第一轮，找到最小的元素，和数组第一个数交换位置。</p><p>第二轮，找到第二小的元素，和数组第二个数交换位置…</p><p>直到最后一个元素，排序完成。</p><p>动画演示：</p><p><img src="https://static.lovebilibili.com/SelectionSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name SelectSort * @date 2020-09-06 22:27 **/public class SelectSort extends BaseSort {    public static void main(String[] args) {        SelectSort sort = new SelectSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        for (int i = 0; i &lt; nums.length; i++) {            int minIndex = i;            for (int j = i + 1; j &lt; nums.length; j++) {                if (nums[j] &lt; nums[minIndex]) {                    minIndex = j;                }            }            if (minIndex != i) {                int temp = nums[i];                nums[minIndex] = temp;                nums[i] = nums[minIndex];            }        }    }}//10万个数的数组，耗时：8492毫秒</code></pre><p>算法复杂度：<strong>O(n²)</strong><br>算法空间复杂度：<strong>O(1)</strong><br>算法稳定性：不稳定</p><h1 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h1><p>思路：</p><p>把数组分割成若干(h)个小组(一般数组长度length/2)，然后对每一个小组分别进行插入排序。每一轮分割的数组的个数逐步缩小，h/2-&gt;h/4-&gt;h/8，并且进行排序，保证有序。当h=1时，则数组排序完成。</p><p>动画演示：</p><p><img src="https://static.lovebilibili.com/ShellSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name SelectSort * @date 2020-09-06 22:27 **/public class ShellSort extends BaseSort {    public static void main(String[] args) {        ShellSort sort = new ShellSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        int length = nums.length;        int temp;        //步长        int gap = length / 2;        while (gap &gt; 0) {            for (int i = gap; i &lt; length; i++) {                temp = nums[i];                int preIndex = i - gap;                while (preIndex &gt;= 0 &amp;&amp; nums[preIndex] &gt; temp) {                    nums[preIndex + gap] = nums[preIndex];                    preIndex -= gap;                }                nums[preIndex + gap] = temp;            }            gap /= 2;        }    }}//10万个数的数组，耗时：261毫秒</code></pre><p>算法复杂度：<strong>O(nlog2n)</strong><br>算法空间复杂度：<strong>O(1)</strong><br>算法稳定性：稳定</p><h1 id="五、快速排序"><a href="#五、快速排序" class="headerlink" title="五、快速排序"></a>五、快速排序</h1><p>快排，面试最喜欢问的排序算法。这是运用分治法的一种排序算法。</p><p>思路：</p><ol><li>从数组中选一个数做为基准值，一般选第一个数，或者最后一个数。</li><li>采用双指针(头尾两端)遍历，从左往右找到比基准值大的第一个数，从右往左找到比基准值小的第一个数，交换两数位置，直到头尾指针相等或头指针大于尾指针，把基准值与头指针的数交换。这样一轮之后，左边的数就比基准值小，右边的数就比基准值大。</li><li>对左边的数列，重复上面1，2步骤。对右边重复1，2步骤。</li><li>左右两边数列递归结束后，排序完成。</li></ol><p>动画演示：</p><p><img src="https://static.lovebilibili.com/QuickSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name SelectSort * @date 2020-09-06 22:27 **/public class QuickSort extends BaseSort {    public static void main(String[] args) {        QuickSort sort = new QuickSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        quickSort(nums, 0, nums.length - 1);    }    private void quickSort(int[] nums, int star, int end) {        if (star &gt; end) {            return;        }        int i = star;        int j = end;        int key = nums[star];        while (i &lt; j) {            while (i &lt; j &amp;&amp; nums[j] &gt; key) {                j--;            }            while (i &lt; j &amp;&amp; nums[i] &lt;= key) {                i++;            }            if (i &lt; j) {                int temp = nums[i];                nums[i] = nums[j];                nums[j] = temp;            }        }        nums[star] = nums[i];        nums[i] = key;        quickSort(nums, star, i - 1);        quickSort(nums, i + 1, end);    }}//10万个数的数组，耗时：50毫秒</code></pre><p>算法复杂度：<strong>O(nlogn)</strong><br>算法空间复杂度：<strong>O(1)</strong><br>算法稳定性：不稳定</p><h1 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h1><p>归并排序是采用分治法的典型应用，而且是一种稳定的排序方式，不过需要使用到额外的空间。</p><p>思路：</p><ol><li>把数组不断划分成子序列，划成长度只有2或者1的子序列。</li><li>然后利用临时数组，对子序列进行排序，合并，再把临时数组的值复制回原数组。</li><li>反复操作1~2步骤，直到排序完成。</li></ol><p>归并排序的优点在于最好情况和最坏的情况的时间复杂度都是O(nlogn)，所以是比较稳定的排序方式。</p><p>动画演示：</p><p><img src="https://static.lovebilibili.com/MergeSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name MergeSort * @date 2020-09-08 23:30 **/public class MergeSort extends BaseSort {    public static void main(String[] args) {        MergeSort sort = new MergeSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        //归并排序        mergeSort(0, nums.length - 1, nums, new int[nums.length]);    }    private void mergeSort(int star, int end, int[] nums, int[] temp) {        //递归终止条件        if (star &gt;= end) {            return;        }        int mid = star + (end - star) / 2;        //左边进行归并排序        mergeSort(star, mid, nums, temp);        //右边进行归并排序        mergeSort(mid + 1, end, nums, temp);        //合并左右        merge(star, end, mid, nums, temp);    }    private void merge(int star, int end, int mid, int[] nums, int[] temp) {        int index = 0;        int i = star;        int j = mid + 1;        while (i &lt;= mid &amp;&amp; j &lt;= end) {            if (nums[i] &gt; nums[j]) {                temp[index++] = nums[j++];            } else {                temp[index++] = nums[i++];            }        }        while (i &lt;= mid) {            temp[index++] = nums[i++];        }        while (j &lt;= end) {            temp[index++] = nums[j++];        }        //把临时数组中已排序的数复制到nums数组中        if (index &gt;= 0) System.arraycopy(temp, 0, nums, star, index);    }}//10万个数的数组，耗时：26毫秒</code></pre><p>算法复杂度：<strong>O(nlogn)</strong><br>算法空间复杂度：<strong>O(n)</strong><br>算法稳定性：稳定</p><h1 id="七、堆排序"><a href="#七、堆排序" class="headerlink" title="七、堆排序"></a>七、堆排序</h1><p>大顶堆概念：每个节点的值都大于或者等于它的左右子节点的值，所以顶点的数就是最大值。</p><p><img src="https://static.lovebilibili.com/heap_big.png" srcset="/img/loading.gif" alt=""></p><p>思路：</p><ol><li>对原数组构建成大顶堆。</li><li>交换头尾值，尾指针索引减一，固定最大值。</li><li>重新构建大顶堆。</li><li>重复步骤2~3，直到最后一个元素，排序完成。</li></ol><p>构建大顶堆的思路，可以看代码注释。</p><p>动画演示：</p><p><img src="https://static.lovebilibili.com/HeapSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name HeapSort * @date 2020-09-08 23:34 **/public class HeapSort extends BaseSort {    public static void main(String[] args) {        HeapSort sort = new HeapSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        heapSort(nums);    }    private void heapSort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        //构建大根堆        createTopHeap(nums);        int size = nums.length;        while (size &gt; 1) {            //大根堆的交换头尾值，固定最大值在末尾            swap(nums, 0, size - 1);            //末尾的索引值往左减1            size--;            //重新构建大根堆            updateHeap(nums, size);        }    }    private void createTopHeap(int[] nums) {        for (int i = 0; i &lt; nums.length; i++) {            //当前插入的索引            int currIndex = i;            //父节点的索引            int parentIndex = (currIndex - 1) / 2;            //如果当前遍历的值比父节点大的话，就交换值。然后继续往上层比较            while (nums[currIndex] &gt; nums[parentIndex]) {                //交换当前遍历的值与父节点的值                swap(nums, currIndex, parentIndex);                //把父节点的索引指向当前遍历的索引                currIndex = parentIndex;                //往上计算父节点索引                parentIndex = (currIndex - 1) / 2;            }        }    }    private void updateHeap(int[] nums, int size) {        int index = 0;        //左节点索引        int left = 2 * index + 1;        //右节点索引        int right = 2 * index + 2;        while (left &lt; size) {            //最大值的索引            int largestIndex;            //如果右节点大于左节点，则最大值索引指向右子节点索引            if (right &lt; size &amp;&amp; nums[left] &lt; nums[right]) {                largestIndex = right;            } else {                largestIndex = left;            }            //如果父节点大于最大值，则把父节点索引指向最大值索引            if (nums[index] &gt; nums[largestIndex]) {                largestIndex = index;            }            //如果父节点索引指向最大值索引，证明已经是大根堆，退出循环            if (largestIndex == index) {                break;            }            //如果不是大根堆，则交换父节点的值            swap(nums, largestIndex, index);            //把最大值的索引变成父节点索引            index = largestIndex;            //重新计算左节点索引            left = 2 * index + 1;            //重新计算右节点索引            right = 2 * index + 2;        }    }    private void swap(int[] nums, int i, int j) {        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    }}//10万个数的数组，耗时：38毫秒</code></pre><p>算法复杂度：<strong>O(nlogn)</strong><br>算法空间复杂度：<strong>O(1)</strong><br>算法稳定性：不稳定</p><h1 id="八、桶排序"><a href="#八、桶排序" class="headerlink" title="八、桶排序"></a>八、桶排序</h1><p>思路：</p><ol><li>找出最大值，最小值。</li><li>根据数组的长度，创建出若干个桶。</li><li>遍历数组的元素，根据元素的值放入到对应的桶中。</li><li>对每个桶的元素进行排序(可使用快排，插入排序等)。</li><li>按顺序合并每个桶的元素，排序完成。</li></ol><p>对于数组中的元素分布均匀的情况，排序效率较高。相反的，如果分布不均匀，则会导致大部分的数落入到同一个桶中，使效率降低。</p><p>动画演示(来源于五分钟学算法，侵删)：</p><p><img src="https://static.lovebilibili.com/BucketSort.gif" srcset="/img/loading.gif" alt=""></p><p>实现代码：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name BucketSort * @date 2020-09-08 23:37 **/public class BucketSort extends BaseSort {    public static void main(String[] args) {        BucketSort sort = new BucketSort();        sort.printNums();    }    @Override    protected void sort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        bucketSort(nums);    }    public void bucketSort(int[] nums) {        if (nums == null || nums.length &lt; 2) {            return;        }        //找出最大值，最小值        int max = Integer.MIN_VALUE;        int min = Integer.MAX_VALUE;        for (int num : nums) {            min = Math.min(min, num);            max = Math.max(max, num);        }        int length = nums.length;        //桶的数量        int bucketCount = (max - min) / length + 1;        int[][] bucketArrays = new int[bucketCount][];        //遍历数组，放入桶内        for (int i = 0; i &lt; length; i++) {            //找到桶的下标            int index = (nums[i] - min) / length;            //添加到指定下标的桶里，并且使用插入排序排序            bucketArrays[index] = insertSortArrays(bucketArrays[index], nums[i]);        }        int k = 0;        //合并全部桶的        for (int[] bucketArray : bucketArrays) {            if (bucketArray == null || bucketArray.length == 0) {                continue;            }            for (int i : bucketArray) {                //把值放回到nums数组中                nums[k++] = i;            }        }    }    //每个桶使用插入排序进行排序    private int[] insertSortArrays(int[] arr, int num) {        if (arr == null || arr.length == 0) {            return new int[]{num};        }        //创建一个temp数组，长度是arr数组的长度+1        int[] temp = new int[arr.length + 1];        //把传进来的arr数组，复制到temp数组        for (int i = 0; i &lt; arr.length; i++) {            temp[i] = arr[i];        }        //找到一个位置，插入，形成新的有序的数组        int i;        for (i = temp.length - 2; i &gt;= 0 &amp;&amp; temp[i] &gt; num; i--) {            temp[i + 1] = temp[i];        }        //插入需要添加的值        temp[i + 1] = num;        //返回        return temp;    }}//10万个数的数组，耗时：8750毫秒</code></pre><p>算法复杂度：<strong>O(M+N)</strong></p><p>算法空间复杂度：<strong>O(M+N)</strong></p><p>算法稳定性：稳定(取决于桶内的排序算法，这里使用的是插入排序所以是稳定的)。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://static.lovebilibili.com/sort_zongjie.png" srcset="/img/loading.gif" alt=""></p><p>动画演示来源于算法学习网站：<a href="https://visualgo.net" target="_blank" rel="noopener">https://visualgo.net</a></p><p>讲完这些排序算法后，可能有人会问学这些排序算法有什么用呢，难道就为了应付笔试面试？平时开发也没用得上这些。</p><p>我觉得我们应该换个角度来看，比如高中时我们学物理，化学，数学，那么多公式定理，现在也没怎么用得上，但是高中课本为什么要教这些呢？</p><p>我的理解是：第一，普及一些常识性的问题。第二，锻炼思维，提高解决问题的能力。第三，为了区分人才。</p><p>回到学排序算法有什么用的问题上，实际上也一样。这些最基本的排序算法就是一些常识性的问题，作为开发者应该了解掌握。同时也锻炼了编程思维，其中包含有双指针，分治，递归等等的思想。最后在面试中体现出来的就是人才的划分，懂得这些基本的排序算法当然要比不懂的人要更有竞争力。</p><p>建议大家看完之后，能找时间动手写一下，加深理解。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从JVM讲到类加载机制，很简单的</title>
    <link href="/2020/09/04/%E4%BB%8EJVM%E8%AE%B2%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%BE%88%E7%AE%80%E5%8D%95%E7%9A%84/"/>
    <url>/2020/09/04/%E4%BB%8EJVM%E8%AE%B2%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%BE%88%E7%AE%80%E5%8D%95%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/jvm_siweidaotu.png" srcset="/img/loading.gif" alt=""></p><blockquote><p><strong>文章已收录到Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="一、JVM介绍"><a href="#一、JVM介绍" class="headerlink" title="一、JVM介绍"></a>一、JVM介绍</h1><p>在介绍JVM之前，先看一下.java文件从编码到执行的过程：</p><p><img src="https://static.lovebilibili.com/jvm_02.png" srcset="/img/loading.gif" alt=""></p><p>整个过程是，x.java文件需要编译成x.class文件，通过类加载器加载到内存中，然后通过解释器或者即时编译器进行解释和编译，最后交给执行引擎执行，执行引擎操作OS硬件。</p><p>从<strong>类加载器到执行引擎这块内容就是JVM</strong>。</p><a id="more"></a><p><strong>JVM是一个跨语言的平台</strong>。从上面的图中可以看到，实际上JVM上运行的不是.java文件，而是.class文件。这就引出一个观点，JVM是一个跨语言的平台，他不仅仅能跑java程序，只要这种编程语言能编译成JVM可识别的.class文件都可以在上面运行。</p><p>所以除了java以外，能在JVM上运行的语言有很多，比如JRuby、Groovy、Scala、Kotlin等等。</p><p>从本质上讲JVM就是一台通过软件虚拟的计算机，它有它自身的指令集，有它自身的操作系统。</p><p>所以Oracle给JVM定了一套JVM规范，Oracle公司也给出了他的实现。基本上是目前最多人使用的java虚拟机实现，叫做Hotspot。使用java -version可以查看：</p><p><img src="https://static.lovebilibili.com/jvm_03.png" srcset="/img/loading.gif" alt=""></p><p>一些体量较大，有一定规模的公司，也会开发自己的JVM虚拟机，比如淘宝的TaobaoVM、IBM公司的J9-IBM、微软的MicrosoftVM等等。</p><h1 id="二、JDK、JRE、JVM"><a href="#二、JDK、JRE、JVM" class="headerlink" title="二、JDK、JRE、JVM"></a>二、JDK、JRE、JVM</h1><p><img src="https://static.lovebilibili.com/jvm_04.png" srcset="/img/loading.gif" alt=""></p><p>JVM应该很清楚了，是运行.class文件的虚拟机。JRE则是运行时环境，包括JVM和java核心类库，没有核心的类库是跑不起来的。</p><p><img src="https://static.lovebilibili.com/jvm_05.png" srcset="/img/loading.gif" alt=""></p><p>JDK则包括JRE和一些开发使用的工具集。</p><p>所以总的关系是<strong>JDK &gt; JRE &gt; JVM</strong>。</p><h1 id="三、Class加载过程"><a href="#三、Class加载过程" class="headerlink" title="三、Class加载过程"></a>三、Class加载过程</h1><p>类加载是JVM工作的一个很重要的过程，我们知道.class是存在在硬盘上的一个文件，如何加载到内存工作的呢，面试中也经常问这个问题。所以你要和其他程序员拉开差距，体现差异化，这个问题要搞懂。</p><p>类加载的过程实际上分为三大步：<strong>Loading(加载)、Linking(连接)、Initlalizing(初始化)</strong>。</p><p>其中第二步Linking又分为三小步：<strong>Verification(验证)、Preparation(准备)、Resolution(解析)</strong>。</p><p><img src="https://static.lovebilibili.com/jvm_06.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-1-Loading"><a href="#3-1-Loading" class="headerlink" title="3.1 Loading"></a>3.1 Loading</h2><p>Loading是<strong>把.class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据，在堆中生成一个java.lang.Class类对象代表这个类，作为方法区这些类型数据的访问入口</strong>。</p><h2 id="3-2-Linking"><a href="#3-2-Linking" class="headerlink" title="3.2 Linking"></a>3.2 Linking</h2><p>Linking简单来说，就是把原始的类定义的信息合并到JVM运行状态之中。分为三小步进行。</p><h3 id="3-2-1-Verification"><a href="#3-2-1-Verification" class="headerlink" title="3.2.1 Verification"></a>3.2.1 Verification</h3><p>验证加载的类信息是否符合class文件的标准，防止恶意信息或者不符合规范的字节信息。是JVM虚拟机运行安全的重要保障。</p><h3 id="3-2-2-Preparation"><a href="#3-2-2-Preparation" class="headerlink" title="3.2.2 Preparation"></a>3.2.2 Preparation</h3><p>创建类或者接口中的<strong>静态变量</strong>，并初始化<strong>静态变量赋默认值</strong>。赋默认值不是赋初始值，比如static int i = 5，这一步只是把i赋值为0，而不是赋值为5。赋值为5是在后面的步骤。</p><h3 id="3-2-3-Resolution"><a href="#3-2-3-Resolution" class="headerlink" title="3.2.3 Resolution"></a>3.2.3 Resolution</h3><p>把class文件常量池里面用到的符号引用转换成直接内存地址，直接可以访问到的内容。</p><h2 id="3-3-Initlalizing"><a href="#3-3-Initlalizing" class="headerlink" title="3.3 Initlalizing"></a>3.3 Initlalizing</h2><p>这一步真正去执行类初始化clinit()(类构造器)的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态代码块内(static{})的逻辑。当初始化一个类时，发现父类还没有进行过初始化，则先初始化父类。虚拟机会保证一个类的clinit()方法在多线程环境中被正确加锁和同步。</p><h1 id="四、类加载器"><a href="#四、类加载器" class="headerlink" title="四、类加载器"></a>四、类加载器</h1><p>上面就是类加载的整个过程。而最后一步Initlalizing是通过类加载器加载类。类加载器这里我单独讲一下，因为这是一个重点。</p><p>Java中的类加载器由上到下分为：</p><ul><li>Bootstrap ClassLoader（启动类加载器）</li><li>ExtClassLoader（扩展类加载器）</li><li>AppClassLoader（应用程序类加载器）</li></ul><p>从类图，可以看到<strong>ExtClassLoader和AppClassLoader都是ClassLoader的子类</strong>。</p><p><img src="https://static.lovebilibili.com/jvm_07.png" srcset="/img/loading.gif" alt=""></p><p>所以如果要自定义一个类加载器，可以继承ClassLoader抽象类，重写里面的方法。重写什么方法后面再讲。</p><h1 id="五、双亲委派机制"><a href="#五、双亲委派机制" class="headerlink" title="五、双亲委派机制"></a>五、双亲委派机制</h1><p>讲完类加载器，这些类加载器是怎么工作的呢。对于双亲委派机制可能多多少少有听过，没听过也没关系，我正要讲。</p><p>上面说过有Bootstrap，ExtClassLoader，AppClassLoader三个类加载器。工作机制如下：</p><p><img src="https://static.lovebilibili.com/jvm_08.png" srcset="/img/loading.gif" alt=""></p><p>加载类的逻辑是怎么样的呢，核心代码是可以在JDK源码中找到的，在抽象类ClassLoader类的loadClass()，有兴趣可以源码看看：</p><pre><code class="java">protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {    synchronized (getClassLoadingLock(name)) {        // First, check if the class has already been loaded        Class&lt;?&gt; c = findLoadedClass(name);        if (c == null) {            long t0 = System.nanoTime();            try {                if (parent != null) {                    //如果上层有类加载器，递归向上，往上层的类加载器寻找                    c = parent.loadClass(name, false);                } else {                    c = findBootstrapClassOrNull(name);                }            } catch (ClassNotFoundException e) {                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader            }            //如果上层的都找不到相应的class            if (c == null) {                // If still not found, then invoke findClass in order                // to find the class.                long t1 = System.nanoTime();                //自己去加载                c = findClass(name);                // this is the defining class loader; record the stats                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            }        }        if (resolve) {            resolveClass(c);        }        return c;    }}</code></pre><p>其实整个逻辑已经很清晰了，为了更好理解，我这里画张图给给大家，更好理解一点：</p><p><img src="https://static.lovebilibili.com/jvm_09.png" srcset="/img/loading.gif" alt=""></p><p>看到这里，应该都清楚了双亲委派机制的流程了。<strong>重点来了，为什么要使用双亲委派机制呢？</strong></p><p>如果面试官问这个问题，一定要答出关键字：<strong>安全性</strong>。</p><p>反证法来辩证。假设不采用双亲委派机制，那我可以自定义一个类加载器，然后我写一个java.lang.String类用自定义的类加载器加载进去，原来java本身又有一个java.lang.String类，那么类的唯一性就没法保证，就不就给虚拟机的安全带来的隐患了吗。<strong>所以要保证一个类只能由同一个类加载器加载，才能保证系统类的的安全</strong>。</p><h1 id="六、自定义类加载器"><a href="#六、自定义类加载器" class="headerlink" title="六、自定义类加载器"></a>六、自定义类加载器</h1><p>自定义类加载器，上面讲过可以有样学样，自定义一个类继承ClassLoader抽象类。重写哪个方法呢？loadClass()方法是加载类的方法，重写这个不就行了？</p><p>如果重写loadClass()那证明有思考过，但是不太对，因为重写loadClass()会破坏了双亲委派机制的逻辑。应该重写loadClass()方法里的findClass()方法。</p><p>findClass()方法才是自定义类加载器加载类的方法。</p><p><img src="https://static.lovebilibili.com/jvm_10.png" srcset="/img/loading.gif" alt=""></p><p>那findClass()方法源码是怎么样的呢？</p><p><img src="https://static.lovebilibili.com/jvm_11.png" srcset="/img/loading.gif" alt=""></p><p>明显这个方法是给子类重写用的，权限修饰符也是protected，如果不重写，那就会抛出找不到类的异常。如果学过设计模式的同学，应该看得出来这里用了<strong>模板模式</strong>的设计模式。所以我们自定义类加载器重写此方法即可。开始动手！</p><p>创建CustomerClassLoader类，继承ClassLoader抽象类的findClass()方法。</p><pre><code class="java">public class CustomerClassLoader extends ClassLoader {    //class文件在磁盘中的路径    private String path;    //通过构造器初始化class文件的路径    public CustomerClassLoader(String path) {        this.path = path;    }    /**     * 加载类     *     * @param name 类的全路径     * @return Class&lt;?&gt;     * @author Ye hongzhi     */    @Override    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {        Class clazz = null;        //获取class文件，转成字节码数组        byte[] data = getData();        if (data != null) {            //将class的字节码数组转换成Class类的实例            clazz = defineClass(name, data, 0, data.length);        }        //返回Class对象        return clazz;    }    private byte[] getData() {        File file = new File(path);        if (file.exists()) {            try (FileInputStream in = new FileInputStream(file);                 ByteArrayOutputStream out = new ByteArrayOutputStream();) {                byte[] buffer = new byte[1024];                int size;                while ((size = in.read(buffer)) != -1) {                    out.write(buffer, 0, size);                }                return out.toByteArray();            } catch (IOException e) {                e.printStackTrace();                return null;            }        } else {            return null;        }    }}</code></pre><p>这样就完成了，接下来测试一下，定义一个Hello类。</p><pre><code class="java">public class Hello {    public void say() {        System.out.println(&quot;hello.......java&quot;);    }}</code></pre><p>使用javac命令编译成class文件，如下图：</p><p><img src="https://static.lovebilibili.com/jvm_12.png" srcset="/img/loading.gif" alt=""></p><p>最后写个main方法运行测试一把：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        String path = &quot;D:\\mall\\core\\src\\main\\java\\io\\github\\yehongzhi\\classloader\\Hello.class&quot;;        CustomerClassLoader classLoader = new CustomerClassLoader(path);        Class&lt;?&gt; clazz = classLoader.findClass(&quot;io.github.yehongzhi.classloader.Hello&quot;);        System.out.println(&quot;使用类加载器：&quot; + clazz.getClassLoader());        Method method = clazz.getDeclaredMethod(&quot;say&quot;);        Object obj = clazz.newInstance();        method.invoke(obj);    }}</code></pre><p>运行结果：</p><p><img src="https://static.lovebilibili.com/jvm_13.png" srcset="/img/loading.gif" alt=""></p><h1 id="七、破坏双亲委派机制"><a href="#七、破坏双亲委派机制" class="headerlink" title="七、破坏双亲委派机制"></a>七、破坏双亲委派机制</h1><p>看到这里，你肯定会很疑惑。上面不是才讲过双亲委派机制为了保证系统的安全性吗，为什么又要破坏双亲委派机制呢？</p><p>重温一下双亲委派机制，应该还记得，就是底层的类加载器一直委托上层的类加载器，如果上层的已经加载了，就无需加载，上层的类加载器没有加载则自己加载。这就<strong>突出了双亲委派机制的一个缺陷，就是只能子的类加载器委托父的类加载器，不能反过来用父的类加载器委托子的类加载器</strong>。</p><p>那你会问，什么情况会出现父的类加载器委托子的类加载器呢？</p><p>还真有这个场景，就是加载JDBC的数据库驱动。在JDK中有一个所有 JDBC 驱动程序需要实现的接口Java.sql.Driver。而Driver接口的实现类则是由各大数据库厂商提供。那问题就出现了，<strong>DriverManager(JDK的rt.jar包中)要加载各个实现了Driver接口的实现类，然后进行统一管理，但是DriverManager是由Bootstrap类加载器加载的，只能加载JAVA_HOME下lib目录下的文件(可以看回上面双亲委派机制的第一张图)，但是实现类是服务商提供的，由AppClassLoader加载，这就需要Bootstrap(上层类加载器)委托AppClassLoader(下层类加载器)，也就破坏了双亲委派机制</strong>。这只是其中一种场景，破坏双亲委派机制的例子还有很多。</p><p>那么怎么实现破坏双亲委派机制呢？</p><ul><li>最简单就是自定义类加载器，前面讲过为了不破坏双亲委派机制重写findClass()方法，所以如果我要破坏双亲委派机制，那就重写loadClass()方法，直接把双亲委派机制的逻辑给改了。在JDK1.2后不提倡重写此方法。所以提供下面这种方式。</li><li>使用线程上下文件类加载器(Thread Context ClassLoader)。<strong>这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是AppClassLoader类加载器</strong>。</li></ul><p><img src="https://static.lovebilibili.com/jvm_14.png" srcset="/img/loading.gif" alt=""></p><p>那么刚刚说的JDBC又是采用什么方式破坏双亲委派机制的呢？</p><p>当然是采用上下文文件类加载器，还有使用了SPI机制，下面一步一步分解。</p><p>第一步，Bootstrap加载DriverManager类，在DriverManager类的静态代码块调用初始化方法。</p><pre><code class="java">public class DriverManager {    static {        loadInitialDrivers();        println(&quot;JDBC DriverManager initialized&quot;);    }}</code></pre><p>第二步，加载Driver接口的所有实现类，得到Driver实现类的集合，获取一个迭代器。</p><p><img src="https://static.lovebilibili.com/jvm_15.png" srcset="/img/loading.gif" alt=""></p><p>第三步，看ServiceLoader.load()方法。</p><p><img src="https://static.lovebilibili.com/jvm_16.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/jvm_17.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/jvm_18.png" srcset="/img/loading.gif" alt=""></p><p>第四步，看迭代器driversIterator。</p><p><img src="https://static.lovebilibili.com/jvm_19.png" srcset="/img/loading.gif" alt=""></p><p>接着一直找下去，就会看到一个很神奇的地方。</p><p><img src="https://static.lovebilibili.com/jvm_21.png" srcset="/img/loading.gif" alt=""></p><p>而这个常量值PREFIX则是：</p><pre><code class="java">private static final String PREFIX = &quot;META-INF/services/&quot;;</code></pre><p>所以我们可以在mysql驱动包中找到这个文件：</p><p><img src="https://static.lovebilibili.com/jvm_22.png" srcset="/img/loading.gif" alt=""></p><p>通过文件名找接口的实现类，这是java的SPI机制。到此为止，破案了大人！</p><p>作为暖男的我，就画张图，总结一下整个过程吧：</p><p><img src="https://static.lovebilibili.com/jvm_23.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章主要介绍了JVM，然后讲到JVM的类加载机制的三大步骤，接着讲自定义类加载器以及双亲委派机制。最后再深入探讨了为什么要使用双亲委派机制，又为什么要破坏双亲委派机制的问题。可能讲得有点长，不过我相信应该都看懂了，因为我讲得比较通俗，而且图文并茂。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5千字的SpringMVC总结，你值得拥有</title>
    <link href="/2020/08/30/5%E5%8D%83%E5%AD%97%E7%9A%84SpringMVC%E6%80%BB%E7%BB%93%EF%BC%8C%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89/"/>
    <url>/2020/08/30/5%E5%8D%83%E5%AD%97%E7%9A%84SpringMVC%E6%80%BB%E7%BB%93%EF%BC%8C%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/springmvc_swdt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>微信公众号已开启：【<strong>java技术爱好者</strong>】，还没关注的记得关注哦~</p><p><strong>文章已收录到我的Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SpringMVC再熟悉不过的框架了，因为现在最火的SpringBoot的内置MVC框架就是SpringMVC。我写这篇文章的动机是想通过回顾总结一下，重新认识SpringMVC，所谓温故而知新嘛。</p><p>为了了解SpringMVC，先看一个流程示意图：</p><p><img src="https://static.lovebilibili.com/springmvc_1.png" srcset="/img/loading.gif" alt=""></p><p>从流程图中，我们可以看到：</p><ul><li>接收前端传过来Request请求。</li><li>根据映射路径找到对应的处理器处理请求，处理完成之后返回ModelAndView。</li><li>进行视图解析，视图渲染，返回响应结果。</li></ul><p>总结就是：<strong>参数接收，定义映射路径，页面跳转，返回响应结果</strong>。</p><p>当然这只是最基本的核心功能，除此之外还可以<strong>定义拦截器，全局异常处理，文件上传下载</strong>等等。</p><h1 id="一、搭建项目"><a href="#一、搭建项目" class="headerlink" title="一、搭建项目"></a>一、搭建项目</h1><p>在以前的老项目中，因为还没有SpringBoot，没有自动配置，所以需要使用<strong>web.xml</strong>文件去定义一个DispatcherServlet。现在互联网应用基本上都使用SpringBoot，所以我就直接使用SpringBoot进行演示。很简单，引入依赖即可：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h1 id="二、定义Controller"><a href="#二、定义Controller" class="headerlink" title="二、定义Controller"></a>二、定义Controller</h1><p>使用SpringMVC定义Controller处理器，总共有五种方式。</p><h2 id="2-1-实现Controller接口"><a href="#2-1-实现Controller接口" class="headerlink" title="2.1 实现Controller接口"></a>2.1 实现Controller接口</h2><p>早期的SpringMVC是通过这种方式定义：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name DemoController * @date 2020-08-25 22:28 **/@org.springframework.stereotype.Controller(&quot;/demo/controller&quot;)public class DemoController implements Controller {    @Override    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {        //业务处理        return null;    }}</code></pre><h2 id="2-2-实现HttpRequestHandler接口"><a href="#2-2-实现HttpRequestHandler接口" class="headerlink" title="2.2 实现HttpRequestHandler接口"></a>2.2 实现HttpRequestHandler接口</h2><p>跟第一种方式差不多，也是通过实现接口的方式：</p><pre><code class="java">/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name HttpDemoController * @date 2020-08-25 22:45 **/@Controller(&quot;/http/controller&quot;)public class HttpDemoController implements HttpRequestHandler{    @Override    public void handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException {        //业务处理    }}</code></pre><h2 id="2-3-实现Servlet接口"><a href="#2-3-实现Servlet接口" class="headerlink" title="2.3 实现Servlet接口"></a>2.3 实现Servlet接口</h2><p>这种方式已经不推荐使用了，不过从这里可以看出<strong>SpringMVC的底层使用的还是Servlet</strong>。</p><pre><code class="java">@Controller(&quot;/servlet/controller&quot;)public class ServletDemoController implements Servlet {    //以下是Servlet生命周期方法    @Override    public void init(ServletConfig servletConfig) throws ServletException {    }    @Override    public ServletConfig getServletConfig() {        return null;    }    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {    }    @Override    public String getServletInfo() {        return null;    }    @Override    public void destroy() {    }}</code></pre><p>因为不推荐使用这种方式，所以默认是不加载这种适配器的，需要加上：</p><pre><code class="java">@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter {    @Bean    public SimpleServletHandlerAdapter simpleServletHandlerAdapter() {        return new SimpleServletHandlerAdapter();    }}</code></pre><h2 id="2-4-使用-RequestMapping"><a href="#2-4-使用-RequestMapping" class="headerlink" title="2.4 使用@RequestMapping"></a>2.4 使用@RequestMapping</h2><p>这种方式是最常用的，因为上面那些方式定义需要使用一个类定义一个路径，就会导致产生很多类。使用注解就相对轻量级一些。</p><pre><code class="java">@Controller@RequestMapping(&quot;/requestMapping/controller&quot;)public class RequestMappingController {    @RequestMapping(&quot;/demo&quot;)    public String demo() {        return &quot;HelloWord&quot;;    }}</code></pre><h3 id="2-4-1-支持Restful风格"><a href="#2-4-1-支持Restful风格" class="headerlink" title="2.4.1 支持Restful风格"></a>2.4.1 支持Restful风格</h3><p>而且支持<strong>Restful风格</strong>，使用<strong>method</strong>属性定义对资源的操作方式：</p><pre><code class="java">    @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.GET)    public String get() {        //查询        return &quot;get&quot;;    }    @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.POST)    public String post() {        //创建        return &quot;post&quot;;    }    @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.PUT)    public String put() {        //更新        return &quot;put&quot;;    }    @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.DELETE)    public String del() {        //删除        return &quot;post&quot;;    }</code></pre><h3 id="2-4-2-支持Ant风格"><a href="#2-4-2-支持Ant风格" class="headerlink" title="2.4.2 支持Ant风格"></a>2.4.2 支持Ant风格</h3><pre><code class="java">    //匹配 /antA 或者 /antB 等URL    @RequestMapping(&quot;/ant?&quot;)    public String ant() {        return &quot;ant&quot;;    }    //匹配 /ant/a/create 或者 /ant/b/create 等URL    @RequestMapping(&quot;/ant/*/create&quot;)    public String antCreate() {        return &quot;antCreate&quot;;    }    //匹配 /ant/create 或者 /ant/a/b/create 等URL    @RequestMapping(&quot;/ant/**/create&quot;)    public String antAllCreate() {        return &quot;antAllCreate&quot;;    }</code></pre><h2 id="2-5-使用HandlerFunction"><a href="#2-5-使用HandlerFunction" class="headerlink" title="2.5 使用HandlerFunction"></a>2.5 使用HandlerFunction</h2><p>最后一种是使用HandlerFunction函数式接口，这是<code>Spring5.0</code>后引入的方式，主要用于做响应式接口的开发，也就是Webflux的开发。</p><p>有兴趣的可以网上搜索相关资料学习，这个讲起来可能要很大篇幅，这里就不赘述了。</p><h1 id="三、接收参数"><a href="#三、接收参数" class="headerlink" title="三、接收参数"></a>三、接收参数</h1><p>定义完Controller之后，需要接收前端传入的参数，怎么接收呢。</p><h2 id="3-1-接收普通参数"><a href="#3-1-接收普通参数" class="headerlink" title="3.1 接收普通参数"></a>3.1 接收普通参数</h2><p>在@RequestMapping映射方法上写上接收参数名即可：</p><pre><code class="java">@RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.POST)public String post(Integer id, String name, int money) {    System.out.println(&quot;id:&quot; + id + &quot;,name:&quot; + name + &quot;,money:&quot; + money);    return &quot;post&quot;;}</code></pre><p><img src="https://static.lovebilibili.com/springmvc_2.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-2-RequestParam参数名绑定"><a href="#3-2-RequestParam参数名绑定" class="headerlink" title="3.2 @RequestParam参数名绑定"></a>3.2 @RequestParam参数名绑定</h2><p>如果不想使用形参名称作为参数名称，可以使用@RequestParam进行参数名称绑定：</p><pre><code class="java">    /**     * value: 参数名     * required: 是否request中必须包含此参数，默认是true。     * defaultValue: 默认参数值     */    @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.GET)    public String get(@RequestParam(value = &quot;userId&quot;, required = false, defaultValue = &quot;0&quot;) String id) {        System.out.println(&quot;id:&quot; + id);        return &quot;get&quot;;    }</code></pre><p><img src="https://static.lovebilibili.com/springmvc_3.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-3-PathVariable路径参数"><a href="#3-3-PathVariable路径参数" class="headerlink" title="3.3 @PathVariable路径参数"></a>3.3 @PathVariable路径参数</h2><p>通过@PathVariable将URL中的占位符{xxx}参数映射到操作方法的入参。演示代码如下：</p><pre><code class="java">@RequestMapping(value = &quot;/restful/{id}&quot;, method = RequestMethod.GET)public String search(@PathVariable(&quot;id&quot;) String id) {    System.out.println(&quot;id:&quot; + id);    return &quot;search&quot;;}</code></pre><p><img src="https://static.lovebilibili.com/springmvc_4.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-4-RequestHeader绑定请求头属性"><a href="#3-4-RequestHeader绑定请求头属性" class="headerlink" title="3.4 @RequestHeader绑定请求头属性"></a>3.4 @RequestHeader绑定请求头属性</h2><p>获取请求头的信息怎么获取呢？</p><p><img src="https://static.lovebilibili.com/springmvc_5.png" srcset="/img/loading.gif" alt=""></p><p>使用@RequestHeader注解，用法和@RequestParam类似：</p><pre><code class="java">    @RequestMapping(&quot;/head&quot;)    public String head(@RequestHeader(&quot;Accept-Language&quot;) String acceptLanguage) {        return acceptLanguage;    }</code></pre><p><img src="https://static.lovebilibili.com/springmvc_6.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-5-CookieValue绑定请求的Cookie值"><a href="#3-5-CookieValue绑定请求的Cookie值" class="headerlink" title="3.5 @CookieValue绑定请求的Cookie值"></a>3.5 @CookieValue绑定请求的Cookie值</h2><p>获取Request中Cookie的值：</p><pre><code class="java">    @RequestMapping(&quot;/cookie&quot;)    public String cookie(@CookieValue(&quot;_ga&quot;) String _ga) {        return _ga;    }</code></pre><p><img src="https://static.lovebilibili.com/springmvc_7.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-6-绑定请求参数到POJO对象"><a href="#3-6-绑定请求参数到POJO对象" class="headerlink" title="3.6 绑定请求参数到POJO对象"></a>3.6 绑定请求参数到POJO对象</h2><p>定义了一个User实体类：</p><pre><code class="java">public class User {    private String id;    private String name;    private Integer age;    //getter、setter方法}</code></pre><p>定义一个@RequestMapping操作方法：</p><pre><code class="java">    @RequestMapping(&quot;/body&quot;)    public String body(User user) {        return user.toString();    }</code></pre><p>只要请求参数与属性名相同自动填充到user对象中：</p><p><img src="https://static.lovebilibili.com/springmvc_8.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_9.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-6-1-支持级联属性"><a href="#3-6-1-支持级联属性" class="headerlink" title="3.6.1 支持级联属性"></a>3.6.1 支持级联属性</h3><p>现在多了一个Address类存储地址信息：</p><pre><code class="java">public class Address {    private String id;    private String name;    //getter、setter方法}</code></pre><p>在User中加上address属性：</p><pre><code class="java">public class User {    private String id;    private String name;    private Integer age;    private Address address;    //getter、setter方法}</code></pre><p>传参时只要传入address.name、address.id即会自动填充：</p><p><img src="https://static.lovebilibili.com/springmvc_11.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_10.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-6-2-InitBinder解决接收多对象时属性名冲突"><a href="#3-6-2-InitBinder解决接收多对象时属性名冲突" class="headerlink" title="3.6.2 @InitBinder解决接收多对象时属性名冲突"></a>3.6.2 @InitBinder解决接收多对象时属性名冲突</h3><p>如果有两个POJO对象拥有相同的属性名，不就产生冲突了吗？比如刚刚的user和address，其中他们都有id和name这两个属性，如果同时接收，就会冲突：</p><pre><code class="java">    //user和address都有id和name这两个属性        @RequestMapping(value = &quot;/twoBody&quot;, method = RequestMethod.POST)    public String twoBody(User user, Address address) {        return user.toString() + &quot;,&quot; + address.toString();    }</code></pre><p>这时就可以使用@InitBinder绑定参数名称：</p><pre><code class="java">    @InitBinder(&quot;user&quot;)    public void initBindUser(WebDataBinder webDataBinder) {        webDataBinder.setFieldDefaultPrefix(&quot;u.&quot;);    }    @InitBinder(&quot;address&quot;)    public void initBindAddress(WebDataBinder webDataBinder) {        webDataBinder.setFieldDefaultPrefix(&quot;addr.&quot;);    }</code></pre><p><img src="https://static.lovebilibili.com/springmvc_12.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_13.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-6-3-Requestbody自动解析JSON字符串封装到对象"><a href="#3-6-3-Requestbody自动解析JSON字符串封装到对象" class="headerlink" title="3.6.3 @Requestbody自动解析JSON字符串封装到对象"></a>3.6.3 @Requestbody自动解析JSON字符串封装到对象</h3><p>前端传入一个json字符串，自动转换成pojo对象，演示代码：</p><pre><code class="java">    @RequestMapping(value = &quot;/requestBody&quot;, method = RequestMethod.POST)    public String requestBody(@RequestBody User user) {        return user.toString();    }</code></pre><p>注意的是，要使用<strong>POST请求，发送端的Content-Type设置为application/json，数据是json字符串</strong>：</p><p><img src="https://static.lovebilibili.com/springmvc_14.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_15.png" srcset="/img/loading.gif" alt=""></p><p>甚至有一些人喜欢用一个Map接收：</p><p><img src="https://static.lovebilibili.com/springmvc_16.png" srcset="/img/loading.gif" alt=""></p><p>但是<strong>千万不要用Map接收，否则会造成代码很难维护</strong>，后面的老哥估计看不懂你这个Map里面有什么数据，所以最好还是定义一个POJO对象。</p><h1 id="四、参数类型转换"><a href="#四、参数类型转换" class="headerlink" title="四、参数类型转换"></a>四、参数类型转换</h1><p>实际上，SpringMVC框架本身就内置了很多类型转换器，比如你传入字符串的数字，接收的入参定为int，long类型，都会自动帮你转换。</p><p>就在包<strong>org.springframework.core.convert.converter</strong>下，如图所示：</p><p><img src="https://static.lovebilibili.com/springmvc_17.png" srcset="/img/loading.gif" alt=""></p><p>有的时候如果内置的类型转换器不足够满足业务需求呢，怎么扩展呢，很简单，看我操作。什么是Java技术爱好者(战术后仰)。</p><p>首先有样学样，内置的转换器实现Converter接口，我也实现：</p><pre><code class="java">public class StringToDateConverter implements Converter&lt;String, Date&gt; {    @Override    public Date convert(String source) {        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        try {            //String转换成Date类型            return sdf.parse(source);        } catch (Exception e) {            //类型转换错误            e.printStackTrace();        }        return null;    }}</code></pre><p>接着把转换器注册到Spring容器中：</p><pre><code class="java">@Configurationpublic class ConverterConfig extends WebMvcConfigurationSupport {    @Override    protected void addFormatters(FormatterRegistry registry) {        //添加类型转换器        registry.addConverter(new StringToDateConverter());    }}</code></pre><p>接着看测试，所有的日期字符串，都自动被转换成Date类型了，非常方便：</p><p><img src="https://static.lovebilibili.com/springmvc_19.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_18.png" srcset="/img/loading.gif" alt=""></p><h1 id="五、页面跳转"><a href="#五、页面跳转" class="headerlink" title="五、页面跳转"></a>五、页面跳转</h1><p>在前后端未分离之前，页面跳转的工作都是由后端控制，采用JSP进行展示数据。虽然现在互联网项目几乎不会再使用JSP，但是我觉得还是需要学习一下，因为有些旧项目还是会用JSP，或者需要重构。</p><p>如果你在RequestMapping方法中直接返回一个字符串是不会跳转到指定的JSP页面的，需要做一些配置。</p><p>第一步，加入解析jsp的Maven配置。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;    &lt;version&gt;7.0.59&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>第二步，添加视图解析器。</p><pre><code class="java">@Configurationpublic class WebAppConfig extends WebMvcConfigurerAdapter {    @Bean    public InternalResourceViewResolver viewResolver() {        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();        viewResolver.setPrefix(&quot;/&quot;);        viewResolver.setSuffix(&quot;.jsp&quot;);        viewResolver.setViewClass(JstlView.class);        return viewResolver;    }}</code></pre><p>第三步，设置IDEA的配置。</p><p><img src="https://static.lovebilibili.com/springmvc_21.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_20.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/springmvc_22.png" srcset="/img/loading.gif" alt=""></p><p>第四步，创建jsp页面。</p><p><img src="https://static.lovebilibili.com/springmvc_23.png" srcset="/img/loading.gif" alt=""></p><p>第五步，创建Controller控制器。</p><pre><code class="java">@Controller@RequestMapping(&quot;/view&quot;)public class ViewController {    @RequestMapping(&quot;/hello&quot;)    public String hello() throws Exception {        return &quot;hello&quot;;    }}</code></pre><p>这样就完成了，启动项目，访问/view/hello就看到了：</p><p><img src="https://static.lovebilibili.com/springmvc_25.png" srcset="/img/loading.gif" alt=""></p><p>就是这么简单，对吧</p><h1 id="六、-ResponseBody"><a href="#六、-ResponseBody" class="headerlink" title="六、@ResponseBody"></a>六、@ResponseBody</h1><p>如果采用前后端分离，页面跳转不需要后端控制了，后端只需要返回json即可，怎么返回呢？</p><p>使用@ResponseBody注解即可，这个注解会把对象自动转成json数据返回。</p><p>@ResponseBody注解可以放在类或者方法上，源码如下：</p><pre><code class="java">//用在类、方法上@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ResponseBody {}</code></pre><p>演示一下：</p><pre><code class="java">@RequestMapping(&quot;/userList&quot;)@ResponseBodypublic List&lt;User&gt; userList() throws Exception {    List&lt;User&gt; list = new ArrayList&lt;&gt;();    list.add(new User(&quot;1&quot;,&quot;姚大秋&quot;,18));    list.add(new User(&quot;2&quot;,&quot;李星星&quot;,18));    list.add(new User(&quot;3&quot;,&quot;冬敏&quot;,18));    return list;}</code></pre><p>测试一下/view/userList：</p><p><img src="https://static.lovebilibili.com/springmvc_26.png" srcset="/img/loading.gif" alt=""></p><h1 id="七、-ModelAttribute"><a href="#七、-ModelAttribute" class="headerlink" title="七、@ModelAttribute"></a>七、@ModelAttribute</h1><p>@ModelAttribute用法比较多，下面一一讲解。</p><h2 id="7-1-用在无返回值的方法上"><a href="#7-1-用在无返回值的方法上" class="headerlink" title="7.1 用在无返回值的方法上"></a>7.1 用在无返回值的方法上</h2><p>在Controller类中，在执行所有的RequestMapping方法前都会先执行@ModelAttribute注解的方法。</p><pre><code class="java">@Controller@RequestMapping(&quot;/modelAttribute&quot;)public class ModelAttributeController {    //先执行这个方法    @ModelAttribute    public void modelAttribute(Model model){        //在request域中放入数据        model.addAttribute(&quot;userName&quot;,&quot;公众号：java技术爱好者&quot;);    }    @RequestMapping(&quot;/index&quot;)    public String index(){        //跳转到inex.jsp页面        return &quot;index&quot;;    }}</code></pre><p>index.jsp页面如下：</p><pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 获取到userName属性值 --&gt;&lt;h1&gt;${userName}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>相当于一个Controller的拦截器一样，在执行RequestMapping方法前先执行@ModelAttribute注解的方法。所以要慎用。</p><p>启动项目，访问/modelAttribute/index可以看到：</p><p><img src="https://static.lovebilibili.com/springmvc_27.png" srcset="/img/loading.gif" alt=""></p><p>即使在index()方法中没有放入userName属性值，jsp页面也能获取到，因为在执行index()方法之前的modelAttribute()方法已经放入了。</p><h2 id="7-2-放在有返回值的方法上"><a href="#7-2-放在有返回值的方法上" class="headerlink" title="7.2 放在有返回值的方法上"></a>7.2 放在有返回值的方法上</h2><p>其实调用顺序是一样，也是在RequestMapping方法前执行，不同的在于，方法的返回值直接帮你放入到Request域中。</p><pre><code class="java">//放在有参数的方法上@ModelAttributepublic User userAttribute() {    //相当于model.addAttribute(&quot;user&quot;,new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18));    return new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18);}@RequestMapping(&quot;/user&quot;)public String user() {    return &quot;user&quot;;}</code></pre><p>创建一个user.jsp:</p><pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;ID:${user.id}&lt;/h1&gt;&lt;h1&gt;名称:${user.name}&lt;/h1&gt;&lt;h1&gt;年龄:${user.age}岁&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>测试一下：</p><p><img src="https://static.lovebilibili.com/springmvc_28.png" srcset="/img/loading.gif" alt=""></p><p>放入Request域中的属性值默认是类名的首字母小写驼峰写法，如果你想自定义呢？很简单，可以这样写：</p><pre><code class="java">//自定义属性名为&quot;u&quot;@ModelAttribute(&quot;u&quot;)public User userAttribute() {    return new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18);}/**JSP就要改成这样写：&lt;h1&gt;ID:${u.id}&lt;/h1&gt;&lt;h1&gt;名称:${u.name}&lt;/h1&gt;&lt;h1&gt;年龄:${u.age}岁&lt;/h1&gt;*/</code></pre><h2 id="7-3-放在RequestMapping方法上"><a href="#7-3-放在RequestMapping方法上" class="headerlink" title="7.3 放在RequestMapping方法上"></a>7.3 放在RequestMapping方法上</h2><pre><code class="java">@Controller@RequestMapping(&quot;/modelAttribute&quot;)public class ModelAttributeController {    @RequestMapping(&quot;/jojo&quot;)    @ModelAttribute(&quot;attributeName&quot;)    public String jojo() {        return &quot;JOJO！我不做人了！&quot;;    }}</code></pre><p>这种情况下RequestMapping方法的返回的值就不是JSP视图了。而是把返回值放入Request域中的属性值，属性名为attributeName。视图则是RequestMapping注解上的URL，所以创建一个对应的JSP页面：</p><p><img src="https://static.lovebilibili.com/springmvc_29.png" srcset="/img/loading.gif" alt=""></p><pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;${attributeName}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>测试一下：</p><p><img src="https://static.lovebilibili.com/springmvc_30.png" srcset="/img/loading.gif" alt=""></p><h2 id="7-4-放在方法入参上"><a href="#7-4-放在方法入参上" class="headerlink" title="7.4 放在方法入参上"></a>7.4 放在方法入参上</h2><p>放在入参上，意思是从前面的Model中提取出对应的属性值，当做入参传入方法中使用。如下所示：</p><pre><code class="java">@ModelAttribute(&quot;u&quot;)public User userAttribute() {    return new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18);}@RequestMapping(&quot;/java&quot;)public String user1(@ModelAttribute(&quot;u&quot;) User user) {    //拿到@ModelAttribute(&quot;u&quot;)方法返回的值，打印出来    System.out.println(&quot;user:&quot; + user);    return &quot;java&quot;;}</code></pre><p>测试一下：</p><p><img src="https://static.lovebilibili.com/springmvc_31.png" srcset="/img/loading.gif" alt=""></p><h1 id="八、拦截器"><a href="#八、拦截器" class="headerlink" title="八、拦截器"></a>八、拦截器</h1><p>拦截器算重点内容了，很多时候都要用拦截器，比如登录校验，权限校验等等。SpringMVC怎么添加拦截器呢？</p><p>很简单，实现HandlerInterceptor接口，接口有三个方法需要重写。</p><ul><li>preHandle()：在业务处理器处理请求之前被调用。预处理。</li><li>postHandle()：在业务处理器处理请求执行完成后，生成视图之前执行。后处理。</li><li>afterCompletion()：在DispatcherServlet完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）；</li></ul><p>自定义的拦截器，实现的接口HandlerInterceptor：</p><pre><code class="java">public class DemoInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //预处理，返回true则继续执行。如果需要登录校验，校验不通过返回false即可，通过则返回true。        System.out.println(&quot;执行preHandle()方法&quot;);        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        //后处理        System.out.println(&quot;执行postHandle()方法&quot;);    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        //在DispatcherServlet完全处理完请求后被调用        System.out.println(&quot;执行afterCompletion()方法&quot;);    }}</code></pre><p>然后把拦截器添加到Spring容器中：</p><pre><code class="java">@Configurationpublic class ConverterConfig extends WebMvcConfigurationSupport {    @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(new DemoInterceptor()).addPathPatterns(&quot;/**&quot;);    }}</code></pre><p>/**代表所有路径，测试一下：</p><p><img src="https://static.lovebilibili.com/springmvc_32.png" srcset="/img/loading.gif" alt=""></p><h1 id="九、全局异常处理"><a href="#九、全局异常处理" class="headerlink" title="九、全局异常处理"></a>九、全局异常处理</h1><p>SpringMVC本身就对一些异常进行了全局处理，所以有内置的异常处理器，在哪里呢？</p><p>看<code>HandlerExceptionResolver</code>接口的类图就知道了：</p><p><img src="https://static.lovebilibili.com/HandlerExceptionResolver.png" srcset="/img/loading.gif" alt=""></p><p>从类图可以看出有四种异常处理器：</p><ul><li><code>DefaultHandlerExceptionResolver</code>，默认的异常处理器。根据各个不同类型的异常，返回不同的异常视图。</li><li><code>SimpleMappingExceptionResolver</code>，简单映射异常处理器。通过配置异常类和view的关系来解析异常。</li><li><code>ResponseStatusExceptionResolver</code>，状态码异常处理器。解析带有<code>@ResponseStatus</code>注释类型的异常。</li><li><code>ExceptionHandlerExceptionResolver</code>，注解形式的异常处理器。对<code>@ExceptionHandler</code>注解的方法进行异常解析。</li></ul><p>第一个默认的异常处理器是内置的异常处理器，对一些常见的异常处理，一般来说不用管它。后面的三个才是需要注意的，是用来扩展的。</p><h2 id="9-1-SimpleMappingExceptionResolver"><a href="#9-1-SimpleMappingExceptionResolver" class="headerlink" title="9.1 SimpleMappingExceptionResolver"></a>9.1 SimpleMappingExceptionResolver</h2><p>翻译过来就是简单映射异常处理器。用途是，我们可以<strong>指定某种异常，当抛出这种异常之后跳转到指定的页面</strong>。请看演示。</p><p>第一步，添加spring-config.xml文件，放在resources目录下，文件名见文知意即可：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;        &lt;!-- 定义默认的异常处理页面 --&gt;        &lt;property name=&quot;defaultErrorView&quot; value=&quot;err&quot;/&gt;        &lt;!-- 定义异常处理页面用来获取异常信息的属性名，默认名为exception --&gt;        &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;        &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常也页名作为值 --&gt;        &lt;property name=&quot;exceptionMappings&quot;&gt;            &lt;props&gt;                &lt;!-- 异常，err表示err.jsp页面 --&gt;                &lt;prop key=&quot;java.lang.Exception&quot;&gt;err&lt;/prop&gt;                &lt;!-- 可配置多个prop --&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>第二步，在启动类加载xml文件：</p><pre><code class="java">@SpringBootApplication@ImportResource(&quot;classpath:spring-config.xml&quot;)public class SpringmvcApplication {    public static void main(String[] args) {        SpringApplication.run(SpringmvcApplication.class, args);    }}</code></pre><p>第三步，在webapp目录下创建一个err.jsp页面：</p><pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;异常页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;出现异常，这是一张500页面&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%=ex.getMessage()%&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这样就完成了，写一个接口测试一下：</p><pre><code class="java">@Controller@RequestMapping(&quot;/exception&quot;)public class ExceptionController {    @RequestMapping(&quot;/index&quot;)    public String index(String msg) throws Exception {        if (&quot;null&quot;.equals(msg)) {            //抛出空指针异常            throw new NullPointerException();        }        return &quot;index&quot;;    }}</code></pre><p>效果如下：</p><p><img src="https://static.lovebilibili.com/springmvc_33.png" srcset="/img/loading.gif" alt=""></p><p>这种异常处理器，在现在前后端分离的项目中几乎已经看不到了。</p><h2 id="9-2-ResponseStatusExceptionResolver"><a href="#9-2-ResponseStatusExceptionResolver" class="headerlink" title="9.2 ResponseStatusExceptionResolver"></a>9.2 ResponseStatusExceptionResolver</h2><p>这种异常处理器主要用于处理带有<code>@ResponseStatus</code>注释的异常。请看演示代码：</p><p>自定义一个异常类，并且使用<code>@ResponseStatus</code>注解修饰：</p><pre><code class="java">//HttpStatus枚举有所有的状态码，这里返回一个400的响应码@ResponseStatus(value = HttpStatus.BAD_REQUEST)public class DefinedException extends Exception{}</code></pre><p>写一个Controller接口进行测试：</p><pre><code class="java">@RequestMapping(&quot;/defined&quot;)public String defined(String msg) throws Exception {    if (&quot;defined&quot;.equals(msg)) {        throw new DefinedException();    }    return &quot;index&quot;;}</code></pre><p>启动项目，测试一下，效果如下：</p><p><img src="https://static.lovebilibili.com/springmvc_34.png" srcset="/img/loading.gif" alt=""></p><h2 id="9-3-ExceptionHandlerExceptionResolver"><a href="#9-3-ExceptionHandlerExceptionResolver" class="headerlink" title="9.3 ExceptionHandlerExceptionResolver"></a>9.3 ExceptionHandlerExceptionResolver</h2><p>注解形式的异常处理器，这是用得最多的。使用起来非常简单方便。</p><p>第一步，定义自定义异常BaseException：</p><pre><code class="java">public class BaseException extends Exception {    public BaseException(String message) {        super(message);    }}</code></pre><p>第二步，定义一个错误提示实体类ErrorInfo：</p><pre><code class="java">public class ErrorInfo {    public static final Integer OK = 0;    public static final Integer ERROR = -1;    private Integer code;    private String message;    private String url;    //getter、setter}</code></pre><p>第三步，定义全局异常处理类GlobalExceptionHandler：</p><pre><code class="java">//这里使用了RestControllerAdvice，是@ResponseBody和@ControllerAdvice的结合//会把实体类转成JSON格式的提示返回，符合前后端分离的架构@RestControllerAdvicepublic class GlobalExceptionHandler {    //这里自定义了一个BaseException，当抛出BaseException异常就会被此方法处理    @ExceptionHandler(BaseException.class)    public ErrorInfo errorHandler(HttpServletRequest req, BaseException e) throws Exception {        ErrorInfo r = new ErrorInfo();        r.setMessage(e.getMessage());        r.setCode(ErrorInfo.ERROR);        r.setUrl(req.getRequestURL().toString());        return r;    }}</code></pre><p>完成之后，写一个测试接口：</p><pre><code class="java">@RequestMapping(&quot;/base&quot;)public String base(String msg) throws Exception {    if (&quot;base&quot;.equals(msg)) {        throw new BaseException(&quot;测试抛出BaseException异常，欧耶！&quot;);    }    return &quot;index&quot;;}</code></pre><p>启动项目，测试：</p><p><img src="https://static.lovebilibili.com/springmvc_35.png" srcset="/img/loading.gif" alt=""></p><h1 id="絮叨"><a href="#絮叨" class="headerlink" title="絮叨"></a>絮叨</h1><p>SpringMVC的功能实际上肯定还不止我写的这些，不过学会上面这些之后，基本上已经可以应对日常的工作了。</p><p>如果要再深入一些，最好是看看SpringMVC源码，我之前写过三篇，<strong>责任链模式与SpringMVC拦截器，适配器模式与SpringMVC，全局异常处理源码分析</strong>。有兴趣可以关注公众号看看我的历史文章。</p><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>觉得有用就点个赞吧，你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL主从复制读写分离，能讲一下吗</title>
    <link href="/2020/08/30/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%8C%E8%83%BD%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%90%97/"/>
    <url>/2020/08/30/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%8C%E8%83%BD%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/mysql_zxfz_wedt.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>微信公众号已开启：【<strong>java技术爱好者</strong>】，还没关注的记得关注哦~</p><p><strong>文章已收录到我的Github精选，欢迎Star</strong>：<a href="https://github.com/yehongzhi/learningSummary" target="_blank" rel="noopener">https://github.com/yehongzhi/learningSummary</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很多项目，特别是互联网项目，在使用MySQL时都会采用主从复制、读写分离的架构。</p><p>为什么要采用主从复制读写分离的架构？如何实现？有什么缺点？让我们带着这些问题开始这段学习之旅吧！</p><h1 id="为什么使用主从复制、读写分离"><a href="#为什么使用主从复制、读写分离" class="headerlink" title="为什么使用主从复制、读写分离"></a>为什么使用主从复制、读写分离</h1><p>主从复制、读写分离一般是一起使用的。目的很简单，就是<strong>为了提高数据库的并发性能</strong>。你想，假设是单机，读写都在一台MySQL上面完成，性能肯定不高。如果有三台MySQL，一台mater只负责写操作，两台salve只负责读操作，性能不就能大大提高了吗？</p><p>所以<strong>主从复制、读写分离就是为了数据库能支持更大的并发</strong>。</p><p>随着业务量的扩展、如果是单机部署的MySQL，会导致I/O频率过高。采用<strong>主从复制、读写分离可以提高数据库的可用性</strong>。</p><h1 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h1><p>①当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。</p><p>②salve从库连接master主库，Master有多少个slave就会创建多少个binlog dump线程。</p><p>③当Master节点的binlog发生变化时，binlog dump 线程会通知所有的salve节点，并将相应的binlog内容推送给slave节点。</p><p>④I/O线程接收到 binlog 内容后，将内容写入到本地的 relay-log。</p><p>⑤SQL线程读取I/O线程写入的relay-log，并且根据 relay-log 的内容对从数据库做对应的操作。</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_1.png" srcset="/img/loading.gif" alt=""></p><h1 id="如何实现主从复制"><a href="#如何实现主从复制" class="headerlink" title="如何实现主从复制"></a>如何实现主从复制</h1><p>我这里用三台虚拟机(Linux)演示，IP分别是104(Master)，106(Slave)，107(Slave)。</p><p>预期的效果是一主二从，如下图所示：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_2.png" srcset="/img/loading.gif" alt=""></p><h2 id="Master配置"><a href="#Master配置" class="headerlink" title="Master配置"></a>Master配置</h2><p>使用命令行进入mysql：</p><pre><code class="java">mysql -u root -p</code></pre><p>接着输入root用户的密码(密码忘记的话就网上查一下重置密码吧~)，然后创建用户：</p><pre><code class="java">//192.168.0.106是slave从机的IPGRANT REPLICATION SLAVE ON *.* to &#39;root&#39;@&#39;192.168.0.106&#39; identified by &#39;Java@1234&#39;;//192.168.0.107是slave从机的IPGRANT REPLICATION SLAVE ON *.* to &#39;root&#39;@&#39;192.168.0.107&#39; identified by &#39;Java@1234&#39;;//刷新系统权限表的配置FLUSH PRIVILEGES;</code></pre><p>创建的这两个用户在配置slave从机时要用到。</p><p>接下来在找到mysql的配置文件/etc/my.cnf，增加以下配置：</p><pre><code class="properties"># 开启binloglog-bin=mysql-binserver-id=104# 需要同步的数据库，如果不配置则同步全部数据库binlog-do-db=test_db# binlog日志保留的天数，清除超过10天的日志# 防止日志文件过大，导致磁盘空间不足expire-logs-days=10 </code></pre><p>配置完成后，重启mysql：</p><pre><code class="java">service mysql restart</code></pre><p>可以通过命令行<code>show master status\G;</code>查看当前binlog日志的信息(后面有用)：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_3.png" srcset="/img/loading.gif" alt=""></p><h2 id="Slave配置"><a href="#Slave配置" class="headerlink" title="Slave配置"></a>Slave配置</h2><p>Slave配置相对简单一点。从机肯定也是一台MySQL服务器，所以和Master一样，找到/etc/my.cnf配置文件，增加以下配置：</p><pre><code class="properties"># 不要和其他mysql服务id重复即可server-id=106</code></pre><p>接着使用命令行登录到mysql服务器：</p><pre><code class="java">mysql -u root -p</code></pre><p>然后输入密码登录进去。</p><p>进入到mysql后，再输入以下命令：</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.0.104&#39;,//主机IPMASTER_USER=&#39;root&#39;,//之前创建的用户账号MASTER_PASSWORD=&#39;Java@1234&#39;,//之前创建的用户密码MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;,//master主机的binlog日志名称MASTER_LOG_POS=862,//binlog日志偏移量master_port=3306;//端口</code></pre><p>还没完，设置完之后需要启动：</p><pre><code class="java"># 启动slave服务start slave;</code></pre><p>启动完之后怎么校验是否启动成功呢？使用以下命令：</p><pre><code class="java">show slave status\G;</code></pre><p>可以看到如下信息（摘取部分关键信息）：</p><pre><code>*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.104                  Master_User: root                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000001          Read_Master_Log_Pos: 619               Relay_Log_File: mysqld-relay-bin.000001                Relay_Log_Pos: 782        Relay_Master_Log_File: mysql-bin.000001 //binlog日志文件名称             Slave_IO_Running: Yes //Slave_IO线程、SQL线程都在运行            Slave_SQL_Running: Yes             Master_Server_Id: 104 //master主机的服务id                  Master_UUID: 0ab6b3a6-e21d-11ea-aaa3-080027f8d623             Master_Info_File: /var/lib/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it           Master_Retry_Count: 86400                Auto_Position: 0</code></pre><p>另一台slave从机配置一样，不再赘述。</p><h2 id="测试主从复制"><a href="#测试主从复制" class="headerlink" title="测试主从复制"></a>测试主从复制</h2><p>在master主机执行sql：</p><pre><code class="sql">CREATE TABLE `tb_commodity_info` (  `id` varchar(32) NOT NULL,  `commodity_name` varchar(512) DEFAULT NULL COMMENT &#39;商品名称&#39;,  `commodity_price` varchar(36) DEFAULT &#39;0&#39; COMMENT &#39;商品价格&#39;,  `number` int(10) DEFAULT &#39;0&#39; COMMENT &#39;商品数量&#39;,  `description` varchar(2048) DEFAULT &#39;&#39; COMMENT &#39;商品描述&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;商品信息表&#39;;</code></pre><p>接着我们可以看到两台slave从机同步也创建了商品信息表：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_5.png" srcset="/img/loading.gif" alt=""></p><p>主从复制就完成了！java技术爱好者有点东西哦~</p><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>主从复制完成后，我们还需要实现读写分离，master负责写入数据，两台slave负责读取数据。怎么实现呢？</p><p>实现的方式有很多，以前我公司是采用AOP的方式，通过方法名判断，方法名中有get、select、query开头的则连接slave，其他的则连接master数据库。</p><p>但是通过AOP的方式实现起来代码有点繁琐，有没有什么现成的框架呢，答案是有的。</p><p>Apache ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 JDBC、Proxy两部分组成。</p><p>ShardingSphere-JDBC定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p><p>读写分离就可以使用ShardingSphere-JDBC实现。</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_6.png" srcset="/img/loading.gif" alt=""></p><p>下面演示一下SpringBoot+Mybatis+Mybatis-plus+druid+ShardingSphere-JDBC代码实现。</p><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>版本说明：</p><pre><code class="java">SpringBoot：2.0.1.RELEASEdruid：1.1.22mybatis-spring-boot-starter:1.3.2mybatis-plus-boot-starter：3.0.7sharding-jdbc-spring-boot-starter:4.1.1</code></pre><p>添加sharding-jdbc的maven配置：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;4.1.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后在application.yml添加配置：</p><pre><code class="yaml"># 这是使用druid连接池的配置，其他的连接池配置可能有所不同spring:  shardingsphere:    datasource:      names: master,slave0,slave1      master:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.jdbc.Driver        url: jdbc:mysql://192.168.0.108:3306/test_db?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT        username: yehongzhi        password: YHZ@1234      slave0:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.jdbc.Driver        url: jdbc:mysql://192.168.0.109:3306/test_db?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT        username: yehongzhi        password: YHZ@1234      slave1:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.jdbc.Driver        url: jdbc:mysql://192.168.0.110:3306/test_db?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT        username: yehongzhi        password: YHZ@1234    props:      sql.show: true    masterslave:      load-balance-algorithm-type: round_robin    sharding:      master-slave-rules:        master:          master-data-source-name: master          slave-data-source-names: slave0,slave1</code></pre><p>sharding.master-slave-rules是标明主库和从库，一定不要写错，否则写入数据到从库，就会导致无法同步。</p><p>load-balance-algorithm-type是路由策略，round_robin表示轮询策略。</p><p>启动项目，可以看到以下信息，代表配置成功：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_8.png" srcset="/img/loading.gif" alt=""></p><p>编写Controller接口：</p><pre><code class="java">    /**     * 添加商品     *     * @param commodityName  商品名称     * @param commodityPrice 商品价格     * @param description    商品价格     * @param number         商品数量     * @return boolean 是否添加成功     * @author java技术爱好者     */    @PostMapping(&quot;/insert&quot;)    public boolean insertCommodityInfo(@RequestParam(name = &quot;commodityName&quot;) String commodityName,                                       @RequestParam(name = &quot;commodityPrice&quot;) String commodityPrice,                                       @RequestParam(name = &quot;description&quot;) String description,                                       @RequestParam(name = &quot;number&quot;) Integer number) throws Exception {        return commodityInfoService.insertCommodityInfo(commodityName, commodityPrice, description, number);    }</code></pre><p>准备就绪，开始测试！</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开POSTMAN，添加商品：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_9.png" srcset="/img/loading.gif" alt=""></p><p>控制台可以看到如下信息：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_11.png" srcset="/img/loading.gif" alt=""></p><p>查询数据的话则通过slave进行：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_12.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/mysql_zcfz_13.png" srcset="/img/loading.gif" alt=""></p><p>就是这么简单！</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>尽管主从复制、读写分离能很大程度保证MySQL服务的高可用和提高整体性能，但是问题也不少：</p><ul><li><strong>从机是通过binlog日志从master同步数据的，如果在网络延迟的情况，从机就会出现数据延迟。那么就有可能出现master写入数据后，slave读取数据不一定能马上读出来</strong>。</li></ul><p>可能有人会问，有没有事务问题呢？</p><p>实际上这个框架已经想到了，我们看回之前的那个截图，有一句话是这样的：</p><p><img src="https://static.lovebilibili.com/mysql_zcfz_14.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>微信公众号已开启：【java技术爱好者】，没关注的同学记得关注哦~</p><p>我是java技术爱好者，罗定的java精英，人称 【罗ja英】</p><p>坚持原创，持续输出兼具广度和深度的技术文章。</p></blockquote><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>你的点赞是我创作的最大动力</strong>~</p><p><strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Canal+Kafka实现MySQL与Redis数据同步</title>
    <link href="/2020/08/16/Canal-Kafka%E5%AE%9E%E7%8E%B0MySQL%E4%B8%8ERedis%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
    <url>/2020/08/16/Canal-Kafka%E5%AE%9E%E7%8E%B0MySQL%E4%B8%8ERedis%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/canal_jinjie_37.png" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很多业务情况下，我们都会在系统中加入redis缓存做查询优化。</p><p>如果数据库数据发生更新，这时候就需要在业务代码中写一段同步更新redis的代码。</p><p>这种<strong>数据同步的代码跟业务代码糅合在一起会不太优雅</strong>，能不能把这些数据同步的代码抽出来形成一个独立的模块呢，答案是可以的。</p><h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p>canal是一个伪装成slave订阅mysql的binlog，实现数据同步的中间件。上一篇文章<a href="https://juejin.im/post/6859278867635388430" target="_blank" rel="noopener">《canal入门》</a></p><p>我已经介绍了最简单的使用方法，也就是tcp模式。</p><p>实际上canal是支持直接发送到MQ的，<strong>目前最新版是支持主流的三种MQ：Kafka、RocketMQ、RabbitMQ</strong>。而canal的RabbitMQ模式目前是有一定的bug，所以一般使用Kafka或者RocketMQ。</p><p><img src="https://static.lovebilibili.com/canal_jinjie_25.png" srcset="/img/loading.gif" alt=""></p><p>本文使用Kafka，实现Redis与MySQL的数据同步。架构图如下：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_26.png" srcset="/img/loading.gif" alt=""></p><p>通过架构图，我们很清晰就知道要用到的组件：MySQL、Canal、Kafka、ZooKeeper、Redis。</p><p>下面演示Kafka的搭建，MySQL搭建大家应该都会，ZooKeeper、Redis这些网上也有很多资料参考。</p><h1 id="搭建Kafka"><a href="#搭建Kafka" class="headerlink" title="搭建Kafka"></a>搭建Kafka</h1><p>首先在<a href="https://github.com/apache/kafka" target="_blank" rel="noopener">官网</a>下载安装包：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_21.png" srcset="/img/loading.gif" alt=""></p><p>解压，打开/config/server.properties配置文件，修改日志目录：</p><pre><code class="properties">log.dirs=./logs</code></pre><p>首先启动ZooKeeper，我用的是3.6.1版本：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_27.png" srcset="/img/loading.gif" alt=""></p><p>接着再启动Kafka，在Kafka的bin目录下打开cmd，输入命令：</p><pre><code class="java">kafka-server-start.bat ../../config/server.properties</code></pre><p>我们可以看到ZooKeeper上注册了Kafka相关的配置信息：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_28.png" srcset="/img/loading.gif" alt=""></p><p>然后需要创建一个队列，用于接收canal传送过来的数据，使用命令：</p><pre><code class="java">kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic canaltopic</code></pre><p>创建的队列名是<code>canaltopic</code>。</p><p><img src="https://static.lovebilibili.com/canal_jinjie_29.png" srcset="/img/loading.gif" alt=""></p><h1 id="配置Cannal-Server"><a href="#配置Cannal-Server" class="headerlink" title="配置Cannal Server"></a>配置Cannal Server</h1><p>canal<a href="https://github.com/alibaba/canal/releases" target="_blank" rel="noopener">官网</a>下载相关安装包：</p><p><img src="https://static.lovebilibili.com/pic/canal_download.png" srcset="/img/loading.gif" alt=""></p><p>找到canal.deployer-1.1.4/conf目录下的canal.properties配置文件：</p><pre><code class="properties"># tcp, kafka, RocketMQ 这里选择kafka模式canal.serverMode = kafka# 解析器的线程数，打开此配置，不打开则会出现阻塞或者不进行解析的情况canal.instance.parser.parallelThreadSize = 16# 配置MQ的服务地址，这里配置的是kafka对应的地址和端口canal.mq.servers = 127.0.0.1:9092# 配置instance，在conf目录下要有example同名的目录，可以配置多个canal.destinations = example</code></pre><p>然后配置instance，找到/conf/example/instance.properties配置文件：</p><pre><code class="properties">## mysql serverId , v1.0.26+ will autoGen(自动生成，不需配置)# canal.instance.mysql.slaveId=0# position infocanal.instance.master.address=127.0.0.1:3306# 在Mysql执行 SHOW MASTER STATUS;查看当前数据库的binlogcanal.instance.master.journal.name=mysql-bin.000006canal.instance.master.position=4596# 账号密码canal.instance.dbUsername=canalcanal.instance.dbPassword=Canal@****canal.instance.connectionCharset = UTF-8#MQ队列名称canal.mq.topic=canaltopic#单队列模式的分区下标canal.mq.partition=0</code></pre><p>配置完成后，就可以启动canal了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>这时可以打开kafka的消费者窗口，测试一下kafka是否收到消息。</p><p>使用命令进行监听消费：</p><pre><code class="java">kafka-console-consumer.bat --bootstrap-server 127.0.0.1:9092 --from-beginning --topic canaltopic</code></pre><p><strong>有个小坑</strong>。我这里使用的是win10系统的cmd命令行，win10系统默认的编码是GBK，而Canal Server是UTF-8的编码，所以控制台会出现乱码：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_30.png" srcset="/img/loading.gif" alt=""></p><p>怎么解决呢？</p><p>在cmd命令行执行前切换到UTF-8编码即可，使用命令行：chcp 65001</p><p>然后再执行打开kafka消费端的命令，就不乱码了：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_31.png" srcset="/img/loading.gif" alt=""></p><p>接下来就是启动Redis，把数据同步到Redis就完事了。</p><h1 id="封装Redis客户端"><a href="#封装Redis客户端" class="headerlink" title="封装Redis客户端"></a>封装Redis客户端</h1><p>环境搭建完成后，我们可以写代码了。</p><p>首先引入Kafka和Redis的maven依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>在application.yml文件增加以下配置：</p><pre><code class="yaml">spring:    redis:    host: 127.0.0.1    port: 6379    database: 0    password: 123456</code></pre><p>封装一个操作Redis的工具类：</p><pre><code class="java">@Componentpublic class RedisClient {    /**     * 获取redis模版     */    @Resource    private StringRedisTemplate stringRedisTemplate;    /**     * 设置redis的key-value     */    public void setString(String key, String value) {        setString(key, value, null);    }    /**     * 设置redis的key-value，带过期时间     */    public void setString(String key, String value, Long timeOut) {        stringRedisTemplate.opsForValue().set(key, value);        if (timeOut != null) {            stringRedisTemplate.expire(key, timeOut, TimeUnit.SECONDS);        }    }    /**     * 获取redis中key对应的值     */    public String getString(String key) {        return stringRedisTemplate.opsForValue().get(key);    }    /**     * 删除redis中key对应的值     */    public Boolean deleteKey(String key) {        return stringRedisTemplate.delete(key);    }}</code></pre><h1 id="创建MQ消费者进行同步"><a href="#创建MQ消费者进行同步" class="headerlink" title="创建MQ消费者进行同步"></a>创建MQ消费者进行同步</h1><p>在application.yml配置文件加上kafka的配置信息：</p><pre><code class="yaml">spring:  kafka:      # Kafka服务地址    bootstrap-servers: 127.0.0.1:9092    consumer:      # 指定一个默认的组名      group-id: consumer-group1      #序列化反序列化      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer    producer:      key-serializer: org.apache.kafka.common.serialization.StringDeserializer      value-serializer: org.apache.kafka.common.serialization.StringDeserializer      # 批量抓取      batch-size: 65536      # 缓存容量      buffer-memory: 524288</code></pre><p>根据上面Kafka消费命令那里，我们知道了json数据的结构，可以创建一个CanalBean对象进行接收：</p><pre><code class="java">public class CanalBean {    //数据    private List&lt;TbCommodityInfo&gt; data;    //数据库名称    private String database;    private long es;    //递增，从1开始    private int id;    //是否是DDL语句    private boolean isDdl;    //表结构的字段类型    private MysqlType mysqlType;    //UPDATE语句，旧数据    private String old;    //主键名称    private List&lt;String&gt; pkNames;    //sql语句    private String sql;    private SqlType sqlType;    //表名    private String table;    private long ts;    //(新增)INSERT、(更新)UPDATE、(删除)DELETE、(删除表)ERASE等等    private String type;    //getter、setter方法}</code></pre><pre><code class="java">public class MysqlType {    private String id;    private String commodity_name;    private String commodity_price;    private String number;    private String description;    //getter、setter方法}</code></pre><pre><code class="java">public class SqlType {    private int id;    private int commodity_name;    private int commodity_price;    private int number;    private int description;}</code></pre><p>最后就可以创建一个消费者CanalConsumer进行消费：</p><pre><code class="java">@Componentpublic class CanalConsumer {    //日志记录    private static Logger log = LoggerFactory.getLogger(CanalConsumer.class);    //redis操作工具类    @Resource    private RedisClient redisClient;    //监听的队列名称为：canaltopic    @KafkaListener(topics = &quot;canaltopic&quot;)    public void receive(ConsumerRecord&lt;?, ?&gt; consumer) {        String value = (String) consumer.value();        log.info(&quot;topic名称:{},key:{},分区位置:{},下标:{},value:{}&quot;, consumer.topic(), consumer.key(),consumer.partition(), consumer.offset(), value);        //转换为javaBean        CanalBean canalBean = JSONObject.parseObject(value, CanalBean.class);        //获取是否是DDL语句        boolean isDdl = canalBean.getIsDdl();        //获取类型        String type = canalBean.getType();        //不是DDL语句        if (!isDdl) {            List&lt;TbCommodityInfo&gt; tbCommodityInfos = canalBean.getData();            //过期时间            long TIME_OUT = 600L;            if (&quot;INSERT&quot;.equals(type)) {                //新增语句                for (TbCommodityInfo tbCommodityInfo : tbCommodityInfos) {                    String id = tbCommodityInfo.getId();                    //新增到redis中,过期时间是10分钟                    redisClient.setString(id, JSONObject.toJSONString(tbCommodityInfo), TIME_OUT);                }            } else if (&quot;UPDATE&quot;.equals(type)) {                //更新语句                for (TbCommodityInfo tbCommodityInfo : tbCommodityInfos) {                    String id = tbCommodityInfo.getId();                    //更新到redis中,过期时间是10分钟                    redisClient.setString(id, JSONObject.toJSONString(tbCommodityInfo), TIME_OUT);                }            } else {                //删除语句                for (TbCommodityInfo tbCommodityInfo : tbCommodityInfos) {                    String id = tbCommodityInfo.getId();                    //从redis中删除                    redisClient.deleteKey(id);                }            }        }    }}</code></pre><h1 id="测试MySQL与Redis同步"><a href="#测试MySQL与Redis同步" class="headerlink" title="测试MySQL与Redis同步"></a>测试MySQL与Redis同步</h1><p>mysql对应的表结构如下：</p><pre><code class="sql">CREATE TABLE `tb_commodity_info` (  `id` varchar(32) NOT NULL,  `commodity_name` varchar(512) DEFAULT NULL COMMENT &#39;商品名称&#39;,  `commodity_price` varchar(36) DEFAULT &#39;0&#39; COMMENT &#39;商品价格&#39;,  `number` int(10) DEFAULT &#39;0&#39; COMMENT &#39;商品数量&#39;,  `description` varchar(2048) DEFAULT &#39;&#39; COMMENT &#39;商品描述&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;商品信息表&#39;;</code></pre><p>首先在MySQL创建表。然后启动项目，接着新增一条数据：</p><pre><code class="sql">INSERT INTO `canaldb`.`tb_commodity_info` (`id`, `commodity_name`, `commodity_price`, `number`, `description`) VALUES (&#39;3e71a81fd80711eaaed600163e046cc3&#39;, &#39;叉烧包&#39;, &#39;3.99&#39;, &#39;3&#39;, &#39;又大又香的叉烧包，老人小孩都喜欢&#39;);</code></pre><p>tb_commodity_info表查到新增的数据：</p><p><img src="https://static.lovebilibili.com/canal_jinjie_32.png" srcset="/img/loading.gif" alt=""></p><p>Redis也查到了对应的数据，证明同步成功！</p><p><img src="https://static.lovebilibili.com/canal_jinjie_33.png" srcset="/img/loading.gif" alt=""></p><p>如果更新呢？试一下Update语句：</p><pre><code class="sql">UPDATE `canaldb`.`tb_commodity_info` SET `commodity_name`=&#39;青菜包&#39;,`description`=&#39;很便宜的青菜包呀，不买也开看看了喂&#39; WHERE `id`=&#39;3e71a81fd80711eaaed600163e046cc3&#39;;</code></pre><p><img src="https://static.lovebilibili.com/canal_jinjie_34.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/canal_jinjie_35.png" srcset="/img/loading.gif" alt=""></p><p>没有问题！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么你会说，canal就没有什么缺点吗？</p><p>肯定是有的：</p><ol><li>canal只能同步增量数据。</li><li>不是实时同步，是准实时同步。</li><li>存在一些bug，不过社区活跃度较高，对于提出的bug能及时修复。</li><li>MQ顺序性问题。我这里把官网的回答列出来，大家参考一下。</li></ol><p><img src="https://static.lovebilibili.com/canal_jinjie_36.png" srcset="/img/loading.gif" alt=""></p><p>尽管有一些缺点，毕竟没有一样技术或者产品是完美的，最重要是合适。</p><p>我们公司在同步MySQL数据到Elastic Search也是采用Canal+RocketMQ的方式。</p><p>参考资料：<a href="https://github.com/alibaba/canal/" target="_blank" rel="noopener">canal官网</a></p><h2 id="絮叨"><a href="#絮叨" class="headerlink" title="絮叨"></a>絮叨</h2><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>如果你觉得这篇文章对你有用，点个赞吧</strong>~</p><p><strong>你的点赞是我创作的最大动力</strong>~</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/dashacha.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>canal</tag>
      
      <tag>kafka</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超详细canal入门</title>
    <link href="/2020/08/08/%E8%B6%85%E8%AF%A6%E7%BB%86canal%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/08/%E8%B6%85%E8%AF%A6%E7%BB%86canal%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/pic/canal_processon.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>本文章已收录到个人博客网站(我爱B站)：me.lovebilibili.com</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都知道一个系统最重要的是数据，数据是保存在数据库里。但是很多时候不单止要保存在数据库中，还要同步保存到Elastic Search、HBase、Redis等等。</p><p>这时我注意到阿里开源的框架<strong>Canal</strong>，他可以很方便地<strong>同步数据库的增量数据到其他的存储应用</strong>。所以在这里总结一下，分享给各位读者参考~</p><a id="more"></a><h1 id="一、什么是canal"><a href="#一、什么是canal" class="headerlink" title="一、什么是canal"></a>一、什么是canal</h1><p>我们先看官网的介绍</p><blockquote><p>canal，译意为水道/管道/沟渠，主要用途是基于 <strong>MySQL 数据库增量日志解析</strong>，提供<strong>增量数据订阅和消费</strong>。</p></blockquote><p>这句介绍有几个关键字：<strong>增量日志，增量数据订阅和消费</strong>。</p><p>这里我们可以简单地把canal理解为一个用来<strong>同步增量数据的一个工具</strong>。</p><p>接下来我们看一张官网提供的示意图：</p><p><img src="https://static.lovebilibili.com/pic/canal_syt.png" srcset="/img/loading.gif" alt=""></p><p>canal的工作原理就是<strong>把自己伪装成MySQL slave，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议，MySQL mater收到canal发送过来的dump请求，开始推送binary log给canal，然后canal解析binary log，再发送到存储目的地</strong>，比如MySQL，Kafka，Elastic Search等等。</p><h1 id="二、canal能做什么"><a href="#二、canal能做什么" class="headerlink" title="二、canal能做什么"></a>二、canal能做什么</h1><p>以下参考<a href="https://github.com/alibaba/canal" target="_blank" rel="noopener">canal官网</a>。</p><p>与其问canal能做什么，不如说数据同步有什么作用。</p><p>但是canal的数据同步<strong>不是全量的，而是增量</strong>。基于binary log增量订阅和消费，canal可以做：</p><ul><li>数据库镜像</li><li>数据库实时备份</li><li>索引构建和实时维护</li><li>业务cache(缓存)刷新</li><li>带业务逻辑的增量数据处理</li></ul><h1 id="三、如何搭建canal"><a href="#三、如何搭建canal" class="headerlink" title="三、如何搭建canal"></a>三、如何搭建canal</h1><h2 id="3-1-首先有一个MySQL服务器"><a href="#3-1-首先有一个MySQL服务器" class="headerlink" title="3.1 首先有一个MySQL服务器"></a>3.1 首先有一个MySQL服务器</h2><p>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x</p><p>我的Linux服务器安装的MySQL服务器是5.7版本。</p><p>MySQL的安装这里就不演示了，比较简单，网上也有很多教程。</p><p>然后在MySQL中需要创建一个用户，并授权：</p><pre><code class="sql">-- 使用命令登录：mysql -u root -p-- 创建用户 用户名：canal 密码：Canal@123456create user &#39;canal&#39;@&#39;%&#39; identified by &#39;Canal@123456&#39;;-- 授权 *.*表示所有库grant SELECT, REPLICATION SLAVE, REPLICATION CLIENT on *.* to &#39;canal&#39;@&#39;%&#39; identified by &#39;Canal@123456&#39;;</code></pre><p>下一步在MySQL配置文件my.cnf设置如下信息：</p><pre><code class="yml">[mysqld]# 打开binloglog-bin=mysql-bin# 选择ROW(行)模式binlog-format=ROW# 配置MySQL replaction需要定义，不要和canal的slaveId重复server_id=1</code></pre><p>改了配置文件之后，重启MySQL，使用命令查看是否打开binlog模式：</p><p><img src="https://static.lovebilibili.com/pic/canal_1.png" srcset="/img/loading.gif" alt=""></p><p>查看binlog日志文件列表：</p><p><img src="https://static.lovebilibili.com/pic/canal_2.png" srcset="/img/loading.gif" alt=""></p><p>查看当前正在写入的binlog文件：</p><p><img src="https://static.lovebilibili.com/pic/canal_3.png" srcset="/img/loading.gif" alt=""></p><p>MySQL服务器这边就搞定了，很简单。</p><h2 id="3-2-安装canal"><a href="#3-2-安装canal" class="headerlink" title="3.2 安装canal"></a>3.2 安装canal</h2><p>去官网下载页面进行下载：<a href="https://github.com/alibaba/canal/releases" target="_blank" rel="noopener">https://github.com/alibaba/canal/releases</a></p><p>我这里下载的是1.1.4的版本：<br><img src="https://static.lovebilibili.com/pic/canal_download.png" srcset="/img/loading.gif" alt=""></p><p>解压<strong>canal.deployer-1.1.4.tar.gz</strong>，我们可以看到里面有四个文件夹：</p><p><img src="https://static.lovebilibili.com/pic/tar_one.png" srcset="/img/loading.gif" alt=""></p><p>接着打开配置文件conf/example/instance.properties，配置信息如下：</p><pre><code class="properties">## mysql serverId , v1.0.26+ will autoGen## v1.0.26版本后会自动生成slaveId，所以可以不用配置# canal.instance.mysql.slaveId=0# 数据库地址canal.instance.master.address=127.0.0.1:3306# binlog日志名称canal.instance.master.journal.name=mysql-bin.000001# mysql主库链接时起始的binlog偏移量canal.instance.master.position=154# mysql主库链接时起始的binlog的时间戳canal.instance.master.timestamp=canal.instance.master.gtid=# username/password# 在MySQL服务器授权的账号密码canal.instance.dbUsername=canalcanal.instance.dbPassword=Canal@123456# 字符集canal.instance.connectionCharset = UTF-8# enable druid Decrypt database passwordcanal.instance.enableDruid=false# table regex .*\\..*表示监听所有表 也可以写具体的表名，用，隔开canal.instance.filter.regex=.*\\..*# mysql 数据解析表的黑名单，多个表用，隔开canal.instance.filter.black.regex=</code></pre><p>我这里用的是win10系统，所以在bin目录下找到startup.bat启动：</p><p>启动就报错，坑呀：</p><p><img src="https://static.lovebilibili.com/pic/canal_4.png" srcset="/img/loading.gif" alt=""></p><p>要修改一下启动的脚本startup.bat：</p><p><img src="https://static.lovebilibili.com/pic/canal_5.png" srcset="/img/loading.gif" alt=""></p><p>然后再启动脚本：</p><p><img src="https://static.lovebilibili.com/pic/canal_6.png" srcset="/img/loading.gif" alt=""></p><p>这就启动成功了。</p><h1 id="Java客户端操作"><a href="#Java客户端操作" class="headerlink" title="Java客户端操作"></a>Java客户端操作</h1><p>首先引入maven依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt;    &lt;artifactId&gt;canal.client&lt;/artifactId&gt;    &lt;version&gt;1.1.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后创建一个canal项目，使用SpringBoot构建，如图所示：</p><p><img src="https://static.lovebilibili.com/pic/canal_8.png" srcset="/img/loading.gif" alt=""></p><p>在CannalClient类使用Spring Bean的生命周期函数afterPropertiesSet()：</p><pre><code class="java">@Componentpublic class CannalClient implements InitializingBean {    private final static int BATCH_SIZE = 1000;    @Override    public void afterPropertiesSet() throws Exception {        // 创建链接        CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(&quot;127.0.0.1&quot;, 11111), &quot;example&quot;, &quot;&quot;, &quot;&quot;);        try {            //打开连接            connector.connect();            //订阅数据库表,全部表            connector.subscribe(&quot;.*\\..*&quot;);            //回滚到未进行ack的地方，下次fetch的时候，可以从最后一个没有ack的地方开始拿            connector.rollback();            while (true) {                // 获取指定数量的数据                Message message = connector.getWithoutAck(BATCH_SIZE);                //获取批量ID                long batchId = message.getId();                //获取批量的数量                int size = message.getEntries().size();                //如果没有数据                if (batchId == -1 || size == 0) {                    try {                        //线程休眠2秒                        Thread.sleep(2000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                } else {                    //如果有数据,处理数据                    printEntry(message.getEntries());                }                //进行 batch id 的确认。确认之后，小于等于此 batchId 的 Message 都会被确认。                connector.ack(batchId);            }        } catch (Exception e) {            e.printStackTrace();        } finally {            connector.disconnect();        }    }    /**     * 打印canal server解析binlog获得的实体类信息     */    private static void printEntry(List&lt;Entry&gt; entrys) {        for (Entry entry : entrys) {            if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) {                //开启/关闭事务的实体类型，跳过                continue;            }            //RowChange对象，包含了一行数据变化的所有特征            //比如isDdl 是否是ddl变更操作 sql 具体的ddl sql beforeColumns afterColumns 变更前后的数据字段等等            RowChange rowChage;            try {                rowChage = RowChange.parseFrom(entry.getStoreValue());            } catch (Exception e) {                throw new RuntimeException(&quot;ERROR ## parser of eromanga-event has an error , data:&quot; + entry.toString(), e);            }            //获取操作类型：insert/update/delete类型            EventType eventType = rowChage.getEventType();            //打印Header信息            System.out.println(String.format(&quot;================》; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;,                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),                    eventType));            //判断是否是DDL语句            if (rowChage.getIsDdl()) {                System.out.println(&quot;================》;isDdl: true,sql:&quot; + rowChage.getSql());            }            //获取RowChange对象里的每一行数据，打印出来            for (RowData rowData : rowChage.getRowDatasList()) {                //如果是删除语句                if (eventType == EventType.DELETE) {                    printColumn(rowData.getBeforeColumnsList());                    //如果是新增语句                } else if (eventType == EventType.INSERT) {                    printColumn(rowData.getAfterColumnsList());                    //如果是更新的语句                } else {                    //变更前的数据                    System.out.println(&quot;-------&gt;; before&quot;);                    printColumn(rowData.getBeforeColumnsList());                    //变更后的数据                    System.out.println(&quot;-------&gt;; after&quot;);                    printColumn(rowData.getAfterColumnsList());                }            }        }    }    private static void printColumn(List&lt;Column&gt; columns) {        for (Column column : columns) {            System.out.println(column.getName() + &quot; : &quot; + column.getValue() + &quot;    update=&quot; + column.getUpdated());        }    }}</code></pre><p>以上就完成了Java客户端的代码。这里不做具体的处理，仅仅是打印，先有个直观的感受。</p><p>最后我们开始测试，首先启动MySQL、Canal Server，还有刚刚写的Spring Boot项目。然后创建表：</p><pre><code class="sql">CREATE TABLE `tb_commodity_info` (  `id` varchar(32) NOT NULL,  `commodity_name` varchar(512) DEFAULT NULL COMMENT &#39;商品名称&#39;,  `commodity_price` varchar(36) DEFAULT &#39;0&#39; COMMENT &#39;商品价格&#39;,  `number` int(10) DEFAULT &#39;0&#39; COMMENT &#39;商品数量&#39;,  `description` varchar(2048) DEFAULT &#39;&#39; COMMENT &#39;商品描述&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;商品信息表&#39;;</code></pre><p>然后我们在控制台就可以看到如下信息：</p><p><img src="https://static.lovebilibili.com/pic/canal_10.png" srcset="/img/loading.gif" alt=""></p><p>如果新增一条数据到表中：</p><pre><code class="sql">INSERT INTO tb_commodity_info VALUES(&#39;3e71a81fd80711eaaed600163e046cc3&#39;,&#39;叉烧包&#39;,&#39;3.99&#39;,3,&#39;又大又香的叉烧包，老人小孩都喜欢&#39;);</code></pre><p>控制台可以看到如下信息：</p><p><img src="https://static.lovebilibili.com/pic/canal_11.png" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>canal的好处在于<strong>对业务代码没有侵入</strong>，因为是<strong>基于监听binlog日志去进行同步数据的</strong>。实时性也能做到准实时，其实是很多企业一种比较常见的数据同步的方案。</p><p>通过上面的学习之后，我们应该都明白canal是什么，它的原理，还有用法。实际上这仅仅只是入门，因为实际项目中我们不是这样玩的…</p><p>实际项目我们是<strong>配置MQ模式，配合RocketMQ或者Kafka，canal会把数据发送到MQ的topic中，然后通过消息队列的消费者进行处理</strong>。</p><p><img src="https://static.lovebilibili.com/pic/canal_12.png" srcset="/img/loading.gif" alt=""></p><p>Canal的部署也是支持集群的，需要配合ZooKeeper进行集群管理。</p><p>Canal还有一个简单的Web管理界面。</p><p>下一篇就讲一下<strong>集群部署Canal，配合使用Kafka，同步数据到Redis</strong>。</p><p>参考资料：<a href="https://github.com/alibaba/canal" target="_blank" rel="noopener">Canal官网</a></p><h2 id="絮叨"><a href="#絮叨" class="headerlink" title="絮叨"></a>絮叨</h2><p>上面所有例子的代码都上传Github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>如果你觉得这篇文章对你有用，点个赞吧</strong>~</p><p><strong>你的点赞是我创作的最大动力</strong>~</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzMwLzE3MzA1Y2MwOGE3ZWQ1ZDc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>canal</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ如何防止消息丢失</title>
    <link href="/2020/08/08/RabbitMQ%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"/>
    <url>/2020/08/08/RabbitMQ%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://img-blog.csdnimg.cn/20200802232920896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="一、分析数据丢失的原因"><a href="#一、分析数据丢失的原因" class="headerlink" title="一、分析数据丢失的原因"></a>一、分析数据丢失的原因</h1><p>分析RabbitMQ消息丢失的情况，不妨先看看一条消息从生产者发送到消费者消费的过程：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1Yzc2OTVkMDE5MjE?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>可以看出，一条消息整个过程要经历两次的网络传输：<strong>从生产者发送到RabbitMQ服务器，从RabbitMQ服务器发送到消费者</strong>。</p><a id="more"></a><p><strong>在消费者未消费前存储在队列(Queue)中</strong>。</p><p>所以可以知道，有三个场景下是会发生消息丢失的：</p><ul><li>存储在队列中，如果队列没有对消息持久化，RabbitMQ服务器宕机重启会丢失数据。</li><li>生产者发送消息到RabbitMQ服务器过程中，RabbitMQ服务器如果宕机停止服务，消息会丢失。</li><li>消费者从RabbitMQ服务器获取队列中存储的数据消费，但是消费者程序出错或者宕机而没有正确消费，导致数据丢失。</li></ul><p>针对以上三种场景，RabbitMQ提供了三种解决的方式，分别是消息持久化，confirm机制，ACK事务机制。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1ZDVhNjQ1YzNkNDc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><h1 id="二、消息持久化"><a href="#二、消息持久化" class="headerlink" title="二、消息持久化"></a>二、消息持久化</h1><p>RabbitMQ是支持消息持久化的，消息持久化需要设置：Exchange为持久化和Queue持久化，这样当消息发送到RabbitMQ服务器时，消息就会持久化。</p><p>首先看Exchange交换机的类图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1ZjY3MTUyNmVkMmQ?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>看这个类图其实是要说明上一篇文章介绍的四种交换机都是AbstractExchange抽象类的子类，所以根据java的特性，<strong>创建子类的实例会先调用父类的构造器</strong>，父类也就是AbstractExchange的构造器是怎么样的呢？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI4LzE3Mzk1ZjhjMGQ1YzhlNTE?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>从上面的注释可以看到<strong>durable参数表示是否持久化。默认是持久化(true)</strong>。创建持久化的Exchange可以这样写：</p><pre><code class="java">    @Bean    public DirectExchange rabbitmqDemoDirectExchange() {        //Direct交换机        return new DirectExchange(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, true, false);    }</code></pre><p>接着是Queue队列，我们先看看Queue的构造器是怎么样的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC9lNTA3ZmU0OTExNWE0MTk5YTFhNjg2ZDIwNWM5OWRlY350cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><p>也是通过durable参数设置是否持久化，默认是true。所以创建时可以不指定：</p><pre><code class="java">    @Bean    public Queue fanoutExchangeQueueA() {        //只需要指定名称，默认是持久化的        return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A);    }</code></pre><p>这就完成了消息持久化的设置，接下来启动项目，发送几条消息，我们可以看到：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC8zNWFmZjJkNmE0YzU0YjFjYmQ4ODk1NTM2NTExOTAwYn50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""><br>怎么证明是已经持久化了呢，实际上可以找到对应的文件：<br><img src="https://img-blog.csdnimg.cn/20200801205656332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>找到对应磁盘中的目录：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC80NmU1NDIxNTYwM2U0MmIyODI4ODlhYTQxYTVhNjFiOH50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""><br><strong>消息持久化可以防止消息在RabbitMQ Server中不会因为宕机重启而丢失</strong>。</p><h1 id="三、消息确认机制"><a href="#三、消息确认机制" class="headerlink" title="三、消息确认机制"></a>三、消息确认机制</h1><h2 id="3-1-confirm机制"><a href="#3-1-confirm机制" class="headerlink" title="3.1 confirm机制"></a>3.1 confirm机制</h2><p><strong>在生产者发送到RabbitMQ Server时有可能因为网络问题导致投递失败，从而丢失数据</strong>。我们可以使用confirm模式防止数据丢失。工作流程是怎么样的呢，看以下图解：<br><img src="https://img-blog.csdnimg.cn/20200801210244345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>从上图中可以看到是通过两个回调函数<strong>confirm()、returnedMessage()</strong>进行通知。</p><p>一条消息从生产者发送到RabbitMQ，首先会发送到Exchange，对应回调函数<strong>confirm()</strong>。第二步从Exchange路由分配到Queue中，对应回调函数则是<strong>returnedMessage()</strong>。</p><p>代码怎么实现呢，请看演示：</p><p>首先在<strong>application.yml</strong>配置文件中加上如下配置：</p><pre><code class="yml">spring:  rabbitmq:    publisher-confirms: true#    publisher-returns: true    template:      mandatory: true# publisher-confirms：设置为true时。当消息投递到Exchange后，会回调confirm()方法进行通知生产者# publisher-returns：设置为true时。当消息匹配到Queue并且失败时，会通过回调returnedMessage()方法返回消息# spring.rabbitmq.template.mandatory: 设置为true时。指定消息在没有被队列接收时会通过回调returnedMessage()方法退回。</code></pre><p>有个小细节，<strong>publisher-returns和mandatory如果都设置的话，优先级是以mandatory优先</strong>。可以看源码：<br><img src="https://img-blog.csdnimg.cn/20200801212504531.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>接着我们需要定义回调方法：</p><pre><code class="java">@Componentpublic class RabbitmqConfirmCallback implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnCallback {    private Logger logger = LoggerFactory.getLogger(RabbitmqConfirmCallback.class);    /**     * 监听消息是否到达Exchange     *     * @param correlationData 包含消息的唯一标识的对象     * @param ack             true 标识 ack，false 标识 nack     * @param cause           nack 投递失败的原因     */    @Override    public void confirm(CorrelationData correlationData, boolean ack, String cause) {        if (ack) {            logger.info(&quot;消息投递成功~消息Id：{}&quot;, correlationData.getId());        } else {            logger.error(&quot;消息投递失败，Id：{}，错误提示：{}&quot;, correlationData.getId(), cause);        }    }    @Override    public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {        logger.info(&quot;消息没有路由到队列，获得返回的消息&quot;);        Map map = byteToObject(message.getBody(), Map.class);        logger.info(&quot;message body: {}&quot;, map == null ? &quot;&quot; : map.toString());        logger.info(&quot;replyCode: {}&quot;, replyCode);        logger.info(&quot;replyText: {}&quot;, replyText);        logger.info(&quot;exchange: {}&quot;, exchange);        logger.info(&quot;routingKey: {}&quot;, exchange);        logger.info(&quot;------------&gt; end &lt;------------&quot;);    }    @SuppressWarnings(&quot;unchecked&quot;)    private &lt;T&gt; T byteToObject(byte[] bytes, Class&lt;T&gt; clazz) {        T t;        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);             ObjectInputStream ois = new ObjectInputStream(bis)) {            t = (T) ois.readObject();        } catch (Exception e) {            e.printStackTrace();            return null;        }        return t;    }}</code></pre><p>我这里就简单地打印回调方法返回的消息，在实际项目中，可以把返回的消息存储到日志表中，使用定时任务进行进一步的处理。</p><p>我这里是使用<strong>RabbitTemplate</strong>进行发送，所以在Service层的RabbitTemplate需要设置一下：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    @Resource    private RabbitmqConfirmCallback rabbitmqConfirmCallback;    @Resource    private RabbitTemplate rabbitTemplate;    @PostConstruct    public void init() {        //指定 ConfirmCallback        rabbitTemplate.setConfirmCallback(rabbitmqConfirmCallback);        //指定 ReturnCallback        rabbitTemplate.setReturnCallback(rabbitmqConfirmCallback);    }    @Override    public String sendMsg(String msg) throws Exception {        Map&lt;String, Object&gt; message = getMessage(msg);        try {            CorrelationData correlationData = (CorrelationData) message.remove(&quot;correlationData&quot;);            rabbitTemplate.convertAndSend(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING, message, correlationData);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }    private Map&lt;String, Object&gt; getMessage(String msg) {        String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32);        CorrelationData correlationData = new CorrelationData(msgId);        String sendTime = sdf.format(new Date());        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msgId&quot;, msgId);        map.put(&quot;sendTime&quot;, sendTime);        map.put(&quot;msg&quot;, msg);        map.put(&quot;correlationData&quot;, correlationData);        return map;    }}</code></pre><p>大功告成！接下来我们进行测试，发送一条消息，我们可以控制台：<br><img src="https://img-blog.csdnimg.cn/20200801214001880.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>假设发送一条信息没有路由匹配到队列，可以看到如下信息：<br><img src="https://img-blog.csdnimg.cn/20200801214142468.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这就是confirm模式。它的作用是<strong>为了保障生产者投递消息到RabbitMQ不会出现消息丢失</strong>。</p><h2 id="3-2-事务机制-ACK"><a href="#3-2-事务机制-ACK" class="headerlink" title="3.2 事务机制(ACK)"></a>3.2 事务机制(ACK)</h2><p>最开始的那张图已经讲过，<strong>消费者从队列中获取到消息后，会直接确认签收，假设消费者宕机或者程序出现异常，数据没有正常消费，这种情况就会出现数据丢失</strong>。</p><p>所以关键在于把自动签收改成手动签收，正常消费则返回确认签收，如果出现异常，则返回拒绝签收重回队列。<br><img src="https://img-blog.csdnimg.cn/20200801215323179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>代码怎么实现呢，请看演示：</p><p>首先在消费者的<strong>application.yml</strong>文件中设置事务提交为<strong>manual</strong>手动模式：</p><pre><code class="yml">spring:  rabbitmq:    listener:      simple:        acknowledge-mode: manual # 手动ack模式        concurrency: 1 # 最少消费者数量        max-concurrency: 10 # 最大消费者数量</code></pre><p>然后编写消费者的监听器：</p><pre><code class="java">@Componentpublic class RabbitDemoConsumer {    enum Action {        //处理成功        SUCCESS,        //可以重试的错误，消息重回队列        RETRY,        //无需重试的错误，拒绝消息，并从队列中删除        REJECT    }    @RabbitHandler    @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC))    public void process(String msg, Message message, Channel channel) {        long tag = message.getMessageProperties().getDeliveryTag();        Action action = Action.SUCCESS;        try {            System.out.println(&quot;消费者RabbitDemoConsumer从RabbitMQ服务端消费消息：&quot; + msg);            if (&quot;bad&quot;.equals(msg)) {                throw new IllegalArgumentException(&quot;测试：抛出可重回队列的异常&quot;);            }            if (&quot;error&quot;.equals(msg)) {                throw new Exception(&quot;测试：抛出无需重回队列的异常&quot;);            }        } catch (IllegalArgumentException e1) {            e1.printStackTrace();            //根据异常的类型判断，设置action是可重试的，还是无需重试的            action = Action.RETRY;        } catch (Exception e2) {            //打印异常            e2.printStackTrace();            //根据异常的类型判断，设置action是可重试的，还是无需重试的            action = Action.REJECT;        } finally {            try {                if (action == Action.SUCCESS) {                    //multiple 表示是否批量处理。true表示批量ack处理小于tag的所有消息。false则处理当前消息                    channel.basicAck(tag, false);                } else if (action == Action.RETRY) {                    //Nack，拒绝策略，消息重回队列                    channel.basicNack(tag, false, true);                } else {                    //Nack，拒绝策略，并且从队列中删除                    channel.basicNack(tag, false, false);                }                channel.close();            } catch (Exception e) {                e.printStackTrace();            }        }    }}</code></pre><p>解释一下上面的代码，如果没有异常，则手动确认回复RabbitMQ服务端basicAck(消费成功)。</p><p>如果抛出某些可以重回队列的异常，我们就回复basicNack并且设置重回队列。</p><p>如果是抛出不可重回队列的异常，就回复basicNack并且设置从RabbitMQ的队列中删除。</p><p>接下来进行测试，发送一条普通的消息”hello”：<br><img src="https://img-blog.csdnimg.cn/20200802215129880.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>解释一下ack返回的三个方法的意思。</p><p>①成功确认</p><pre><code class="java">void basicAck(long deliveryTag, boolean multiple) throws IOException;</code></pre><p>消费者成功处理后调用此方法对消息进行确认。</p><ul><li>deliveryTag：该消息的index</li><li>multiple：是否批量.。true：将一次性ack所有小于deliveryTag的消息。</li></ul><p>②失败确认</p><pre><code class="java">void basicNack(long deliveryTag, boolean multiple, boolean requeue) throws IOException;</code></pre><ul><li>deliveryTag：该消息的index。</li><li>multiple：是否批量。true：将一次性拒绝所有小于deliveryTag的消息。</li><li>requeue：被拒绝的是否重新入队列。</li></ul><p>③失败确认</p><pre><code class="java">void basicReject(long deliveryTag, boolean requeue) throws IOException;</code></pre><ul><li>deliveryTag:该消息的index。</li><li>requeue：被拒绝的是否重新入队列。</li></ul><p>basicNack()和basicReject()的区别在于：<strong>basicNack()可以批量拒绝，basicReject()一次只能拒接一条消息</strong>。</p><h1 id="四、遇到的坑"><a href="#四、遇到的坑" class="headerlink" title="四、遇到的坑"></a>四、遇到的坑</h1><h2 id="4-1-启用nack机制后，导致的死循环"><a href="#4-1-启用nack机制后，导致的死循环" class="headerlink" title="4.1 启用nack机制后，导致的死循环"></a>4.1 启用nack机制后，导致的死循环</h2><p>上面的代码我故意写了一个bug。测试发送一条”bad”，然后会抛出重回队列的异常。这就有个问题：重回队列后消费者又消费，消费抛出异常又重回队列，就造成了死循环。<br><img src="https://img-blog.csdnimg.cn/20200802215521688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>那怎么避免这种情况呢？</p><p>既然nack会造成死循环的话，我提供的一个思路是<strong>不使用basicNack()，把抛出异常的消息落库到一张表中，记录抛出的异常，消息体，消息Id。通过定时任务去处理</strong>。</p><p>如果你有什么好的解决方案，也可以留言讨论~</p><h2 id="4-2-double-ack"><a href="#4-2-double-ack" class="headerlink" title="4.2 double ack"></a>4.2 double ack</h2><p>有的时候比较粗心，不小心开启了自动Ack模式，又手动回复了Ack。那就会报这个错误：</p><pre><code class="java">消费者RabbitDemoConsumer从RabbitMQ服务端消费消息：java技术爱好者2020-08-02 22:52:42.148 ERROR 4880 --- [ 127.0.0.1:5672] o.s.a.r.c.CachingConnectionFactory       : Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - unknown delivery tag 1, class-id=60, method-id=80)2020-08-02 22:52:43.102  INFO 4880 --- [cTaskExecutor-1] o.s.a.r.l.SimpleMessageListenerContainer : Restarting Consumer@f4a3a8d: tags=[{amq.ctag-8MJeQ7el_PNbVJxGOOw7Rw=rabbitmq.demo.topic}], channel=Cached Rabbit Channel: AMQChannel(amqp://guest@127.0.0.1:5672/,5), conn: Proxy@782a1679 Shared Rabbit Connection: SimpleConnection@67c5b175 [delegate=amqp://guest@127.0.0.1:5672/, localPort= 56938], acknowledgeMode=AUTO local queue size=0</code></pre><p>出现这个错误，可以检查一下yml文件是否添加了以下配置：</p><pre><code class="yml">spring:  rabbitmq:    listener:      simple:        acknowledge-mode: manual        concurrency: 1        max-concurrency: 10</code></pre><p>如果上面这个配置已经添加了，还是报错，<strong>有可能你使用@Configuration配置了SimpleRabbitListenerContainerFactory，根据SpringBoot的特性，代码优于配置，代码的配置覆盖了yml的配置，并且忘记设置手动manual模式</strong>：</p><pre><code class="java">@Bean    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) {        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();        factory.setConnectionFactory(connectionFactory);        //设置手动ack模式        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);        return factory;    }</code></pre><p>如果你还是有报错，那可能是写错地方了，写在生产者的项目了。以上的配置应该配置在消费者的项目。因为ack模式是针对消费者而言的。我就是写错了，写在生产者，折腾了几个小时，泪目~</p><h2 id="4-3-性能问题"><a href="#4-3-性能问题" class="headerlink" title="4.3 性能问题"></a>4.3 性能问题</h2><p>其实手动ACK相对于自动ACK肯定是会慢很多，我在网上查了一些资料，性能相差大概有10倍。所以一般在实际应用中不太建议开手动ACK模式。不过也不是绝对不可以开，具体情况具体分析，看并发量，还有数据的重要性等等。</p><p>所以<strong>在实际项目中还需要权衡一下并发量和数据的重要性，再决定具体的方案</strong>。</p><h2 id="4-4-启用手动ack模式，如果没有及时回复，会造成队列异常"><a href="#4-4-启用手动ack模式，如果没有及时回复，会造成队列异常" class="headerlink" title="4.4 启用手动ack模式，如果没有及时回复，会造成队列异常"></a>4.4 启用手动ack模式，如果没有及时回复，会造成队列异常</h2><p>如果开启了手动ACK模式，但是由于代码有bug的原因，没有回复RabbitMQ服务端，那么这条消息就会放到Unacked状态的消息堆里，只有等到消费者的连接断开才会转到Ready消息。如果消费者一直没有断开连接，那Unacked的消息就会越来越多，占用内存就越来越大，最后就会出现异常。</p><p>这个问题，我没法用我的电脑演示，我的电脑太卡了。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>通过上面的学习后，总结了RabbitMQ防止数据丢失有三种方式：</p><ul><li>消息持久化</li><li>生产者消息确认机制(confirm模式)</li><li>消费者消息确认模式(ack模式)</li></ul><p>上面所有例子的代码都上传github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>如果你觉得这篇文章对你有用，点个赞吧</strong>~</p><p><strong>你的点赞是我创作的最大动力</strong>~</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzMwLzE3MzA1Y2MwOGE3ZWQ1ZDc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ入门</title>
    <link href="/2020/08/08/RabbitMQ%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/08/RabbitMQ%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/26/17389a94030dbf28?w=729&h=515&f=png&s=44034" srcset="/img/loading.gif" alt=""></p><h1 id="一、什么是消息队列"><a href="#一、什么是消息队列" class="headerlink" title="一、什么是消息队列"></a>一、什么是消息队列</h1><p><strong>消息</strong>指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。</p><p><strong>“消息队列(Message Queue)”是在消息的传输过程中保存消息的容器</strong>。在消息队列中，通常有生产者和消费者两个角色。生产者只负责发送数据到消息队列，谁从消息队列中取出数据处理，他不管。消费者只负责从消息队列中取出数据处理，他不管这是谁发送的数据。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/1736753c4753c6f9?w=436&h=93&f=png&s=8826" srcset="/img/loading.gif" alt=""></p><h1 id="二、为什么使用消息队列"><a href="#二、为什么使用消息队列" class="headerlink" title="二、为什么使用消息队列"></a>二、为什么使用消息队列</h1><p>主要有三个作用：</p><ul><li><strong>解耦</strong>。如图所示。假设有系统B、C、D都需要系统A的数据，于是系统A调用三个方法发送数据到B、C、D。这时，系统D不需要了，那就需要在系统A把相关的代码删掉。假设这时有个新的系统E需要数据，这时系统A又要增加调用系统E的代码。为了降低这种强耦合，就可以使用MQ，<strong>系统A只需要把数据发送到MQ，其他系统如果需要数据，则从MQ中获取即可</strong>。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/173678c7a81cc1c0?w=589&h=254&f=png&s=20463" srcset="/img/loading.gif" alt=""></p><ul><li>异步。如图所示。一个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是800ms。<strong>如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能</strong>。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用MQ。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/17367945a8c4df73?w=570&h=264&f=png&s=13623" srcset="/img/loading.gif" alt=""></p><ul><li>削峰。如图所示。这其实是MQ一个很重要的应用。假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。<strong>如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃</strong>。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/17367a9d902cca4f?w=759&h=335&f=png&s=34834" srcset="/img/loading.gif" alt=""></p><h1 id="三、RabbitMQ的特点"><a href="#三、RabbitMQ的特点" class="headerlink" title="三、RabbitMQ的特点"></a>三、RabbitMQ的特点</h1><p>RabbitMQ是一款使用Erlang语言开发的，实现AMQP(高级消息队列协议)的开源消息中间件。首先要知道一些RabbitMQ的特点，<a href="https://www.rabbitmq.com" target="_blank" rel="noopener">官网</a>可查：</p><ul><li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li><li>灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li><li>支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li><li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li><li>可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li><li>插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li></ul><h1 id="四、RabbitMQ初の体验"><a href="#四、RabbitMQ初の体验" class="headerlink" title="四、RabbitMQ初の体验"></a>四、RabbitMQ初の体验</h1><h2 id="4-1-安装RabbitMQ-Win10系统"><a href="#4-1-安装RabbitMQ-Win10系统" class="headerlink" title="4.1 安装RabbitMQ (Win10系统)"></a>4.1 安装RabbitMQ (Win10系统)</h2><p>由于只是学习需要，所以安装在win10系统，就懒得开虚拟机。如果用Linux系统安装的话，我建议用Docker拉一个RabbitMQ的镜像下来，这样会方便一点。</p><h3 id="4-1-1-安装erLang语言，配置环境变量"><a href="#4-1-1-安装erLang语言，配置环境变量" class="headerlink" title="4.1.1 安装erLang语言，配置环境变量"></a>4.1.1 安装erLang语言，配置环境变量</h3><p>首先到erlang<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">官网</a>下载win10版安装包。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b11e8ce24fc?w=610&h=383&f=png&s=42809" srcset="/img/loading.gif" alt=""></p><p>下载完之后，就得到这个东西：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b35ca09e258?w=120&h=152&f=png&s=3625" srcset="/img/loading.gif" alt=""></p><p>接着双击安装，一直点next(下一步)就行了，安装完之后，配置环境变量。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b5796ccda18?w=648&h=176&f=png&s=12500" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b63e3dd7f73?w=591&h=312&f=png&s=28042" srcset="/img/loading.gif" alt=""></p><p>使用cmd命令，输入 erl -version 验证：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371bac494381d6?w=475&h=50&f=png&s=2778" srcset="/img/loading.gif" alt=""></p><h3 id="4-1-2-安装RabbitMQ服务端"><a href="#4-1-2-安装RabbitMQ服务端" class="headerlink" title="4.1.2 安装RabbitMQ服务端"></a>4.1.2 安装RabbitMQ服务端</h3><p>在RabbitMQ的<a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.3" target="_blank" rel="noopener">gitHub项目</a>中，下载window版本的服务端安装包。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371bf868e203f4?w=394&h=169&f=png&s=19585" srcset="/img/loading.gif" alt=""></p><p>下载后，就得到这个东西：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371c1d6501ab40?w=117&h=153&f=png&s=3533" srcset="/img/loading.gif" alt=""></p><p>接着到双击安装，一直点下一步安装即可，安装完成后，找到安装目录：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371c5bccf4f9d5?w=618&h=280&f=png&s=40338" srcset="/img/loading.gif" alt=""></p><p>在此目录下打开cmd命令，输入rabbitmq-plugins enable rabbitmq_management命令安装管理页面的插件：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371c7989899657?w=718&h=161&f=png&s=11588" srcset="/img/loading.gif" alt=""></p><p>然后双击rabbitmq-server.bat启动脚本，然后打开服务管理可以看到RabbitMQ正在运行：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371ca5f47fce8b?w=1176&h=332&f=png&s=95743" srcset="/img/loading.gif" alt=""></p><p>这时，打开浏览器输入<code>http://localhost:15672</code>，账号密码默认是：guest/guest</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371cb642afc306?w=379&h=170&f=png&s=8715" srcset="/img/loading.gif" alt=""></p><p>到这一步，安装就大功告成了！</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371cc62006368a?w=1296&h=506&f=png&s=65917" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-永远的Hello-Word"><a href="#4-2-永远的Hello-Word" class="headerlink" title="4.2 永远的Hello Word"></a>4.2 永远的Hello Word</h2><p>服务端搭建好了之后肯定要用客户端去操作，接下来就用Java做一个简单的HelloWord演示。</p><p>因为我用的是SpringBoot，所以在<strong>生产者这边</strong>加入对应的starter依赖即可：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>一般需要创建一个公共项目common，共享一些配置，比如队列主题，交换机名称，路由匹配键名称等等。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376a8962ac345e?w=1187&h=422&f=png&s=87972" srcset="/img/loading.gif" alt=""></p><p>首先在application.yml文件加上RabbitMQ的配置信息：</p><pre><code class="yml">spring:    rabbitmq:        host: 127.0.0.1        port: 5672        username: guest        password: guest</code></pre><p>然后在生产者这边，加上common包的maven依赖，然后创建一个Direct交换机以及队列的配置类：</p><pre><code class="java">@Configurationpublic class DirectRabbitConfig {    @Bean    public Queue rabbitmqDemoDirectQueue() {        /**         * 1、name:    队列名称         * 2、durable: 是否持久化         * 3、exclusive: 是否独享、排外的。如果设置为true，定义为排他队列。则只有创建者可以使用此队列。也就是private私有的。         * 4、autoDelete: 是否自动删除。也就是临时队列。当最后一个消费者断开连接后，会自动删除。         * */        return new Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC, true, false, false);    }    @Bean    public DirectExchange rabbitmqDemoDirectExchange() {        //Direct交换机        return new DirectExchange(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, true, false);    }    @Bean    public Binding bindDirect() {        //链式写法，绑定交换机和队列，并设置匹配键        return BindingBuilder                //绑定队列                .bind(rabbitmqDemoDirectQueue())                //到交换机                .to(rabbitmqDemoDirectExchange())                //并设置匹配键                .with(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING);    }}</code></pre><p>然后再创建一个发送消息的Service类：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    //日期格式化    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    @Resource    private RabbitTemplate rabbitTemplate;    @Override    public String sendMsg(String msg) throws Exception {        try {            String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32);            String sendTime = sdf.format(new Date());            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();            map.put(&quot;msgId&quot;, msgId);            map.put(&quot;sendTime&quot;, sendTime);            map.put(&quot;msg&quot;, msg);            rabbitTemplate.convertAndSend(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING, map);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }}</code></pre><p>然后根据业务放在需要用的地方，比如定时任务，或者接口。我这里就简单一点使用Controller层进行发送：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    @Resource    private RabbitMQService rabbitMQService;    /**     * 发送消息     * @author java技术爱好者     */    @PostMapping(&quot;/sendMsg&quot;)    public String sendMsg(@RequestParam(name = &quot;msg&quot;) String msg) throws Exception {        return rabbitMQService.sendMsg(msg);    }}</code></pre><p>生产者写完之后，就写消费者端的代码，消费者很简单。maven依赖，yml文件配置和生产者一样。只需要创建一个类，@RabbitListener注解写上监听队列的名称，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376b4781b8bd8a?w=1198&h=380&f=png&s=66605" srcset="/img/loading.gif" alt=""></p><p><strong>这里有个小坑</strong>，一开始RabbitMQ服务器里还没有创建队列：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bcd4d88602d?w=628&h=287&f=png&s=18084" srcset="/img/loading.gif" alt=""></p><p>这时如果启动消费者，会报错：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bd6f8340df0?w=1241&h=128&f=png&s=34738" srcset="/img/loading.gif" alt=""></p><p>要先启动生产者，发送一条消息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bef5bc1dec1?w=934&h=241&f=png&s=21574" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376c019fa7c8bb?w=778&h=273&f=png&s=27026" srcset="/img/loading.gif" alt=""></p><p>最后再启动消费者，进行消费：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376c132059ba20?w=1164&h=264&f=png&s=95439" srcset="/img/loading.gif" alt=""></p><p>这时候就会持续监听队列的消息，只要生产者发送一条消息到MQ，消费者就消费一条。我这里尝试发送4条：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376c3ca37adf87?w=1139&h=111&f=png&s=36994" srcset="/img/loading.gif" alt=""></p><p>由于队列不存在，启动消费者报错的这个问题。最好的方法是生产者和消费者都尝试创建队列，怎么写呢，有很多方式，我这里用一个相对简单一点的：</p><p>生产者的配置类加点东西：</p><pre><code class="java">//实现BeanPostProcessor类，使用Bean的生命周期函数@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    //这是创建交换机和队列用的rabbitAdmin对象    @Resource    private RabbitAdmin rabbitAdmin;    //初始化rabbitAdmin对象    @Bean    public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory) {        RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory);        // 只有设置为 true，spring 才会加载 RabbitAdmin 这个类        rabbitAdmin.setAutoStartup(true);        return rabbitAdmin;    }    //实例化bean后，也就是Bean的后置处理器    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        //创建交换机        rabbitAdmin.declareExchange(rabbitmqDemoDirectExchange());        //创建队列        rabbitAdmin.declareQueue(rabbitmqDemoDirectQueue());        return null;    }}</code></pre><p>这样启动生产者就会自动创建交换机和队列，不用等到发送消息才创建。</p><p>消费者需要加一点代码：</p><pre><code class="java">@Component//使用queuesToDeclare属性，如果不存在则会创建队列@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC))public class RabbitDemoConsumer {    //...省略}</code></pre><p>这样，无论生产者还是消费者先启动都不会出现问题了~</p><blockquote><p>代码地址：<a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><h1 id="五、RabbitMQ中的组成部分"><a href="#五、RabbitMQ中的组成部分" class="headerlink" title="五、RabbitMQ中的组成部分"></a>五、RabbitMQ中的组成部分</h1><p>从上面的HelloWord例子中，我们大概也能体验到一些，就是RabbitMQ的组成，它是有这几部分：</p><ul><li>Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。</li><li>Exchange：消息队列交换机。<strong>按一定的规则将消息路由转发到某个队列</strong>。</li><li>Queue：消息队列，存储消息的队列。</li><li>Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。</li><li>Consumer：消息消费者。消费队列中存储的消息。</li></ul><p>这些组成部分是如何协同工作的呢，大概的流程如下，请看下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/1737728b72852d77?w=620&h=344&f=png&s=18810" srcset="/img/loading.gif" alt=""></p><ul><li>消息生产者连接到RabbitMQ Broker，创建connection，开启channel。</li><li>生产者声明交换机类型、名称、是否持久化等。</li><li>生产者发送消息，并指定消息是否持久化等属性和routing key。</li><li>exchange收到消息之后，<strong>根据routing key路由到跟当前交换机绑定的相匹配的队列</strong>里面。</li><li>消费者监听接收到消息之后开始业务处理。</li></ul><h1 id="六、Exchange的四种类型以及用法"><a href="#六、Exchange的四种类型以及用法" class="headerlink" title="六、Exchange的四种类型以及用法"></a>六、Exchange的四种类型以及用法</h1><p>从上面的工作流程可以看出，实际上有个关键的组件Exchange，因为<strong>消息发送到RabbitMQ后首先要经过Exchange路由才能找到对应的Queue</strong>。</p><p>实际上Exchange类型有四种，根据不同的类型工作的方式也有所不同。在HelloWord例子中，我们就使用了比较简单的<strong>Direct Exchange</strong>，翻译就是直连交换机。其余三种分别是：<strong>Fanout exchange、Topic exchange、Headers exchange</strong>。</p><h2 id="6-1-Direct-Exchange"><a href="#6-1-Direct-Exchange" class="headerlink" title="6.1 Direct Exchange"></a>6.1 Direct Exchange</h2><p>见文知意，直连交换机意思是此交换机需要绑定一个队列，要求<strong>该消息与一个特定的路由键完全匹配</strong>。简单点说就是一对一的，点对点的发送。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/173773fe45569885?w=468&h=267&f=png&s=65093" srcset="/img/loading.gif" alt=""></p><p>完整的代码就是上面的HelloWord的例子，不再重复代码。</p><h2 id="6-2-Fanout-exchange"><a href="#6-2-Fanout-exchange" class="headerlink" title="6.2 Fanout exchange"></a>6.2 Fanout exchange</h2><p>这种类型的交换机需要将队列绑定到交换机上。<strong>一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上</strong>。很像子网广播，每台子网内的主机都获得了一份复制的消息。简单点说就是发布订阅。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/173774203ee5afd3?w=465&h=299&f=png&s=79778" srcset="/img/loading.gif" alt=""></p><p>代码怎么写呢，演示一下：</p><p>首先要先配置交换机和队列的名称：</p><pre><code class="java">public class RabbitMQConfig {    /**     * RabbitMQ的FANOUT_EXCHANG交换机类型的队列 A 的名称     */    public static final String FANOUT_EXCHANGE_QUEUE_TOPIC_A = &quot;fanout.A&quot;;    /**     * RabbitMQ的FANOUT_EXCHANG交换机类型的队列 B 的名称     */    public static final String FANOUT_EXCHANGE_QUEUE_TOPIC_B = &quot;fanout.B&quot;;    /**     * RabbitMQ的FANOUT_EXCHANG交换机类型的名称     */    public static final String FANOUT_EXCHANGE_DEMO_NAME = &quot;fanout.exchange.demo.name&quot;;}</code></pre><p>再配置FanoutExchange类型的交换机和A、B两个队列，并且绑定。这种类型不需要配置routing key：</p><pre><code class="java">@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    @Resource    private RabbitAdmin rabbitAdmin;    @Bean    public Queue fanoutExchangeQueueA() {        //队列A        return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A, true, false, false);    }    @Bean    public Queue fanoutExchangeQueueB() {        //队列B        return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_B, true, false, false);    }    @Bean    public FanoutExchange rabbitmqDemoFanoutExchange() {        //创建FanoutExchange类型交换机        return new FanoutExchange(RabbitMQConfig.FANOUT_EXCHANGE_DEMO_NAME, true, false);    }    @Bean    public Binding bindFanoutA() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(fanoutExchangeQueueA()).to(rabbitmqDemoFanoutExchange());    }    @Bean    public Binding bindFanoutB() {        //队列B绑定到FanoutExchange交换机        return BindingBuilder.bind(fanoutExchangeQueueB()).to(rabbitmqDemoFanoutExchange());    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        //启动项目即创建交换机和队列        rabbitAdmin.declareExchange(rabbitmqDemoFanoutExchange());        rabbitAdmin.declareQueue(fanoutExchangeQueueB());        rabbitAdmin.declareQueue(fanoutExchangeQueueA());        return null;    }}</code></pre><p>创建service发布消息的方法：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    @Resource    private RabbitTemplate rabbitTemplate;    //发布消息    @Override    public String sendMsgByFanoutExchange(String msg) throws Exception {        Map&lt;String, Object&gt; message = getMessage(msg);        try {            rabbitTemplate.convertAndSend(RabbitMQConfig.FANOUT_EXCHANGE_DEMO_NAME, &quot;&quot;, message);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }    //组装消息体    private Map&lt;String, Object&gt; getMessage(String msg) {        String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32);        String sendTime = sdf.format(new Date());        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msgId&quot;, msgId);        map.put(&quot;sendTime&quot;, sendTime);        map.put(&quot;msg&quot;, msg);        return map;    }}</code></pre><p>Controller接口：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    /**     * 发布消息     *     * @author java技术爱好者     */    @PostMapping(&quot;/publish&quot;)    public String publish(@RequestParam(name = &quot;msg&quot;) String msg) throws Exception {        return rabbitMQService.sendMsgByFanoutExchange(msg);    }}</code></pre><p>接着在消费者项目这边，创建两个队列的监听类，监听队列进行消费：</p><pre><code class="java">@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A))public class FanoutExchangeConsumerA {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列A收到消息：&quot; + map.toString());    }}</code></pre><pre><code class="java">@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_B))public class FanoutExchangeConsumerB {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列B收到消息：&quot; + map.toString());    }}</code></pre><p>然后启动生产者和消费者两个项目，可以看到管理界面创建了一个FanoutExchange交换机和两个队列，并且绑定了：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737c7793f971244?w=647&h=367&f=png&s=27283" srcset="/img/loading.gif" alt=""></p><p>使用POSTMAN进行发送消息，测试：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737c7829f71b8f2?w=944&h=276&f=png&s=22267" srcset="/img/loading.gif" alt=""></p><p>然后可以看到控制台，两个队列同时都收到了相同的消息，形成了发布订阅的效果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737c794ca2a0106?w=961&h=95&f=png&s=32829" srcset="/img/loading.gif" alt=""></p><h2 id="6-3-Topic-Exchange"><a href="#6-3-Topic-Exchange" class="headerlink" title="6.3 Topic Exchange"></a>6.3 Topic Exchange</h2><p>直接翻译的话叫做主题交换机，如果从用法上面翻译可能叫通配符交换机会更加贴切。这种交换机是使用通配符去匹配，路由到对应的队列。通配符有两种：”*” 、 “#”。需要注意的是通配符前面必须要加上”.”符号。</p><p><code>*</code> 符号：有且只匹配一个词。比如 <code>a.*</code>可以匹配到”a.b”、”a.c”，但是匹配不了”a.b.c”。</p><p><code>#</code> 符号：匹配一个或多个词。比如”rabbit.#”既可以匹配到”rabbit.a.b”、”rabbit.a”，也可以匹配到”rabbit.a.b.c”。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/1737cc2e35abb0c2?w=787&h=472&f=png&s=44593" srcset="/img/loading.gif" alt=""></p><p>废话不多说，代码演示一下：</p><p>依然是配置TopicExchange名称和三个队列的名称：</p><pre><code class="java">    /**     * RabbitMQ的TOPIC_EXCHANGE交换机名称     */    public static final String TOPIC_EXCHANGE_DEMO_NAME = &quot;topic.exchange.demo.name&quot;;    /**     * RabbitMQ的TOPIC_EXCHANGE交换机的队列A的名称     */    public static final String TOPIC_EXCHANGE_QUEUE_A = &quot;topic.queue.a&quot;;    /**     * RabbitMQ的TOPIC_EXCHANGE交换机的队列B的名称     */    public static final String TOPIC_EXCHANGE_QUEUE_B = &quot;topic.queue.b&quot;;    /**     * RabbitMQ的TOPIC_EXCHANGE交换机的队列C的名称     */    public static final String TOPIC_EXCHANGE_QUEUE_C = &quot;topic.queue.c&quot;;</code></pre><p>然后还是老配方，配置交换机和队列，然后绑定，创建：</p><pre><code class="java">@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    //省略...    @Bean    public TopicExchange rabbitmqDemoTopicExchange() {        //配置TopicExchange交换机        return new TopicExchange(RabbitMQConfig.TOPIC_EXCHANGE_DEMO_NAME, true, false);    }    @Bean    public Queue topicExchangeQueueA() {        //创建队列1        return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A, true, false, false);    }    @Bean    public Queue topicExchangeQueueB() {        //创建队列2        return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B, true, false, false);    }    @Bean    public Queue topicExchangeQueueC() {        //创建队列3        return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C, true, false, false);    }    @Bean    public Binding bindTopicA() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(topicExchangeQueueB())                .to(rabbitmqDemoTopicExchange())                .with(&quot;a.*&quot;);    }    @Bean    public Binding bindTopicB() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(topicExchangeQueueC())                .to(rabbitmqDemoTopicExchange())                .with(&quot;a.*&quot;);    }    @Bean    public Binding bindTopicC() {        //队列A绑定到FanoutExchange交换机        return BindingBuilder.bind(topicExchangeQueueA())                .to(rabbitmqDemoTopicExchange())                .with(&quot;rabbit.#&quot;);    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        rabbitAdmin.declareExchange(rabbitmqDemoTopicExchange());        rabbitAdmin.declareQueue(topicExchangeQueueA());        rabbitAdmin.declareQueue(topicExchangeQueueB());        rabbitAdmin.declareQueue(topicExchangeQueueC());        return null;    }}</code></pre><p>然后写一个发送消息的service方法：</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    @Override    public String sendMsgByTopicExchange(String msg, String routingKey) throws Exception {        Map&lt;String, Object&gt; message = getMessage(msg);        try {            //发送消息            rabbitTemplate.convertAndSend(RabbitMQConfig.TOPIC_EXCHANGE_DEMO_NAME, routingKey, message);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }}</code></pre><p>写一个Controller接口：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    @Resource    private RabbitMQService rabbitMQService;    /**     * 通配符交换机发送消息     *     * @author java技术爱好者     */    @PostMapping(&quot;/topicSend&quot;)    public String topicSend(@RequestParam(name = &quot;msg&quot;) String msg, @RequestParam(name = &quot;routingKey&quot;) String routingKey) throws Exception {        return rabbitMQService.sendMsgByTopicExchange(msg, routingKey);    }}</code></pre><p>生产者这边写完，就写消费端，消费端比较简单，写三个监听类：</p><pre><code class="java">@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A))public class TopicExchangeConsumerA {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A + &quot;]收到消息：&quot; + map.toString());    }}@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B))public class TopicExchangeConsumerB {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B+ &quot;]收到消息：&quot; + map.toString());    }}@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C))public class TopicExchangeConsumerC {    @RabbitHandler    public void process(Map&lt;String, Object&gt; map) {        System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C + &quot;]收到消息：&quot; + map.toString());    }}</code></pre><p>大功告成，然后启动项目开始调试。启动成功后可以看到队列和路由键绑定的关系：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17380fc32fda0fa2?w=518&h=379&f=png&s=26158" srcset="/img/loading.gif" alt=""></p><p>通过POSTMAN进行测试，测试一下 rabbit.# 的路由键是否能够匹配成功：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17380fd5053e38bc?w=934&h=253&f=png&s=23565" srcset="/img/loading.gif" alt=""></p><p>测试成功，队列A消费到消息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17380fe5e090ae23?w=1104&h=46&f=png&s=14452" srcset="/img/loading.gif" alt=""></p><p>接着测试 a.* 路由键，发送 routingKey = a.b ：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/17381008ddcc1a5b?w=937&h=233&f=png&s=21310" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/24/173810049898ae69?w=948&h=51&f=png&s=12864" srcset="/img/loading.gif" alt=""></p><p>比较常用的就是以上三种：直连(DirectExchange)，发布订阅(FanoutExchange)，通配符(TopicExchange)。熟练运用这三种交换机类型，基本上可以解决大部分的业务场景。</p><p>实际上稍微思考一下，可以发现通配符(TopicExchange)这种模式其实是可以达到直连(DirectExchange)和发布订阅(FanoutExchange)这两种的效果的。</p><p>FanoutExchange不需要绑定routingKey，所以性能相对TopicExchange会好一点。</p><h2 id="6-4-Headers-Exchange"><a href="#6-4-Headers-Exchange" class="headerlink" title="6.4 Headers Exchange"></a>6.4 Headers Exchange</h2><p>这种交换机用的相对没这么多。<strong>它跟上面三种有点区别，它的路由不是用routingKey进行路由匹配，而是在匹配请求头中所带的键值进行路由</strong>。如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/1738499671e1955e?w=828&h=252&f=png&s=34357" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/173849a014d576e5?w=799&h=252&f=png&s=34238" srcset="/img/loading.gif" alt=""></p><p>创建队列需要设置绑定的头部信息，有两种模式：<strong>全部匹配和部分匹配</strong>。如上图所示，交换机会根据生产者发送过来的头部信息携带的键值去匹配队列绑定的键值，路由到对应的队列。代码怎么实现呢，往下看演示代码：</p><p>首先还是需要定义交换机名称，队列名称：</p><pre><code class="java">    /**     * HEADERS_EXCHANGE交换机名称     */    public static final String HEADERS_EXCHANGE_DEMO_NAME = &quot;headers.exchange.demo.name&quot;;    /**     * RabbitMQ的HEADERS_EXCHANGE交换机的队列A的名称     */    public static final String HEADERS_EXCHANGE_QUEUE_A = &quot;headers.queue.a&quot;;    /**     * RabbitMQ的HEADERS_EXCHANGE交换机的队列B的名称     */    public static final String HEADERS_EXCHANGE_QUEUE_B = &quot;headers.queue.b&quot;;</code></pre><p>然后设置交换机，队列，进行绑定：</p><pre><code class="java">@Componentpublic class DirectRabbitConfig implements BeanPostProcessor {    @Bean    public Queue headersQueueA() {        return new Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A, true, false, false);    }    @Bean    public Queue headersQueueB() {        return new Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B, true, false, false);    }    @Bean    public HeadersExchange rabbitmqDemoHeadersExchange() {        return new HeadersExchange(RabbitMQConfig.HEADERS_EXCHANGE_DEMO_NAME, true, false);    }    @Bean    public Binding bindHeadersA() {        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;key_one&quot;, &quot;java&quot;);        map.put(&quot;key_two&quot;, &quot;rabbit&quot;);        //全匹配        return BindingBuilder.bind(headersQueueA())                .to(rabbitmqDemoHeadersExchange())                .whereAll(map).match();    }    @Bean    public Binding bindHeadersB() {        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;headers_A&quot;, &quot;coke&quot;);        map.put(&quot;headers_B&quot;, &quot;sky&quot;);        //部分匹配        return BindingBuilder.bind(headersQueueB())                .to(rabbitmqDemoHeadersExchange())                .whereAny(map).match();    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        rabbitAdmin.declareExchange(rabbitmqDemoHeadersExchange());        rabbitAdmin.declareQueue(headersQueueA());        rabbitAdmin.declareQueue(headersQueueB());        return null;    }}</code></pre><p>再写一个Service方法发送消息:</p><pre><code class="java">@Servicepublic class RabbitMQServiceImpl implements RabbitMQService {    @Resource    private RabbitTemplate rabbitTemplate;    @Override    public String sendMsgByHeadersExchange(String msg, Map&lt;String, Object&gt; map) throws Exception {        try {            MessageProperties messageProperties = new MessageProperties();            //消息持久化            messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);            messageProperties.setContentType(&quot;UTF-8&quot;);            //添加消息            messageProperties.getHeaders().putAll(map);            Message message = new Message(msg.getBytes(), messageProperties);            rabbitTemplate.convertAndSend(RabbitMQConfig.HEADERS_EXCHANGE_DEMO_NAME, null, message);            return &quot;ok&quot;;        } catch (Exception e) {            e.printStackTrace();            return &quot;error&quot;;        }    }}</code></pre><p>再写一个Controller接口：</p><pre><code class="java">@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController {    @Resource    private RabbitMQService rabbitMQService;    @PostMapping(&quot;/headersSend&quot;)    @SuppressWarnings(&quot;unchecked&quot;)    public String headersSend(@RequestParam(name = &quot;msg&quot;) String msg,                              @RequestParam(name = &quot;json&quot;) String json) throws Exception {        ObjectMapper mapper = new ObjectMapper();        Map&lt;String, Object&gt; map = mapper.readValue(json, Map.class);        return rabbitMQService.sendMsgByHeadersExchange(msg, map);    }}</code></pre><p>生产者这边写完了，再写两个队列的监听类进行消费：</p><pre><code class="java">@Componentpublic class HeadersExchangeConsumerA {    @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A))    public void process(Message message) throws Exception {        MessageProperties messageProperties = message.getMessageProperties();        String contentType = messageProperties.getContentType();        System.out.println(&quot;队列[&quot; + RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A + &quot;]收到消息：&quot; + new String(message.getBody(), contentType));    }}@Componentpublic class HeadersExchangeConsumerB {    @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B))    public void process(Message message) throws Exception {        MessageProperties messageProperties = message.getMessageProperties();        String contentType = messageProperties.getContentType();        System.out.println(&quot;队列[&quot; + RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B + &quot;]收到消息：&quot; + new String(message.getBody(), contentType));    }}</code></pre><p>大功告成~启动项目，打开管理界面，我们可以看到交换机绑定队列的信息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a470aa42de3?w=570&h=364&f=png&s=31572" srcset="/img/loading.gif" alt=""></p><p>跟上面示意图一样~证明没有问题，一切尽在掌握之中。使用POSTMAN发送，测试全匹配的队列A：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a81c6f1551f?w=939&h=264&f=png&s=24756" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a87b820f9f3?w=471&h=63&f=png&s=6969" srcset="/img/loading.gif" alt=""></p><p>再测试部分匹配的队列B：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a9b2293c0e2?w=930&h=258&f=png&s=23945" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384a9f8bbab549?w=472&h=76&f=png&s=7341" srcset="/img/loading.gif" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章就先写到这里了。回顾一下学了哪些：</p><ul><li>什么是消息队列？为什么使用消息队列？</li><li>RabbitMQ的特点、组成部分、工作流程</li><li>安装RabbitMQ，以及完成一个HelloWord小案例</li><li>RabbitMQ交换机的四种类型的特点，以及使用方法</li></ul><p>实际上RabbitMQ还有事务机制和负载均衡这些还没讲，因为篇幅实在有点长了，差不多5千字了。所以放在下期讲吧，尽请期待一下。</p><p>上面所有例子的代码都上传github了：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p><strong>如果你觉得这篇文章对你有用，点个赞吧</strong>~</p><p><strong>你的点赞是我创作的最大动力</strong>~</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZooKeeper入门</title>
    <link href="/2020/07/26/ZooKeeper%E5%85%A5%E9%97%A8/"/>
    <url>/2020/07/26/ZooKeeper%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/12/17343787ae8f3533?w=538&h=629&f=png&s=42414" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很多时候，我们都可以在各种框架应用中看到ZooKeeper的身影，比如Kafka中间件，Dubbo框架，Hadoop等等。为什么到处都看到ZooKeeper？</p><h1 id="一、什么是ZooKeeper"><a href="#一、什么是ZooKeeper" class="headerlink" title="一、什么是ZooKeeper"></a>一、什么是ZooKeeper</h1><p><strong>ZooKeeper是一个分布式服务协调框架</strong>，提供了分布式数据一致性的解决方案，基于ZooKeeper的<strong>数据结构，Watcher，选举机制</strong>等特点，可以<strong>实现数据的发布/订阅，软负载均衡，命名服务，统一配置管理，分布式锁，集群管理</strong>等等。</p><h1 id="二、为什么使用ZooKeeper"><a href="#二、为什么使用ZooKeeper" class="headerlink" title="二、为什么使用ZooKeeper"></a>二、为什么使用ZooKeeper</h1><p>ZooKeeper能保证：</p><ul><li>更新请求顺序进行。来自同一个client的更新请求按其发送顺序依次执行</li><li>数据更新原子性。一次数据更新要么成功，要么失败</li><li><strong>全局唯一数据视图</strong>。client无论连接到哪个server，数据视图都是一致的</li><li><strong>实时性</strong>。在一定时间范围内，client读到的数据是最新的</li></ul><h1 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h1><p>ZooKeeper的数据结构和Unix文件系统很类似，总体上可以看做是一棵树，每一个节点称之为一个ZNode，每一个ZNode<strong>默认能存储1M的数据</strong>。每一个ZNode可<strong>通过唯一的路径标识</strong>。如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/9/173343f042cc21bf?w=450&h=317&f=png&s=19615" srcset="/img/loading.gif" alt=""></p><p>创建ZNode时，可以指定以下四种类型，包括：</p><ul><li><strong>PERSISTENT，持久性ZNode</strong>。创建后，即使客户端与服务端断开连接也不会删除，只有客户端主动删除才会消失。</li><li><strong>PERSISTENT_SEQUENTIAL，持久性顺序编号ZNode</strong>。和持久性节点一样不会因为断开连接后而删除，并且ZNode的编号会自动增加。</li><li><strong>EPHEMERAL，临时性ZNode</strong>。客户端与服务端断开连接，该ZNode会被删除。</li><li><strong>EPEMERAL_SEQUENTIAL，临时性顺序编号ZNode</strong>。和临时性节点一样，断开连接会被删除，并且ZNode的编号会自动增加。</li></ul><h1 id="四、监听通知机制"><a href="#四、监听通知机制" class="headerlink" title="四、监听通知机制"></a>四、监听通知机制</h1><p>Watcher是基于<strong>观察者模式</strong>实现的一种机制。如果我们需要实现当某个ZNode节点发生变化时收到通知，就可以使用Watcher监听器。</p><p><strong>客户端通过设置监视点（watcher）向 ZooKeeper 注册需要接收通知的 znode，在 znode 发生变化时 ZooKeeper 就会向客户端发送消息</strong>。</p><p><strong>这种通知机制是一次性的</strong>。一旦watcher被触发，ZooKeeper就会从相应的存储中删除。如果需要不断监听ZNode的变化，可以在收到通知后再设置新的watcher注册到ZooKeeper。</p><p>监视点的类型有很多，如<strong>监控ZNode数据变化、监控ZNode子节点变化、监控ZNode 创建或删除</strong>。</p><h1 id="五、选举机制"><a href="#五、选举机制" class="headerlink" title="五、选举机制"></a>五、选举机制</h1><p>ZooKeeper是一个高可用的应用框架，因为ZooKeeper是支持集群的。ZooKeeper在集群状态下，配置文件是不会指定Master和Slave，而是在ZooKeeper服务器初始化时就在内部进行选举，产生一台做为Leader，多台做为Follower，并且遵守半数可用原则。</p><p>由于遵守半数可用原则，所以5台服务器和6台服务器，实际上最大允许宕机数量都是3台，所以为了节约成本，<strong>集群的服务器数量一般设置为奇数</strong>。</p><p>如果在运行时，<strong>如果长时间无法和Leader保持连接的话，则会再次进行选举，产生新的Leader，以保证服务的可用</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339067a2c6c061?w=600&h=185&f=png&s=87756" srcset="/img/loading.gif" alt=""></p><h1 id="六、初の体验"><a href="#六、初の体验" class="headerlink" title="六、初の体验"></a>六、初の体验</h1><p>首先在<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">官网</a>下载ZooKeeper，我这里用的是3.3.6版本。</p><p>然后解压，复制一下/conf目录下的zoo_sample.cfg文件，重命名为zoo.cfg。</p><p>修改zoo.cfg中dataDir的值，并创建对应的目录：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339300106f99c6?w=515&h=245&f=png&s=18915" srcset="/img/loading.gif" alt=""></p><p>最后到/bin目录下启动，我用的是window系统，所以启动zkServer.cmd，双击即可：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/1733937df5bee4e3?w=663&h=180&f=png&s=28318" srcset="/img/loading.gif" alt=""></p><p>启动成功的话就可以看到这个对话框：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339369078c2cc2?w=961&h=407&f=png&s=51377" srcset="/img/loading.gif" alt=""></p><p>可视化界面的话，我推荐使用<code>ZooInspector</code>，操作比较简便：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/173393a9befbac48?w=767&h=156&f=png&s=10149" srcset="/img/loading.gif" alt=""></p><h2 id="6-1-使用java连接ZooKeeper"><a href="#6-1-使用java连接ZooKeeper" class="headerlink" title="6.1 使用java连接ZooKeeper"></a>6.1 使用java连接ZooKeeper</h2><p>首先引入Maven依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>接着我们写一个Main方法，进行操作：</p><pre><code class="java">    //连接地址及端口号    private static final String SERVER_HOST = &quot;127.0.0.1:2181&quot;;    //会话超时时间    private static final int SESSION_TIME_OUT = 2000;    public static void main(String[] args) throws Exception {        //参数一：服务端地址及端口号        //参数二：超时时间        //参数三：监听器        ZooKeeper zooKeeper = new ZooKeeper(SERVER_HOST, SESSION_TIME_OUT, new Watcher() {            @Override            public void process(WatchedEvent watchedEvent) {                //获取事件的状态                Event.KeeperState state = watchedEvent.getState();                //判断是否是连接事件                if (Event.KeeperState.SyncConnected == state) {                    Event.EventType type = watchedEvent.getType();                    if (Event.EventType.None == type) {                        System.out.println(&quot;zk客户端已连接...&quot;);                    }                }            }        });        zooKeeper.create(&quot;/java&quot;, &quot;Hello World&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        System.out.println(&quot;新增ZNode成功&quot;);        zooKeeper.close();    }</code></pre><p>创建一个持久性ZNode，路径是/java，值为”Hello World”：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/10/17339630f8746e96?w=443&h=168&f=png&s=10357" srcset="/img/loading.gif" alt=""></p><h1 id="七、API概述"><a href="#七、API概述" class="headerlink" title="七、API概述"></a>七、API概述</h1><h2 id="7-1-创建"><a href="#7-1-创建" class="headerlink" title="7.1 创建"></a>7.1 创建</h2><pre><code class="java">public String create(final String path, byte data[], List&lt;ACL&gt; acl, CreateMode createMode)</code></pre><p>参数解释：</p><ul><li>path ZNode路径</li><li>data ZNode存储的数据</li><li>acl ACL权限控制</li><li>createMode ZNode类型</li></ul><p>ACL权限控制，有三个是ZooKeeper定义的常用权限，在ZooDefs.Ids类中：</p><pre><code class="java">/** * This is a completely open ACL. * 完全开放的ACL，任何连接的客户端都可以操作该属性znode */public final ArrayList&lt;ACL&gt; OPEN_ACL_UNSAFE = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.ALL, ANYONE_ID_UNSAFE)));/** * This ACL gives the creators authentication id&#39;s all permissions. * 只有创建者才有ACL权限 */public final ArrayList&lt;ACL&gt; CREATOR_ALL_ACL = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.ALL, AUTH_IDS)));/** * This ACL gives the world the ability to read. * 只能读取ACL */public final ArrayList&lt;ACL&gt; READ_ACL_UNSAFE = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.READ, ANYONE_ID_UNSAFE)));</code></pre><p>createMode就是前面讲过的四种ZNode类型：</p><pre><code class="java">public enum CreateMode {    /**     * 持久性ZNode     */    PERSISTENT (0, false, false),    /**     * 持久性自动增加顺序号ZNode     */    PERSISTENT_SEQUENTIAL (2, false, true),    /**     * 临时性ZNode     */    EPHEMERAL (1, true, false),    /**     * 临时性自动增加顺序号ZNode     */    EPHEMERAL_SEQUENTIAL (3, true, true);}</code></pre><h2 id="7-2-查询"><a href="#7-2-查询" class="headerlink" title="7.2 查询"></a>7.2 查询</h2><pre><code class="java">//同步获取节点数据public byte[] getData(String path, boolean watch, Stat stat){    ...}//异步获取节点数据public void getData(final String path, Watcher watcher, DataCallback cb, Object ctx){    ...}</code></pre><p>同步getData()方法中的stat参数是用于接收返回的节点描述信息：</p><pre><code class="java">public byte[] getData(final String path, Watcher watcher, Stat stat){    //省略...    GetDataResponse response = new GetDataResponse();    //发送请求到ZooKeeper服务器，获取到response    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (stat != null) {        //把response的Stat赋值到传入的stat中        DataTree.copyStat(response.getStat(), stat);    }}</code></pre><p>使用同步getData()获取数据：</p><pre><code class="java">    //数据的描述信息，包括版本号，ACL权限，子节点信息等等    Stat stat = new Stat();    //返回结果是byte[]数据，getData()方法底层会把描述信息复制到stat对象中    byte[] bytes = zooKeeper.getData(&quot;/java&quot;, false, stat);    //打印结果    System.out.println(&quot;ZNode的数据data:&quot; + new String(bytes));//Hello World    System.out.println(&quot;获取到dataVersion版本号:&quot; + stat.getVersion());//默认数据版本号是0</code></pre><h2 id="7-3-更新"><a href="#7-3-更新" class="headerlink" title="7.3 更新"></a>7.3 更新</h2><pre><code class="java">public Stat setData(final String path, byte data[], int version){    ...}</code></pre><p>值得注意的是第三个参数version，<strong>使用CAS机制，这是为了防止多个客户端同时更新节点数据，所以需要在更新时传入版本号，每次更新都会使版本号+1</strong>，如果服务端接收到版本号，对比发现不一致的话，则会抛出异常。</p><p>所以，在更新前需要先查询获取到版本号，否则你不知道当前版本号是多少，就没法更新：</p><pre><code class="java">    //获取节点描述信息    Stat stat = new Stat();    zooKeeper.getData(&quot;/java&quot;, false, stat);    System.out.println(&quot;更新ZNode数据...&quot;);    //更新操作，传入路径，更新值，版本号三个参数,返回结果是新的描述信息    Stat setData = zooKeeper.setData(&quot;/java&quot;, &quot;fly!!!&quot;.getBytes(), stat.getVersion());    System.out.println(&quot;更新后的版本号为：&quot; + setData.getVersion());//更新后的版本号为：1</code></pre><p>更新后，版本号增加了：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733999126b62716?w=440&h=320&f=png&s=19876" srcset="/img/loading.gif" alt=""></p><p>如果传入的版本参数是”-1”，就是告诉zookeeper服务器，客户端需要基于数据的最新版本进行更新操作。但是-1并不是一个合法的版本号，而是一个标识符。</p><h2 id="7-4-删除"><a href="#7-4-删除" class="headerlink" title="7.4 删除"></a>7.4 删除</h2><pre><code class="java">public void delete(final String path, int version){    ...}</code></pre><ul><li>path 删除节点的路径</li><li>version 版本号</li></ul><p>这里也需要传入版本号，调用getData()方法即可获取到版本号，很简单：</p><pre><code class="java">Stat stat = new Stat();zooKeeper.getData(&quot;/java&quot;, false, stat);//删除ZNodezooKeeper.delete(&quot;/java&quot;, stat.getVersion());</code></pre><h2 id="7-5-watcher机制"><a href="#7-5-watcher机制" class="headerlink" title="7.5 watcher机制"></a>7.5 watcher机制</h2><p>在上面第三点提到，ZooKeeper是可以使用通知监听机制，当ZNode发生变化会收到通知消息，进行处理。基于watcher机制，ZooKeeper能玩出很多花样。怎么使用？</p><p>ZooKeeper的通知监听机制，总的来说可以分为三个过程：</p><p>①客户端注册 Watcher<br>②服务器处理 Watcher<br>③客户端回调 Watcher客户端。</p><p>注册 watcher 有 4 种方法，new ZooKeeper()、getData()、exists()、getChildren()。下面演示一下使用exists()方法注册watcher：</p><p>首先<strong>需要实现Watcher接口</strong>，新建一个监听器：</p><pre><code class="java">public class MyWatcher implements Watcher {    @Override    public void process(WatchedEvent event) {        //获取事件类型        Event.EventType eventType = event.getType();        //通知状态        Event.KeeperState eventState = event.getState();        //节点路径        String eventPath = event.getPath();        System.out.println(&quot;监听到的事件类型:&quot; + eventType.name());        System.out.println(&quot;监听到的通知状态:&quot; + eventState.name());        System.out.println(&quot;监听到的ZNode路径:&quot; + eventPath);    }}</code></pre><p>然后调用exists()方法，注册监听器：</p><pre><code class="java">zooKeeper.exists(&quot;/java&quot;, new MyWatcher());//对ZNode进行更新数据的操作，触发监听器zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), -1);</code></pre><p>然后在控制台就可以看到打印的信息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733cd85f8b2bb10?w=682&h=200&f=png&s=48245" srcset="/img/loading.gif" alt=""></p><p>这里我们可以看到<strong>Event.EventType对象就是事件类型</strong>，我们可以对事件类型进行判断，再配合<strong>Event.KeeperState通知状态</strong>，做相关的业务处理，事件类型有哪些？</p><p>打开EventType、KeeperState的源码查看：</p><pre><code class="java">//事件类型是一个枚举public enum EventType {    None (-1),//无    NodeCreated (1),//Watcher监听的数据节点被创建    NodeDeleted (2),//Watcher监听的数据节点被删除    NodeDataChanged (3),//Watcher监听的数据节点内容发生变更    NodeChildrenChanged (4);//Watcher监听的数据节点的子节点列表发生变更}//通知状态也是一个枚举public enum KeeperState {    Unknown (-1),//属性过期    Disconnected (0),//客户端与服务端断开连接    NoSyncConnected (1),//属性过期    SyncConnected (3),//客户端与服务端正常连接    AuthFailed (4),//身份认证失败    ConnectedReadOnly (5),//返回这个状态给客户端，客户端只能处理读请求    SaslAuthenticated(6),//服务器采用SASL做校验时    Expired (-112);//会话session失效}</code></pre><h3 id="7-5-1-watcher的特性"><a href="#7-5-1-watcher的特性" class="headerlink" title="7.5.1 watcher的特性"></a>7.5.1 watcher的特性</h3><ul><li>一次性。一旦watcher被触发，ZK都会从相应的存储中移除。</li></ul><pre><code class="java">    zooKeeper.exists(&quot;/java&quot;, new Watcher() {        @Override        public void process(WatchedEvent event) {            System.out.println(&quot;我是exists()方法的监听器&quot;);        }    });    //对ZNode进行更新数据的操作，触发监听器    zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), -1);    //企图第二次触发监听器    zooKeeper.setData(&quot;/java&quot;, &quot;spring&quot;.getBytes(), -1);</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733cfc7501b447c?w=476&h=149&f=png&s=27289" srcset="/img/loading.gif" alt=""></p><ul><li>串行执行。客户端Watcher回调的过程是一个串行同步的过程，这是为了保证顺序。<pre><code class="java">  zooKeeper.exists(&quot;/java&quot;, new Watcher() {      @Override      public void process(WatchedEvent event) {          System.out.println(&quot;我是exists()方法的监听器&quot;);      }  });  Stat stat = new Stat();  zooKeeper.getData(&quot;/java&quot;, new Watcher() {      @Override      public void process(WatchedEvent event) {          System.out.println(&quot;我是getData()方法的监听器&quot;);      }  }, stat);  //对ZNode进行更新数据的操作，触发监听器  zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), stat.getVersion());</code></pre>打印结果，说明先调用exists()方法的监听器，再调用getData()方法的监听器。因为exists()方法先注册了。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733cf5f77df73f1?w=541&h=140&f=png&s=27151" srcset="/img/loading.gif" alt=""></p><ul><li>轻量级。WatchedEvent是ZK整个Watcher通知机制的最小通知单元。WatchedEvent包含三部分：<strong>通知状态，事件类型，节点路径</strong>。Watcher通知仅仅告诉客户端发生了什么事情，而不会说明事件的具体内容。</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>我记得B站的UP主李永乐说过，<strong>只有你让更多的人生活变得更美好时，自己的生活才能变得更美好。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733d114535c1c80?w=631&h=127&f=png&s=23550" srcset="/img/loading.gif" alt=""></p><p>这句话也是我今年开始写技术分享的一个动力源泉，希望这篇文章对你有用~</p><p>著名的飞行家<strong>马老师</strong>说过：<strong>回城是收费的，而点赞是免费的~</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从秒杀聊到ZooKeeper分布式锁</title>
    <link href="/2020/07/26/%E4%BB%8E%E7%A7%92%E6%9D%80%E8%81%8A%E5%88%B0ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2020/07/26/%E4%BB%8E%E7%A7%92%E6%9D%80%E8%81%8A%E5%88%B0ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/17365f514c2871a0?w=846&h=397&f=png&s=36190" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过<a href="https://juejin.im/post/5f05e96c5188252e5e22d8f4" target="_blank" rel="noopener">《ZooKeeper入门》</a>后，我们学会了ZooKeeper的基本用法。</p><p>实际上ZooKeeper的应用是非常广泛的，实现分布式锁只是其中一种。接下来我们就ZooKeeper实现分布式锁解决<strong>秒杀超卖问题</strong>进行展开。</p><h1 id="一、什么是秒杀超卖问题"><a href="#一、什么是秒杀超卖问题" class="headerlink" title="一、什么是秒杀超卖问题"></a>一、什么是秒杀超卖问题</h1><p>秒杀活动应该都不陌生，不用过多解释。</p><p>不难想象，在这种”秒杀”的场景中，实际上会出现多个用户争抢”资源”的情况，<strong>也就是多个线程同时并发，这种情况是很容易出现数据不准确，也就是超卖问题</strong>。</p><h2 id="1-1-项目演示"><a href="#1-1-项目演示" class="headerlink" title="1.1 项目演示"></a>1.1 项目演示</h2><p>下面使用程序演示，我使用了<strong>SpringBoot2.0、Mybatis、Mybatis-Plus、SpringMVC</strong>搭建了一个简单的项目，github地址：</p><blockquote><p><a href="https://github.com/yehongzhi/mall" target="_blank" rel="noopener">https://github.com/yehongzhi/mall</a></p></blockquote><p>创建一个商品信息表：</p><pre><code class="sql">CREATE TABLE `tb_commodity_info` (  `id` varchar(32) NOT NULL,  `commodity_name` varchar(512) DEFAULT NULL COMMENT &#39;商品名称&#39;,  `commodity_price` varchar(36) DEFAULT &#39;0&#39; COMMENT &#39;商品价格&#39;,  `number` int(10) DEFAULT &#39;0&#39; COMMENT &#39;商品数量&#39;,  `description` varchar(2048) DEFAULT &#39;&#39; COMMENT &#39;商品描述&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;商品信息表&#39;;</code></pre><p>添加一个商品[<strong>叉烧包</strong>]进去：<br><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e32e530bc75a?w=770&h=45&f=png&s=6596" srcset="/img/loading.gif" alt=""></p><p>核心的代码逻辑是这样的：</p><pre><code class="java">    @Override    public boolean purchaseCommodityInfo(String commodityId, Integer number) throws Exception {        //1.先查询数据库中商品的数量        TbCommodityInfo commodityInfo = commodityInfoMapper.selectById(commodityId);        //2.判断商品数量是否大于0，或者购买的数量大于库存        Integer count = commodityInfo.getNumber();        if (count &lt;= 0 || number &gt; count) {            //商品数量小于或者等于0，或者购买的数量大于库存，则返回false            return false;        }        //3.如果库存数量大于0，并且购买的数量小于或者等于库存。则更新商品数量        count -= number;        commodityInfo.setNumber(count);        boolean bool = commodityInfoMapper.updateById(commodityInfo) == 1;        if (bool) {            //如果更新成功，则打印购买商品成功            System.out.println(&quot;购买商品[ &quot; + commodityInfo.getCommodityName() + &quot; ]成功,数量为：&quot; + number);        }        return bool;    }</code></pre><p>逻辑示意图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e422a298bdef?w=719&h=411&f=png&s=35372" srcset="/img/loading.gif" alt=""></p><p>上面这个逻辑，如果单线程请求的话是没有问题的。</p><p>但是多线程的话就出现问题了。现在我就创建多个线程，通过HttpClient进行请求，看会发生什么：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //请求地址        String url = &quot;http://localhost:8080/mall/commodity/purchase&quot;;        //请求参数，商品ID，数量        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;);        map.put(&quot;number&quot;, &quot;1&quot;);        //创建10个线程通过HttpClient进行发送请求，测试        for (int i = 0; i &lt; 10; i++) {            //这个线程的逻辑仅仅是发送请求            CommodityThread commodityThread = new CommodityThread(url, map);            commodityThread.start();        }    }</code></pre><p>说明一下，叉烧包的数量是100，这里有10个线程同时去购买，假设都购买成功的话，库存数量应该是90。</p><p>实际上，10个线程的确都购买成功了：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e52bcd8c8410?w=348&h=182&f=png&s=10183" srcset="/img/loading.gif" alt=""></p><p>但是数据库的商品库存，却不准确：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/1734e5372723db05?w=777&h=47&f=png&s=7006" srcset="/img/loading.gif" alt=""></p><h1 id="二、尝试使用本地锁"><a href="#二、尝试使用本地锁" class="headerlink" title="二、尝试使用本地锁"></a>二、尝试使用本地锁</h1><p>上面的场景，大概流程如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/16/173576192aaa3672?w=827&h=458&f=png&s=71783" srcset="/img/loading.gif" alt=""></p><p>可以看出问题的<strong>关键在于两个线程”同时”去查询剩余的库存，然后更新库存导致的</strong>。要解决这个问题，其实<strong>只要保证多个线程在这段逻辑是顺序执行即可，也就是加锁</strong>。</p><p>本地锁JDK提供有两种：synchronized和Lock锁。</p><p>两种方式都可以，我这里为了简便，使用synchronized：</p><pre><code class="java">    //使用synchronized修饰方法    @Override    public synchronized boolean purchaseCommodityInfo(String commodityId, Integer number) throws Exception {        //省略...    }</code></pre><p>然后再测试刚刚多线程并发抢购的情况，看看结果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352d90c1ca872c?w=779&h=50&f=png&s=6771" srcset="/img/loading.gif" alt=""></p><p>问题得到解决！！！</p><p>你以为事情就这样结束了吗，看了看进度条，发现事情并不简单。</p><p>我们知道在实际项目中，往往不会只部署一台服务器，所以不妨我们启动两台服务器，端口号分别是8080、8081，模拟实际项目的场景：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352e08465b09fb?w=592&h=391&f=png&s=38702" srcset="/img/loading.gif" alt=""></p><p>写一个交替请求的测试脚本，模拟多台服务器分别处理请求，用户秒杀抢购的场景：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //请求地址        String url = &quot;http://localhost:%s/mall/commodity/purchase&quot;;        //请求参数，商品ID，数量        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;);        map.put(&quot;number&quot;, &quot;1&quot;);        //创建10个线程通过HttpClient进行发送请求，测试        for (int i = 0; i &lt; 10; i++) {            //8080、8081交替请求，每个服务器处理5个请求            String port = &quot;808&quot; + (i % 2);            CommodityThread commodityThread = new CommodityThread(String.format(url, port), map);            commodityThread.start();        }    }</code></pre><p>首先看购买的情况，肯定都是购买成功的:</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352ecdc9af8253?w=615&h=302&f=png&s=36798" srcset="/img/loading.gif" alt=""></p><p>关键是库存数量是否正确：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352edee5171303?w=786&h=50&f=png&s=7086" srcset="/img/loading.gif" alt=""></p><p>有10个请求购买成功，库存应该是90才对，这里库存是95。事实证明<strong>本地锁是不能解决多台服务器秒杀抢购出现超卖的问题</strong>。</p><p>为什么会这样呢，请看示意图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352fc7c52787c9?w=650&h=458&f=png&s=63889" srcset="/img/loading.gif" alt=""></p><p>其实和多线程问题是差不多的原因，<strong>多个服务器去查询数据库，获取到相同的库存，然后更新库存，导致数据不正确</strong>。要保证库存的数量正确，<strong>关键在于多台服务器要保证只能一台服务器在执行这段逻辑</strong>，也就是要加分布式锁。</p><p>这也体现出分布式锁的作用，就是要保证多台服务器只能有一台服务器执行。</p><p>分布式锁有三种实现方式，分别是redis、ZooKeeper、数据库(比如mysql)。</p><h1 id="三、使用ZooKeeper实现分布式锁"><a href="#三、使用ZooKeeper实现分布式锁" class="headerlink" title="三、使用ZooKeeper实现分布式锁"></a>三、使用ZooKeeper实现分布式锁</h1><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h2><p>实际上是利用ZooKeeper的临时顺序节点的特性实现分布式锁。怎么实现呢？</p><p>假设现在有一个客户端A，需要加锁，那么就在”/Lock”路径下创建一个临时顺序节点。然后获取”/Lock”下的节点列表，判断自己的序号是否是最小的，如果是最小的序号，则加锁成功！</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17353229075ad04f?w=698&h=276&f=png&s=23589" srcset="/img/loading.gif" alt=""></p><p>现在又有另一个客户端，客户端B需要加锁，那么也是在”/Lock”路径下创建临时顺序节点。依然获取”/Lock”下的节点列表，判断自己的节点序号是否最小的。发现不是最小的，加锁失败，接着对自己的上一个节点进行监听。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/173532ccde8ed6b4?w=736&h=328&f=png&s=29464" srcset="/img/loading.gif" alt=""></p><p>怎么释放锁呢，其实就是把临时节点删除。假设客户端A释放锁，把节点01删除了。那就会触发节点02的监听事件，客户端就再次获取节点列表，然后判断自己是否是最小的序号，如果是最小序号则加锁。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/16/1735337578204cc5?w=788&h=314&f=png&s=33283" srcset="/img/loading.gif" alt=""></p><p>如果多个客户端其实也是一样，一上来就会创建一个临时节点，然后开始判断自己是否是最小的序号，如果不是就监听上一个节点，形成一种排队的机制。也就形成了锁的效果，保证了多台服务器只有一台执行。</p><p><strong>假设其中有一个客户端宕机了，根据临时节点的特点，ZooKeeper会自动删除对应的临时节点</strong>，相当于自动释放了锁。</p><h2 id="3-2-手写代码实现分布式锁"><a href="#3-2-手写代码实现分布式锁" class="headerlink" title="3.2 手写代码实现分布式锁"></a>3.2 手写代码实现分布式锁</h2><p>首先加入Maven依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.101tec&lt;/groupId&gt;    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;    &lt;version&gt;0.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>接着按照上面分析的思路敲代码，创建ZkLock类：</p><pre><code class="java">public class ZkLock implements Lock {    //计数器，用于加锁失败时，阻塞    private static CountDownLatch cdl = new CountDownLatch(1);    //ZooKeeper服务器的IP端口    private static final String IP_PORT = &quot;127.0.0.1:2181&quot;;    //锁的根路径    private static final String ROOT_NODE = &quot;/Lock&quot;;    //上一个节点的路径    private volatile String beforePath;    //当前上锁的节点路径    private volatile String currPath;    //创建ZooKeeper客户端    private ZkClient zkClient = new ZkClient(IP_PORT);    public ZkLock() {        //判断是否存在根节点        if (!zkClient.exists(ROOT_NODE)) {            //不存在则创建            zkClient.createPersistent(ROOT_NODE);        }    }    //加锁    public void lock() {        if (tryLock()) {            System.out.println(&quot;加锁成功！！&quot;);        } else {            // 尝试加锁失败，进入等待 监听            waitForLock();            // 再次尝试加锁            lock();        }    }    //尝试加锁    public synchronized boolean tryLock() {        // 第一次就进来创建自己的临时节点        if (StringUtils.isBlank(currPath)) {            currPath = zkClient.createEphemeralSequential(ROOT_NODE + &quot;/&quot;, &quot;lock&quot;);        }        // 对节点排序        List&lt;String&gt; children = zkClient.getChildren(ROOT_NODE);        Collections.sort(children);        // 当前的是最小节点就返回加锁成功        if (currPath.equals(ROOT_NODE + &quot;/&quot; + children.get(0))) {            return true;        } else {            // 不是最小节点 就找到自己的前一个 依次类推 释放也是一样            int beforePathIndex = Collections.binarySearch(children, currPath.substring(ROOT_NODE.length() + 1)) - 1;            beforePath = ROOT_NODE + &quot;/&quot; + children.get(beforePathIndex);            //返回加锁失败            return false;        }    }    //解锁    public void unlock() {        //删除节点并关闭客户端        zkClient.delete(currPath);        zkClient.close();    }    //等待上锁，加锁失败进入阻塞，监听上一个节点    private void waitForLock() {        IZkDataListener listener = new IZkDataListener() {            //监听节点更新事件            public void handleDataChange(String s, Object o) throws Exception {            }            //监听节点被删除事件            public void handleDataDeleted(String s) throws Exception {                //解除阻塞                cdl.countDown();            }        };        // 监听上一个节点        this.zkClient.subscribeDataChanges(beforePath, listener);        //判断上一个节点是否存在        if (zkClient.exists(beforePath)) {            //上一个节点存在            try {                System.out.println(&quot;加锁失败 等待&quot;);                //加锁失败，阻塞等待                cdl.await();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        // 释放监听        zkClient.unsubscribeDataChanges(beforePath, listener);    }    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {        return false;    }    public void lockInterruptibly() throws InterruptedException {    }    public Condition newCondition() {        return null;    }}</code></pre><p>在Controller层加上锁：</p><pre><code class="java">    @PostMapping(&quot;/purchase&quot;)    public boolean purchaseCommodityInfo(@RequestParam(name = &quot;commodityId&quot;) String commodityId, @RequestParam(name = &quot;number&quot;) Integer number) throws Exception {        boolean bool;        //获取ZooKeeper分布式锁        ZkLock zkLock = new ZkLock();        try {            //上锁            zkLock.lock();            //调用秒杀抢购的service方法            bool = commodityInfoService.purchaseCommodityInfo(commodityId, number);        } catch (Exception e) {            e.printStackTrace();            bool = false;        } finally {            //解锁            zkLock.unlock();        }        return bool;    }</code></pre><p>测试，依然起两台服务器，8080、8081。然后跑测试脚本：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //请求地址        String url = &quot;http://localhost:%s/mall/commodity/purchase&quot;;        //请求参数，商品ID，数量        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;);        map.put(&quot;number&quot;, &quot;1&quot;);        //创建10个线程通过HttpClient进行发送请求，测试        for (int i = 0; i &lt; 10; i++) {            //8080、8081交替请求            String port = &quot;808&quot; + (i % 2);            CommodityThread commodityThread = new CommodityThread(String.format(url, port), map);            commodityThread.start();        }    }</code></pre><p>结果正确：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/173623e9dd3cc00b?w=776&h=47&f=png&s=7044" srcset="/img/loading.gif" alt=""></p><h2 id="3-3-造好的轮子"><a href="#3-3-造好的轮子" class="headerlink" title="3.3 造好的轮子"></a>3.3 造好的轮子</h2><p>Curator是Apache开源的一个操作ZooKeeper的框架。其中就有实现ZooKeeper分布式锁的功能。</p><p>当然分布式锁的实现只是这个框架的其中一个很小的部分，除此之外还有很多用途，大家可以到<a href="http://curator.apache.org/" target="_blank" rel="noopener">官网</a>去学习。</p><p>首先添加Maven依赖：</p><pre><code class="java">    &lt;dependency&gt;        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;        &lt;version&gt;4.3.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;        &lt;version&gt;4.3.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>还是一样在需要加锁的地方进行加锁：</p><pre><code class="java">    @PostMapping(&quot;/purchase&quot;)    public boolean purchaseCommodityInfo(@RequestParam(name = &quot;commodityId&quot;) String commodityId,                                         @RequestParam(name = &quot;number&quot;) Integer number) throws Exception {        boolean bool = false;        //设置重试策略        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;127.0.0.1:2181&quot;, retryPolicy);        // 启动客户端        client.start();        InterProcessMutex mutex = new InterProcessMutex(client, &quot;/locks&quot;);        try {            //加锁            if (mutex.acquire(3, TimeUnit.SECONDS)) {                //调用抢购秒杀service方法                bool = commodityInfoService.purchaseCommodityInfo(commodityId, number);            }        } catch (Exception e) {            e.printStackTrace();        } finally {            //解锁            mutex.release();            client.close();        }        return bool;    }</code></pre><h1 id="四、遇到的坑"><a href="#四、遇到的坑" class="headerlink" title="四、遇到的坑"></a>四、遇到的坑</h1><p>我尝试用原生的ZooKeeper写分布式锁，有点炸裂。遇到不少坑，最终放弃了，用zkclient的API。可能我太菜了不太会用。</p><p>下面我分享我遇到的一些问题，希望你们在遇到同类型的异常时能迅速定位问题。</p><h2 id="4-1-Session-expired"><a href="#4-1-Session-expired" class="headerlink" title="4.1 Session expired"></a>4.1 Session expired</h2><p>这个错误是使用原生ZooKeeper的API出现的错误。主要是我在进入debug模式进行调试出现的。</p><p>因为原生的ZooKeeper需要设定一个会话超时时间，一般debug模式我们都会卡在一个地方去调试，肯定就超出了设置的会话时间~</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/1736258e60ae7778?w=742&h=434&f=png&s=58282" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-KeeperErrorCode-ConnectionLoss"><a href="#4-2-KeeperErrorCode-ConnectionLoss" class="headerlink" title="4.2 KeeperErrorCode = ConnectionLoss"></a>4.2 KeeperErrorCode = ConnectionLoss</h2><p>这个也是原生ZooKeeper的API的错误，怎么出现的呢？</p><p>主要是创建的ZooKeeper客户端连接服务器时是异步的，由于连接需要时间，还没连接成功，代码已经开始执行create()或者exists()，然后就报这个错误。</p><p>解决方法：使用CountDownLatch计数器阻塞，连接成功后再停止阻塞，然后执行create()或者exists()等操作。</p><h2 id="4-3-并发查询更新出现数据不一致"><a href="#4-3-并发查询更新出现数据不一致" class="headerlink" title="4.3 并发查询更新出现数据不一致"></a>4.3 并发查询更新出现数据不一致</h2><p>这个错误真的太炸裂了~</p><p>一开始我是把分布式锁加在service层，然后以为搞定了。接着启动8080、8081进行并发测试。10个线程都是购买成功，结果居然是不正确！</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/173627032c88e91b?w=876&h=184&f=png&s=26788" srcset="/img/loading.gif" alt=""></p><p>第一反应觉得自己实现的代码有问题，于是换成curator框架实现的分布式锁，开源框架应该没问题了吧。没想到还是不行~</p><p>既然不是锁本身的问题，是不是事务问题。<strong>上一个事务更新库存的操作还没提交，然后下一个请求就进来查询。于是我就把加锁的范围放大一点，放在Controller层</strong>。居然成功了！</p><p>你可能已经注意到，我在上面的例子就是把分布式锁加在Controller层，其实我不太喜欢在Controller层写太多代码。</p><p>也许有更加优雅的方式，可惜本人能力不足，如果你有更好的实现方式，可以分享一下~</p><p>补充：下面评论有位大佬说，在原来的方法外再包裹一层，亲测是可以的。这应该是事务的问题。</p><p>上面放在Controller层可以成功是不是因为Controller层没有事务，原来写在service我是写了一个@Transactional注解在类上，所以整个类里面的都有事务，所以解锁后还没提交事务去更新数据库，然后下一个请求进来就查到了没更新的数据。</p><p>为了优雅一点，就把@Transactional注解放在抢购的service方法上<br><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736c9d98626282d?w=863&h=230&f=png&s=49347" srcset="/img/loading.gif" alt=""></p><p>然后再包裹一个没有事务的方法，用于上锁。<br><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736c993c04ea9e5?w=873&h=378&f=png&s=62335" srcset="/img/loading.gif" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736c9a2d2881ae3?w=846&h=248&f=png&s=44367" srcset="/img/loading.gif" alt=""></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>最后，我们回顾总结一下吧：</p><ul><li>首先我们模拟单机多线程的秒杀场景，单机的话可以使用本地锁解决问题。</li><li>接着模拟多服务器多线程的场景，思路是使用ZooKeeper实现分布式锁解决。</li><li>图解ZooKeeper实现分布式锁的原理。</li><li>然后动手写代码，实现分布式锁。</li><li>最后总结遇到的坑。</li></ul><p><strong>希望这篇文章对你有用</strong></p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty进阶之粘包和拆包</title>
    <link href="/2020/07/08/Netty%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/"/>
    <url>/2020/07/08/Netty%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17329e0e4be94869?w=895&h=340&f=png&s=33550" srcset="/img/loading.gif" alt=""></p><h1 id="一、什么是粘包和拆包"><a href="#一、什么是粘包和拆包" class="headerlink" title="一、什么是粘包和拆包"></a>一、什么是粘包和拆包</h1><p>TCP是一种<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。(来自百度百科)</p><p>发送端为了将多个发给接收端的数据包，更有效地发送到接收端，会使用<strong>Nagle算法</strong>。Nagle算法会<strong>将多次时间间隔较小且数据量小的数据合并成一个大的数据块</strong>进行发送。虽然这样的确提高了效率，但是<strong>因为面向流通信，数据是无消息保护边界的</strong>，就会<strong>导致接收端难以分辨出完整的数据包</strong>了。</p><p>所谓的粘包和拆包问题，就是因为TCP消息无保护边界导致的。</p><a id="more"></a><h2 id="1-1-图解粘包和拆包"><a href="#1-1-图解粘包和拆包" class="headerlink" title="1.1 图解粘包和拆包"></a>1.1 图解粘包和拆包</h2><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e5cfafa34ed7?w=774&h=456&f=png&s=36343" srcset="/img/loading.gif" alt=""><br>正常发送消息是三次发送三个数据包，这种情况没有问题。</p><p>粘包，则是其中有多个数据包合并成一个数据包进行发送，也就是上图的第二种情况。</p><p>拆包，则是其中一个数据包被拆成了多段，发送的数据包只包含了一个完整数据包的一部分。也就是上图的第三种情况。</p><h2 id="1-2-程序演示"><a href="#1-2-程序演示" class="headerlink" title="1.2 程序演示"></a>1.2 程序演示</h2><p>首先准备客户端负责发送消息，连续发送5次消息，代码如下：</p><pre><code class="java">    for (int i = 1; i &lt;= 5; i++) {        ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + &quot; &quot;, Charset.forName(&quot;utf-8&quot;));        ctx.writeAndFlush(byteBuf);    }</code></pre><p>然后服务端作为接收方，接收并且打印结果：</p><pre><code class="java">//count变量，用于计数private int count = 0;@Overrideprotected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {    byte[] bytes = new byte[msg.readableBytes()];    //把ByteBuf的数据读到bytes数组中    msg.readBytes(bytes);    String message = new String(bytes, Charset.forName(&quot;utf-8&quot;));    System.out.println(&quot;服务器接收到数据：&quot; + message);    //打印接收的次数    System.out.println(&quot;接收到的数据量是：&quot; + (++this.count));}</code></pre><p>启动服务端，再启动两个客户端发送消息,服务端的控制台可以看到这样：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f27303054a8f?w=719&h=199&f=png&s=28205" srcset="/img/loading.gif" alt=""></p><p>粘包的问题其实是随机的，所以每次结果都不太一样。</p><h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>总体思路可以分为三种：</p><ul><li>在数据的末尾添加特殊的符号标识数据包的边界。通常会加\n\r、\t或者其他的符号。</li><li>在数据的头部声明数据的长度，按长度获取数据。</li><li>规定报文的长度，不足则补空位。读取时按规定好的长度来读取。</li></ul><h2 id="2-1-使用LineBasedFrameDecoder"><a href="#2-1-使用LineBasedFrameDecoder" class="headerlink" title="2.1 使用LineBasedFrameDecoder"></a>2.1 使用LineBasedFrameDecoder</h2><p>这是Netty内置的一个解码器，对应的编码器是LineEncoder。</p><p>原理是上面讲的第一种思路，在数据末尾加上特殊符号以标识边界。默认是使用换行符\n。</p><p>用法很简单，发送方加上编码器：</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //添加编码器，使用默认的符号\n，字符集是UTF-8        ch.pipeline().addLast(new LineEncoder(LineSeparator.DEFAULT, CharsetUtil.UTF_8));        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>接收方加上解码器：</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //解码器需要设置数据的最大长度，我这里设置成1024        ch.pipeline().addLast(new LineBasedFrameDecoder(1024));        //给pipeline管道设置业务处理器        ch.pipeline().addLast(new TcpServerHandler());    }</code></pre><p>然后在发送方，发送消息时在末尾加上标识符：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 5; i++) {            //在末尾加上默认的标识符\n            ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + StringUtil.LINE_FEED, Charset.forName(&quot;utf-8&quot;));            ctx.writeAndFlush(byteBuf);        }    }</code></pre><p>于是我们再次启动服务端和客户端，在服务端的控制台可以看到：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f4a496a5469d?w=505&h=231&f=png&s=42918" srcset="/img/loading.gif" alt=""><br>粘包、拆包的问题就轻松得到解决。</p><p>注意点：<strong>数据末尾一定是分隔符，分隔符后面不要再加上数据</strong>，否则会当做下一条数据的开始部分。下面是错误演示：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 5; i++) {            //在分隔符后面加上一段字符串            ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + StringUtil.LINE_FEED + &quot;[我是分隔符后面的字符串]&quot;, Charset.forName(&quot;utf-8&quot;));            ctx.writeAndFlush(byteBuf);        }    }</code></pre><p>服务端的控制台就会看到这样的打印信息：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f7fca99184e9?w=446&h=208&f=png&s=24270" srcset="/img/loading.gif" alt=""></p><h2 id="2-2-使用自定义长度帧解码器"><a href="#2-2-使用自定义长度帧解码器" class="headerlink" title="2.2 使用自定义长度帧解码器"></a>2.2 使用自定义长度帧解码器</h2><p>使用这个解码器解决粘包问题的原理是上面讲的第二种，在数据的头部声明数据的长度，按长度获取数据。这个解码器构造器需要定义5个参数，相对较为复杂一点，先看参数的解释：</p><ul><li>maxFrameLength  发送数据包的最大长度</li><li>lengthFieldOffset  长度域的偏移量。长度域位于整个数据包字节数组中的开始下标。</li><li>lengthFieldLength  长度域的字节数长度。长度域的字节数长度。</li><li>lengthAdjustment  长度域的偏移量矫正。如果长度域的值，除了包含有效数据域的长度外，还包含了其他域（如长度域自身）长度，那么，就需要进行矫正。矫正的值为：包长 - 长度域的值 – 长度域偏移 – 长度域长。</li><li>initialBytesToStrip  丢弃的起始字节数。丢弃处于此索引值前面的字节。</li></ul><p>前面三个参数比较简单，可以用下面这张图进行演示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/6/173249f1dcce734e?w=557&h=342&f=png&s=28445" srcset="/img/loading.gif" alt=""><br>矫正偏移量是什么意思呢？意思是假设你的长度域设置的值除了包括有效数据的长度还有其他域的长度包含在里面，那么就要设置这个值进行矫正，否则解码器拿不到有效数据。矫正值的公式就是上面写着了。</p><p>丢弃的起始字节数。这个比较简单，就是在这个索引值前面的数据都丢弃，只要后面的数据。一般都是丢弃长度域的数据。当然如果你希望得到全部数据，那就设置为0。</p><p>下面就在消息接收端使用自定义长度帧解码器，解决粘包的问题：</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //数据包最大长度是1024        //长度域的起始索引是0        //长度域的数据长度是4        //矫正值为0，因为长度域只有 有效数据的长度的值        //丢弃数据起始值是4，因为长度域长度为4，我要把长度域丢弃，才能得到有效数据        ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>接着编写发送端代码，根据解码器的设置，进行发送：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 5; i++) {            String str = &quot;msg No&quot; + i;            ByteBuf byteBuf = Unpooled.buffer(1024);            byte[] bytes = str.getBytes(Charset.forName(&quot;utf-8&quot;));            //设置长度域的值，为有效数据的长度            byteBuf.writeInt(bytes.length);            //设置有效数据            byteBuf.writeBytes(bytes);            ctx.writeAndFlush(byteBuf);        }    }</code></pre><p>然后启动服务端，客户端，我们可以看到控制台打印结果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/6/17324aa254af3f3f?w=343&h=199&f=png&s=15892" srcset="/img/loading.gif" alt=""><br>可以看到，利用自定义长度帧解码器解决了粘包问题。</p><h2 id="2-3-使用Google-Protobuf编解码器"><a href="#2-3-使用Google-Protobuf编解码器" class="headerlink" title="2.3 使用Google Protobuf编解码器"></a>2.3 使用Google Protobuf编解码器</h2><p>Netty<a href="https://netty.io/" target="_blank" rel="noopener">官网</a>上是明显写着支持Google Protobuf的，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/6/17322cc3e98146fe?w=599&h=343&f=png&s=56992" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-1-Google-Protobuf是什么"><a href="#2-3-1-Google-Protobuf是什么" class="headerlink" title="2.3.1 Google Protobuf是什么"></a>2.3.1 Google Protobuf是什么</h3><blockquote><p>摘自官网的原话：<br>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p></blockquote><p>翻译一下：Protocol buffers是Google公司的<strong>与语言无关、平台无关、可扩展的序列化数据的机制</strong>，类似XML，但是<strong>更小、更快、更简单</strong>。您只需<strong>定义一次数据的结构化方式</strong>，然后就可以使用<strong>特殊生成的源代码</strong>，轻松地<strong>将结构化数据写入和读取到各种数据流中，并支持多种语言</strong>。</p><p><a href="https://developers.google.cn/protocol-buffers/" target="_blank" rel="noopener">Google Protobuf官网</a></p><h3 id="2-3-2-使用Google-Protobuf"><a href="#2-3-2-使用Google-Protobuf" class="headerlink" title="2.3.2 使用Google Protobuf"></a>2.3.2 使用Google Protobuf</h3><p>首先先下载编译器，我使用的是win系统，所以下载的是win版本。<a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.6.1" target="_blank" rel="noopener">下载编译器链接，版本是v3.6.1</a></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17324e5a84010099?w=1041&h=240&f=png&s=31916" srcset="/img/loading.gif" alt=""></p><p>如果官网下载慢的话，我已经下载了一个，并且上传到百度网盘，<a href="https://pan.baidu.com/s/11yckiP4uWXR9I0bKyRBzOQ" target="_blank" rel="noopener">网盘链接</a>，提取码：8b1r。公众号什么的随缘关注吧，哈哈~</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17329eb724fd70a4?w=741&h=364&f=png&s=19605" srcset="/img/loading.gif" alt=""></p><p>以下步骤参考Google Protobuf的github项目的<a href="https://github.com/protocolbuffers/protobuf/tree/master/java" target="_blank" rel="noopener">指南</a>。</p><h4 id="第一步：添加maven依赖"><a href="#第一步：添加maven依赖" class="headerlink" title="第一步：添加maven依赖"></a>第一步：添加maven依赖</h4><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;    &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;    &lt;version&gt;3.6.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="第二步：编写proto文件Message-proto"><a href="#第二步：编写proto文件Message-proto" class="headerlink" title="第二步：编写proto文件Message.proto"></a>第二步：编写proto文件Message.proto</h4><p>如何编写.proto文件的相关文档说明，可以去<a href="https://developers.google.cn/protocol-buffers/docs/proto3#scalar" target="_blank" rel="noopener">官网查看</a></p><p>下面我写一个例子，请看示范：</p><pre><code class="proto">syntax = &quot;proto3&quot;; //版本option java_outer_classname = &quot;MessagePojo&quot;;//生成的外部类名，同时也是文件名message Message {    int32 id = 1;//Message类的一个属性，属性名称是id，序号为1    string content = 2;//Message类的一个属性，属性名称是content，序号为2}</code></pre><h4 id="第三步：使用编译器，通过-proto文件生成代码"><a href="#第三步：使用编译器，通过-proto文件生成代码" class="headerlink" title="第三步：使用编译器，通过.proto文件生成代码"></a>第三步：使用编译器，通过.proto文件生成代码</h4><p>解压前面下载下来的压缩包protoc-3.6.1-win32.zip,然后打开\protoc-3.6.1-win32\bin目录下，可以看到有一个protoc.exe程序。如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/1732508b9c9007ee?w=635&h=108&f=png&s=6967" srcset="/img/loading.gif" alt=""></p><p>然后复制前面写好的Message.proto文件到此目录下，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250997e5b223c?w=638&h=136&f=png&s=10706" srcset="/img/loading.gif" alt=""></p><p>接着在此目录下打开命令行cmd，输入命令：protoc.exe –java_out=. Message.proto</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250bea472e4c7?w=521&h=107&f=png&s=3797" srcset="/img/loading.gif" alt=""></p><p>然后就可以看到生成的MessagePojo.java文件。最后把文件复制到IDEA项目中。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250d5605c8188?w=242&h=179&f=png&s=7294" srcset="/img/loading.gif" alt=""></p><h4 id="第四步：在发送端添加编码器，在接收端添加解码器"><a href="#第四步：在发送端添加编码器，在接收端添加解码器" class="headerlink" title="第四步：在发送端添加编码器，在接收端添加解码器"></a>第四步：在发送端添加编码器，在接收端添加解码器</h4><p>客户端添加编码器，对消息进行编码。</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //在发送端添加Protobuf编码器        ch.pipeline().addLast(new ProtobufEncoder());        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>服务端添加解码器，对消息进行解码。</p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //添加Protobuf解码器，构造器需要指定解码具体的对象实例        ch.pipeline().addLast(new ProtobufDecoder(MessagePojo.Message.getDefaultInstance()));        //给pipeline管道设置处理器        ch.pipeline().addLast(new TcpServerHandler());    }</code></pre><h4 id="第五步：发送消息"><a href="#第五步：发送消息" class="headerlink" title="第五步：发送消息"></a>第五步：发送消息</h4><p>客户端发送消息，代码如下：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        //使用的是构建者模式进行创建对象        MessagePojo.Message message = MessagePojo                .Message                .newBuilder()                .setId(1)                .setContent(&quot;芜湖大司马，起飞~&quot;)                .build();        ctx.writeAndFlush(message);    }</code></pre><p>服务端接收到数据，并且打印：</p><pre><code class="java">    @Override    protected void channelRead0(ChannelHandlerContext ctx, MessagePojo.Message messagePojo) throws Exception {        System.out.println(&quot;id:&quot; + messagePojo.getId());        System.out.println(&quot;content:&quot; + messagePojo.getContent());    }</code></pre><p>测试结果正确：<br><img src="https://user-gold-cdn.xitu.io/2020/7/7/17325145051d6e3a?w=364&h=68&f=png&s=2580" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-3-分析Protocol的粘包、拆包"><a href="#2-3-3-分析Protocol的粘包、拆包" class="headerlink" title="2.3.3 分析Protocol的粘包、拆包"></a>2.3.3 分析Protocol的粘包、拆包</h3><p>实际上直接使用Protocol编解码器还是存在粘包问题的。</p><p>证明一下，发送端循环一百次发送100条”大司马，起飞”的消息，请看发送端代码演示：</p><pre><code class="java">    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        for (int i = 1; i &lt;= 100; i++) {            MessagePojo.Message message = MessagePojo                    .Message                    .newBuilder()                    .setId(i)                    .setContent(i + &quot;号大司马，起飞~&quot;)                    .build();            ctx.writeAndFlush(message);        }    }</code></pre><p>这时，启动服务端，客户端后，你会在控制台看到如下错误：</p><blockquote><p>com.google.protobuf.InvalidProtocolBufferException: While parsing a protocol message, the input ended unexpectedly in the middle of a field.  This could mean either that the input has been truncated or that an embedded message misreported its own length.</p></blockquote><p>意思是：分析protocol消息时，输入意外地在字段中间结束。这可能意味着输入被截断，或者嵌入的消息误报了自己的长度。</p><p>其实就是粘包问题，多条数据合并成一条数据了，导致解析出现异常。</p><h3 id="2-3-4-解决Protocol的粘包、拆包问题"><a href="#2-3-4-解决Protocol的粘包、拆包问题" class="headerlink" title="2.3.4 解决Protocol的粘包、拆包问题"></a>2.3.4 解决Protocol的粘包、拆包问题</h3><p>只需要在发送端加上编码器<strong>ProtobufVarint32LengthFieldPrepender</strong></p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());        ch.pipeline().addLast(new ProtobufEncoder());        ch.pipeline().addLast(new TcpClientHandler());    }</code></pre><p>接收方加上解码器<strong>ProtobufVarint32FrameDecoder</strong></p><pre><code class="java">    @Override    protected void initChannel(SocketChannel ch) throws Exception {        ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());        ch.pipeline().addLast(new ProtobufDecoder(MessagePojo.Message.getDefaultInstance()));        //给pipeline管道设置处理器        ch.pipeline().addLast(new TcpServerHandler());    }</code></pre><p>然后再启动服务端和客户端，我们可以看到<strong>马老师成功地起飞了</strong><del>~</del></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17329b2d05572fb7?w=261&h=284&f=png&s=15543" srcset="/img/loading.gif" alt=""></p><p>ProtobufVarint32LengthFieldPrepender编码器的工作如下：</p><pre><code class="java"> * BEFORE ENCODE (300 bytes)       AFTER ENCODE (302 bytes) * +---------------+               +--------+---------------+ * | Protobuf Data |--------------&gt;| Length | Protobuf Data | * |  (300 bytes)  |               | 0xAC02 |  (300 bytes)  | * +---------------+               +--------+---------------+@Sharablepublic class ProtobufVarint32LengthFieldPrepender extends MessageToByteEncoder&lt;ByteBuf&gt; {    @Override    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throws Exception {        int bodyLen = msg.readableBytes();        int headerLen = computeRawVarint32Size(bodyLen);        //写入请求头，消息长度        out.ensureWritable(headerLen + bodyLen);        writeRawVarint32(out, bodyLen);        //写入数据        out.writeBytes(msg, msg.readerIndex(), bodyLen);    }}</code></pre><p>ProtobufVarint32FrameDecoder解码器的工作如下：</p><pre><code class="java"> * BEFORE DECODE (302 bytes)       AFTER DECODE (300 bytes) * +--------+---------------+      +---------------+ * | Length | Protobuf Data |-----&gt;| Protobuf Data | * | 0xAC02 |  (300 bytes)  |      |  (300 bytes)  | * +--------+---------------+      +---------------+public class ProtobufVarint32FrameDecoder extends ByteToMessageDecoder {    @Override    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {        //标记读取的下标位置        in.markReaderIndex();        //获取读取的下标位置        int preIndex = in.readerIndex();        //解码，获取消息的长度,并且移动读取的下标位置        int length = readRawVarint32(in);        //比较解码前和解码后的下标位置，如果相等。表示字节数不够读取，跳到下一轮        if (preIndex == in.readerIndex()) {            return;        }        //如果消息的长度小于0，抛出异常        if (length &lt; 0) {            throw new CorruptedFrameException(&quot;negative length: &quot; + length);        }        //如果不够读取一个完整的数据，reset还原下标位置。        if (in.readableBytes() &lt; length) {            in.resetReaderIndex();        } else {            //否则，把数据写入到out，接收端就拿到了完整的数据了            out.add(in.readRetainedSlice(length));        } }</code></pre><p>总结一下：</p><p>发送端通过编码器在发送的时候在<strong>消息体前面加上一个描述数据长度的数据块</strong>。</p><p>接收方通过<strong>解码器先获取描述数据长度的数据块</strong>，知道完整数据的长度，<strong>然后根据数据长度获取一条完整的数据</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>创作不易</strong>，觉得有用就<strong>关注一下</strong>吧。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty入门</title>
    <link href="/2020/07/04/Netty%E5%85%A5%E9%97%A8/"/>
    <url>/2020/07/04/Netty%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731948029b90fc2?w=755&h=648&f=png&s=53135" srcset="/img/loading.gif" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲述Netty框架的一些特性以及重要组件，希望看完之后能对Netty框架有一个比较直观的感受，希望能帮助读者快速入门Netty，减少一些弯路。</p><a id="more"></a><h1 id="一、Netty概述"><a href="#一、Netty概述" class="headerlink" title="一、Netty概述"></a>一、Netty概述</h1><p>官方的介绍：</p><blockquote><p>Netty is <em>an asynchronous event-driven network application framework</em><br>for rapid development of maintainable high performance protocol servers &amp; clients.</p></blockquote><p><strong>Netty</strong>是 一个<strong>异步事件驱动</strong>的网络应用程序框架，用于<strong>快速开发可维护的高性能协议服务器和客户端</strong>。</p><h1 id="二、为什么使用Netty"><a href="#二、为什么使用Netty" class="headerlink" title="二、为什么使用Netty"></a>二、为什么使用Netty</h1><p>从官网上介绍，Netty是一个网络应用程序框架，开发服务器和客户端。也就是用于网络编程的一个框架。既然是网络编程，Socket就不谈了，为什么不用NIO呢？</p><h2 id="2-1-NIO的缺点"><a href="#2-1-NIO的缺点" class="headerlink" title="2.1 NIO的缺点"></a>2.1 NIO的缺点</h2><p>对于这个问题，之前我写了一篇文章<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw" target="_blank" rel="noopener">《NIO入门》</a>对NIO有比较详细的介绍，NIO的主要问题是：</p><ul><li>NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</li><li>需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。</li><li>臭名昭著的epoll bug。它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本依然没得到根本性的解决。</li></ul><h2 id="2-2-Netty的优点"><a href="#2-2-Netty的优点" class="headerlink" title="2.2 Netty的优点"></a>2.2 Netty的优点</h2><p>相对地，Netty的优点有很多：</p><ul><li>API使用简单，学习成本低。</li><li>功能强大，内置了多种解码编码器，支持多种协议。</li><li>性能高，对比其他主流的NIO框架，Netty的性能最优。</li><li>社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。</li><li>Dubbo、Elasticsearch都采用了Netty，质量得到验证。</li></ul><h1 id="三、架构图"><a href="#三、架构图" class="headerlink" title="三、架构图"></a>三、架构图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194d4a8fd419c?w=592&h=348&f=png&s=55075" srcset="/img/loading.gif" alt=""></p><p>上面这张图就是在官网首页的架构图，我们从上到下分析一下。</p><blockquote><p>绿色的部分<strong>Core</strong>核心模块，包括零拷贝、API库、可扩展的事件模型。</p></blockquote><blockquote><p>橙色部分<strong>Protocol Support</strong>协议支持，包括Http协议、webSocket、SSL(安全套接字协议)、谷歌Protobuf协议、zlib/gzip压缩与解压缩、Large File Transfer大文件传输等等。</p></blockquote><blockquote><p>红色的部分<strong>Transport Services</strong>传输服务，包括Socket、Datagram、Http Tunnel等等。</p></blockquote><p>以上可看出Netty的功能、协议、传输方式都比较全，比较强大。</p><h1 id="四、永远的Hello-Word"><a href="#四、永远的Hello-Word" class="headerlink" title="四、永远的Hello Word"></a>四、永远的Hello Word</h1><p>首先搭建一个HelloWord工程，先熟悉一下API，还有为后面的学习做铺垫。以下面这张图为依据：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc0641d4ed5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt=""></p><h2 id="4-1-引入Maven依赖"><a href="#4-1-引入Maven依赖" class="headerlink" title="4.1 引入Maven依赖"></a>4.1 引入Maven依赖</h2><p>使用的版本是4.1.20，相对比较稳定的一个版本。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.netty&lt;/groupId&gt;    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;    &lt;version&gt;4.1.20.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="4-2-创建服务端启动类"><a href="#4-2-创建服务端启动类" class="headerlink" title="4.2 创建服务端启动类"></a>4.2 创建服务端启动类</h2><pre><code class="java">public class MyServer {    public static void main(String[] args) throws Exception {        //创建两个线程组 boosGroup、workerGroup        EventLoopGroup bossGroup = new NioEventLoopGroup();        EventLoopGroup workerGroup = new NioEventLoopGroup();        try {            //创建服务端的启动对象，设置参数            ServerBootstrap bootstrap = new ServerBootstrap();            //设置两个线程组boosGroup和workerGroup            bootstrap.group(bossGroup, workerGroup)                //设置服务端通道实现类型                    .channel(NioServerSocketChannel.class)                //设置线程队列得到连接个数                    .option(ChannelOption.SO_BACKLOG, 128)                //设置保持活动连接状态                    .childOption(ChannelOption.SO_KEEPALIVE, true)                //使用匿名内部类的形式初始化通道对象                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {                        @Override                        protected void initChannel(SocketChannel socketChannel) throws Exception {                            //给pipeline管道设置处理器                            socketChannel.pipeline().addLast(new MyServerHandler());                        }                    });//给workerGroup的EventLoop对应的管道设置处理器            System.out.println(&quot;java技术爱好者的服务端已经准备就绪...&quot;);            //绑定端口号，启动服务端            ChannelFuture channelFuture = bootstrap.bind(6666).sync();            //对关闭通道进行监听            channelFuture.channel().closeFuture().sync();        } finally {            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        }    }}</code></pre><h2 id="4-3-创建服务端处理器"><a href="#4-3-创建服务端处理器" class="headerlink" title="4.3 创建服务端处理器"></a>4.3 创建服务端处理器</h2><pre><code class="java">/** * 自定义的Handler需要继承Netty规定好的HandlerAdapter * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式 **/public class MyServerHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //获取客户端发送过来的消息        ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(&quot;收到客户端&quot; + ctx.channel().remoteAddress() + &quot;发送的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));    }    @Override    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {        //发送消息给客户端        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;服务端已收到消息，并给你发送一个问号?&quot;, CharsetUtil.UTF_8));    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {        //发生异常，关闭通道        ctx.close();    }}</code></pre><h2 id="4-4-创建客户端启动类"><a href="#4-4-创建客户端启动类" class="headerlink" title="4.4 创建客户端启动类"></a>4.4 创建客户端启动类</h2><pre><code class="java">public class MyClient {    public static void main(String[] args) throws Exception {        NioEventLoopGroup eventExecutors = new NioEventLoopGroup();        try {            //创建bootstrap对象，配置参数            Bootstrap bootstrap = new Bootstrap();            //设置线程组            bootstrap.group(eventExecutors)                //设置客户端的通道实现类型                    .channel(NioSocketChannel.class)                //使用匿名内部类初始化通道                .handler(new ChannelInitializer&lt;SocketChannel&gt;() {                        @Override                        protected void initChannel(SocketChannel ch) throws Exception {                            //添加客户端通道的处理器                            ch.pipeline().addLast(new MyClientHandler());                        }                    });            System.out.println(&quot;客户端准备就绪，随时可以起飞~&quot;);            //连接服务端            ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666).sync();            //对通道关闭进行监听            channelFuture.channel().closeFuture().sync();        } finally {            //关闭线程组            eventExecutors.shutdownGracefully();        }    }}</code></pre><h2 id="4-5-创建客户端处理器"><a href="#4-5-创建客户端处理器" class="headerlink" title="4.5 创建客户端处理器"></a>4.5 创建客户端处理器</h2><pre><code class="java">public class MyClientHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        //发送消息到服务端        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;, CharsetUtil.UTF_8));    }    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //接收服务端发送过来的消息        ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(&quot;收到服务端&quot; + ctx.channel().remoteAddress() + &quot;的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));    }}</code></pre><h2 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h2><p>先启动服务端，再启动客户端，就可以看到结果：</p><p>MyServer打印结果:</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194df71b69cc2?w=764&h=65&f=png&s=10322" srcset="/img/loading.gif" alt=""></p><p>MyClient打印结果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194e2409505c1?w=712&h=49&f=png&s=7914" srcset="/img/loading.gif" alt=""></p><h1 id="五、Netty的特性与重要组件"><a href="#五、Netty的特性与重要组件" class="headerlink" title="五、Netty的特性与重要组件"></a>五、Netty的特性与重要组件</h1><h2 id="5-1-taskQueue任务队列"><a href="#5-1-taskQueue任务队列" class="headerlink" title="5.1 taskQueue任务队列"></a>5.1 taskQueue任务队列</h2><p>如果Handler处理器有一些长时间的业务处理，可以交给<strong>taskQueue异步处理</strong>。怎么用呢，请看代码演示：</p><pre><code class="java">public class MyServerHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //获取到线程池eventLoop，添加线程，执行        ctx.channel().eventLoop().execute(new Runnable() {            @Override            public void run() {                try {                    //长时间操作，不至于长时间的业务操作导致Handler阻塞                    Thread.sleep(1000);                    System.out.println(&quot;长时间的业务处理&quot;);                } catch (Exception e) {                    e.printStackTrace();                }            }        });    }}</code></pre><p>我们打一个debug调试，是可以看到添加进去的taskQueue有一个任务。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194f4d1d340fc?w=675&h=233&f=png&s=18480" srcset="/img/loading.gif" alt=""></p><h2 id="5-2-scheduleTaskQueue延时任务队列"><a href="#5-2-scheduleTaskQueue延时任务队列" class="headerlink" title="5.2 scheduleTaskQueue延时任务队列"></a>5.2 scheduleTaskQueue延时任务队列</h2><p>延时任务队列和上面介绍的任务队列非常相似，只是多了一个可延迟一定时间再执行的设置，请看代码演示：</p><pre><code class="java">ctx.channel().eventLoop().schedule(new Runnable() {    @Override    public void run() {        try {            //长时间操作，不至于长时间的业务操作导致Handler阻塞            Thread.sleep(1000);            System.out.println(&quot;长时间的业务处理&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }},5, TimeUnit.SECONDS);//5秒后执行</code></pre><p>依然打开debug进行调试查看，我们可以有一个scheduleTaskQueue任务待执行中</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173194f21adfa111?w=705&h=214&f=png&s=17798" srcset="/img/loading.gif" alt=""></p><h2 id="5-3-Future异步机制"><a href="#5-3-Future异步机制" class="headerlink" title="5.3 Future异步机制"></a>5.3 Future异步机制</h2><p>在搭建HelloWord工程的时候，我们看到有一行这样的代码：</p><pre><code class="java">ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666);</code></pre><p>很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？</p><p>ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。请看一段代码演示：</p><pre><code class="java">//添加监听器channelFuture.addListener(new ChannelFutureListener() {    //使用匿名内部类，ChannelFutureListener接口    //重写operationComplete方法    @Override    public void operationComplete(ChannelFuture future) throws Exception {        //判断是否操作成功            if (future.isSuccess()) {            System.out.println(&quot;连接成功&quot;);        } else {            System.out.println(&quot;连接失败&quot;);        }    }});</code></pre><h2 id="5-4-Bootstrap与ServerBootStrap"><a href="#5-4-Bootstrap与ServerBootStrap" class="headerlink" title="5.4 Bootstrap与ServerBootStrap"></a>5.4 Bootstrap与ServerBootStrap</h2><p>Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731950cf2dbd785?w=595&h=296&f=png&s=7746" srcset="/img/loading.gif" alt=""></p><p>可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。</p><p>一般来说，使用Bootstrap创建启动器的步骤可分为以下几步：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731951012e334fc?w=960&h=292&f=png&s=20428" srcset="/img/loading.gif" alt=""></p><h3 id="5-4-1-group"><a href="#5-4-1-group" class="headerlink" title="5.4.1 group()"></a>5.4.1 group()</h3><p>在上一篇文章<a href="https://mp.weixin.qq.com/s/vWbbn1qXRFVva8Y9yET18Q" target="_blank" rel="noopener">《Reactor模式》</a>中，我们就讲过服务端要使用两个线程组：</p><ul><li>bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。</li><li>workerGroup用于处理每一个连接发生的读写事件。</li></ul><p>一般创建线程组直接使用以下new就完事了：</p><pre><code class="java">EventLoopGroup bossGroup = new NioEventLoopGroup();EventLoopGroup workerGroup = new NioEventLoopGroup();</code></pre><p>有点好奇的是，既然是线程组，那线程数默认是多少呢？深入源码：</p><pre><code class="java">    //使用一个常量保存    private static final int DEFAULT_EVENT_LOOP_THREADS;    static {        //NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量        DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(                &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));        if (logger.isDebugEnabled()) {            logger.debug(&quot;-Dio.netty.eventLoopThreads: {}&quot;, DEFAULT_EVENT_LOOP_THREADS);        }    }    protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {        //如果不传入，则使用常量的值，也就是cpu核数的两倍        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);    }</code></pre><p>通过源码可以看到，默认的线程数是cpu核数的两倍。假设想自定义线程数，可以使用有参构造器：</p><pre><code class="java">//设置bossGroup线程数为1EventLoopGroup bossGroup = new NioEventLoopGroup(1);//设置workerGroup线程数为16EventLoopGroup workerGroup = new NioEventLoopGroup(16);</code></pre><h3 id="5-4-2-channel"><a href="#5-4-2-channel" class="headerlink" title="5.4.2 channel()"></a>5.4.2 channel()</h3><p>这个方法用于设置通道类型，当建立连接后，会根据这个设置创建对应的Channel实例。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731951ae3c43228?w=838&h=328&f=png&s=59491" srcset="/img/loading.gif" alt=""></p><p>使用debug模式可以看到</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731951f80b07785?w=495&h=212&f=png&s=16456" srcset="/img/loading.gif" alt=""></p><p>通道类型有以下：</p><p><strong>NioSocketChannel</strong>： 异步非阻塞的客户端 TCP Socket 连接。</p><p><strong>NioServerSocketChannel</strong>： 异步非阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。</p></blockquote><p>OioSocketChannel： 同步阻塞的客户端 TCP Socket 连接。</p><p>OioServerSocketChannel： 同步阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>稍微在本地调试过，用起来和Nio有一些不同，是阻塞的，所以API调用也不一样。因为是阻塞的IO，几乎没什么人会选择使用Oio，所以也很难找到例子。我稍微琢磨了一下，经过几次报错之后，总算调通了。代码如下：</p></blockquote><pre><code class="java">//server端代码，跟上面几乎一样，只需改三个地方//这个地方使用的是OioEventLoopGroupEventLoopGroup bossGroup = new OioEventLoopGroup();ServerBootstrap bootstrap = new ServerBootstrap();bootstrap.group(bossGroup)//只需要设置一个线程组boosGroup        .channel(OioServerSocketChannel.class)//设置服务端通道实现类型//client端代码，只需改两个地方//使用的是OioEventLoopGroupEventLoopGroup eventExecutors = new OioEventLoopGroup();//通道类型设置为OioSocketChannelbootstrap.group(eventExecutors)//设置线程组        .channel(OioSocketChannel.class)//设置客户端的通道实现类型</code></pre><p>NioSctpChannel： 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。<br>NioSctpServerChannel： 异步的 Sctp 服务器端连接。</p><blockquote><p>本地没启动成功，网上看了一些网友的评论，说是只能在linux环境下才可以启动。从报错信息看：SCTP not supported on this platform，不支持这个平台。因为我电脑是window系统，所以网友说的有点道理。</p></blockquote><h3 id="5-4-3-option-与childOption"><a href="#5-4-3-option-与childOption" class="headerlink" title="5.4.3 option()与childOption()"></a>5.4.3 option()与childOption()</h3><p>首先说一下这两个的区别。</p><p>option()设置的是服务端用于接收进来的连接，也就是boosGroup线程。</p><p>childOption()是提供给父管道接收到的连接，也就是workerGroup线程。</p><p>搞清楚了之后，我们看一下常用的一些设置有哪些：</p><p>SocketChannel参数，也就是childOption()常用的参数：</p><blockquote><p><strong>SO_RCVBUF</strong>     Socket参数，TCP数据接收缓冲区大小。<br><strong>TCP_NODELAY</strong>     TCP参数，立即发送数据，默认值为Ture。<br><strong>SO_KEEPALIVE</strong>     Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。</p></blockquote><p>ServerSocketChannel参数，也就是option()常用参数：</p><blockquote><p><strong>SO_BACKLOG</strong>     Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。</p></blockquote><p>由于篇幅限制，其他就不列举了，大家可以去网上找资料看看，了解一下。</p><h3 id="5-4-4-设置流水线-重点"><a href="#5-4-4-设置流水线-重点" class="headerlink" title="5.4.4 设置流水线(重点)"></a>5.4.4 设置流水线(重点)</h3><p>ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。</p><p>在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。代码演示如下：</p><pre><code class="java">//使用匿名内部类的形式初始化通道对象bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {    @Override    protected void initChannel(SocketChannel socketChannel) throws Exception {        //给pipeline管道设置自定义的处理器        socketChannel.pipeline().addLast(new MyServerHandler());    }});</code></pre><p>处理器Handler主要分为两种：</p><blockquote><p>ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器)</p></blockquote><p>入站指的是数据从底层java NIO Channel到Netty的Channel。</p><p>出站指的是通过Netty的Channel来操作底层的java NIO Channel。</p><p><strong>ChannelInboundHandlerAdapter处理器常用的事件有</strong>：</p><ol><li><p>注册事件 fireChannelRegistered。</p></li><li><p>连接建立事件 fireChannelActive。</p></li><li><p>读事件和读完成事件 fireChannelRead、fireChannelReadComplete。</p></li><li><p>异常通知事件 fireExceptionCaught。</p></li><li><p>用户自定义事件 fireUserEventTriggered。</p></li><li><p>Channel 可写状态变化事件 fireChannelWritabilityChanged。</p></li><li><p>连接关闭事件 fireChannelInactive。</p></li></ol><p><strong>ChannelOutboundHandler处理器常用的事件有</strong>：</p><ol><li><p>端口绑定 bind。</p></li><li><p>连接服务端 connect。</p></li><li><p>写事件 write。</p></li><li><p>刷新时间 flush。</p></li><li><p>读事件 read。</p></li><li><p>主动断开连接 disconnect。</p></li><li><p>关闭 channel 事件 close。</p></li></ol><blockquote><p>还有一个类似的handler()，主要用于装配parent通道，也就是bossGroup线程。一般情况下，都用不上这个方法。</p></blockquote><h3 id="5-4-5-bind"><a href="#5-4-5-bind" class="headerlink" title="5.4.5 bind()"></a>5.4.5 bind()</h3><p>提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步。</p><p>有五个同名的重载方法，作用都是用于绑定地址端口号。不一一介绍了。</p><h3 id="5-4-6-优雅地关闭EventLoopGroup"><a href="#5-4-6-优雅地关闭EventLoopGroup" class="headerlink" title="5.4.6 优雅地关闭EventLoopGroup"></a>5.4.6 优雅地关闭EventLoopGroup</h3><pre><code class="java">//释放掉所有的资源，包括创建的线程bossGroup.shutdownGracefully();workerGroup.shutdownGracefully();</code></pre><p>会关闭所有的child Channel。关闭之后，释放掉底层的资源。</p><h2 id="5-5-Channel"><a href="#5-5-Channel" class="headerlink" title="5.5 Channel"></a>5.5 Channel</h2><p>Channel是什么？不妨看一下官方文档的说明：</p><blockquote><p>A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind</p></blockquote><p>翻译大意：一种连接到网络套接字或能进行读、写、连接和绑定等I/O操作的组件。</p><p>如果上面这段说明比较抽象，下面还有一段说明：</p><blockquote><p>A channel provides a user:</p><p>the current state of the channel (e.g. is it open? is it connected?),<br>the configuration parameters of the channel (e.g. receive buffer size),<br>the I/O operations that the channel supports (e.g. read, write, connect, and bind), and<br>the ChannelPipeline which handles all I/O events and requests associated with the channel.</p></blockquote><p>翻译大意：</p><p>channel为用户提供：</p><ol><li><p>通道当前的状态（例如它是打开？还是已连接？）</p></li><li><p>channel的配置参数（例如接收缓冲区的大小）</p></li><li><p>channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。</p></li></ol><h3 id="5-5-1-获取channel的状态"><a href="#5-5-1-获取channel的状态" class="headerlink" title="5.5.1 获取channel的状态"></a>5.5.1 获取channel的状态</h3><pre><code class="java">boolean isOpen(); //如果通道打开，则返回trueboolean isRegistered();//如果通道注册到EventLoop，则返回trueboolean isActive();//如果通道处于活动状态并且已连接，则返回trueboolean isWritable();//当且仅当I/O线程将立即执行请求的写入操作时，返回true。</code></pre><p>以上就是获取channel的四种状态的方法。</p><h3 id="5-5-2-获取channel的配置参数"><a href="#5-5-2-获取channel的配置参数" class="headerlink" title="5.5.2 获取channel的配置参数"></a>5.5.2 获取channel的配置参数</h3><p>获取单条配置信息，使用getOption()，代码演示：</p><pre><code class="java">ChannelConfig config = channel.config();//获取配置参数//获取ChannelOption.SO_BACKLOG参数,Integer soBackLogConfig = config.getOption(ChannelOption.SO_BACKLOG);//因为我启动器配置的是128，所以我这里获取的soBackLogConfig=128</code></pre><p>获取多条配置信息，使用getOptions()，代码演示：</p><pre><code class="java">ChannelConfig config = channel.config();Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = config.getOptions();for (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; entry : options.entrySet()) {    System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue());}/**SO_REUSEADDR : falseWRITE_BUFFER_LOW_WATER_MARK : 32768WRITE_BUFFER_WATER_MARK : WriteBufferWaterMark(low: 32768, high: 65536)SO_BACKLOG : 128以下省略...*/</code></pre><h3 id="5-5-3-channel支持的IO操作"><a href="#5-5-3-channel支持的IO操作" class="headerlink" title="5.5.3 channel支持的IO操作"></a>5.5.3 channel支持的IO操作</h3><p><strong>写操作</strong>，这里演示从服务端写消息发送到客户端：</p><pre><code class="java">@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {    ctx.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;这波啊，这波是肉蛋葱鸡~&quot;, CharsetUtil.UTF_8));}</code></pre><p>客户端控制台：</p><pre><code class="java">//收到服务端/127.0.0.1:6666的消息：这波啊，这波是肉蛋葱鸡~</code></pre><p><strong>连接</strong>操作，代码演示：</p><pre><code class="java">ChannelFuture connect = channelFuture.channel().connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666));//一般使用启动器，这种方式不常用</code></pre><p><strong>通过channel获取ChannelPipeline</strong>，并做相关的处理：</p><pre><code class="java">//获取ChannelPipeline对象ChannelPipeline pipeline = ctx.channel().pipeline();//往pipeline中添加ChannelHandler处理器，装配流水线pipeline.addLast(new MyServerHandler());</code></pre><h2 id="5-6-Selector"><a href="#5-6-Selector" class="headerlink" title="5.6 Selector"></a>5.6 Selector</h2><p>在NioEventLoop中，有一个成员变量selector，这是nio包的Selector，在之前<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw" target="_blank" rel="noopener">《NIO入门》</a>中，我已经讲过Selector了。</p><p>Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731957c1e90bf2a?w=725&h=576&f=png&s=326067" srcset="/img/loading.gif" alt=""></p><h2 id="5-7-PiPeline与ChannelPipeline"><a href="#5-7-PiPeline与ChannelPipeline" class="headerlink" title="5.7 PiPeline与ChannelPipeline"></a>5.7 PiPeline与ChannelPipeline</h2><p>在前面介绍Channel时，我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。</p><p>于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731954229ab93ac?w=719&h=240&f=png&s=8344" srcset="/img/loading.gif" alt=""></p><p>在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。</p><h2 id="5-8-ChannelHandlerContext"><a href="#5-8-ChannelHandlerContext" class="headerlink" title="5.8 ChannelHandlerContext"></a>5.8 ChannelHandlerContext</h2><p>在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。</p><p>于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731954657f33870?w=540&h=230&f=png&s=7746" srcset="/img/loading.gif" alt=""></p><p>通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。</p><p>实际上ChannelHandlerContext在pipeline中是一个链表的形式。看一段源码就明白了：</p><pre><code class="java">//ChannelPipeline实现类DefaultChannelPipeline的构造器方法protected DefaultChannelPipeline(Channel channel) {    this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);    succeededFuture = new SucceededChannelFuture(channel, null);    voidPromise =  new VoidChannelPromise(channel, true);    //设置头结点head，尾结点tail    tail = new TailContext(this);    head = new HeadContext(this);    head.next = tail;    tail.prev = head;}</code></pre><p>下面我用一张图来表示，会更加清晰一点：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731954b31d6c9cf?w=942&h=262&f=png&s=16168" srcset="/img/loading.gif" alt=""></p><h2 id="5-9-EventLoopGroup"><a href="#5-9-EventLoopGroup" class="headerlink" title="5.9 EventLoopGroup"></a>5.9 EventLoopGroup</h2><p>我们先看一下EventLoopGroup的类图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731955081291714?w=738&h=216&f=png&s=6894" srcset="/img/loading.gif" alt=""></p><p>其中包括了常用的实现类NioEventLoopGroup。OioEventLoopGroup在前面的例子中也有使用过。</p><p>从Netty的架构图中，可以知道服务器是需要两个线程组进行配合工作的，而这个线程组的接口就是EventLoopGroup。</p><p>每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。</p><h3 id="5-9-1-轮询机制的实现原理"><a href="#5-9-1-轮询机制的实现原理" class="headerlink" title="5.9.1 轮询机制的实现原理"></a>5.9.1 轮询机制的实现原理</h3><p>我们不妨看一段DefaultEventExecutorChooserFactory的源码：</p><pre><code class="java">private final AtomicInteger idx = new AtomicInteger();private final EventExecutor[] executors;@Overridepublic EventExecutor next() {    //idx.getAndIncrement()相当于idx++，然后对任务长度取模    return executors[idx.getAndIncrement() &amp; executors.length - 1];}</code></pre><p>这段代码可以确定执行的方式是轮询机制，接下来debug调试一下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17319554d4546047?w=1241&h=520&f=png&s=82119" srcset="/img/loading.gif" alt=""></p><p>它这里还有一个判断，如果线程数不是2的N次方，则采用取模算法实现。</p><pre><code class="java">@Overridepublic EventExecutor next() {    return executors[Math.abs(idx.getAndIncrement() % executors.length)];}</code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>参考Netty官网文档：<a href="https://netty.io/4.1/api/index.html" target="_blank" rel="noopener">API文档</a></p><p><strong>创作不易</strong>，觉得有用就<strong>点个赞</strong>吧。</p><p>我不要下次一定，希望<strong>这次一定素质三连</strong>，感谢！</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reactor模式</title>
    <link href="/2020/07/01/Reactor%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/07/01/Reactor%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05ba3465c?w=894&h=436&f=png&s=45997" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="一、Reactor模式介绍"><a href="#一、Reactor模式介绍" class="headerlink" title="一、Reactor模式介绍"></a>一、Reactor模式介绍</h1><p>本文主要参考Doug Lea(大神)的“<strong>Scalable IO in Java</strong>”中讲述的Reactor模式。</p><p>原文地址：<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p>有兴趣的可以看看这本书，受益匪浅！</p><a id="more"></a><h2 id="1-1-什么是Reactor模式"><a href="#1-1-什么是Reactor模式" class="headerlink" title="1.1 什么是Reactor模式"></a>1.1 什么是Reactor模式</h2><p>Reactor模式一般翻译成”<strong>反应器模式</strong>“，也有人称为”<strong>分发者模式</strong>“。它是将客户端请求提交到一个或者多个服务处理程序的设计模式。工作原理是由<strong>一个线程来接收所有的请求</strong>，然后<strong>派发这些请求到相关的工作线程中</strong>。</p><h2 id="1-2-为什么使用Reactor模式"><a href="#1-2-为什么使用Reactor模式" class="headerlink" title="1.2 为什么使用Reactor模式"></a>1.2 为什么使用Reactor模式</h2><p>在java中，没有NIO出现之前都是使用socket编程。socket的接收请求是阻塞的，需要处理完一个请求才能处理下一个请求，所以在面对高并发的服务请求时，性能就会很差。</p><p>那有人就会说使用多线程（如下图所示）。接收到一个请求，就创建一个线程处理，这样就不会阻塞了。实际上这样的确是可以在提升性能上起到一定的作用，<strong>但是当请求很多的时候，就会创建大量的线程，维护线程需要资源的消耗，线程之间的切换也需要消耗性能</strong>。而且系统创建线程的数量也是有限的，所以当高并发时，会直接把系统拖垮。<br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05ef76206?w=736&h=316&f=png&s=203508" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由于以上的问题，提出了Reactor模式。</p><p>基于Java，Doug Lea（Java并发包作者）提出了三种形式，<strong>单Reactor单线程，单Reactor多线程和多Reactor多线程</strong>。</p><h1 id="二、Reactor模式的演进过程"><a href="#二、Reactor模式的演进过程" class="headerlink" title="二、Reactor模式的演进过程"></a>二、Reactor模式的演进过程</h1><p>在介绍三种Reactor模式前，先简单地说明三个角色：</p><blockquote><p><code>Reactor</code>：负责响应事件，将事件分发到绑定了对应事件的Handler，如果是连接事件，则分发到Acceptor。</p></blockquote><blockquote><p><code>Handler</code>：事件处理器。负责执行对应事件对应的业务逻辑。</p></blockquote><blockquote><p><code>Acceptor</code>：绑定了 connect 事件，当客户端发起connect请求时，Reactor会将accept事件分发给Acceptor处理。</p></blockquote><h2 id="2-1-单Reactor单线程"><a href="#2-1-单Reactor单线程" class="headerlink" title="2.1 单Reactor单线程"></a>2.1 单Reactor单线程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05bf6fbe7?w=714&h=310&f=png&s=84409" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>只有一个<code>select</code>循环接收请求，客户端（client）注册进来由<code>Reactor</code>接收注册事件，然后再由reactor分发（dispatch）出去，由下面的处理器（Handler）去处理。</p></blockquote><h3 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>一个餐厅里只有一个既是前台也是服务员的人，负责接待客人，也负责把客人点的菜下达给厨师。</p><h3 id="单Reactor单线程的特点"><a href="#单Reactor单线程的特点" class="headerlink" title="单Reactor单线程的特点"></a>单Reactor单线程的特点</h3><p>单线程的问题实际上是很明显的。只要其中一个Handler方法阻塞了，那就会导致所有的client的Handler都被阻塞了，也会导致注册事件也无法处理，无法接收新的请求。所以这种模式用的比较少，因为不能充分利用到多核的资源。</p><p>这种模式仅仅只能处理Handler比较快速完成的场景。</p><h2 id="2-2-单Reactor多线程"><a href="#2-2-单Reactor多线程" class="headerlink" title="2.2 单Reactor多线程"></a>2.2 单Reactor多线程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05fac64c3?w=721&h=496&f=png&s=181611" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>在<strong>单Reactor多线程</strong>中，注册接收事件都是由<code>Reactor</code>来做，其它的计算，编解码由一个线程池来做。从图中可以看出工作线程是多线程的，监听注册事件的<code>Reactor</code>还是单线程。</p></blockquote><h3 id="通俗解释-1"><a href="#通俗解释-1" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>相当于餐厅里有一个前台，多个服务员。前台只负责接待客人，服务员只负责服务客人。</p><h3 id="单Reactor多线程的特点"><a href="#单Reactor多线程的特点" class="headerlink" title="单Reactor多线程的特点"></a>单Reactor多线程的特点</h3><p>对比<strong>单Reactor单线程</strong>模型，多线程Reactor模式在Handler读写处理时，交给工作线程池处理，不会导致Reactor无法执行，因为Reactor分发和Handler处理是分开的，能充分地利用资源。从而提升应用的性能。</p><p>缺点：<br>Reactor只在主线程中运行，承担所有事件的监听和响应，如果短时间的高并发场景下，依然会造成性能瓶颈。</p><h2 id="2-3-多Reactor多线程"><a href="#2-3-多Reactor多线程" class="headerlink" title="2.3 多Reactor多线程"></a>2.3 多Reactor多线程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc05faeebc1?w=686&h=483&f=png&s=121267" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>1、mainReactor负责监听客户端请求，专门处理新连接的建立，将建立好的连接注册到subReactor。<br>2、subReactor 将分配的连接加入到队列进行监听，当有新的事件发生时，会调用连接相对应的Handler进行处理。</p></blockquote><h3 id="通俗解释-2"><a href="#通俗解释-2" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>相当于餐厅里有多个前台和多个服务员，前台只负责接待客人，服务员只负责服务客人。</p><h3 id="多Reactor多线程的特点"><a href="#多Reactor多线程的特点" class="headerlink" title="多Reactor多线程的特点"></a>多Reactor多线程的特点</h3><p>mainReactor 主要是用来处理客户端请求连接建立的操作。<br>subReactor主要做和建立起来的连接做数据交互和事件业务处理操作，每个subReactor一个线程来处理。</p><blockquote><p>这样的模型使得每个模块更加专一，耦合度更低，能支持更高的并发量。许多框架也使用这种模式，比如接下来要讲的Netty框架就采用了这种模式。</p></blockquote><h1 id="三、在Netty中的应用"><a href="#三、在Netty中的应用" class="headerlink" title="三、在Netty中的应用"></a>三、在Netty中的应用</h1><p>Netty可谓是框架中精品中的极品，要用一张图或者一段话来总结概括不太可能，所以下面我仅分析一下Netty框架的架构模型。在下一篇文章再继续深入探究Netty。<br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc0641d4ed5?w=855&h=726&f=png&s=400825" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这个架构实际上跟多Reactor多线程模型比较像。</p><blockquote><p>1、BossGroup相当于mainReactor，负责建立连接并且把连接注册到WorkGroup中。WorkGroup负责处理连接对应的读写事件。</p></blockquote><blockquote><p>2、BossGroup和WorkGroup是两个线程池，里面有多个NioEventGroup(实际上是线程)，默认BossGroup和WorkGroup里的线程数是cpu核数的两倍（源码中有体现）。</p></blockquote><blockquote><p>3、每一个NioEventGroup都是一个无限循环，负责监听相对应的事件。</p></blockquote><blockquote><p>4、Pipeline(通道)里包含多个ChannelHandler(业务处理)，按顺序执行。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>其实上面的这些模型都只是一种思想，很多人可能觉得学习思想不是很重要。实际上要学习一门技术，要先有天上飞的理论才有落地的产品。世界上的事物大多都是如此。</p><p>最后借用大神<strong>Doug Lea</strong>的名言：</p><blockquote><p>分享知识和分享苹果是不一样的，苹果会越分越少，而自己的知识并不会因为给了别人就减少了，知识的分享更能激荡出不一样的火花。</p></blockquote><p><strong>创作不易</strong>，觉得有用就<strong>点个赞</strong>吧。</p><p>下一篇讲Netty框架，想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/30/17305cc08a7ed5d7?w=1180&h=528&f=png&s=152520" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO入门</title>
    <link href="/2020/06/25/NIO%E5%85%A5%E9%97%A8/"/>
    <url>/2020/06/25/NIO%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://static.lovebilibili.com/image-20200625230224224.png" srcset="/img/loading.gif" alt="image-20200625230224224"></p><blockquote><p>学如逆水行舟，不进则退</p></blockquote><h1 id="1-NIO概述"><a href="#1-NIO概述" class="headerlink" title="1 NIO概述"></a>1 NIO概述</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p><strong>java.nio</strong>全称<strong>java non-blocking IO</strong>，是指<strong>JDK1.4 及以上</strong>版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供<strong>缓存支持的数据容器</strong>，使用它可以提供<strong>非阻塞式</strong>的高伸缩性网络(来源于百度百科)。</p><a id="more"></a><h2 id="1-2-为什么使用NIO"><a href="#1-2-为什么使用NIO" class="headerlink" title="1.2 为什么使用NIO"></a>1.2 为什么使用NIO</h2><p>在上面的描述中提到，是在JDK1.4以上的版本才提供NIO，那在之前使用的是什么呢？答案很简单，就是<strong>BIO</strong>(阻塞式IO)，也就是我们常用的IO流。</p><p>BIO的问题其实不用多说了，因为在使用BIO时，主线程会进入阻塞状态，这就非常影响程序的性能，<strong>不能充分利用机器资源</strong>。但是这样就会有人提出疑问了，那我<strong>使用多线程</strong>不就可以了吗？</p><p>但是在高并发的情况下，会创建很多线程，线程会占用内存，线程之间的切换也会浪费资源开销。</p><p>而NIO<strong>只有在连接/通道真正有读写事件</strong>发生时(<strong>事件驱动</strong>)，<strong>才会进行读写</strong>，就大大地减少了系统的开销。不必为每一个连接都创建一个线程，也不必去维护多个线程。</p><p><strong>避免了多个线程之间的上下文切换</strong>，导致资源的浪费。</p><h1 id="为什么使用NIO"><a href="#为什么使用NIO" class="headerlink" title="为什么使用NIO"></a>为什么使用NIO</h1><h1 id="2-NIO的三大核心"><a href="#2-NIO的三大核心" class="headerlink" title="2 NIO的三大核心"></a>2 NIO的三大核心</h1><table><thead><tr><th>NIO的核心</th><th>对应的类或接口</th><th>应用</th><th>作用</th></tr></thead><tbody><tr><td>缓冲区</td><td>java.nio.Buffer</td><td>文件IO/网络IO</td><td>存储数据</td></tr><tr><td>通道</td><td>java.nio.channels.Channel</td><td>文件IO/网络IO</td><td>运输</td></tr><tr><td>选择器</td><td>java.nio.channels.Selector</td><td>网络IO</td><td>控制器</td></tr></tbody></table><h2 id="2-1缓冲区-Buffer"><a href="#2-1缓冲区-Buffer" class="headerlink" title="2.1缓冲区(Buffer)"></a>2.1缓冲区(Buffer)</h2><h3 id="2-1-1-什么是缓冲区"><a href="#2-1-1-什么是缓冲区" class="headerlink" title="2.1.1 什么是缓冲区"></a>2.1.1 什么是缓冲区</h3><p>我们先看以下这张类图，可以看到<code>Buffer</code>有七种类型。</p><p><img src="https://static.lovebilibili.com/Buffer.png" srcset="/img/loading.gif" alt=""></p><p><code>Buffer</code>是一个内存块。在<code>NIO</code>中，所有的数据都是用<code>Buffer</code>处理，有读写两种模式。所以NIO和传统的IO的区别就体现在这里。传统IO是面向<code>Stream</code>流，<code>NIO</code>而是面向缓冲区(<code>Buffer</code>)。</p><h3 id="2-1-2-常用的类型ByteBuffer"><a href="#2-1-2-常用的类型ByteBuffer" class="headerlink" title="2.1.2 常用的类型ByteBuffer"></a>2.1.2 常用的类型ByteBuffer</h3><p>一般我们常用的类型是<code>ByteBuffer</code>，把数据转成字节进行处理。实质上是一个<code>byte[]</code>数组。</p><pre><code class="java">public abstract class ByteBuffer extends Buffer implements Comparable&lt;ByteBuffer&gt;{    //存储数据的数组    final byte[] hb;    //构造器方法    ByteBuffer(int mark, int pos, int lim, int cap, byte[] hb, int offset) {        super(mark, pos, lim, cap);        //初始化数组        this.hb = hb;        this.offset = offset;    }}</code></pre><h3 id="2-1-3-创建Buffer的方式"><a href="#2-1-3-创建Buffer的方式" class="headerlink" title="2.1.3 创建Buffer的方式"></a>2.1.3 创建Buffer的方式</h3><p>主要分成两种：JVM堆内内存块Buffer、堆外内存块Buffer。</p><p>创建堆内内存块(非直接缓冲区)的方法是：</p><pre><code class="java">//创建堆内内存块HeapByteBufferByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);String msg = &quot;java技术爱好者&quot;;//包装一个byte[]数组获得一个Buffer，实际类型是HeapByteBufferByteBuffer byteBuffer2 = ByteBuffer.wrap(msg.getBytes());</code></pre><p>创建堆外内存块(直接缓冲区)的方法：</p><pre><code class="java">//创建堆外内存块DirectByteBufferByteBuffer byteBuffer3 = ByteBuffer.allocateDirect(1024);</code></pre><h4 id="2-1-3-1-HeapByteBuffer与DirectByteBuffer的区别"><a href="#2-1-3-1-HeapByteBuffer与DirectByteBuffer的区别" class="headerlink" title="2.1.3.1 HeapByteBuffer与DirectByteBuffer的区别"></a>2.1.3.1 HeapByteBuffer与DirectByteBuffer的区别</h4><p>其实根据类名就可以看出，<code>HeapByteBuffer</code>所创建的字节缓冲区就是在JVM堆中的，即JVM内部所维护的字节数组。而<code>DirectByteBuffer</code>是<strong>直接操作操作系统本地代码</strong>创建的<strong>内存缓冲数组</strong>。</p><p><code>DirectByteBuffer</code>的使用场景：</p><ol><li><p>java程序与本地磁盘、socket传输数据</p></li><li><p>大文件对象，可以使用。不会受到堆内存大小的限制。</p></li><li><p>不需要频繁创建，生命周期较长的情况，能重复使用的情况。</p></li></ol><p><code>HeapByteBuffer</code>的使用场景：</p><p>除了以上的场景外，其他情况还是建议使用<code>HeapByteBuffer</code>，没有达到一定的量级，实际上使用<code>DirectByteBuffer</code>是体现不出优势的。</p><h4 id="2-1-3-2-Buffer的初体验"><a href="#2-1-3-2-Buffer的初体验" class="headerlink" title="2.1.3.2 Buffer的初体验"></a>2.1.3.2 Buffer的初体验</h4><p>接下来，使用<code>ByteBuffer</code>做一个小例子，熟悉一下：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        String msg = &quot;java技术爱好者，起飞！&quot;;        //创建一个固定大小的buffer(返回的是HeapByteBuffer)        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);        byte[] bytes = msg.getBytes();        //写入数据到Buffer中        byteBuffer.put(bytes);        //切换成读模式，关键一步        byteBuffer.flip();        //创建一个临时数组，用于存储获取到的数据        byte[] tempByte = new byte[bytes.length];        int i = 0;        //如果还有数据，就循环。循环判断条件        while (byteBuffer.hasRemaining()) {            //获取byteBuffer中的数据            byte b = byteBuffer.get();            //放到临时数组中            tempByte[i] = b;            i++;        }        //打印结果        System.out.println(new String(tempByte));//java技术爱好者，起飞！    }</code></pre><p>这上面有一个<code>flip()</code>方法是很重要的。意思是切换到读模式。上面已经提到<strong>缓存区是双向的</strong>，<strong>既可以往缓冲区写入数据，也可以从缓冲区读取数据</strong>。但是不能同时进行，需要切换。那么这个切换模式的本质是什么呢？</p><h3 id="2-1-4-三个重要参数"><a href="#2-1-4-三个重要参数" class="headerlink" title="2.1.4 三个重要参数"></a>2.1.4 三个重要参数</h3><pre><code class="java">//位置，默认是从第一个开始private int position = 0;//限制，不能读取或者写入的位置索引private int limit;//容量，缓冲区所包含的元素的数量private int capacity;</code></pre><p>那么我们以上面的例子，一句一句代码进行分析：</p><pre><code class="java">String msg = &quot;java技术爱好者，起飞！&quot;;//创建一个固定大小的buffer(返回的是HeapByteBuffer)ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</code></pre><p>当创建一个缓冲区时，参数的值是这样的：</p><p><img src="https://static.lovebilibili.com/image-20200625122035548.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/image-20200625122337215.png" srcset="/img/loading.gif" alt="image-20200625122337215"></p><p>当执行到<code>byteBuffer.put(bytes)</code>，当<code>put()</code>进入多少数据，position就会增加多少，参数就会发生变化：</p><p><img src="https://static.lovebilibili.com/image-20200625122640979.png" srcset="/img/loading.gif" alt="image-20200625122640979"></p><p><img src="https://static.lovebilibili.com/image-20200625123835657.png" srcset="/img/loading.gif" alt="image-20200625123835657"></p><p>接下来关键一步<code>byteBuffer.flip()</code>，会发生如下变化：</p><p><img src="https://static.lovebilibili.com/image-20200625122931713.png" srcset="/img/loading.gif" alt="image-20200625122931713"></p><p><img src="https://static.lovebilibili.com/image-20200625123004623.png" srcset="/img/loading.gif" alt="image-20200625123004623"></p><p><code>flip()</code>方法的源码如下：</p><pre><code class="java">    public final Buffer flip() {        limit = position;        position = 0;        mark = -1;        return this;    }</code></pre><p>为什么要这样赋值呢？因为下面有一句循环条件判断：</p><pre><code class="java">byteBuffer.hasRemaining();public final boolean hasRemaining() {    //判断position的索引是否小于limit。    //所以可以看出limit的作用就是记录写入数据的位置，那么当读取数据时，就知道读到哪个位置    return position &lt; limit;}</code></pre><p>接下来就是在<code>while</code>循环中<code>get()</code>读取数据，读取完之后。</p><p><img src="https://static.lovebilibili.com/image-20200625123623688.png" srcset="/img/loading.gif" alt="image-20200625123623688"></p><p><img src="https://static.lovebilibili.com/image-20200625123745018.png" srcset="/img/loading.gif" alt="image-20200625123745018"></p><p>最后当<code>position</code>等于<code>limit</code>时，循环判断条件不成立，就跳出循环，读取完毕。</p><p>所以可以看出实质上<code>capacity</code>容量大小是不变的，实际上是通过控制<code>position</code>和<code>limit</code>的值来控制读写的数据。</p><h2 id="2-2-管道-Channel"><a href="#2-2-管道-Channel" class="headerlink" title="2.2 管道(Channel)"></a>2.2 管道(Channel)</h2><p>首先我们看一下Channel有哪些子类：</p><p><img src="https://static.lovebilibili.com/Channel.png" srcset="/img/loading.gif" alt=""></p><p>常用的Channel有这四种：</p><blockquote><p>FileChannel，读写文件中的数据。<br>SocketChannel，通过TCP读写网络中的数据。<br>ServerSockectChannel，监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。<br>DatagramChannel，通过UDP读写网络中的数据。</p></blockquote><p><strong>Channel本身并不存储数据，只是负责数据的运输</strong>。必须要和<code>Buffer</code>一起使用。</p><h3 id="2-2-1-获取通道的方式"><a href="#2-2-1-获取通道的方式" class="headerlink" title="2.2.1 获取通道的方式"></a>2.2.1 获取通道的方式</h3><h4 id="2-2-1-1-FileChannel"><a href="#2-2-1-1-FileChannel" class="headerlink" title="2.2.1.1 FileChannel"></a>2.2.1.1 FileChannel</h4><p>FileChannel的获取方式，下面举个文件复制拷贝的例子进行说明：</p><p><img src="https://static.lovebilibili.com/image-20200625130742262.png" srcset="/img/loading.gif" alt="image-20200625130742262"></p><p>首先准备一个”1.txt”放在项目的根目录下，然后编写一个main方法：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了        ByteBuffer byteBuffer = ByteBuffer.allocate((int)file.length());        //把输入流通道的数据读取到缓冲区        inputStreamChannel.read(byteBuffer);        //切换成读模式        byteBuffer.flip();        //把数据从缓冲区写入到输出流通道        outputStreamChannel.write(byteBuffer);        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }</code></pre><p>执行后，我们就获得一个”2.txt”。执行成功。</p><p><img src="https://static.lovebilibili.com/image-20200625130945572.png" srcset="/img/loading.gif" alt="image-20200625130945572"></p><p>以上的例子，可以用一张示意图表示，是这样的：</p><p><img src="https://static.lovebilibili.com/image-20200625132433945.png" srcset="/img/loading.gif" alt="image-20200625132433945"></p><h4 id="2-2-1-2-SocketChannel"><a href="#2-2-1-2-SocketChannel" class="headerlink" title="2.2.1.2 SocketChannel"></a>2.2.1.2 SocketChannel</h4><p>接下来我们学习获取<code>SocketChannel</code>的方式。</p><p>还是一样，我们通过一个例子来快速上手：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取ServerSocketChannel        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666);        //绑定地址，端口号        serverSocketChannel.bind(address);        //创建一个缓冲区        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);        while (true) {            //获取SocketChannel            SocketChannel socketChannel = serverSocketChannel.accept();            while (socketChannel.read(byteBuffer) != -1){                //打印结果                System.out.println(new String(byteBuffer.array()));                //清空缓冲区                byteBuffer.clear();            }        }    }</code></pre><p>然后运行main()方法，我们可以通过<code>telnet</code>命令进行连接测试：</p><p><img src="https://static.lovebilibili.com/image-20200625134508044.png" srcset="/img/loading.gif" alt="image-20200625134508044"></p><p>通过上面的例子可以知道，通过<code>ServerSocketChannel.open()</code>方法可以获取服务器的通道，然后绑定一个地址端口号，接着<code>accept()</code>方法可获得一个<code>SocketChannel</code>通道，也就是客户端的连接通道。</p><p>最后配合使用<code>Buffer</code>进行读写即可。</p><p>这就是一个简单的例子，实际上上面的例子是阻塞式的。要做到非阻塞还需要使用选择器<code>Selector</code>。</p><h2 id="2-3-选择器-Selector"><a href="#2-3-选择器-Selector" class="headerlink" title="2.3 选择器(Selector)"></a>2.3 选择器(Selector)</h2><p><code>Selector</code>翻译成<strong>选择器</strong>，有些人也会翻译成<strong>多路复用器</strong>，实际上指的是同一样东西。</p><p>只有网络IO才会使用选择器，文件IO是不需要使用的。</p><p>选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。换句话说，也就是事件驱动。以此实现<strong>单线程管理多个Channel</strong>的目的。</p><p><img src="https://static.lovebilibili.com/20180813104125886.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-1-核心API"><a href="#2-3-1-核心API" class="headerlink" title="2.3.1 核心API"></a>2.3.1 核心API</h3><table><thead><tr><th>API方法名</th><th>作用</th></tr></thead><tbody><tr><td>Selector.open()</td><td>打开一个选择器。</td></tr><tr><td>select()</td><td>选择一组键，其相应的通道已为 I/O 操作准备就绪。</td></tr><tr><td>selectedKeys()</td><td>返回此选择器的已选择键集。</td></tr></tbody></table><p>以上的API会在后面的例子用到，先有个印象。</p><h1 id="3-NIO快速入门"><a href="#3-NIO快速入门" class="headerlink" title="3 NIO快速入门"></a>3 NIO快速入门</h1><h2 id="3-1-文件IO"><a href="#3-1-文件IO" class="headerlink" title="3.1 文件IO"></a>3.1 文件IO</h2><h3 id="3-1-1-通道间的数据传输"><a href="#3-1-1-通道间的数据传输" class="headerlink" title="3.1.1 通道间的数据传输"></a>3.1.1 通道间的数据传输</h3><p>这里主要介绍两个通道与通道之间数据传输的方式：</p><p><code>transferTo()</code>：把源通道的数据传输到目的通道中。</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了        ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length());        //把输入流通道的数据读取到输出流的通道        inputStreamChannel.transferTo(0, byteBuffer.limit(), outputStreamChannel);        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }    </code></pre><p><code>transferFrom()</code>：把来自源通道的数据传输到目的通道。</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了        ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length());        //把输入流通道的数据读取到输出流的通道        outputStreamChannel.transferFrom(inputStreamChannel,0,byteBuffer.limit());        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }</code></pre><h3 id="3-1-2-分散读取和聚合写入"><a href="#3-1-2-分散读取和聚合写入" class="headerlink" title="3.1.2 分散读取和聚合写入"></a>3.1.2 分散读取和聚合写入</h3><p>我们先看一下FileChannel的源码：</p><pre><code class="java">public abstract class FileChannel extends AbstractInterruptibleChannel    implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel {   }</code></pre><p>从源码中可以看出实现了GatheringByteChannel, ScatteringByteChannel接口。也就是支持分散读取和聚合写入的操作。怎么使用呢，请看以下例子：</p><p>我们写一个main方法来实现复制1.txt文件，文件内容是：</p><pre><code class="java">abcdefghijklmnopqrstuvwxyz//26个字母</code></pre><p>代码如下：</p><pre><code class="java">    public static void main(String[] args) throws Exception {        //获取文件输入流        File file = new File(&quot;1.txt&quot;);        FileInputStream inputStream = new FileInputStream(file);        //从文件输入流获取通道        FileChannel inputStreamChannel = inputStream.getChannel();        //获取文件输出流        FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;));        //从文件输出流获取通道        FileChannel outputStreamChannel = outputStream.getChannel();        //创建三个缓冲区，分别都是5        ByteBuffer byteBuffer1 = ByteBuffer.allocate(5);        ByteBuffer byteBuffer2 = ByteBuffer.allocate(5);        ByteBuffer byteBuffer3 = ByteBuffer.allocate(5);        //创建一个缓冲区数组        ByteBuffer[] buffers = new ByteBuffer[]{byteBuffer1, byteBuffer2, byteBuffer3};        //循环写入到buffers缓冲区数组中，分散读取        long read;        long sumLength = 0;        while ((read = inputStreamChannel.read(buffers)) != -1) {            sumLength += read;            Arrays.stream(buffers)                    .map(buffer -&gt; &quot;posstion=&quot; + buffer.position() + &quot;,limit=&quot; + buffer.limit())                    .forEach(System.out::println);            //切换模式            Arrays.stream(buffers).forEach(Buffer::flip);            //聚合写入到文件输出通道            outputStreamChannel.write(buffers);            //清空缓冲区            Arrays.stream(buffers).forEach(Buffer::clear);        }        System.out.println(&quot;总长度:&quot; + sumLength);        //关闭通道        outputStream.close();        inputStream.close();        outputStreamChannel.close();        inputStreamChannel.close();    }</code></pre><p>打印结果：</p><pre><code class="java">posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=1,limit=5总长度:26</code></pre><p>可以看到循环了两次。第一次循环时，三个缓冲区都读取了5个字节，总共读取了15，也就是读满了。还剩下11个字节，于是第二次循环时，前两个缓冲区分配了5个字节，最后一个缓冲区给他分配了1个字节，刚好读完。总共就是26个字节。</p><p>这就是分散读取，聚合写入的过程。</p><p>使用场景就是可以<strong>使用一个缓冲区数组，自动地根据需要去分配缓冲区的大小。可以减少内存消耗</strong>。网络IO也可以使用，这里就不写例子演示了。</p><h3 id="3-1-3-非直接-直接缓冲区"><a href="#3-1-3-非直接-直接缓冲区" class="headerlink" title="3.1.3 非直接/直接缓冲区"></a>3.1.3 非直接/直接缓冲区</h3><p>非直接缓冲区的创建方式：</p><pre><code class="java">static ByteBuffer allocate(int capacity)</code></pre><p>直接缓冲区的创建方式：</p><pre><code class="java">static ByteBuffer allocateDirect(int capacity)</code></pre><p>非直接/直接缓冲区的区别示意图：</p><p><img src="https://static.lovebilibili.com/307536-20170731145300974-520326124.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/307536-20170731145311224-406164516.png" srcset="/img/loading.gif" alt=""></p><p>从示意图中我们可以发现，最大的不同在于直接缓冲区不需要再把文件内容copy到物理内存中。这就大大地提高了性能。其实在介绍Buffer时，我们就有接触到这个概念。直接缓冲区是堆外内存，在本地文件IO效率会更高一点。</p><p>接下来我们来对比一下效率，以一个136 MB的视频文件为例：</p><pre><code class="java">public static void main(String[] args) throws Exception {    long starTime = System.currentTimeMillis();    //获取文件输入流    File file = new File(&quot;D:\\小电影.mp4&quot;);//文件大小136 MB    FileInputStream inputStream = new FileInputStream(file);    //从文件输入流获取通道    FileChannel inputStreamChannel = inputStream.getChannel();    //获取文件输出流    FileOutputStream outputStream = new FileOutputStream(new File(&quot;D:\\test.mp4&quot;));    //从文件输出流获取通道    FileChannel outputStreamChannel = outputStream.getChannel();    //创建一个直接缓冲区    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(5 * 1024 * 1024);    //创建一个非直接缓冲区    //ByteBuffer byteBuffer = ByteBuffer.allocate(5 * 1024 * 1024);    //写入到缓冲区    while (inputStreamChannel.read(byteBuffer) != -1) {        //切换读模式        byteBuffer.flip();        outputStreamChannel.write(byteBuffer);        byteBuffer.clear();    }    //关闭通道    outputStream.close();    inputStream.close();    outputStreamChannel.close();    inputStreamChannel.close();    long endTime = System.currentTimeMillis();    System.out.println(&quot;消耗时间：&quot; + (endTime - starTime) + &quot;毫秒&quot;);}</code></pre><p>结果：</p><p>直接缓冲区的消耗时间：283毫秒</p><p>非直接缓冲区的消耗时间：487毫秒</p><h2 id="3-2-网络IO"><a href="#3-2-网络IO" class="headerlink" title="3.2 网络IO"></a>3.2 网络IO</h2><p>其实NIO的主要用途是网络IO，在NIO之前java要使用网络编程就只有用<code>Socket</code>。而<code>Socket</code>是阻塞的，显然对于高并发的场景是不适用的。所以NIO的出现就是解决了这个痛点。</p><p>主要思想是把Channel通道注册到Selector中，通过Selector去监听Channel中的事件状态，这样就不需要阻塞等待客户端的连接，从主动等待客户端的连接，变成了通过事件驱动。没有监听的事件，服务器可以做自己的事情。</p><h3 id="3-2-1-使用Selector的小例子"><a href="#3-2-1-使用Selector的小例子" class="headerlink" title="3.2.1 使用Selector的小例子"></a>3.2.1 使用Selector的小例子</h3><p>接下来趁热打铁，我们来做一个服务器接受客户端消息的例子：</p><p>首先服务端代码：</p><pre><code class="java">public class NIOServer {    public static void main(String[] args) throws Exception {        //打开一个ServerSocketChannel        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666);        //绑定地址        serverSocketChannel.bind(address);        //设置为非阻塞        serverSocketChannel.configureBlocking(false);        //打开一个选择器        Selector selector = Selector.open();        //serverSocketChannel注册到选择器中,监听连接事件        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        //循环等待客户端的连接        while (true) {            //等待3秒，（返回0相当于没有事件）如果没有事件，则跳过            if (selector.select(3000) == 0) {                System.out.println(&quot;服务器等待3秒，没有连接&quot;);                continue;            }            //如果有事件selector.select(3000)&gt;0的情况,获取事件            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();            //获取迭代器遍历            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();            while (it.hasNext()) {                //获取到事件                SelectionKey selectionKey = it.next();                //判断如果是连接事件                if (selectionKey.isAcceptable()) {                    //服务器与客户端建立连接，获取socketChannel                    SocketChannel socketChannel = serverSocketChannel.accept();                    //设置成非阻塞                    socketChannel.configureBlocking(false);                    //把socketChannel注册到selector中，监听读事件，并绑定一个缓冲区                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));                }                //如果是读事件                if (selectionKey.isReadable()) {                    //获取通道                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();                    //获取关联的ByteBuffer                    ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();                    //打印从客户端获取到的数据                    socketChannel.read(buffer);                    System.out.println(&quot;from 客户端：&quot; + new String(buffer.array()));                }                //从事件集合中删除已处理的事件，防止重复处理                it.remove();            }        }    }}</code></pre><p>客户端代码：</p><pre><code class="java">public class NIOClient {    public static void main(String[] args) throws Exception {        SocketChannel socketChannel = SocketChannel.open();        InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666);        socketChannel.configureBlocking(false);        //连接服务器        boolean connect = socketChannel.connect(address);        //判断是否连接成功        if(!connect){            //等待连接的过程中            while (!socketChannel.finishConnect()){                System.out.println(&quot;连接服务器需要时间，期间可以做其他事情...&quot;);            }        }        String msg = &quot;hello java技术爱好者！&quot;;        ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());        //把byteBuffer数据写入到通道中        socketChannel.write(byteBuffer);        //让程序卡在这个位置，不关闭连接        System.in.read();    }}</code></pre><p>接下来启动服务端，然后再启动客户端，我们可以看到控制台打印以下信息：</p><pre><code class="java">服务器等待3秒，没有连接服务器等待3秒，没有连接from 客户端：hello java技术爱好者！                       服务器等待3秒，没有连接服务器等待3秒，没有连接</code></pre><p>通过这个例子我们引出以下知识点。</p><h3 id="3-2-2-SelectionKey"><a href="#3-2-2-SelectionKey" class="headerlink" title="3.2.2 SelectionKey"></a>3.2.2 SelectionKey</h3><p>在<code>SelectionKey</code>类中有四个常量表示四种事件，来看源码：</p><pre><code class="java">public abstract class SelectionKey {    //读事件    public static final int OP_READ = 1 &lt;&lt; 0; //2^0=1    //写事件    public static final int OP_WRITE = 1 &lt;&lt; 2; // 2^2=4    //连接操作,Client端支持的一种操作    public static final int OP_CONNECT = 1 &lt;&lt; 3; // 2^3=8    //连接可接受操作,仅ServerSocketChannel支持    public static final int OP_ACCEPT = 1 &lt;&lt; 4; // 2^4=16}</code></pre><p>附加的对象(可选)，把通道注册到选择器中时可以附加一个对象。</p><pre><code class="java">public final SelectionKey register(Selector sel, int ops, Object att)</code></pre><p>从<code>selectionKey</code>中获取附件对象可以使用<code>attachment()</code>方法</p><pre><code class="java">public final Object attachment() {    return attachment;}</code></pre><h1 id="4-使用NIO实现多人聊天室"><a href="#4-使用NIO实现多人聊天室" class="headerlink" title="4 使用NIO实现多人聊天室"></a>4 使用NIO实现多人聊天室</h1><p>接下来进行一个实战例子，用NIO实现一个多人运动版本的聊天室。</p><p>服务端代码：</p><pre><code class="java">public class GroupChatServer {    private Selector selector;    private ServerSocketChannel serverSocketChannel;    public static final int PORT = 6667;    //构造器初始化成员变量    public GroupChatServer() {        try {            //打开一个选择器            this.selector = Selector.open();            //打开serverSocketChannel            this.serverSocketChannel = ServerSocketChannel.open();            //绑定地址，端口号            this.serverSocketChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, PORT));            //设置为非阻塞            serverSocketChannel.configureBlocking(false);            //把通道注册到选择器中            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 监听，并且接受客户端消息，转发到其他客户端     */    public void listen() {        try {            while (true) {                //获取监听的事件总数                int count = selector.select(2000);                if (count &gt; 0) {                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                    //获取SelectionKey集合                    Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();                    while (it.hasNext()) {                        SelectionKey key = it.next();                        //如果是获取连接事件                        if (key.isAcceptable()) {                            SocketChannel socketChannel = serverSocketChannel.accept();                            //设置为非阻塞                            socketChannel.configureBlocking(false);                            //注册到选择器中                            socketChannel.register(selector, SelectionKey.OP_READ);                            System.out.println(socketChannel.getRemoteAddress() + &quot;上线了~&quot;);                        }                        //如果是读就绪事件                        if (key.isReadable()) {                            //读取消息，并且转发到其他客户端                            readData(key);                        }                        it.remove();                    }                } else {                    System.out.println(&quot;等待...&quot;);                }            }        } catch (Exception e) {            e.printStackTrace();        }    }    //获取客户端发送过来的消息    private void readData(SelectionKey selectionKey) {        SocketChannel socketChannel = null;        try {            //从selectionKey中获取channel            socketChannel = (SocketChannel) selectionKey.channel();            //创建一个缓冲区            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);            //把通道的数据写入到缓冲区            int count = socketChannel.read(byteBuffer);            //判断返回的count是否大于0，大于0表示读取到了数据            if (count &gt; 0) {                //把缓冲区的byte[]转成字符串                String msg = new String(byteBuffer.array());                //输出该消息到控制台                System.out.println(&quot;from 客户端：&quot; + msg);                //转发到其他客户端                notifyAllClient(msg, socketChannel);            }        } catch (Exception e) {            try {                //打印离线的通知                System.out.println(socketChannel.getRemoteAddress() + &quot;离线了...&quot;);                //取消注册                selectionKey.cancel();                //关闭流                socketChannel.close();            } catch (IOException e1) {                e1.printStackTrace();            }        }    }    /**     * 转发消息到其他客户端     * msg 消息     * noNotifyChannel 不需要通知的Channel     */    private void notifyAllClient(String msg, SocketChannel noNotifyChannel) throws Exception {        System.out.println(&quot;服务器转发消息~&quot;);        for (SelectionKey selectionKey : selector.keys()) {            Channel channel = selectionKey.channel();            //channel的类型实际类型是SocketChannel，并且排除不需要通知的通道            if (channel instanceof SocketChannel &amp;&amp; channel != noNotifyChannel) {                //强转成SocketChannel类型                SocketChannel socketChannel = (SocketChannel) channel;                //通过消息，包裹获取一个缓冲区                ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());                socketChannel.write(byteBuffer);            }        }    }    public static void main(String[] args) throws Exception {        GroupChatServer chatServer = new GroupChatServer();        //启动服务器，监听        chatServer.listen();    }}</code></pre><p>客户端代码：</p><pre><code class="java">public class GroupChatClinet {    private Selector selector;    private SocketChannel socketChannel;    private String userName;    public GroupChatClinet() {        try {            //打开选择器            this.selector = Selector.open();            //连接服务器            socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, GroupChatServer.PORT));            //设置为非阻塞            socketChannel.configureBlocking(false);            //注册到选择器中            socketChannel.register(selector, SelectionKey.OP_READ);            //获取用户名            userName = socketChannel.getLocalAddress().toString().substring(1);            System.out.println(userName + &quot; is ok~&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }    //发送消息到服务端    private void sendMsg(String msg) {        msg = userName + &quot;说：&quot; + msg;        try {            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));        } catch (Exception e) {            e.printStackTrace();        }    }    //读取服务端发送过来的消息    private void readMsg() {        try {            int count = selector.select();            if (count &gt; 0) {                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                while (iterator.hasNext()) {                    SelectionKey selectionKey = iterator.next();                    //判断是读就绪事件                    if (selectionKey.isReadable()) {                        SocketChannel channel = (SocketChannel) selectionKey.channel();                        //创建一个缓冲区                        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);                        //从服务器的通道中读取数据到缓冲区                        channel.read(byteBuffer);                        //缓冲区的数据，转成字符串，并打印                        System.out.println(new String(byteBuffer.array()));                    }                    iterator.remove();                }            }        } catch (Exception e) {            e.printStackTrace();        }    }    public static void main(String[] args) throws Exception {        GroupChatClinet chatClinet = new GroupChatClinet();        //启动线程，读取服务器转发过来的消息        new Thread(() -&gt; {            while (true) {                chatClinet.readMsg();                try {                    Thread.sleep(3000);                } catch (Exception e) {                    e.printStackTrace();                }            }        }).start();        //主线程发送消息到服务器        Scanner scanner = new Scanner(System.in);        while (scanner.hasNextLine()) {            String msg = scanner.nextLine();            chatClinet.sendMsg(msg);        }    }}</code></pre><p>先启动服务端的main方法，再启动两个客户端的main方法：</p><p><img src="https://static.lovebilibili.com/image-20200625225034967.png" srcset="/img/loading.gif" alt="image-20200625225034967"></p><p>然后使用两个客户端开始聊天了~</p><p><img src="https://static.lovebilibili.com/image-20200625225118983.png" srcset="/img/loading.gif" alt="image-20200625225118983"></p><p><img src="https://static.lovebilibili.com/image-20200625225130048.png" srcset="/img/loading.gif" alt="image-20200625225130048"></p><p>以上就是使用NIO<strong>实现多人聊天室</strong>的例子，同学们可以看着我这个例子自己完成一下。要多写代码才好理解这些概念。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>创作不易</strong>，觉得有用就<strong>点个赞</strong>吧。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个努力让别人记住的程序员。我们下期再见！！！</strong></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List集合的坑</title>
    <link href="/2020/06/21/List%E9%9B%86%E5%90%88%E7%9A%84%E5%9D%91/"/>
    <url>/2020/06/21/List%E9%9B%86%E5%90%88%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学如逆水行舟，不进则退</p></blockquote><p>经过几年的工作经验，我发现<code>List</code>有很多坑，之前公司有些实习生一不小心就踩到了，所以我打算写一篇文章总结一下，希望看到这篇文章的人能不再踩到坑，代码没bug。做个快乐的程序员。</p><a id="more"></a><h3 id="迭代时删除元素"><a href="#迭代时删除元素" class="headerlink" title="迭代时删除元素"></a>迭代时删除元素</h3><p>使用<code>for-each</code>迭代遍历时，删除集合中的元素，会报错。</p><pre><code class="java">    private static List&lt;String&gt; list = new ArrayList&lt;&gt;();    static {        //初始化集合        for (int i = 1; i &lt;= 10; i++) {            list.add(String.valueOf(i));        }    }    public static void main(String[] args) {        //使用for-each迭代时删除元素        for (String str : list) {            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }    }</code></pre><p>或者你使用迭代器<code>Iterator</code>遍历时，删除元素。</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        Iterator&lt;String&gt; it = list.iterator();        while (it.hasNext()) {            String str = it.next();            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }    }</code></pre><p>以上两种情况都会报这个错：</p><pre><code class="java">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)    at java.util.ArrayList$Itr.next(ArrayList.java:851)</code></pre><p>这就是不正确的删除姿势，那怎么删呢？</p><p>使用<code>for-i</code>循环遍历删除(亲测有效)：</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        for (int i = 0; i &lt; list.size(); i++) {            String s = list.get(i);            if (&quot;1&quot;.equals(s)) {                list.remove(s);            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>使用<code>for-i</code>循环倒序遍历，删除元素。</p><pre><code class="java">    public static void main(String[] args) {        //使用for-i倒序遍历，删除元素        for (int i = list.size() - 1; i &gt;= 0; i--) {            String str = list.get(i);            if (&quot;1&quot;.equals(str)) {                list.remove(str);            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>使用<code>Iterator</code>的<code>remove()</code>方法删除。</p><pre><code class="java">    public static void main(String[] args) {        //使用Iterator迭代器遍历时，删除元素        Iterator&lt;String&gt; it = list.iterator();        while (it.hasNext()) {            String str = it.next();            if (&quot;1&quot;.equals(str)) {                it.remove();            }        }        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><p>要么潇洒一点，用<code>Lambda</code>表达式。在java8中，<code>List</code>增加了一个<code>removeIf()</code>方法用于删除。</p><pre><code class="java">    public static void main(String[] args) {        //使用removeIf()遍历时，删除元素。删除集合中为1的元素        list.removeIf(str -&gt; &quot;1&quot;.equals(str));        list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10    }</code></pre><h3 id="使用asList-获得集合删除-增加"><a href="#使用asList-获得集合删除-增加" class="headerlink" title="使用asList()获得集合删除/增加"></a>使用asList()获得集合删除/增加</h3><p>看代码演示：</p><pre><code class="java">    public static void main(String[] args) {        List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6);        nums.add(7);    }</code></pre><pre><code class="java">    public static void main(String[] args) {        List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6);        nums.remove(1);    }</code></pre><p>如果你进行以上操作，就会看到报错：</p><pre><code class="java">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException    at java.util.AbstractList.remove(AbstractList.java:161)</code></pre><p>为什么会报这个错，看一下源代码就知道了！</p><pre><code class="java">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable {}</code></pre><p><code>ArrayList</code>不是<code>util</code>包的<code>ArrayList</code>，而是<code>Arrays</code>的一个内部类。因为继承了<code>AbstractList</code>抽象类，但是又没有实现<code>add()</code>、<code>remove()</code>方法。所以会调用抽象类的<code>add()</code>和<code>remove()</code>。<br>你猜猜抽象类的<code>add()</code>怎么着？</p><pre><code class="java">    public void add(int index, E element) {        throw new UnsupportedOperationException();    }    public E remove(int index) {        throw new UnsupportedOperationException();    }</code></pre><p>所以不能用<code>asList()</code>得到的集合去增删了！</p><h3 id="通过subList-方法获得集合后增删"><a href="#通过subList-方法获得集合后增删" class="headerlink" title="通过subList()方法获得集合后增删"></a>通过subList()方法获得集合后增删</h3><p>当使用<code>subList()</code>方法获得集合后删除，原(父)集合也会被删除。</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; subList = list.subList(0, 5);        System.out.println(list);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5]        subList.remove(&quot;1&quot;);        System.out.println(list);//[2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[2, 3, 4, 5]    }</code></pre><p>当使用<code>subList()</code>方法获得集合后增加元素，原(父)集合也会增加。</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; subList = list.subList(0, 5);        System.out.println(list);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5]        subList.add(&quot;11&quot;);        System.out.println(list);//[1, 2, 3, 4, 5, 11, 6, 7, 8, 9, 10]        System.out.println(subList);//[1, 2, 3, 4, 5, 11]    }</code></pre><p>大家看一下源码就知道什么原因了。</p><pre><code class="java">private class SubList extends AbstractList&lt;E&gt; implements RandomAccess {        public void add(int index, E e) {            rangeCheckForAdd(index);            checkForComodification();            //父集合添加元素            parent.add(parentOffset + index, e);            this.modCount = parent.modCount;            this.size++;        }        public E remove(int index) {            rangeCheck(index);            checkForComodification();            //父集合删除元素            E result = parent.remove(parentOffset + index);            this.modCount = parent.modCount;            this.size--;            return result;        }}</code></pre><p>如果希望截取的集合是和原集合互不干扰的话，可以这样：</p><pre><code class="java">List&lt;String&gt; subList = new ArrayList&lt;&gt;(list.subList(0, 5));</code></pre><h3 id="使用Collections-unmodifiableList-创建不可变集合也是可变的。"><a href="#使用Collections-unmodifiableList-创建不可变集合也是可变的。" class="headerlink" title="使用Collections.unmodifiableList()创建不可变集合也是可变的。"></a>使用Collections.unmodifiableList()创建不可变集合也是可变的。</h3><p>当不可变集合的原集合改变时，不可变集合也跟着改变。演示代码：</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(list);        System.out.println(unmodifiableList);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]        //删除原集合元素        list.remove(&quot;1&quot;);        System.out.println(unmodifiableList);//[2, 3, 4, 5, 6, 7, 8, 9, 10]    }</code></pre><p>看源码就知道原因了：</p><pre><code class="java">    UnmodifiableList(List&lt;? extends E&gt; list) {        super(list);        this.list = list;    }</code></pre><p><strong>因为不可变集合的成员变量的引用是指向原集合的，所以当原集合改变时，不可变集合也会随之改变</strong>。</p><p>解决方式：使用<code>Guava</code>工具包的<code>ImmutableList.copyOf()</code>方法创建。</p><pre><code class="java">    public static void main(String[] args) throws Exception {        List&lt;String&gt; unmodifiableList = ImmutableList.copyOf(list);        list.remove(&quot;1&quot;);        System.out.println(unmodifiableList);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]    }</code></pre><p>创作不易，觉得有用就<strong>点个赞</strong>吧。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong><br><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
      <tag>经验总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC全局异常处理</title>
    <link href="/2020/06/14/SpringMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2020/06/14/SpringMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC全局异常处理"><a href="#SpringMVC全局异常处理" class="headerlink" title="SpringMVC全局异常处理"></a>SpringMVC全局异常处理</h1><p><code>SpringMVC</code>除了可以做<code>URL映射</code>和<code>请求拦截</code>外，还可以做<code>全局异常</code>的处理。全局异常处理可能我们平时比较少机会接触，但是每个项目都肯定会做这个处理。比如在上一间公司，是前后端分离的架构，所以后端只要有运行时异常就会报“系统异常，请稍后再试”。如果想要走上架构师的话，这个肯定是要学会的。</p><h2 id="SpringMVC全局异常处理机制"><a href="#SpringMVC全局异常处理机制" class="headerlink" title="SpringMVC全局异常处理机制"></a>SpringMVC全局异常处理机制</h2><p>首先，要知道全局异常处理，<code>SpringMVC</code>提供了两种方式：</p><ul><li>实现<code>HandlerExceptionResolver</code>接口，自定义异常处理器。</li><li>使用<code>HandlerExceptionResolver</code>接口的子类，也就是<code>SpringMVC</code>提供的异常处理器。</li></ul><p>所以，总得来说就两种方式，一种是自定义异常处理器，第二种是<code>SpringMVC</code>提供的。接下来先说<code>SpringMVC</code>提供的几种异常处理器的使用方式，然后再讲自定义异常处理器。</p><p><code>SpringMVC</code>提供的异常处理器有哪些呢？我们可以直接看源码的类图。</p><p><img src="https://static.lovebilibili.com/HandlerExceptionResolver.png" srcset="/img/loading.gif" alt=""></p><p>可以看出有四种：</p><ul><li><code>DefaultHandlerExceptionResolver</code>，默认的异常处理器。根据各个不同类型的异常，返回不同的异常视图。</li><li><code>SimpleMappingExceptionResolver</code>，简单映射异常处理器。通过配置异常类和view的关系来解析异常。</li><li><code>ResponseStatusExceptionResolver</code>，状态码异常处理器。解析带有<code>@ResponseStatus</code>注释类型的异常。</li><li><code>ExceptionHandlerExceptionResolver</code>，注解形式的异常处理器。对<code>@ExceptionHandler</code>注解的方法进行异常解析。</li></ul><h3 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h3><p>这个异常处理器是<code>SprngMVC</code>默认的一个处理器，处理一些常见的异常，比如：没有找到请求参数，参数类型转换异常，请求方式不支持等等。</p><p>接着我们看<code>DefaultHandlerExceptionResolver</code>类的<code>doResolveException()</code>方法：</p><pre><code class="java">    @Override    @Nullable    protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response,@Nullable Object handler, Exception ex) {        try {            if (ex instanceof HttpRequestMethodNotSupportedException) {                return handleHttpRequestMethodNotSupported((HttpRequestMethodNotSupportedException) ex, request,                        response, handler);            }            else if (ex instanceof HttpMediaTypeNotSupportedException) {                return handleHttpMediaTypeNotSupported((HttpMediaTypeNotSupportedException) ex, request, response,                        handler);            }            else if (ex instanceof HttpMediaTypeNotAcceptableException) {                return handleHttpMediaTypeNotAcceptable((HttpMediaTypeNotAcceptableException) ex, request, response,                        handler);            }            //省略...以下还有十几种异常的else-if        }catch (Exception handlerException) {            //是否打开日志，如果打开，那就记录日志            if (logger.isWarnEnabled()) {                logger.warn(&quot;Handling of [&quot; + ex.getClass().getName() + &quot;] resulted in Exception&quot;, handlerException);            }        }        return null;    }</code></pre><p>通过<code>if-else</code>判断，判断继承什么异常就显示对应的错误码和错误提示信息。由此可以知道，处理一般有两步，一是设置响应码，二是在响应头设置异常信息。下面是<code>MissingServletRequestPartException</code>的处理的源码：</p><pre><code class="java">    protected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex,            HttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {        //设置响应码，设置异常信息，SC_BAD_REQUEST就是400(bad request)        response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage());        return new ModelAndView();    }    //响应码    public static final int SC_BAD_REQUEST = 400;</code></pre><p>为什么要存在这个异常处理器呢？</p><p>从框架的设计理念来看，这种公共的、常见的异常应该交给框架本身来完成，是一些必需处理的异常。比如参数类型转换异常，如果程序员不处理，还有框架提供默认的处理方式，<strong>不至于出现这种错误而无法排查</strong>。</p><h3 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a>SimpleMappingExceptionResolver</h3><p>这种异常处理器需要提前配置异常类和对应的<code>view</code>视图。一般用于使用<code>JSP</code>的项目中，出现异常则通过这个异常处理器跳转到指定的页面。</p><p>怎么配置？首先搭建<code>JSP</code>项目我就不浪费篇幅介绍了。首先要加载一个<code>XML</code>文件。</p><pre><code class="java">@SpringBootApplication//在启动类，加载配置文件@ImportResource(&quot;classpath:spring-config.xml&quot;)public class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre><p>然后在<code>resources</code>目录下，创建一个<code>spring-config.xml</code>文件，内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;        &lt;!-- 定义默认的异常处理页面 --&gt;        &lt;property name=&quot;defaultErrorView&quot; value=&quot;err&quot;/&gt;        &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt;        &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;        &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常也页名作为值 --&gt;        &lt;property name=&quot;exceptionMappings&quot;&gt;            &lt;props&gt;                &lt;!-- 数组越界异常 --&gt;                &lt;prop key=&quot;java.lang.ArrayIndexOutOfBoundsException&quot;&gt;err/arrayIndexOutOfBounds&lt;/prop&gt;                &lt;!-- 空指针异常 --&gt;                &lt;prop key=&quot;java.lang.NullPointerException&quot;&gt;err/nullPointer&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>然后在<code>webapp</code>也就是存放<code>JSP</code>页面的目录下，创建两个<code>JSP</code>页面。</p><p><code>arrayIndexOutOfBounds.jsp</code>如下：</p><pre><code class="JSP">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;数组越界异常&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;数组越界异常&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%= ex.getMessage() %&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>nullPointer.jsp</code>如下：</p><pre><code class="JSP">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;空指针异常&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;空指针异常&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%=ex.getMessage()%&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>接着创建两个<code>Controller</code>，分别抛出空指针异常和数组越界异常。</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/null&quot;)    public String err() throws Exception{        String str = null;        //抛出空指针异常        int length = str.length();        System.out.println(length);        return &quot;index&quot;;    }    @RequestMapping(&quot;/indexOut&quot;)    public String indexOut() throws Exception{        int[] nums = new int[2];        for (int i = 0; i &lt; 3; i++) {            //抛出数组越界异常            nums[i] = i;            System.out.println(nums[i]);        }        return &quot;index&quot;;    }}</code></pre><p>启动项目后，我们发送两个请求，就可以看到：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_2.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/exceptionResolver_3.png" srcset="/img/loading.gif" alt=""></p><p>通过上述例子可以看出，其实对于现在<strong>前后端分离的项目</strong>来说，<strong>这种异常处理器已经不是很常用了</strong>。</p><h3 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h3><p>这种异常处理器主要用于处理带有<code>@ResponseStatus</code>注释的异常。下面演示一下使用方式。</p><p>首先自定义异常类继承<code>Exception</code>，并且使用<code>@ResponseStatus</code>注解修饰。如下：</p><pre><code class="java">//value需要使用HttpStatus枚举类型，HttpStatus.FORBIDDEN=403。@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;My defined Exception&quot;)public class DefinedException extends Exception{}</code></pre><p>然后再在<code>Controller</code>层抛出此异常。如下：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/myException&quot;)    public String ex(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception {        if (num == 1) {            //抛出自定义异常            throw new DefinedException();        }        return &quot;index&quot;;    }}</code></pre><p>然后启动项目，请求接口，可以看到如下信息：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_4.png" srcset="/img/loading.gif" alt=""></p><p>使用这种异常处理器，需要自定义一个异常，一定要一直往上层抛出异常，如果不往上层抛出，在<code>service</code>或者<code>dao</code>层就<code>try-catch</code>处理掉的话，是不会触发的。</p><h3 id="ExceptionHandlerExceptionResolver"><a href="#ExceptionHandlerExceptionResolver" class="headerlink" title="ExceptionHandlerExceptionResolver"></a>ExceptionHandlerExceptionResolver</h3><p>这个异常处理器才是最重要的，也是最常用，最灵活的，因为是使用注解。首先我们还是简单地演示一下怎么使用：</p><p>首先需要定义一个全局的异常处理器。</p><pre><code class="java">//这里使用了RestControllerAdvice，是@ResponseBody和@ControllerAdvice的结合//会把实体类转成JSON格式的提示返回，符合前后端分离的架构@RestControllerAdvicepublic class GlobalExceptionHandler {    //这里自定义了一个BaseException，当抛出BaseException异常就会被此方法处理    @ExceptionHandler(BaseException.class)    public ErrorInfo errorHandler(HttpServletRequest req, BaseException e) throws Exception {        ErrorInfo r = new ErrorInfo();        r.setMessage(e.getMessage());        r.setCode(ErrorInfo.ERROR);        r.setUrl(req.getRequestURL().toString());        return r;    }}</code></pre><p>然后我们自定义一个自定义异常类<code>BaseException</code>：</p><pre><code class="java">public class BaseException extends Exception {    public BaseException(String message) {        super(message);    }}</code></pre><p>然后在<code>Controller</code>层定义一个方法测试：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/base&quot;)    public String base() throws BaseException {        throw new BaseException(&quot;系统异常，请稍后重试。&quot;);    }}</code></pre><p>老规矩，启动项目，请求接口可以看到结果：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_1.jpg" srcset="/img/loading.gif" alt=""></p><p>你也可以不自定义异常<code>BaseException</code>，而直接拦截常见的各种异常都可以。所以这是一个非常灵活的异常处理器。你也可以做跳转页面，返回<code>ModelAndView</code>即可（以免篇幅过长就不演示了，哈哈）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>经过以上的演示后我们学习了<code>SpringMVC</code>四种异常处理器的工作机制，最后这种作为程序员我觉得是必须掌握的，前面的简单映射异常处理器和状态映射处理器可以选择性掌握，默认的异常处理器了解即可。</p><p>那这么多异常处理器，究竟是如何工作的呢？为什么是设计一个接口，下面有一个抽象类加上四个实现子类呢？接下来我们通过源码分析来揭开谜底！</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码分析从哪里入手呢？在<code>SpringMVC</code>中，其实你想都不用想，肯定在<code>DispatcherServlet</code>类里。经过我顺藤摸瓜，我定位在了<code>processHandlerException()</code>方法。怎么定位的呢？其实很简单，看源码：</p><pre><code class="java">    private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,            @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,            @Nullable Exception exception) throws Exception {        boolean errorView = false;        //异常不为空        if (exception != null) {            if (exception instanceof ModelAndViewDefiningException) {                logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);                mv = ((ModelAndViewDefiningException) exception).getModelAndView();            }            else {                Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);                //关键点：执行异常处理                mv = processHandlerException(request, response, handler, exception);                //省略...            }        }        //省略...    }</code></pre><h3 id="processHandlerException"><a href="#processHandlerException" class="headerlink" title="processHandlerException()"></a>processHandlerException()</h3><p>就是这个直接的一个<code>if-else</code>判断，那个<code>processHandlerException()</code>方法又是怎么处理的呢？</p><pre><code class="java">@Nullableprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,      @Nullable Object handler, Exception ex) throws Exception {   ModelAndView exMv = null;   //判断异常处理器的集合是否为空   if (this.handlerExceptionResolvers != null) {      //不为空则遍历异常处理器       for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {         //调用异常处理器的resolveException()方法进行处理异常         exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);         //判断返回的ModelAndView是否为null，不为null则跳出循环，为null则继续下一个异常处理器         if (exMv != null) {            break;         }      }   }   //如果ModelAndView不为空   if (exMv != null) {      if (exMv.isEmpty()) {         //设置异常信息提示         request.setAttribute(EXCEPTION_ATTRIBUTE, ex);         return null;      }      //如果返回的ModelAndView不包含view      if (!exMv.hasView()) {         //设置一个默认的视图          String defaultViewName = getDefaultViewName(request);         if (defaultViewName != null) {            exMv.setViewName(defaultViewName);         }      }      //省略...      //返回异常的ModelAndView          return exMv;   }   throw ex;}</code></pre><p>这不就是责任链模式吗！提前加载异常处理器到<code>handlerExceptionResolvers</code>集合中，然后遍历去执行，能处理就处理，不能处理就跳到下一个异常处理器处理。</p><p>那接下来我们就有一个问题了，<code>handlerExceptionResolvers</code>集合是怎么加载异常处理器的？这个问题很简单，就是使用<code>DispatcherServlet.properties</code>配置文件。这个文件真的很重要！！！</p><pre><code class="properties">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</code></pre><p>默认是加载以上三种异常处理器到集合中，所以只要带有<code>@ControllerAdvice</code>、<code>@ExceptionHandler</code>、<code>@ResponseStatus</code>注解的都会被扫描。<code>SimpleMappingExceptionResolver</code>则是通过<code>xml</code>文件(当然也可以使用<code>@Configuration</code>)去配置。</p><h3 id="resolveException"><a href="#resolveException" class="headerlink" title="resolveException()"></a>resolveException()</h3><p>其实在<code>resolveException()</code>处理异常的方法中，还使用了模板模式。</p><pre><code class="java">    @Override    @Nullable    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response,            @Nullable Object handler, Exception ex) {            //省略...            //预处理            prepareResponse(ex, response);            //调用了一个抽象方法，抽象方法由子类去实现            ModelAndView result = doResolveException(request, response, handler, ex);            //省略...    }</code></pre><p>抽象方法<code>doResolveException()</code>，由子类实现。</p><pre><code class="java">@Nullableprotected abstract ModelAndView doResolveException(HttpServletRequest request,      HttpServletResponse response, @Nullable Object handler, Exception ex);</code></pre><p>怎么识别模板方法，其实很简单，只要看到抽象类，有个具体方法里面调用了抽象方法，那很大可能就是模板模式。抽象方法就是模板方法，由子类实现。</p><p>子类我们都知道就是那四个异常处理器实现类了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用流程图概括一下：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_5.png" srcset="/img/loading.gif" alt=""></p><p>经过以上的学习后，我们知道只需要把异常处理器加到集合中，就可以执行。所以我们可以使用直接实现<code>HandlerExceptionResolver</code>接口的方式来实现异常处理器。</p><h2 id="实现HandlerExceptionResolver接口实现全局异常处理"><a href="#实现HandlerExceptionResolver接口实现全局异常处理" class="headerlink" title="实现HandlerExceptionResolver接口实现全局异常处理"></a>实现HandlerExceptionResolver接口实现全局异常处理</h2><p>首先自定一个异常类<code>MyException</code>。</p><pre><code class="java">public class MyException extends Exception {    public MyException(String message) {        super(message);    }}</code></pre><p>然后实现<code>HandlerExceptionResolver</code>接口定义一个异常处理器。</p><pre><code class="java">//注册异常处理器到Spring容器中@Componentpublic class MyExceptionHandler implements HandlerExceptionResolver {    @Override    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {        try {            //如果属于MyException异常，则输出异常提示到页面            if (ex instanceof MyException) {                response.setContentType(&quot;text/html;charset=utf-8&quot;);                response.getWriter().println(ex.getMessage());                //这里返回null，不做处理。也可以返回ModelAndView跳转页面                return null;            }        } catch (IOException e) {            e.printStackTrace();        }        return null;    }}</code></pre><p>然后在<code>Controller</code>层定义一个方法测试：</p><pre><code class="java">@Controller@RequestMapping(&quot;/error&quot;)public class ErrController {    @RequestMapping(&quot;/myEx&quot;)    public String myEx() throws MyException {        System.out.println(&quot;执行myEx()&quot;);        throw new MyException(&quot;自定义异常提示信息&quot;);    }}</code></pre><p>启动项目，请求接口，我们可以看到：</p><p><img src="https://static.lovebilibili.com/exceptionResolver_6.png" srcset="/img/loading.gif" alt=""></p><h1 id="最后说几句"><a href="#最后说几句" class="headerlink" title="最后说几句"></a>最后说几句</h1><p>以上就是我对于<code>SpringMVC</code>全局异常处理机制的理解。更多的<code>java</code>技术分享，可以关注我的公众号“<strong>java技术爱好者</strong>”，后续会不断更新。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringMVC</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题总结-基础篇</title>
    <link href="/2020/06/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2020/06/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="JVM、JRE、JDK有什么联系与区别？"><a href="#JVM、JRE、JDK有什么联系与区别？" class="headerlink" title="JVM、JRE、JDK有什么联系与区别？"></a>JVM、JRE、JDK有什么联系与区别？</h3><p><strong>JVM是java虚拟机</strong>，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。<br><strong>JRE是java运行时环境</strong>，它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。换句话说，JRE包含JVM。<br><strong>JDK是java开发工具包</strong>，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。JDK包含JRE。<br>所以总得来说，<strong>JDK&gt;JRE&gt;JVM</strong>。</p><h3 id="面向对象的特征有哪些？"><a href="#面向对象的特征有哪些？" class="headerlink" title="面向对象的特征有哪些？"></a>面向对象的特征有哪些？</h3><p>有三大特征，继承，封装，多态。</p><h3 id="为什么java可以实现跨平台？"><a href="#为什么java可以实现跨平台？" class="headerlink" title="为什么java可以实现跨平台？"></a>为什么java可以实现跨平台？</h3><p>因为java是编译成.class文件运行在JVM上的。<strong>针对不同的系统有不同的JVM实现，在不同的JVM实现上会映射到不同系统的 API 调用</strong>，从而实现代码的跨平台运行。</p><h3 id="类的加载顺序？"><a href="#类的加载顺序？" class="headerlink" title="类的加载顺序？"></a>类的加载顺序？</h3><p>静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。</p><h3 id="接口和抽象类有什么共同点和不同点？"><a href="#接口和抽象类有什么共同点和不同点？" class="headerlink" title="接口和抽象类有什么共同点和不同点？"></a>接口和抽象类有什么共同点和不同点？</h3><p>共同点：<br>1.都可以定义抽象方法，子类都要实现定义的抽象方法。<br>2.都不能被实例化，但是可以定义抽象类和接口类型的引用。<br>不同点：<br>1.接口没有构造器，抽象类可以定义构造器。<br>2.接口定义具体方法只能定义<strong>default</strong>修饰，抽象类可以直接定义具体方法。<br>3.接口的子类是实现接口，关键字是<strong>implements</strong>，抽象类的子类是继承，关键字是<strong>extends</strong>。<br>4.接口不能定义成员变量，只能定义常量。抽象类可以定义成员变量。</p><h3 id="static关键字有哪些用法？"><a href="#static关键字有哪些用法？" class="headerlink" title="static关键字有哪些用法？"></a>static关键字有哪些用法？</h3><p>①<strong>修饰成员变量，用static修饰的成员变量就成为静态变量</strong>，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。<br>②<strong>static修饰方法，该方法就被定义为静态方法</strong>，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。<br>③<strong>用static修饰代码块，该代码块就被定义为静态代码块</strong>，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。</p><h3 id="Switch能用什么数据类型作为参数？"><a href="#Switch能用什么数据类型作为参数？" class="headerlink" title="Switch能用什么数据类型作为参数？"></a>Switch能用什么数据类型作为参数？</h3><p>JDK1.5前：<strong>byte、short、char、int</strong><br>JDK1.5：枚举<br>JDK1.7：String</p><h3 id="枚举有哪些特点？在项目中如何使用？"><a href="#枚举有哪些特点？在项目中如何使用？" class="headerlink" title="枚举有哪些特点？在项目中如何使用？"></a>枚举有哪些特点？在项目中如何使用？</h3><p>特点：<br>1.枚举的构造器是私有的。<br>2.枚举不能被继承。<br>3.枚举是绝对的单例，即使是反序列化也无法创建多个实例。<br>使用场景：<br>当变量只能从一堆固定的值中取出一个时，那么就应该使用枚举。比如时间的单位，季度等等。</p><h3 id="什么是方法重载？什么是方法重写？"><a href="#什么是方法重载？什么是方法重写？" class="headerlink" title="什么是方法重载？什么是方法重写？"></a>什么是方法重载？什么是方法重写？</h3><p><strong>方法重载</strong>，一个类中允许同时存在一个以上的同名方法，主要体现在方法参数的类型和数量不同，方法名相同，与访问修饰符和返回值类型都是无关的。口诀是”<strong>一同两不同</strong>“。<br><strong>方法重写</strong>一般在继承中，子类重写父类的方法，既然是重写一遍，那么方法名和参数部分一定是相同的。只是实现的功能不同。<strong>声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，声明为 private 的方法不能被重写。</strong></p><h3 id="静态变量和实例变量有什么不同？分别位于内存的什么区域？"><a href="#静态变量和实例变量有什么不同？分别位于内存的什么区域？" class="headerlink" title="静态变量和实例变量有什么不同？分别位于内存的什么区域？"></a>静态变量和实例变量有什么不同？分别位于内存的什么区域？</h3><p>1.静态变量使用static修饰，实例变量不需要。<br>2.静态变量在类被加载时就会分配内存空间，就可以使用。实例变量需要实例对象才会分配内存空间，才可以被引用，是属于实例的。<br>3.静态变量是存在于<strong>静态区(全局区)</strong>的，实例变量位于<strong>堆内存</strong>中。</p><h3 id="java的内部类的分类有哪些？"><a href="#java的内部类的分类有哪些？" class="headerlink" title="java的内部类的分类有哪些？"></a>java的内部类的分类有哪些？</h3><p>实例内部类、静态内部类、局部内部类、匿名内部类。</p><h3 id="break、continue、return-的作用是什么？"><a href="#break、continue、return-的作用是什么？" class="headerlink" title="break、continue、return 的作用是什么？"></a>break、continue、return 的作用是什么？</h3><ul><li>break：结束循环。不仅可以结束其所在的循环，还可结束其外层循环。</li><li>continue：跳过本次循环，开始下一次循环。</li><li>return：不是专用于结束循环，而是用于结束方法。如果在循环中使用return，就会结束整个方法，循环当然也会结束。<h3 id="Object类有哪些常用的方法？"><a href="#Object类有哪些常用的方法？" class="headerlink" title="Object类有哪些常用的方法？"></a>Object类有哪些常用的方法？</h3></li></ul><p><strong>toString()、equals()、hashCode()。</strong></p><ul><li><code>toString()</code>默认输出对象的内存地址，一般不希望输出内存地址可以重写toString()方法。</li><li><code>equals()</code>方法用于比较对象是否相等，默认比较是内存地址，所以要正确比较两个对象是否值相等，此方法必须被重写。</li><li><code>hashCode()</code>方法用来返回其所在对象的物理地址（哈希码值），常会和<code>equals()</code>方法同时重写，确保相等的两个对象拥有相等的<strong>hashCode</strong>。<h3 id="与equals-的区别？"><a href="#与equals-的区别？" class="headerlink" title="==与equals()的区别？"></a>==与equals()的区别？</h3><code>equals()</code>方法属于<code>Object</code>对象的，所以比较基础数据类型是不能使用<code>equals()</code>。必须使用<code>==</code>。</li></ul><p><strong>在默认情况下</strong>，<code>equals()</code>与<code>==</code>是一样的，都是比较内存地址。所以在业务逻辑中，我们一般会重写<code>equals()</code>方法。</p><h3 id="equals-与hashCode-有什么联系？"><a href="#equals-与hashCode-有什么联系？" class="headerlink" title="equals()与hashCode()有什么联系？"></a>equals()与hashCode()有什么联系？</h3><p>1.<code>equals()</code>相等的两个对象他们的<code>hashCode()</code>肯定相等，也就是用<code>equals()</code>对比是绝对可靠的。<br>2.<code>hashCode()</code>相等的两个对象他们的<code>equals()</code>不一定相等，也就是<code>hashCode()</code>不是绝对可靠的。<br>在使用<code>HashSet</code>或者<code>HashMap</code>集合中，比较两个对象是否相等时，会先调用<code>hashCode()</code>比较，如果<code>hashCode()</code>相等，则会继续调用<code>equals()</code>比较，<code>equals()</code>也相等才会认为是同一个对象。如果<code>hashCode()</code>返回不相等，则认为是不相等的对象。<br>所以一般我们会同时重写<code>hashCode()</code>和<code>equals()</code>方法。</p><h3 id="amp-和-amp-amp-有什么区别？"><a href="#amp-和-amp-amp-有什么区别？" class="headerlink" title="&amp; 和 &amp;&amp;有什么区别？"></a>&amp; 和 &amp;&amp;有什么区别？</h3><p><code>&amp;&amp;</code>具有短路的功能，也就是如果<code>&amp;&amp;</code>左边的条件为<code>fasle</code>就不再执行后面的条件判断。<br><code>&amp;</code>则会执行完左右两边的条件判断。</p><h3 id="final、finalize-、finally-分别有什么作用？"><a href="#final、finalize-、finally-分别有什么作用？" class="headerlink" title="final、finalize()、finally{}分别有什么作用？"></a>final、finalize()、finally{}分别有什么作用？</h3><p><code>final</code>修饰类，表明这个类不可被其他类继承。<br><code>final</code>修饰成员变量，表示此变量为常量，只能在初始化时被赋值一次，赋值后不能修改。<br><code>final</code>修饰方法。把方法锁定，不能被子类重写，以防止子类对其进行更改。<br><code>finalize()</code>是<code>Object</code>里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。一个对象的<code>finalize()</code>方法只会被调用一次。<br><code>finally</code>作为异常处理的一部分，它只能用在<code>try/catch</code>语句中，并且附带一个语句块。</p><h3 id="Cloneable接口有什么作用？"><a href="#Cloneable接口有什么作用？" class="headerlink" title="Cloneable接口有什么作用？"></a>Cloneable接口有什么作用？</h3><p><code>Cloneable</code>接口是一个标记接口，实现了此接口，表示可以使用<code>clone()</code>方法，没有实现此接口使用<code>clone()</code>会抛出<code>CloneNotSupportedException</code>异常。</p><h3 id="什么是浅克隆，什么是深克隆？"><a href="#什么是浅克隆，什么是深克隆？" class="headerlink" title="什么是浅克隆，什么是深克隆？"></a>什么是浅克隆，什么是深克隆？</h3><p><strong>浅克隆是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量）</strong>，而不拷贝对象包含的引用指向的对象。</p><p><strong>深克隆不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。</strong></p><h3 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h3><p>序列化：把<strong>对象</strong>转换为<strong>字节序列</strong>的过程称为对象的序列化。<br>反序列化：把<strong>字节序列</strong>恢复为<strong>对象</strong>的过程称为对象的反序列化。</p><h3 id="Serializable接口有什么作用？"><a href="#Serializable接口有什么作用？" class="headerlink" title="Serializable接口有什么作用？"></a>Serializable接口有什么作用？</h3><p><code>Serializable</code>接口是一个标记接口，一个类只有实现了<code>Serializable</code>接口，它的对象才是可序列化的。否则序列化时会报<code>NotSerializableException</code>异常。如果不显性声明<code>serialVersionUID</code>，则会默认生成一个。为了<code>serialVersionUID</code>的确定性，最好是显性声明。</p><h3 id="String、StringBuffer、StringBuilder有什么区别"><a href="#String、StringBuffer、StringBuilder有什么区别" class="headerlink" title="String、StringBuffer、StringBuilder有什么区别?"></a>String、StringBuffer、StringBuilder有什么区别?</h3><ul><li><code>String</code>被声明为<code>final class</code>，是由定义<code>final</code>的字符数组实现的，因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。<ul><li><code>StringBuffer</code>是由定义了临时数据<code>transient</code>的字符数组实现的，提供<code>append()</code>和<code>add()</code>方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列，所有修改数据的方法都加上<code>synchronized</code>。性能相对<code>StringBuilder</code>会差一点。</li></ul></li><li><code>StringBuilder</code>和<code>StringBuffer</code>本质上没什么区别，区别是去掉了保证线程安全的<code>synchronized</code>，减少了开销，性能有所提高。<h3 id="什么是泛型-什么是泛型的上界和下界"><a href="#什么是泛型-什么是泛型的上界和下界" class="headerlink" title="什么是泛型?什么是泛型的上界和下界?"></a>什么是泛型?什么是泛型的上界和下界?</h3>Java 泛型是 JDK1.5中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<br>上界用<code>extends</code>关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。<br>下界用<code>super</code>进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至Object。<h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><strong>Java反射机制</strong>是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在<strong>运行时动态的获取信息以及动态调用对象的方法的功能</strong>称为Java的反射机制。<h3 id="获取Class对象的方式有哪些？"><a href="#获取Class对象的方式有哪些？" class="headerlink" title="获取Class对象的方式有哪些？"></a>获取Class对象的方式有哪些？</h3><ul><li>通过<code>Object</code>类中的<code>getClass()</code>方法，想要用这种方法必须要明确具体的类并且创建该类的对象。</li><li>所有数据类型都具备一个静态的属性<code>.class</code>来获取对应的<code>Class</code>对象。但是还是要明确到类，然后才能调用类中的静态成员。</li><li>通过<code>Class.forName()</code>方法完成，必须要指定类的全限定名，由于前两种方法都是在知道该类的情况下获取该类的字节码对象，因此不会有异常，但是<code>Class.forName()</code>方法如果写错类的路径会报<code>ClassNotFoundException</code>的异常。<h3 id="java中的异常有哪几种异常？"><a href="#java中的异常有哪几种异常？" class="headerlink" title="java中的异常有哪几种异常？"></a>java中的异常有哪几种异常？</h3><code>Throwable</code>类是<code>Java</code>异常类型的顶层父类，<code>Throwable</code>包含了<code>Error</code>和<code>Excetion</code>。<code>Excetion</code>分为两种，一种是<strong>非运行时异常(又称为检查异常)</strong>，另一种是<strong>运行时异常(RuntimeException)</strong>。<h3 id="java是如何处理异常的？"><a href="#java是如何处理异常的？" class="headerlink" title="java是如何处理异常的？"></a>java是如何处理异常的？</h3></li><li><code>Error</code>是程序无法处理的, 比如<code>OutOfMemoryError</code>、<code>OutOfMemoryError</code>等等, 这些异常发生时, <code>JVM</code>一般会终止线程。</li><li>运行时异常(<code>RuntimeException</code>)，如 <code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>等，是在程序运行的时候可能会发生的，所以程序可以捕捉，也可以不捕捉。这些错误一般是由程序的逻辑错误引起的，<strong>程序应该从逻辑角度去尽量避免</strong>。</li><li>非运行时异常是<code>RuntimeException</code>以外的异常，是<code>Exception</code>及其子类，这些异常从程序的角度来说是必须经过捕捉检查处理的，否则不能通过编译。如<code>IOException</code>、<code>SQLException</code>等。<h1 id="java集合、IO流、日期处理等"><a href="#java集合、IO流、日期处理等" class="headerlink" title="java集合、IO流、日期处理等"></a>java集合、IO流、日期处理等</h1><h3 id="常用的集合有哪些？"><a href="#常用的集合有哪些？" class="headerlink" title="常用的集合有哪些？"></a>常用的集合有哪些？</h3>常用集合有<strong>Map、List、Set</strong>。<h3 id="HashMap是线程安全的吗？"><a href="#HashMap是线程安全的吗？" class="headerlink" title="HashMap是线程安全的吗？"></a>HashMap是线程安全的吗？</h3>不是线程安全的。<h3 id="如何使HashMap线程安全？"><a href="#如何使HashMap线程安全？" class="headerlink" title="如何使HashMap线程安全？"></a>如何使HashMap线程安全？</h3>使用<code>Collections</code>类的<code>synchronizedMap()</code>方法包装。<pre><code class="java">Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</code></pre>使用<code>java.util.concurrent</code>包下的<code>ConcurrentHashMap</code>类也可以获得线程安全的Map。<pre><code class="java">ConcurrentHashMap concurrentHashMap = new ConcurrentHashMap();</code></pre>使用<code>Hashtable</code>类，也可以获得线程安全的Map<pre><code class="java">Map&lt;String,Object&gt; hashtable = new Hashtable&lt;&gt;();</code></pre><h3 id="HashMap和Hashtable的区别是什么？"><a href="#HashMap和Hashtable的区别是什么？" class="headerlink" title="HashMap和Hashtable的区别是什么？"></a>HashMap和Hashtable的区别是什么？</h3></li><li><code>Hashtable</code>继承自<code>Dictionary</code>类，而<code>HashMap</code>继承自<code>AbstractMap</code>类。但二者都实现了Map接口。</li><li><code>Hashtable</code>是线程安全的，<code>HashMap</code>是线程不安全的。</li><li><code>Hashtable</code>中，key和value都不允许出现null值。</li><li><code>HashTable</code>在不指定容量的情况下的<strong>默认容量为11，而HashMap为16</strong>，<code>Hashtable</code>不要求底层数组的容量一定要为2的整数次幂，而<code>HashMap</code>则要求一定为2的整数次幂。<code>Hashtable</code>扩容时，将容量变为原来的2倍加1，而<code>HashMap</code>扩容时，将容量变为原来的2倍。<h3 id="HashMap是如何解决哈希冲突的？"><a href="#HashMap是如何解决哈希冲突的？" class="headerlink" title="HashMap是如何解决哈希冲突的？"></a>HashMap是如何解决哈希冲突的？</h3></li><li>在JDK1.8前，<code>HashMap</code>是采用<strong>链表法</strong>解决哈希冲突的。当<code>put()</code>一个值到<code>Map</code>时，会通过<code>Key</code>拿到一个哈希值，通过哈希值获取数组下标，先查询是否存在该<code>hash</code>值。若不存在，则直接以<code>Entry&lt;V,V&gt;</code>的方式存放在数组中。若存在，则再调用<code>equals()</code>方法对比<code>key</code>是否相同，若<code>hashcode()</code>值和<code>key</code>都相同，则替换<code>value</code>，若<code>hashcode()</code>值相同，<code>key</code>不相同，则形成一个单链表，将<code>hashcode()</code>值相同，<code>key</code>不同的元素以<code>Entry&lt;V,V&gt;</code>的方式存放在链表中，这样就解决了哈希冲突。</li><li>JDK1.8以后，当链表的长度达到某个限制值(默认是8)，就会转换成<strong>红黑树</strong>，提高性能。<h3 id="HashMap初始大小是多少？负载因子是多少？"><a href="#HashMap初始大小是多少？负载因子是多少？" class="headerlink" title="HashMap初始大小是多少？负载因子是多少？"></a>HashMap初始大小是多少？负载因子是多少？</h3>默认的数组初始大小是16。负载因子是0.75。</li></ul><strong>（为什么初始值是2的n次方，为什么负载因子取0.75，这两个问题可以网上找资料看看，这里就不详述了）</strong><h3 id="简述一下HashMap的扩容机制？"><a href="#简述一下HashMap的扩容机制？" class="headerlink" title="简述一下HashMap的扩容机制？"></a>简述一下HashMap的扩容机制？</h3><code>HashMap</code>是懒加载的，当调用<code>put()</code>方法时，会先初始化<code>Map</code>的大小，默认数组长度是16，负载因子是0.75，所以阈值是12。当<code>HashMap</code>元素的个数超过阈值时，就会把数组的大小扩展到原来的2倍，然后重新计算每个元素在数组中的位置。<h3 id="List有哪些常用的子类？"><a href="#List有哪些常用的子类？" class="headerlink" title="List有哪些常用的子类？"></a>List有哪些常用的子类？</h3><code>ArrayList</code>和<code>LinkedList</code>。<h3 id="ArrayList和LinkedList有什么区别？"><a href="#ArrayList和LinkedList有什么区别？" class="headerlink" title="ArrayList和LinkedList有什么区别？"></a>ArrayList和LinkedList有什么区别？</h3><ul><li>底层<strong>数据结构不同</strong>。<code>ArrayList</code>基于数组+动态扩容实现的，<code>LinkedList</code>基于双向链表实现。从储存结构上分析，<code>LinkedList</code>更加占内存，因为每个节点除了存储数据外还要<strong>存储指向前节点的引用和指向后节点的引用。</strong></li><li><strong>效率不同</strong>。当随机访问时，<code>ArrayList</code>是基于数组下标访问，<strong>查询效率较高</strong>，但是由于数组的长度是固定的，所以当添加的元素到一定的阈值时会扩容数组，消耗性能，<strong>增删效率偏低</strong>。<code>LinkedList</code>在查询时，需要从前到后依次遍历，所以<strong>查询效率不高</strong>，但是在增删时只需要更改节点的引用，开销较少，所以<strong>增删效率较高</strong>。<h3 id="List集合排序的方式有哪些？"><a href="#List集合排序的方式有哪些？" class="headerlink" title="List集合排序的方式有哪些？"></a>List集合排序的方式有哪些？</h3>使用List接口定义的sort()方法。<pre><code class="java">list.sort(Comparator.comparingInt(User::getAge));</code></pre>使用<code>Collections</code>的<code>sort()</code>方法，排序的对象需要实现<code>Comparable</code>接口，重写<code>compareTo()</code>方法。<pre><code class="java">//实现Comparable接口public class User implements Comparable&lt;User&gt; {//重写compareTo方法@Overridepublic int compareTo(User user) {      return Integer.compare(this.getAge(), user.getAge());}}</code></pre>使用<code>Collections</code>的<code>sort()</code>方法<pre><code class="java">Collections.sort(list);//如果不想实现Comparable接口，也可以使用这个方法Collections.sort(list,Comparator.comparingInt(User::getAge));</code></pre>使用Stream流操作的<code>sort()</code>方法，传入一个<code>Comparator</code>接口。<pre><code class="java">list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList());</code></pre><h3 id="栈和队列的特点分别是什么？在java中有哪些实现的类？"><a href="#栈和队列的特点分别是什么？在java中有哪些实现的类？" class="headerlink" title="栈和队列的特点分别是什么？在java中有哪些实现的类？"></a>栈和队列的特点分别是什么？在java中有哪些实现的类？</h3>栈是<strong>先进后出</strong>，队列是<strong>先进先出</strong>。<br><code>Stack</code>类是栈在java中的实现，继承<code>Vector</code>类，底层是基于数组存储数据。<br><code>Queue</code>接口是队列在java中的代表，<code>Queue</code>接口有几个常用的子类<code>ArrayDeque</code>、<code>LinkedList</code>。<h3 id="IO、NIO有什么区别？"><a href="#IO、NIO有什么区别？" class="headerlink" title="IO、NIO有什么区别？"></a>IO、NIO有什么区别？</h3>IO包括：<code>File</code>、<code>OutputStream</code>、<code>InputStream</code>、<code>Writer</code>，<code>Reader</code>。<br>NIO三大核心：<code>selector</code>（选择器），<code>channel</code>（通道），<code>buffer</code>（缓冲区）<br>NIO与IO区别在于，IO面向流，NIO面向缓冲区。IO是阻塞，NIO是非阻塞。<h3 id="如何进行日期的转换？"><a href="#如何进行日期的转换？" class="headerlink" title="如何进行日期的转换？"></a>如何进行日期的转换？</h3>使用<code>SimpleDateFormat</code>类进行<code>String</code>和<code>Date</code>之间的转换。<h3 id="如何获取上一年的今天的日期？"><a href="#如何获取上一年的今天的日期？" class="headerlink" title="如何获取上一年的今天的日期？"></a>如何获取上一年的今天的日期？</h3>使用<code>Calendar</code>对象。如下所示：<pre><code class="java">//创建Calendar对象Calendar calendar = Calendar.getInstance();//设置年份，当前年份减去一年calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1);//以下是打印结果Date time = calendar.getTime();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);System.out.println(sdf.format(time));//2019-06-08 23:43:14 正确</code></pre><h3 id="BigDecimal类型一定不会失真吗？"><a href="#BigDecimal类型一定不会失真吗？" class="headerlink" title="BigDecimal类型一定不会失真吗？"></a>BigDecimal类型一定不会失真吗？</h3>不一定。<br>参数类型为<code>double</code>的构造方法的结果有一定的不可预知性，是有可能产生失真的。<pre><code class="java">BigDecimal bigDecimal = new BigDecimal(0.99);System.out.println(bigDecimal);//结果如下//0.9899999999999999911182158029987476766109466552734375</code></pre>使用参数类型<code>String</code>构造方法是完全可预知的，不会产生失真。所以在开发中推荐使用参数类型<code>String</code>构造方法。<h1 id="java并发编程"><a href="#java并发编程" class="headerlink" title="java并发编程"></a>java并发编程</h1><h3 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h3></li><li>避免主线程阻塞，可以使用多线程做成异步调用。</li><li>提升性能，充分利用CPU资源。<h3 id="创建线程有哪几种方法？"><a href="#创建线程有哪几种方法？" class="headerlink" title="创建线程有哪几种方法？"></a>创建线程有哪几种方法？</h3></li><li>通过继承<code>Thread</code>类创建线程类。</li><li>通过实现<code>Runnable</code>接口创建线程类。</li><li>通过实现<code>Callable</code>接口创建线程类。<h3 id="如何获取多线程的返回值？"><a href="#如何获取多线程的返回值？" class="headerlink" title="如何获取多线程的返回值？"></a>如何获取多线程的返回值？</h3>使用<code>Callable</code>和<code>FutureTask</code>接口，获取返回值。<pre><code class="java">public static void main(String[] args) throws Exception {  try {      //使用匿名内部类创建Callable      Callable callable = () -&gt; &quot;hello call&quot;;      FutureTask futureTask = new FutureTask(callable);      //执行线程      new Thread(futureTask).start();      if (!futureTask.isDone()) {          //获取返回值          System.out.println(futureTask.get());      }  } catch (Exception e) {      e.printStackTrace();  }}</code></pre><h3 id="多线程的生命周期？"><a href="#多线程的生命周期？" class="headerlink" title="多线程的生命周期？"></a>多线程的生命周期？</h3>新建状态、就绪状态、运行状态、阻塞状态、死亡状态<h3 id="如何进行线程之间的通信？"><a href="#如何进行线程之间的通信？" class="headerlink" title="如何进行线程之间的通信？"></a>如何进行线程之间的通信？</h3></li><li>使用<code>synchronized、wait()、notify()</code></li><li>使用JUC工具类<code>CountDownLatch</code></li><li>使用<code>ReentrantLock</code>结合<code>Condition</code></li><li>基本<code>LockSupport</code>实现线程间的阻塞和唤醒</li></ul></li></ul><p>以上几种方式的具体实现代码，可以网上找一下资料，这里不演示了。</p><h3 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h3><p>相同点：</p><ul><li><code>sleep()</code>方法和<code>wait()</code>方法都用来改变线程的状态，能够让线程从<strong>运行状态</strong>，转变为<strong>休眠状态</strong>。</li></ul><p>不同点：</p><ul><li><code>sleep()</code>方法是<code>Thread</code>类中的静态方法，而<code>wait()</code>方法是<code>Object</code>类中的方法。</li><li><code>sleep()</code>方法可以在任何地方调用，而wait()方法只能在同步代码块或同步方法中使用(即使用<code>synchronized</code>关键字修饰的)。</li><li>这两个方法都在同步代码块或同步方法中使用时，<code>sleep()</code>方法不会释放对象锁。而<code>wait()</code>方法则会释放对象锁。<h3 id="如何停止线程？"><a href="#如何停止线程？" class="headerlink" title="如何停止线程？"></a>如何停止线程？</h3></li><li>使用退出标志，使线程正常退出，也就是当<code>run()</code>方法完成后线程终止。</li><li>使用<code>stop()</code>方法强行终止(不推荐)，可能会出现数据不同步，或者资源未释放等问题。</li><li>使用<code>interrupt()</code>方法中断线程。<h3 id="什么是线程的死锁？如何避免线程死锁？"><a href="#什么是线程的死锁？如何避免线程死锁？" class="headerlink" title="什么是线程的死锁？如何避免线程死锁？"></a>什么是线程的死锁？如何避免线程死锁？</h3>多个线程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进，这种现象称为死锁。</li></ul><p>避免死锁的三种方式：</p><ul><li>加锁顺序（线程按照一定的顺序加锁）</li><li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）<h3 id="线程池的作用？"><a href="#线程池的作用？" class="headerlink" title="线程池的作用？"></a>线程池的作用？</h3></li><li>利用线程池管理并复用线程，减少创建线程和销毁线程的资源消耗。</li><li>实现任务线程队列缓存策略和拒绝机制。</li><li>可以对线程进行统一的分配，监控和调优。</li><li>提供定时执行、最大线程数、并发数控制等功能。<h3 id="创建线程池的重要参数分别代表什么意思？"><a href="#创建线程池的重要参数分别代表什么意思？" class="headerlink" title="创建线程池的重要参数分别代表什么意思？"></a>创建线程池的重要参数分别代表什么意思？</h3></li><li><code>corePoolSize</code>线程池核心线程大小。在没有设置 <code>allowCoreThreadTimeOut</code>为<code>true</code>的情况下，核心线程会在线程池中一直存活，即使处于闲置状态。当向线程池提交一个任务时，若线程池已创建的线程数小于<code>corePoolSize</code>，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于<code>corePoolSize</code>。</li><li><code>maximumPoolSize</code>线程池最大线程数量。线程池所允许的最大线程个数。<strong>当队列满了</strong>，且已创建的线程数小于<code>maximumPoolSize</code>，则线程池会创建新的线程来执行任务。对于无界队列可以忽略此参数。</li><li><code>keepAliveTime</code>线程存活保持时间。当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</li><li><code>unit</code>空间线程存活时间单位。</li><li><code>workQueue</code>任务队列：用于传输和保存等待执行任务的阻塞队列。<br>①<code>ArrayBlockingQueue</code>，基于数组的有界阻塞队列，按FIFO排序。<br>②<code>LinkedBlockingQuene</code>，基于链表的无界阻塞队列（其实最大容量为<code>Interger.MAX</code>），按照FIFO排序。当使用该队列时，<code>maximumPoolSize</code>参数可以忽略。<br>③<code>SynchronousQuene</code>，一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。<br>④<code>PriorityBlockingQueue</code>，具有优先级的无界阻塞队列，优先级通过参数<code>Comparator</code>实现。</li><li><code>threadFactory</code>线程工厂，用于创建新线程。</li><li><code>handler</code>线程饱和策略，当线程池和队列都满了，再加入线程会执行此策略。<h3 id="线程池中submit-和-execute-方法有什么区别？"><a href="#线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中submit() 和 execute()方法有什么区别？"></a>线程池中submit() 和 execute()方法有什么区别？</h3></li><li>参数不同</li></ul><p><code>submit()</code>方法有三个重载方法。</p><pre><code class="java">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);</code></pre><p><code>execute()</code>方法只有一个</p><pre><code class="java">void execute(Runnable command);</code></pre><ul><li><code>execute()</code>没有返回值；而<code>submit()</code>有返回值</li><li><code>submit()</code>的返回值<code>Future</code>调用<code>get()</code>方法时，可以捕获处理异常。而<code>execute()</code>没有返回值不能捕获异常。<h3 id="有哪些常用的线程池？"><a href="#有哪些常用的线程池？" class="headerlink" title="有哪些常用的线程池？"></a>有哪些常用的线程池？</h3><code>Executors.newCacheThreadPool()</code>：<strong>可缓存线程池</strong>，先查看池中有没有已建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务。<br><code>Executors.newFixedThreadPool()</code>：<strong>可重用固定个数的线程池</strong>，以共享的无界队列方式来运行这些线程。<br><code>Executors.newScheduledThreadPool(int n)</code>：<strong>定长线程池</strong>，支持定时及周期性任务执行。<br><code>Executors.newSingleThreadExecutor()</code>：<strong>单线程化的线程池</strong>，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<h3 id="什么是线程安全问题？如何保证线程安全？"><a href="#什么是线程安全问题？如何保证线程安全？" class="headerlink" title="什么是线程安全问题？如何保证线程安全？"></a>什么是线程安全问题？如何保证线程安全？</h3>当<strong>多个线程</strong>同时共享，同一个<strong>全局变量或者静态变量</strong>，做写的操作时，可能会发生数据冲突问题，也就是<strong>线程安全问题</strong>。<h3 id="java的内存模型？"><a href="#java的内存模型？" class="headerlink" title="java的内存模型？"></a>java的内存模型？</h3>java的内存模型规定了所有的变量都<strong>存储在主内存中，每个线程拥有自己的工作内存</strong>，工作内存保存了该线程使用到的变量的主内存拷贝，<strong>线程对变量所有操作，读取，赋值，都必须在工作内存中进行，不能直接写主内存变量</strong>，线程间变量值的传递均需要主内存来完成。<h3 id="volatile关键字有什么作用？volatile一定能保证原子性吗？"><a href="#volatile关键字有什么作用？volatile一定能保证原子性吗？" class="headerlink" title="volatile关键字有什么作用？volatile一定能保证原子性吗？"></a>volatile关键字有什么作用？volatile一定能保证原子性吗？</h3>volatile关键字有什么作用：</li><li>内存<strong>可见性</strong>（Memory Visibility)：所有线程都能看到共享内存的最新状态。</li><li>禁止指令重排。</li></ul><p><code>volatile</code>是Java提供的一种<strong>轻量级的同步机制</strong>，并不能保证原子性。</p><h3 id="什么是指令重排？"><a href="#什么是指令重排？" class="headerlink" title="什么是指令重排？"></a>什么是指令重排？</h3><p>指令重排是指<code>JVM</code>在编译Java代码的时候，或者CPU在执行<code>JVM</code>字节码的时候，对现有的指令顺序进行重新排序。<br>指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。</p><h3 id="synchronized的使用方式？"><a href="#synchronized的使用方式？" class="headerlink" title="synchronized的使用方式？"></a>synchronized的使用方式？</h3><ul><li>修饰实例(非静态方法。被锁对象是类的实例(<code>this</code>)。</li><li>修饰静态方法。被锁对象是类对象。</li><li>同步代码块。有三种形式。<br>①<code>synchronized(this){}</code>，被锁对象是类的实例。<br>②<code>synchronized(XXX.Class)</code>，被锁对象是类对象。<br>③<code>synchronized(new Object())</code>，被锁对象是实例对象<code>object</code>。<h3 id="Lock锁的使用方式？"><a href="#Lock锁的使用方式？" class="headerlink" title="Lock锁的使用方式？"></a>Lock锁的使用方式？</h3></li></ul><p>1.获取锁。2.上锁。3.释放锁。<br>注意点：释放锁最好放在<code>finally{}</code>代码块中，保证能执行释放锁。</p><h3 id="什么是乐观锁、什么是悲观锁？"><a href="#什么是乐观锁、什么是悲观锁？" class="headerlink" title="什么是乐观锁、什么是悲观锁？"></a>什么是乐观锁、什么是悲观锁？</h3><ul><li><strong>悲观锁</strong>：它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。具有强烈的独占和排他特性。</li><li><strong>乐观锁</strong>：乐观锁认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的重提与否进行检测，如果发现冲突了，程序自动去重试。相对于悲观锁，在高并发的场景下有更好的性能表现，通常用”版本号”实现。<h3 id="synchronized与Lock锁的区别？"><a href="#synchronized与Lock锁的区别？" class="headerlink" title="synchronized与Lock锁的区别？"></a>synchronized与Lock锁的区别？</h3></li><li><code>synchronized</code>是java内置关键字，在<code>jvm</code>层面。<code>Lock</code>是个java类。</li><li><code>synchronized</code>无法判断是否获取锁的状态。<code>Lock</code>可以判断是否获取到锁。</li><li><code>synchronized</code>会自动释放锁。<code>Lock</code>锁需要在<code>finally{}</code>代码块中手工释放锁。</li><li><code>synchronized</code>的锁可重入、不可中断、非公平。而<code>Lock</code>锁可重入、可判断、可公平（两者皆可）。<h3 id="有哪些常用的线程安全的集合？"><a href="#有哪些常用的线程安全的集合？" class="headerlink" title="有哪些常用的线程安全的集合？"></a>有哪些常用的线程安全的集合？</h3><code>ConcurrentHashMap</code>、<code>Vector</code>、<code>Hashtable</code>、<code>Stack</code>。还可以使用<code>Collections包装方法</code>获得线程安全的集合。<h3 id="CAS是什么，有什么问题，如何解决？"><a href="#CAS是什么，有什么问题，如何解决？" class="headerlink" title="CAS是什么，有什么问题，如何解决？"></a>CAS是什么，有什么问题，如何解决？</h3><code>CAS</code>是<code>compare and swap</code>的缩写，意思是比较与交换。<code>CAS</code>是乐观锁的一种实现。CAS操作包含三个操作数—内存位置的值（V）、预期原值（A）和新值（B）。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。</li></ul><p><code>CAS</code>有以下缺点：</p><ul><li>ABA问题： 线程C、D。线程D将A修改为B后又修改为A，此时C线程以为A没有改变过。这个问题通常可以使用版本号来解决。</li><li>CPU开销过大。在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很到的压力。</li><li><code>CAS</code>机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用<code>synchronized</code>了。<h3 id="什么是ThreadLocal？"><a href="#什么是ThreadLocal？" class="headerlink" title="什么是ThreadLocal？"></a>什么是ThreadLocal？</h3>这个类提供了线程局部变量也称为线程本地变量，它为变量在每个线程中创建了一个副本，通过这样的方式做到变量在线程间隔离且在方法间共享的场景。<h3 id="ThreadLocal是如何保证线程安全的？"><a href="#ThreadLocal是如何保证线程安全的？" class="headerlink" title="ThreadLocal是如何保证线程安全的？"></a>ThreadLocal是如何保证线程安全的？</h3><code>ThreadLocal</code>存储的值不是线程共享的，而是属于线程的。内部会维护一个<code>ThreadLocalMap</code>，key是当前线程的<code>ThreadLocal</code>，value是存储的值。换句话说，每个线程都有自己的值，当然不会出现线程安全问题了。</li></ul><p>源码如下：</p><pre><code class="java">    public void set(T value) {        //获取当前线程        Thread t = Thread.currentThread();        //通过当前线程获取到ThreadLocalMap        ThreadLocalMap map = getMap(t);        if (map != null)            //key是this，value是需要存储的值            map.set(this, value);        else            //创建一个map            createMap(t, value);    }</code></pre><h1 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h1><h3 id="什么是JVM内存模型？"><a href="#什么是JVM内存模型？" class="headerlink" title="什么是JVM内存模型？"></a>什么是JVM内存模型？</h3><p>Java内存模型（Java Memory Model，简称为<strong>JMM</strong>)，是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p>根据java虚拟机规范，JVM内存共分为<strong>虚拟机栈，堆，方法区，程序计数器，本地方法栈</strong>五个部分。</p><h3 id="栈内存溢出-StackOverflowError-的常见原因有哪些？"><a href="#栈内存溢出-StackOverflowError-的常见原因有哪些？" class="headerlink" title="栈内存溢出(StackOverflowError)的常见原因有哪些？"></a>栈内存溢出(StackOverflowError)的常见原因有哪些？</h3><p>栈溢出原因就是方法执行时创建的栈帧超过了栈的深度。最有可能的就是<strong>方法递归调用</strong>产生这种结果。</p><h3 id="堆内存溢出-OOM-的常见原因有哪些？"><a href="#堆内存溢出-OOM-的常见原因有哪些？" class="headerlink" title="堆内存溢出(OOM)的常见原因有哪些？"></a>堆内存溢出(OOM)的常见原因有哪些？</h3><ul><li><code>OutOfMemoryError: Java heap space</code>。在创建新的对象时, 堆内存中的空间不足以存放新创建的对象时发生。产生原因：程序中出现了死循环，不断创建对象；程序占用内存太多，<strong>超过了JVM堆设置的最大值</strong>。</li><li><code>OutOfMemoryError: unable to create new native thread</code>。产生原因：系统内存耗尽，无法为新线程分配内存；<strong>创建线程数超过了操作系统的限制</strong>。</li><li><code>OutOfMemoryError: PermGen space</code>。永久代溢出，即方法区溢出了，一般<strong>出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况</strong>，因为上述情况会产生大量的Class信息存储于方法区。</li><li><code>OutOfMemoryError：GC overhead limit exceeded</code>。<strong>超过98%的时间都在用来做GC并且回收了不到2%的堆内存</strong>。连续多次的GC，都回收了不到2%的极端情况下才会抛出。</li></ul><h3 id="JVM参数调优有哪些重要的参数？分别有什么作用？"><a href="#JVM参数调优有哪些重要的参数？分别有什么作用？" class="headerlink" title="JVM参数调优有哪些重要的参数？分别有什么作用？"></a>JVM参数调优有哪些重要的参数？分别有什么作用？</h3><ul><li>-Xms  初始堆内存大小。</li><li>-Xmx  最大堆内存大小。</li><li>-Xss  每个线程的栈大小。</li><li>-XX:+PrintGC  每次GC时打印相关信息。</li><li>-XX:Newratio  设置年轻代和老年代的比例，比如值为2，则老年代是年轻代的2倍。</li><li>-XX:Newsize  设置年轻代的初始值大小。</li><li>-XX:Maxnewsize  设置年轻代的最大值大小。</li></ul><h3 id="GC垃圾回收机制，有哪些垃圾回收算法？"><a href="#GC垃圾回收机制，有哪些垃圾回收算法？" class="headerlink" title="GC垃圾回收机制，有哪些垃圾回收算法？"></a>GC垃圾回收机制，有哪些垃圾回收算法？</h3><p>标记-清除算法、复制算法、标记整理算法、分代收集算法。</p><h3 id="JVM如何判断对象是否可以回收？"><a href="#JVM如何判断对象是否可以回收？" class="headerlink" title="JVM如何判断对象是否可以回收？"></a>JVM如何判断对象是否可以回收？</h3><p>会使用可达性分析算法进行判断，原理是从一系列被称为<code>GC ROOT</code>的对象开始，向下搜索，搜索走过的路径称为引用链，当一个对象到<code>GC ROOT</code>之间没有引用链，说明这个对象不可用，那么就会被GC回收。</p><h3 id="什么是强引用、软引用、弱引用、虚引用？"><a href="#什么是强引用、软引用、弱引用、虚引用？" class="headerlink" title="什么是强引用、软引用、弱引用、虚引用？"></a>什么是强引用、软引用、弱引用、虚引用？</h3><p>强引用。一般<code>new</code>出来的对象都是强引用。如果一个对象具有强引用，<code>GC</code>绝不会回收它；当内存空间不足，JVM宁愿抛出<code>OutOfMemoryError</code>错误。</p><pre><code class="java">//强引用Object obj = new Object();</code></pre><p>软引用。如果一个对象只具有软引用。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p><pre><code class="java">//软引用SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(new Object());</code></pre><p>弱引用。如果一个对象具有弱引用，在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存。</p><pre><code class="java">//弱引用WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(new Object());</code></pre><p>虚引用。如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收。</p><pre><code class="java">//虚引用PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(new Object(), new ReferenceQueue&lt;&gt;());</code></pre><h3 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h3><p>Java类加载器是Java运行时环境的一部分，负责动态加载Java类到JVM的内存空间中。</p><h3 id="什么是双亲委派机制？"><a href="#什么是双亲委派机制？" class="headerlink" title="什么是双亲委派机制？"></a>什么是双亲委派机制？</h3><p>双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。</p><h3 id="类的生命周期？"><a href="#类的生命周期？" class="headerlink" title="类的生命周期？"></a>类的生命周期？</h3><p><strong>加载、验证、准备、解析、初始化、使用、卸载</strong>。</p><p>有些资料会把(验证、准备、解析)归纳为连接，于是就变成：<strong>加载、连接、初始化、使用、卸载</strong>。</p><h1 id="设计模式相关"><a href="#设计模式相关" class="headerlink" title="设计模式相关"></a>设计模式相关</h1><h3 id="如何实现单例模式？"><a href="#如何实现单例模式？" class="headerlink" title="如何实现单例模式？"></a>如何实现单例模式？</h3><ul><li>饿汉式单例模式。定义一个静态成员变量，把构造器私有化，只对外暴露一个获取实例的方法。<pre><code class="java">public class SingLeton {  //立即加载  private static SingLeton singLeton = new SingLeton();  //私有化构造器  private SingLeton(){}  //对外暴露获取实例的方法  public static SingLeton getSingLeton(){      return singLeton;  }}</code></pre></li><li>懒汉式单例模式。非线程安全。基本和上面饿汉式实现方式类似，只是在获取时再判断是否创建实例，但是会有线程安全问题。<pre><code class="java">public class SingLeton {  //立即加载  private static SingLeton singLeton;  //私有化构造器  private SingLeton() {  }  //对外暴露获取实例的方法  public static SingLeton getSingLeton() {      if (singLeton == null) {          singLeton = new SingLeton();      }      return singLeton;  }}</code></pre></li><li>使用静态内部类实现<pre><code class="java">public class SingLeton {  //私有化构造器  private SingLeton() {}  //对外暴露获取实例的方法  public static SingLeton getSingLeton() {      return SingLetonHolder.SINGLETON;  }  //私有静态内部类  private static class SingLetonHolder {      private static final SingLeton SINGLETON = new SingLeton();  }}</code></pre></li><li>使用枚举实现<pre><code class="java">public enum SingLeton {  SINGLETON;}</code></pre></li></ul><h3 id="如何实现线程安全的单例模式？"><a href="#如何实现线程安全的单例模式？" class="headerlink" title="如何实现线程安全的单例模式？"></a>如何实现线程安全的单例模式？</h3><p><strong>饿汉式实现、枚举、静态内部类</strong>都是<strong>线程安全</strong>的实现方式。<br>还可以使用<strong>双检锁</strong>的懒汉式方式实现：</p><pre><code class="java">public class SingLeton {    private static volatile SingLeton singLeton;    //私有化构造器    private SingLeton() {}    //对外暴露获取实例的方法    public static SingLeton getSingLeton() {        if (singLeton == null) {            synchronized (SingLeton.class) {                if (singLeton == null) {                    singLeton = new SingLeton();                }            }        }        return singLeton;    }}</code></pre><h3 id="为什么要使用工厂模式创建对象？"><a href="#为什么要使用工厂模式创建对象？" class="headerlink" title="为什么要使用工厂模式创建对象？"></a>为什么要使用工厂模式创建对象？</h3><ul><li><strong>解耦</strong>。把对象的创建和使用的过程分开。</li><li><strong>可以降低代码重复</strong>。如果创建B过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。</li><li><strong>减少了使用者因为创建逻辑导致的错误</strong>。因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可。</li><li><strong>提高了代码的可维护性</strong>。如果发生业务逻辑变化，不需要找到所有需要创建对象的地方去逐个修正，只需要在工厂里修改即可。</li></ul><h3 id="在java中，实现代理模式有哪几种方式？"><a href="#在java中，实现代理模式有哪几种方式？" class="headerlink" title="在java中，实现代理模式有哪几种方式？"></a>在java中，实现代理模式有哪几种方式？</h3><ul><li>静态代理。</li><li>JDK动态代理。</li><li>CGlib动态代理。</li></ul><h3 id="JDK动态代理和CGlib动态代理的区别？"><a href="#JDK动态代理和CGlib动态代理的区别？" class="headerlink" title="JDK动态代理和CGlib动态代理的区别？"></a>JDK动态代理和CGlib动态代理的区别？</h3><p> （1）<code>JDK动态代理</code>只能对实现了接口的类生成代理，而不能针对类。<br> （2）<code>CGLIB</code>是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。<br>   因为是继承，所以该类或方法不能声明成<code>final</code>。</p><h3 id="策略模式的使用场景？"><a href="#策略模式的使用场景？" class="headerlink" title="策略模式的使用场景？"></a>策略模式的使用场景？</h3><ul><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时<strong>动态选择具体要执行的行为</strong>。</li><li>需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</li><li>对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</li></ul><h3 id="装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？"><a href="#装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？" class="headerlink" title="装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？"></a>装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？</h3><p>使用场景：</p><ul><li>扩展一个类的功能。<ul><li>动态增加功能，动态撤销。</li></ul></li></ul><p>java中经典的例子就是I/O流。具体分析过程可以参考我写的这篇文章：<a href="https://blog.csdn.net/yehongzhi1994/article/details/106065136" target="_blank" rel="noopener">装饰者模式与IO流的应用</a>。</p><h1 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h1><h3 id="有哪些经典的排序算法？"><a href="#有哪些经典的排序算法？" class="headerlink" title="有哪些经典的排序算法？"></a>有哪些经典的排序算法？</h3><p>插入排序、冒泡排序、归并排序、快速排序、堆排序、桶排序、基数排序等等。</p><h3 id="冒泡排序的时间复杂度和空间复杂度？"><a href="#冒泡排序的时间复杂度和空间复杂度？" class="headerlink" title="冒泡排序的时间复杂度和空间复杂度？"></a>冒泡排序的时间复杂度和空间复杂度？</h3><p>平均的时间复杂度是<code>O(n^2)</code>，最好的情况是<code>O(n)</code>，最坏的情况是<code>O(n^2)</code>。空间复杂度是<code>O(1)</code>。</p><h3 id="哪一种排序算法的时间复杂度比较稳定？"><a href="#哪一种排序算法的时间复杂度比较稳定？" class="headerlink" title="哪一种排序算法的时间复杂度比较稳定？"></a>哪一种排序算法的时间复杂度比较稳定？</h3><p>归并排序。最好和最坏的情况下，时间复杂度都是<code>O(n*log n)</code>。</p><h3 id="如何实现二分查找？二分查找的时间复杂度？-笔试常见"><a href="#如何实现二分查找？二分查找的时间复杂度？-笔试常见" class="headerlink" title="如何实现二分查找？二分查找的时间复杂度？(笔试常见)"></a>如何实现二分查找？二分查找的时间复杂度？(笔试常见)</h3><p>有两种方式，迭代法和递归法。具体实现代码，可以参考我写的这篇《<a href="https://blog.csdn.net/yehongzhi1994/article/details/105835380" target="_blank" rel="noopener">手把手教你实现二分查找</a>》。时间复杂度是<code>O(log n)</code>。</p><h3 id="跳楼梯的问题。-笔试常见"><a href="#跳楼梯的问题。-笔试常见" class="headerlink" title="跳楼梯的问题。(笔试常见)"></a>跳楼梯的问题。(笔试常见)</h3><p>这是一个经典的斐波那契数列问题。力扣题库第70题。可以看看大佬们的题解。这是我的题解，使用了<code>Map</code>作为缓存，减少一些不必要的递归，效率还不错。执行时间：1 ms。当然你去掉那个<code>Map</code>也是完全没错的，只是运行时间会久一些，可能会超出<code>leetcode</code>的时间限制，没法通过。<br><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/guan-fang-jie-fa-yi-chao-shi-cai-yong-maphuan-cun-/" target="_blank" rel="noopener">我的题解链接</a></p><pre><code class="java">/** * 题目描述： * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？*/class Solution {    private Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    public int climbStairs(int n) {        if (n == 1) {            map.put(n, 1);            return 1;        }        if (n == 2) {            map.put(n, 2);            return 2;        }        if (map.get(n) != null) {            return map.get(n);        } else {            int num = climbStairs(n - 1) + climbStairs(n - 2);            map.put(n, num);            return num;        }    }}</code></pre><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong></p><p><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>责任链模式</title>
    <link href="/2020/06/06/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/06/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>各位<strong>java技术爱好者</strong>，我们又见面了！<br>之前我在面试的时候遇到这个问题，当时答不上来。这件事就一直在我心里耿耿于怀。相信很多人面试完都有这种体验，哈哈~<br>不过今日不同往日了，现在我已经搞懂了，其实并不是很难。</p><a id="more"></a><p><img src="https://static.lovebilibili.com/20200606_2211_01.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="开始搞事情"><a href="#开始搞事情" class="headerlink" title="开始搞事情"></a>开始搞事情</h1><p>要学习一种技术，当然要搞清楚能解决什么问题，这是最关键的，否则就像买了一个开瓶器，还是用嘴咬开啤酒瓶盖一样(比喻很巧妙)。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先我们用<code>Request</code>对象，表示一个请求。</p><pre><code class="java">public class Request {    //请求数据    private String data;    public String getData() {        return data;    }    public void setData(String data) {        this.data = data;    }}</code></pre><p>假设<code>data</code>中有很多数据，我们要过滤掉一些关键字，比如<code>水果</code>、<code>蔬菜</code>。<br>如果不用设计模式，直接用<code>if</code>解决，就是这样写：</p><pre><code class="java">public static void main(String[] args) throws Exception {        //创建请求体        String data = &quot;肉蛋葱鸡水果蔬菜千层饼雅俗共赏第五层的马老师&quot;;        Request request = new Request();        request.setData(data);        String requestData = request.getData();        //如果包含水果关键字        if (requestData.contains(&quot;水果&quot;)) {            //过滤水果关键字            requestData = filterByWord(requestData, &quot;水果&quot;);        }        //如果包含蔬菜关键字        if (requestData.contains(&quot;蔬菜&quot;)) {            //过滤蔬菜关键字            requestData = filterByWord(requestData, &quot;蔬菜&quot;);        }        request.setData(requestData);        System.out.println(requestData);//肉蛋葱鸡千层饼雅俗共赏第五层的马老师    }    //过滤关键字的方法    private static String filterByWord(String data, String word) {        StringBuilder sb = new StringBuilder(data);        while (true) {            int index = sb.indexOf(word);            //如果不等于-1，搜索到关键字            if (index != -1) {                for (int i = 0; i &lt; word.length(); i++) {                    //关键字有多长就删多少次，比如水果，在index位置上删两次                    sb.deleteCharAt(index);                }            } else {                //等于-1，没有关键字，跳出循环                break;            }        }        return sb.toString();    }}    </code></pre><p>这样的代码在项目中不要太多，遇事不决来个<code>if</code>，不行就再来一个。一般这种程序员就只看到了<strong>第一层</strong>。<br>问题：<br>1.如果这时候要增加多一些关键字呢，怎么处理？在原来的代码里继续加<code>if</code>的话，那这个方法就越写越长。而且破坏了<code>开闭原则</code>。<br>2.如果要调换顺序呢。难道要剪切复制代码？<br><strong>所以一个好的程序员，实现功能只是基本要求，重要是代码要有好的维护性和扩展性。</strong><br><img src="https://static.lovebilibili.com/20200606_2211_00.png" srcset="/img/loading.gif" alt=""></p><h2 id="怎么优化呢？"><a href="#怎么优化呢？" class="headerlink" title="怎么优化呢？"></a>怎么优化呢？</h2><p>我们可以这样想，把每个过滤关键字的方法<strong>抽成一个类</strong>，然后定义一个<strong>过滤关键字的方法</strong>，因为有很多个类似职责的类，所以<strong>定义一个接口</strong>，<strong>公共的方法</strong>可以定义在接口。<br>第一步：定义<strong>过滤器接口</strong></p><pre><code class="java">public interface Filter {    //接口方法    String doFilter(String data, FilterChain filterChain);    //过滤关键字的方法    default String filterByWord(String data, String word) {        StringBuilder sb = new StringBuilder(data);        while (true) {            int index = sb.indexOf(word);            if (index != -1) {                for (int i = 0; i &lt; word.length(); i++) {                    //关键字有几个字，就删几次。比如水果就在index删两次即可                    sb.deleteCharAt(index);                }            } else {                //如果找不到关键字，就跳出循环                break;            }        }        return sb.toString();    }}</code></pre><p>第二步：定义<strong>水果关键字过滤器</strong></p><pre><code class="java">public class FruitsFilter implements Filter {    @Override    public String doFilter(String data, FilterChain filterChain) {        //过滤水果关键字        data = filterByWord(data, &quot;水果&quot;);        //拿到控制器，继续调用下一个过滤器        return filterChain.preHandleRequest(data);    }}</code></pre><p>第三部：定义<strong>蔬菜关键字过滤器</strong></p><pre><code class="java">public class VegetablesFilter implements Filter {    @Override    public String doFilter(String data, FilterChain filterChain) {        //过滤蔬菜关键字        data = filterByWord(data, &quot;蔬菜&quot;);        //拿到控制器，继续调用下一个过滤器        return filterChain.preHandleRequest(data);    }}</code></pre><p>第四步：定义一个<strong>过滤器的控制器</strong></p><pre><code class="java">public class FilterChain {    //使用List装过滤器，List是有序的    private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();    //过滤器的下标，从0开始，每次调用preHandleRequest方法就+1    private int index = 0;    //添加过滤器    public void addFilter(Filter filter) {        filters.add(filter);    }    //调用过滤器的doFilter()方法，并把指针+1指向下一个过滤器    public String preHandleRequest(String data) {        //如果指针大于集合的size，则return，不再往下调用，相当于递归的终结条件        if (index == filters.size()) {            return data;        }        Filter filter = filters.get(index);        //下标指针+1        index++;        //精髓在这个this，把自己再当做参数传进去，实现了递归        return filter.doFilter(data, this);    }}</code></pre><p>这样就大功告成了，最后我们创建一个Main方法试试吧~</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //创建请求体        String data = &quot;肉蛋葱鸡水果蔬菜千层饼雅俗共赏第五层的马老师&quot;;        Request request = new Request();        request.setData(data);        //创建FilterChain执行链        FilterChain filterChain = new FilterChain();        //添加过滤器        filterChain.addFilter(new FruitsFilter());        filterChain.addFilter(new VegetablesFilter());        //执行预处理        String s = filterChain.preHandleRequest(request.getData());        request.setData(s);        //打印结果，验证        System.out.println(request.getData());//下面是打印结果，结果正确        //肉蛋葱鸡千层饼雅俗共赏第五层的马老师    }}</code></pre><p>这就是责任链模式！下面用一张图来看看调用链的执行顺序。其实没有想得那么难吧。你学会了吗？<br><img src="https://img-blog.csdnimg.cn/20200606120835391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="责任链模式的优点"><a href="#责任链模式的优点" class="headerlink" title="责任链模式的优点"></a>责任链模式的优点</h2><p>我们回过头去看，为什么这么绕呢，直接<code>if</code>不香吗？<br>还真不香，在用<code>if</code>的时候，提到的两个问题，破坏<code>开闭原则</code>，还有调用顺序的问题，用责任链模式都得到解决了。<br><strong>1.如果要加一些过滤的关键字，只需要加一个过滤的类，然后再添加到过滤器的集合中，不需要对原来的代码进行侵入式的开发。符合<code>开闭原则</code>。<br>2.执行顺序要变更的话，也不需要侵入式的改代码，只需要改一下添加过滤器的顺序。在<code>Servlet</code>中，过滤器的顺序就是按<code>xml</code>文件定义的顺序。在<code>SpringMVC</code>则是按注册的顺序。这就非常易于扩展。</strong><br>要多为下一个程序员着想，我为人人，人人为我，世界才会变得更美好！哈哈~~</p><h1 id="SpringMVC的责任链模式"><a href="#SpringMVC的责任链模式" class="headerlink" title="SpringMVC的责任链模式"></a>SpringMVC的责任链模式</h1><p>以上就是一个简单的<code>demo</code>，重要的是学习这种思想。那么我们看实战中是怎么应用的，所谓知其然知其所以然，学习<strong>忌讳浅尝辄止</strong>，趁热打铁，我们看看框架中怎么应用责任链模式。</p><h2 id="SpringMVC拦截器的使用"><a href="#SpringMVC拦截器的使用" class="headerlink" title="SpringMVC拦截器的使用"></a>SpringMVC拦截器的使用</h2><p>很简单，实现<code>HandlerInterceptor</code>接口，接口有三个方法需要重写。</p><ul><li>preHandle()：在业务处理器处理请求之前被调用。预处理。</li><li>postHandle()：在业务处理器处理请求执行完成后，生成视图之前执行。后处理。</li><li>afterCompletion()：在<code>DispatcherServlet</code>完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）；</li></ul><p>我们定义一个关键字过滤器<code>WordInterceptor</code>：</p><pre><code class="java">//定义一个关键字拦截器public class WordInterceptor implements HandlerInterceptor {    //在执行controller定义的请求方法前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;执行WordInterceptor的preHandle()&quot;);        return true;    }    //controller定义的请求方法执行后，但还没渲染页面前，执行    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;执行WordInterceptor的postHandle()&quot;);    }    //在渲染页面完毕后执行，或者preHandle()返回fasle时执行    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(&quot;执行WordInterceptor的afterCompletion()&quot;);    }}</code></pre><p>如法炮制，再定义一个登录拦截器</p><pre><code class="java">public class LoginInterceptor implements HandlerInterceptor {    //在执行controller定义的请求方法前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;执行LoginInterceptor的preHandle()&quot;);        return true;    }    //controller定义的请求方法执行后，但还没渲染页面前，执行    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;执行LoginInterceptor的postHandle()&quot;);    }    //在渲染页面完毕后执行，或者preHandle()返回fasle时执行    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(&quot;执行LoginInterceptor的afterCompletion()&quot;);    }}</code></pre><p>然后再注册到拦截器的集合中。</p><pre><code class="java">@Componentpublic class WebInterceptorConfig implements WebMvcConfigurer {    @Override    public void addInterceptors(InterceptorRegistry registry) {        //先注册关键字拦截器，拦截所有请求        registry.addInterceptor(new WordInterceptor()).addPathPatterns(&quot;/**&quot;);        //再注册登录拦截器，拦截所有请求        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;);    }}</code></pre><p>然后启动项目，发起一个请求，我们就可以在控制台看到调用的顺序了。注意观察：</p><pre><code class="java">//按注册顺序执行preHandle()方法执行WordInterceptor的preHandle()执行LoginInterceptor的preHandle()//按注册顺序，逆序执行postHandle()方法执行LoginInterceptor的postHandle()执行WordInterceptor的postHandle()//从最后一个preHandle()执行的类，逆序执行afterCompletion()执行LoginInterceptor的afterCompletion()执行WordInterceptor的afterCompletion()</code></pre><p>执行的流程图就是这样：<br><img src="https://static.lovebilibili.com/SpringMVC_liuchengtu.png" srcset="/img/loading.gif" alt=""><br>原理是什么呢？我们不妨走进源码去分析。</p><h2 id="SpringMVC拦截器源码分析"><a href="#SpringMVC拦截器源码分析" class="headerlink" title="SpringMVC拦截器源码分析"></a>SpringMVC拦截器源码分析</h2><p>还是要看<code>DispatcherServlet</code>的<code>doDispatch()</code>方法</p><h3 id="doDispatch-调用顺序"><a href="#doDispatch-调用顺序" class="headerlink" title="doDispatch()调用顺序"></a><code>doDispatch()</code>调用顺序</h3><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        //请求对象        HttpServletRequest processedRequest = request;        //定义一个调用链        HandlerExecutionChain mappedHandler = null;        boolean multipartRequestParsed = false;        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                //省略                // 获取调用链                mappedHandler = getHandler(processedRequest);                if (mappedHandler == null) {                    noHandlerFound(processedRequest, response);                    return;                }                //获取对应的适配器                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());                //调用拦截器的preHandle()前处理方法                if (!mappedHandler.applyPreHandle(processedRequest, response)) {                    //如果上面返回fasle,取反就是true，进来这里就return，结束了                    return;                }                //调用Controller的RequestMapping对应的方法                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                //调用拦截器的postHandle()后处理方法                mappedHandler.applyPostHandle(processedRequest, response, mv);                //省略            }catch (Exception ex) {            //如果出现异常还是会执行triggerAfterCompletion()方法            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);        }        catch (Throwable err) {            //如果出现异常还是会执行triggerAfterCompletion()方法            triggerAfterCompletion(processedRequest, response, mappedHandler,                    new NestedServletException(&quot;Handler processing failed&quot;, err));        }        finally {            //省略        }    }</code></pre><p>从上面源码中明显可以知道，拦截器接口的执行顺序:<br><code>applyPreHandle()</code>→<code>handle()</code>→<code>applyPostHandle()</code>→<code>triggerAfterCompletion()</code><br>或者<br><code>applyPreHandle()</code>→<code>triggerAfterCompletion()</code></p><h3 id="关键在于HandlerExecutionChain接口"><a href="#关键在于HandlerExecutionChain接口" class="headerlink" title="关键在于HandlerExecutionChain接口"></a>关键在于<code>HandlerExecutionChain</code>接口</h3><p>其实上面这些方法除了<code>handle()</code>定义在适配器中，其他都是这个接口的。<code>handle()</code>方法我已经在上一篇《适配器模式与SpringMV》讲过了。下面我们看<code>HandlerExecutionChain</code>接口。</p><pre><code class="java">public class HandlerExecutionChain {    //省略    @Nullable    private HandlerInterceptor[] interceptors;    @Nullable//拦截器集合    private List&lt;HandlerInterceptor&gt; interceptorList;    //指针,用来记录applyPreHandle()方法执行到哪一个拦截器    private int interceptorIndex = -1;}</code></pre><p>这不就跟我们的<code>demo</code>类似吗？定义了一个集合封装拦截器，定义一个指针遍历集合。</p><h4 id="applyPreHandle-方法"><a href="#applyPreHandle-方法" class="headerlink" title="applyPreHandle()方法"></a>applyPreHandle()方法</h4><p>那么前置方法<code>applyPreHandle()</code>是怎么样执行的呢？</p><pre><code class="java">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {        //获取拦截器        HandlerInterceptor[] interceptors = getInterceptors();        //判断不为空        if (!ObjectUtils.isEmpty(interceptors)) {            //按顺序遍历，所以拦截器接口定义的preHandle()是按顺序执行的            for (int i = 0; i &lt; interceptors.length; i++) {                //按顺序获取注册的拦截器                HandlerInterceptor interceptor = interceptors[i];                //执行拦截器的preHandle()方法                if (!interceptor.preHandle(request, response, this.handler)) {                    //如果preHandle()返回false,那就调用triggerAfterCompletion()方法                    triggerAfterCompletion(request, response, null);                    //返回false，结束调用                    return false;                }                //如果preHandle()返回true，继续执行                //把下标索引记录到成员变量的指针中，用于后面执行triggerAfterCompletion()方法                this.interceptorIndex = i;            }        }        return true;    }</code></pre><h4 id="applyPostHandle-方法"><a href="#applyPostHandle-方法" class="headerlink" title="applyPostHandle()方法"></a>applyPostHandle()方法</h4><p>然后下一步执行的<code>applyPostHandle()</code>方法，又是怎么执行的呢？</p><pre><code class="java">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)            throws Exception {        HandlerInterceptor[] interceptors = getInterceptors();        if (!ObjectUtils.isEmpty(interceptors)) {            //倒序遍历，所以postHandle()方法是从最后一个拦截器开始执行的            for (int i = interceptors.length - 1; i &gt;= 0; i--) {                HandlerInterceptor interceptor = interceptors[i];                //postHandle()能获取到ModelAndView对象，拦截器可以对mv对象进行后处理                interceptor.postHandle(request, response, this.handler, mv);            }        }    }</code></pre><h4 id="triggerAfterCompletion-方法"><a href="#triggerAfterCompletion-方法" class="headerlink" title="triggerAfterCompletion()方法"></a>triggerAfterCompletion()方法</h4><pre><code class="java">void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex)            throws Exception {        HandlerInterceptor[] interceptors = getInterceptors();        if (!ObjectUtils.isEmpty(interceptors)) {            //从成员变量interceptorIndex记录的指针值，开始倒序遍历            for (int i = this.interceptorIndex; i &gt;= 0; i--) {                HandlerInterceptor interceptor = interceptors[i];                try {                    interceptor.afterCompletion(request, response, this.handler, ex);                }                catch (Throwable ex2) {                    logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);                }            }        }    }</code></pre><h3 id="拦截器集合-interceptorList如何组装"><a href="#拦截器集合-interceptorList如何组装" class="headerlink" title="拦截器集合 interceptorList如何组装"></a>拦截器集合 <code>interceptorList</code>如何组装</h3><p>我们都看到上面三个方法都有一个公用的方法<code>getInterceptors()</code>。</p><pre><code class="java">    @Nullable    public HandlerInterceptor[] getInterceptors() {        if (this.interceptors == null &amp;&amp; this.interceptorList != null) {            this.interceptors = this.interceptorList.toArray(new HandlerInterceptor[0]);        }        return this.interceptors;    }</code></pre><p>关键是这个<code>interceptorList</code>是在哪里把拦截器<code>add()</code>进去的呢？<br>其实很简单，经过一路顺藤摸瓜，我们看到<code>AbstractHandlerMapping</code>的<code>getHandlerExecutionChain()</code>方法：</p><pre><code class="java">    protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {        HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?                (HandlerExecutionChain) handler : new HandlerExecutionChain(handler));        String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);        for (HandlerInterceptor interceptor : this.adaptedInterceptors) {            //判断是否继承拦截器父类            if (interceptor instanceof MappedInterceptor) {                MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;                if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) {                    //添加拦截器                    chain.addInterceptor(mappedInterceptor.getInterceptor());                }            }            else {                //添加拦截器                chain.addInterceptor(interceptor);            }        }        //返回调用链        return chain;    }</code></pre><p>那么上面这个方法又在什么时候被调用呢？我们一直往上找调用方。<br>首先是<code>AbstractHandlerMapping</code>的<code>getHandler()</code>方法</p><pre><code class="java">    @Override    @Nullable    public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {        //获取调用链        HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);        //省略        return executionChain;    }</code></pre><p>然后到了<code>DispatcherServlet</code>的<code>getHandler()</code>方法</p><pre><code class="java">    @Nullable    protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {        if (this.handlerMappings != null) {            for (HandlerMapping hm : this.handlerMappings) {                //省略                //获取调用链                HandlerExecutionChain handler = hm.getHandler(request);                if (handler != null) {                    //不为null则返回                    return handler;                }            }        }        return null;    }</code></pre><p>最后回到了<code>DispatcherServlet</code>的<code>doDispatch()</code>方法</p><pre><code class="java">    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                // 获取调用链方法！！！                mappedHandler = getHandler(processedRequest);                //省略                }            }        }    }</code></pre><p>哈哈~~真相大白了！是在<code>doDispatch()</code>方法里，获取调用链<code>getHandler()</code>方法中组装好<code>interceptorList</code>拦截器集合的！</p><h3 id="SpringMVC拦截器执行流程图解"><a href="#SpringMVC拦截器执行流程图解" class="headerlink" title="SpringMVC拦截器执行流程图解"></a>SpringMVC拦截器执行流程图解</h3><p>用张图总结一下，就是这样，我用不同的颜色分步骤从浅到深标记了(<strong>求点赞</strong>)：<br><img src="https://static.lovebilibili.com/SringMVC_tujie.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="最后说多几句"><a href="#最后说多几句" class="headerlink" title="最后说多几句"></a>最后说多几句</h1><p>除了<code>SpringMVC</code>外，其实还有很多框架都使用了责任链模式，比如<code>Servlet</code>的<code>Filter</code>，还有<code>Struts2</code>的<code>Interceptor</code>等等。有兴趣的同学可以去看看源码，其实都大同小异，思想懂了之后，源码看起来就没那么费劲了。</p><p>想第一时间看到我更新的文章，可以微信搜索公众号「<code>java技术爱好者</code>」，<strong>拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！</strong><br><img src="https://static.lovebilibili.com/erweimaguanzhu.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote><blockquote><p>学之，则难者亦易矣。不学，则易者亦难矣。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式与SpringMVC</title>
    <link href="/2020/05/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8ESpringMVC/"/>
    <url>/2020/05/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8ESpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>适配器模式是将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>用生活中的例子就是充电器的转接头或者数据线转接头，也就是两个类不兼容的情况下，通过适配器类来做到兼容。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>我看了网上很多人的博客，关于适配器模式的一些例子，主要有两种，一种叫类适配器，一种叫对象适配器。写完这两个例子后，我有种恍然大悟的感觉！</p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>首先有一个接口是目标接口<code>PayService</code>，目标方法<code>pay()</code>。</p><pre><code class="java">public interface PayService {    String pay(String channel, String amount) throws Exception;}</code></pre><p>然后有一个被适配的类<code>CheckHelper</code>，适配方法<code>checkedPay()</code></p><pre><code class="java">public class CheckHelper {    //检查支付渠道和支付金额    public boolean checkedPay(String channel, String amount) {        try {            //字符串转成数字，如果出现转换异常返回fasle            int mount = Integer.parseInt(amount);            //PayEnum定义了一些支付渠道，比如支付宝、微信、银联等等            List&lt;String&gt; channelList = Arrays.stream(PayEnum.values())                .map(PayEnum::getChannel)                .collect(Collectors.toList());            //包含在支付渠道中，并且金额大于0，返回true，否则返回false            return channelList.contains(channel) &amp;&amp; mount &gt; 0;        } catch (Exception e) {            return false;        }    }}</code></pre><p>需求是要使得在接口<code>PayService</code>调用<code>CheckHelper</code>的<code>checkedPay()</code>方法，现在使用类适配器的方式演示：</p><pre><code class="java">public class PayAdapter extends CheckHelper implements PayService {    @Override    public String pay(String channel, String amount) throws Exception {        boolean checked = super.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>其实就是使用继承的方式来完成，适配器类继承<code>CheckHelper</code>类，然后使用<code>super</code>来调用被适配类</p><p><code>CheckHelper</code>的<code>checkedPay()</code>方法，一目了然了。</p><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>明显使用类适配器的方式不太灵活，因为<code>java</code>是单继承，所以我们可以改成成员变量的方式，也就是对象适配器。代码如下：</p><pre><code class="java">public class PayAdapter implements PayService {    //使用成员变量    private CheckHelper checkHelper = new CheckHelper();    @Override    public String pay(String channel, String amount) throws Exception {        //调用CheckHelper的checkedPay()方法        boolean checked = checkHelper.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>那么肯定有人会说，你这样直接<code>new</code>一个对象不好，可以使用<code>SpringIOC</code>注入，于是又可以写成这样：</p><pre><code class="java">//注册到Spring容器中@Component(&quot;checkHelper&quot;)public class CheckHelper {}</code></pre><pre><code class="java">public class PayAdapter implements PayService {    @Resource(name = &quot;checkHelper&quot;)    private CheckHelper checkHelper;    @Override    public String pay(String channel, String amount) throws Exception {        boolean checked = checkHelper.checkedPay(channel, amount);        if (!checked) {            return &quot;支付失败，支付参数有误&quot;;        }        return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount;    }}</code></pre><p>然后有人可能已经开始察觉了，这不就是平时我们使用的依赖注入吗？没错！所以我开始就说了，写完这两个例子后，我恍然大悟了。原来适配器模式我们一直都在用，只是没认出来罢了。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>那么我们用适配器模式有什么优点呢？为什么要这样写：</p><p>1.解耦，降低了对象与对象之间的耦合性。</p><p>2.增加了类的复用，这点是比较重要的。</p><p>3.灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。这点我待会在下面<code>SpringMVC</code>的应用中详细说明。</p><h2 id="在SpringMVC中的应用"><a href="#在SpringMVC中的应用" class="headerlink" title="在SpringMVC中的应用"></a>在SpringMVC中的应用</h2><p>我们都知道<code>SpringMVC</code>定义一个映射的方式很简单，使用<code>@RequestMapping</code>注解，如下所示：</p><pre><code class="java">@RestControllerpublic class PayController {    @RequestMapping(&quot;/pay&quot;)    public String pay(String channel,String amount)throws Exception{        return &quot;&quot;;    }}</code></pre><p>实际上除了上面这种常用的方式外，还有其他的方式定义：</p><blockquote><p>实现<code>Controller</code>接口</p></blockquote><pre><code class="java">@org.springframework.stereotype.Controller(&quot;/path&quot;)public class TestController implements Controller {    @Override    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {        return null;    }}</code></pre><blockquote><p>实现<code>HttpRequestHandler</code>接口</p></blockquote><pre><code class="java">@Controller(&quot;/httpPath&quot;)public class HttpController implements HttpRequestHandler {    @Override    public void handleRequest(HttpServletRequest request,                              HttpServletResponse response    ) throws ServletException, IOException {        //业务处理，页面跳转，返回响应结果等等    }}</code></pre><blockquote><p>实现<code>Servlet</code>接口</p></blockquote><pre><code class="java">@Controller(&quot;/servletPath&quot;)public class ServletController implements Servlet {    //Servlet生命周期函数    //重写init()方法      //重写getServletConfig()方法    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {        //业务处理    }    //重写getServletInfo()方法    //重写destroy()方法}</code></pre><p>还要配置一个<code>SimpleServletHandlerAdapter</code>适配器的<code>bean</code>，因为默认只加载前面三种适配器，所以这种适配器需要自己手动添加。从这里也可以看出<code>SpringMVC</code>已经不推荐这种创建方式。</p><pre><code class="java">@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter {    @Bean    public SimpleServletHandlerAdapter simpleServletHandlerAdapter() {        return new SimpleServletHandlerAdapter();    }}</code></pre><blockquote><p><code>HandlerFunction</code>接口，关于响应式接口的开发</p></blockquote><p>最后一种是使用<code>HandlerFunction</code>函数式接口，这是<code>Spring5.0</code>后引入的方式，主要用于做响应式接口的开发，这里就不举例子了。后面我会写一篇文章再详述。</p><p><strong>问题：</strong>以上就有五种方式定义<code>Mapping</code>映射，那么<code>SpringMVC</code>是如何去适配的呢？并且具有良好的扩展性和维护性呢？</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先我们把目光放在<code>DispatcherServlet</code>类的<code>doDispatch()</code>方法</p><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        boolean multipartRequestParsed = false;        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                processedRequest = checkMultipart(request);                multipartRequestParsed = (processedRequest != request);                // Determine handler for the current request.                mappedHandler = getHandler(processedRequest);                if (mappedHandler == null) {                    noHandlerFound(processedRequest, response);                    return;                }                //重点： 获取到对应的适配器                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());                //省略...                //重点： 调用HandlerAdapter接口的handle()方法，得到ModelAndView结果                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                //省略...            }            catch (Exception ex) {                //省略...            }            catch (Throwable err) {                //省略..            }        }    }</code></pre><p>先不要慌张，其实学过策略模式你一眼就可以看出来，实际上这里就是运用了类似于策略模式的方式，根据不同的对象获取到对应的适配器，然后执行<code>HandlerAdapter</code>接口的<code>handle()</code>方法得到结果。</p><p>关键是这个<code>getHandlerAdapter()</code>方法，是怎么获取到对应的<code>HandlerAdapter</code>。</p><pre><code class="java">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {        if (this.handlerAdapters != null) {            //这个handlerAdapters有全部的适配器，遍历handlerAdapters集合            for (HandlerAdapter adapter : this.handlerAdapters) {                //如果匹配                if (adapter.supports(handler)) {                    //就返回这个适配器                    return adapter;                }            }        }        throw new ServletException(&quot;No adapter for handler [&quot; + handler +                &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);    }</code></pre><p>那么你看到上面这个<code>this.handlerAdapters</code>肯定会有疑问，<code>handlerAdapters</code>集合里面的适配器是什么时候初始化的？哪里初始化？继续看。</p><p>在<code>DispatcherServlet</code>的<code>initStrategies()</code>方法中有一堆初始化方法。</p><pre><code class="java">protected void initStrategies(ApplicationContext context) {        initMultipartResolver(context);        initLocaleResolver(context);        initThemeResolver(context);        initHandlerMappings(context);        //这个就是初始化适配器的方法，handlerAdapters就是在这里初始化的        initHandlerAdapters(context);        initHandlerExceptionResolvers(context);        initRequestToViewNameTranslator(context);        initViewResolvers(context);        initFlashMapManager(context);    }</code></pre><p>接着我们看<code>initHandlerAdapters()</code>方法</p><pre><code class="java">private void initHandlerAdapters(ApplicationContext context) {        this.handlerAdapters = null;        //省略...        //如果为null，刚开始当然为null，所以加载handlerAdapters集合        if (this.handlerAdapters == null) {            //关键又在于getDefaultStrategies方法            this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);            if (logger.isDebugEnabled()) {                logger.debug(&quot;No HandlerAdapters found in servlet &#39;&quot; + getServletName() + &quot;&#39;: using default&quot;);            }        }    }</code></pre><p>然后我们又去<code>getDefaultStrategies()</code>方法中看你会发现：</p><pre><code class="java">    protected &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) {        String key = strategyInterface.getName();        //defaultStrategies中获取值，key就是HandlerAdapter.class对象        String value = defaultStrategies.getProperty(key);        //省略...    }</code></pre><p>然后重点就在于这个<code>defaultStrategies</code>对象。我们继续看，很快看到了。</p><pre><code class="java">    //DispatcherServlet.properties文件名    private static final String DEFAULT_STRATEGIES_PATH = &quot;DispatcherServlet.properties&quot;;    //Properties对象，全局变量    private static final Properties defaultStrategies;    static {        try {            ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);            //加载DispatcherServlet.properties文件            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);        }        catch (IOException ex) {            throw new IllegalStateException(&quot;Could not load &#39;&quot; + DEFAULT_STRATEGIES_PATH + &quot;&#39;: &quot; + ex.getMessage());        }    }</code></pre><p>所以明显可以看到所有的适配器类都是写在<code>DispatcherServlet.properties</code>文件里了！默认加载这三种适配器。</p><pre><code class="properties">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\    org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</code></pre><h3 id="得到结论："><a href="#得到结论：" class="headerlink" title="得到结论："></a>得到结论：</h3><p>适配器实现类是从<code>DispatcherServlet.properties</code>文件加载到内存中的。</p><h2 id="HandlerAdapter接口"><a href="#HandlerAdapter接口" class="headerlink" title="HandlerAdapter接口"></a>HandlerAdapter接口</h2><p>所以关键在于<code>HandlerAdapter</code>接口，接口信息如下：</p><pre><code class="java">public interface HandlerAdapter {    //子类去实现，用于判断上级接口    boolean supports(Object handler);    //子类实现这个方法，返回响应的结果    @Nullable    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;    //判断是否使用浏览器缓存，返回-1表示不使用浏览器缓存    long getLastModified(HttpServletRequest request, Object handler);}</code></pre><p>学过策略模式的应该很清楚了，上面讲过有5种方式定义<code>Mapping</code>。</p><p>所以应该可以猜测<code>HandlerAdapter</code>接口有五个子类。打开类图：</p><p><img src="https://static.lovebilibili.com/HandlerAdapter.png" srcset="/img/loading.gif" alt=""></p><p>果然是有五个实现的子类分别对应五种方式！</p><p>那么我们找其中一个实现类，比如最简单的<code>SimpleControllerHandlerAdapter</code>，来分析一下：</p><pre><code class="java">public class SimpleControllerHandlerAdapter implements HandlerAdapter {    @Override    //getHandlerAdapter()方法就会调用这个方法判断，然后返回对应的适配器实现类    //这里返回的就是SimpleControllerHandlerAdapter适配器    public boolean supports(Object handler) {        return (handler instanceof Controller);    }    @Override    @Nullable    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception {        //执行Controller接口的handleRequest，也就是mapping映射的方法        return ((Controller) handler).handleRequest(request, response);    }    //判断是否使用浏览器缓存，返回-1表示不使用浏览器缓存    @Override    public long getLastModified(HttpServletRequest request, Object handler) {        if (handler instanceof LastModified) {            return ((LastModified) handler).getLastModified(request);        }        return -1L;    }}</code></pre><p>下面画一张图来总结一下以上的分析过程：</p><p><img src="https://static.lovebilibili.com/adapterProcessPic.png" srcset="/img/loading.gif" alt=""></p><p>这不就像策略模式吗…只能解释为设计模式有很多都比较类似。假设<code>SpringMVC</code>要增加一种定义<code>Mapping</code>的方式，那就很容易了，增加对应的适配器实现类，对原有的代码没有任何的侵入，这就非常符合开闭原则。接下来我们就对适配器进行扩展，自定义一个适配器。</p><h2 id="自定义SpringMVC适配器"><a href="#自定义SpringMVC适配器" class="headerlink" title="自定义SpringMVC适配器"></a>自定义SpringMVC适配器</h2><p>首先要定义一个适配器<code>MyHandlerAdapter</code>，实现<code>HandlerAdapter</code>接口。</p><pre><code class="java">public class MyHandlerAdapter implements HandlerAdapter {    @Override    public boolean supports(Object handler) {        return handler instanceof MyController;    }    @Override    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        return ((MyController) handler).handleRequest(request, response);    }    @Override    public long getLastModified(HttpServletRequest request, Object handler) {        //不使用浏览器缓存，返回-1        return -1;    }}</code></pre><p>接着定义一个<code>MyController</code>接口。</p><pre><code class="java">public interface MyController {    /**     * 处理请求     */    @Nullable    ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;}</code></pre><p>注册适配器到<code>Spring</code>容器中。</p><pre><code class="java">@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter {    //注册自定义的适配器    @Bean    public MyHandlerAdapter myHandlerAdapter() {        return new MyHandlerAdapter();    }}</code></pre><p>最后创建一个<code>MyTestController</code>实现<code>MyController</code>进行测试。</p><pre><code class="java">@Controller(&quot;/myTest&quot;)public class MyTestController implements MyController {    @Override    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {        response.getWriter().println(&quot;MyTestController Test success!!!&quot;);        return null;    }}</code></pre><p>启动项目，然后在浏览器输入访问地址，即可看到。</p><p><img src="https://static.lovebilibili.com/adapter_test.png" srcset="/img/loading.gif" alt=""></p><p>当你理解透彻之后，你就可以这样自定义一个适配器，来加深一下理解，验证之前的分析的正确性。</p><p>沉下心学习，才能跑得更快！</p><p>以上就是适配器模式的学习，更多的java技术分享，就关注<strong>java技术爱好者</strong>吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次高级java面试</title>
    <link href="/2020/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E7%BA%A7java%E9%9D%A2%E8%AF%95/"/>
    <url>/2020/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E7%BA%A7java%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一次高级JAVA开发面试题目"><a href="#记录一次高级JAVA开发面试题目" class="headerlink" title="记录一次高级JAVA开发面试题目"></a>记录一次高级JAVA开发面试题目</h1><p>面试时间大概40多分钟，问了有十几个问题，回忆一下记录下来，总结经验，以供参考。</p><a id="more"></a><p><strong>1、 static关键字的作用，平时开发用在什么地方？</strong><br>答：主要有三种用法。<br>①修饰成员变量，用static修饰的成员变量就成为静态变量，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。<br>②static修饰方法，该方法就被定义为静态方法，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。<br>③用static修饰代码块，该代码块就被定义为静态代码块，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。</p><p><strong>2、static修饰的成员变量和非static修饰的成员变量有什么区别？分别存在什么区域？</strong><br>答：静态成员变量在内存中只会存在一份，是通过类名访问，存在于静态区中。非静态成员变量是随着对象的创建而存在的，可以有多份，通过创建的对象访问，存在于堆内存中。</p><p><strong>3、说一下类初始化的顺序。</strong><br>答：静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。</p><p><strong>4、常用的集合类型有哪些？</strong><br>答：有Map、Set、List是比较常用的。</p><p><strong>5、List常用的实现类有哪些？ArrayList和LinkedList底层实现原理是什么？</strong><br>答：List常用的实现类有ArrayList和LinkedList。ArrayList底层原理是数组+动态扩容机制实现的，LinkedList底层原理是用Node结点形成的链表实现的。</p><p><strong>6、在开发中如何选择使用ArrayList和LinkedList？</strong><br>答：ArrayList是数组实现，所以通过下标访问效率最快，但是缺点是如果增删比较频繁的情况下，需要经常扩容，性能不是很好。LinkedList在增删的情况下，效率较高，但是访问集合中的元素时都需要从第一个元素开始遍历，效率较低。所以如果增删的情况较多的时候，可以使用LinkedList。查询较多时使用ArrayList。</p><p> <strong>7、List集合如果要排序有哪些实现方式？</strong><br>①使用List接口定义的sort()方法。</p><pre><code class="java">list.sort(Comparator.comparingInt(User::getAge));</code></pre><p>②使用Collections的sort()方法，排序的对象需要实现Comparable接口，重写compareTo()方法。</p><pre><code class="java">//实现Comparable接口public class User implements Comparable&lt;User&gt; {    //重写compareTo方法    @Override    public int compareTo(User user) {            return Integer.compare(this.getAge(), user.getAge());    }}</code></pre><p>使用Collections的sort()方法</p><pre><code class="java">Collections.sort(list);//如果不想实现Comparable接口，也可以使用这个方法Collections.sort(list,Comparator.comparingInt(User::getAge));</code></pre><p>③使用Stream流操作的sort()方法，传入一个Comparator接口。</p><pre><code class="java">list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList());</code></pre><p> <strong>8、ArrayList是线程安全的吗？有什么方式可以让ArrayList变成线程安全的？</strong><br>答：不是线程安全的。<br>使用Collections的synchronizedList()方法包装可获得线程安全的ArrayList。</p><pre><code class="java">List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code></pre><p><strong>9、你是怎么在项目中使用redis的？</strong><br>答：这其实是考了“redis常用的应用场景”这个问题。<br>①利用redis读写速度快的特点，可以做热点数据的储存，降低数据库查询的压力。<br>②利用redis键值设置有效期的特性，做一些限时的业务。比如手机验证码。<br>③利用setnx命令的特性，可以实现分布式锁。</p><p><strong>10、使用Redis实现分布式锁的原理是什么？</strong><br>答： 利用setnx命令的特性。使用setnx一个lockKey字符串作为键，当前的时间+上锁时间作为value。如果返回是0，表示已经被上锁了，需要等待锁持有者释放锁；如果返回1，则表示获得了锁。客户端释放锁的话执行del命令删除lockKey对应的键值。</p><p><strong>11、如果使用分布式锁加锁后，由于一些异常的原因没有执行解锁的操作，怎么办？</strong><br>答：一般解锁操作会放在finally代码块中执行。如果有极端情况下没有执行到解锁的操作，可以通过key对应的时间戳判断是否超时，然后使用GETSET命令去进行解锁，通过判断返回的时间戳是否是超时的key对应的时间戳，确认是否成功上锁。</p><p><strong>12、如果加分布式锁的时候，业务操作时间比较长，造成长时间的阻塞，有什么解决方案？</strong><br>答：可以在加锁时启动一个watch dog(看门狗)线程，每隔10秒检查一下，如果客户端还持有锁则加长lockKey的生存时间。或者可以考虑用zookeeper实现的分布式锁，因为zk实现原理是基于事件监听的方式来实现。</p><p><strong>13、MySQL性能优化的策略有哪些？</strong><br>①复杂的多表查询可以拆成多句简单查询。<br>②返回尽量少的列，按需返回，严禁使用select *。<br>③尽量使用索引列做查询条件和排序条件。<br>④使用复合索引要遵循最左匹配原则。</p><p><strong>14、MySQL索引创建的原则是什么？</strong><br>①对于查询频率高的字段，创建索引。<br>②对排序、分组、联合查询频率高的字段创建索引。<br>③如果多个列都需要设置索引，可以考虑创建复合索引。<br>④尽量选择数据量较少的列作为索引。<br>⑤一个表的索引数量不宜过多，会降低查询的效率。</p><p><strong>15、雪花算法是什么原理？</strong><br>答：使用一个 64 bit 的 long 型的数字作为全局唯一 id。是由时间戳、机房id、机器id、序号组成的。结合了UUID的全局唯一的特点，又具有自增有顺序的特点。</p><p><strong>16、为什么雪花算法生成的主键有字符串类型和long类型两种类型？</strong><br>答：因为后端返回给前端一个long类型时，会有可能产生丢失精度的问题，所以会有字符串的类型，弥补这个问题。</p><p><strong>17、谈一谈MySQL锁机制。</strong><br>主要有以下几种锁：<br>表锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>行锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>在MySQL中只有InnoDB存储引擎可以使用行锁。行锁又分为以下两种形式：<br>读锁(共享锁)：当读取一条数据时，会加上读锁，其他事务如果要读取是可以的，如果要修改则要等事务释放才可以。<br>写锁(排他锁)：这个比较简单，当有一个事务要修改数据时，就会给这些行加上写锁。在加锁期间，不允许其他事务加上任何的锁，只有当这个事务释放了，才可以加锁操作。</p><p>在这次面试中，其实也不是特别难，大部分都回答得不错，但是有两个问题不是很好。雪花算法为什么主键生成有两种类型这个问题没有答出来，还有分布式锁长时间阻塞的解决方案没有详细展开讲。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式在实战中的应用</title>
    <link href="/2020/05/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>比如有些人喜欢写文章，但是如果从头到尾原创的话太麻烦了，那么他可以上网去搜索，找一篇写得不错的文章，然后复制下来，做一些修改，最后发布就是自己的文章了。这其实就使用了原型模式的设计模式，创建一个对象过于麻烦的时候，我们只需要创建一次，后面再创建的话只需要对原对象进行克隆即可。</p><h2 id="不使用原型模式的问题"><a href="#不使用原型模式的问题" class="headerlink" title="不使用原型模式的问题"></a>不使用原型模式的问题</h2><p>假设我们有一个用户<code>User</code>的类，类里面有很多字段，当我们创建对象时，就会像这样子：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setAge(18);        user.setJob(&quot;程序员&quot;);        user.setSchool(&quot;家里蹲大学&quot;);        user.setNation(&quot;汉族&quot;);        //0-男 1-女        user.setGender((byte)0);        user.setPhone(&quot;110&quot;);        user.setPoliticalFeatures(&quot;群众&quot;);        user.setEducation(&quot;大学本科&quot;);        //第二个用户，跟第一个用户只有id，name，phone这三个字段不同        User user1 = new User();        user1.setId(2);        user1.setName(&quot;李四&quot;);        user1.setAge(18);        user1.setJob(&quot;程序员&quot;);        user1.setSchool(&quot;家里蹲大学&quot;);        user1.setNation(&quot;汉族&quot;);        //0-男 1-女        user1.setGender((byte)0);        user1.setPhone(&quot;111&quot;);        user1.setPoliticalFeatures(&quot;群众&quot;);        user1.setEducation(&quot;大学本科&quot;);    }}</code></pre><p>不难看出上面的代码有以下问题：</p><p>1.<code>user</code>对象有10个字段，明显在创建第二个<code>user</code>对象的时候有很多重复的设值的操作。在实际项目中，肯定还不止设置10个字段，那么就会显得很难看。</p><p>2.创建对象如果消耗资源很多的话，这样多次去创建设值肯定会造成资源浪费。</p><p>对于以上的问题，我们可以使用原型模式进行优化。</p><h2 id="使用Cloneable接口优化"><a href="#使用Cloneable接口优化" class="headerlink" title="使用Cloneable接口优化"></a>使用Cloneable接口优化</h2><p><code>java</code>提供了一个<code>Cloneable</code>接口，可以实现克隆对象的用途，怎么实现，请看以下代码：</p><pre><code class="java">//实现Cloneable接口public class User implements Cloneable {    //省略了字段    //省略了字段的Get、Set方法    //重写clone()方法    @Override    public User clone() throws CloneNotSupportedException {        return (User) super.clone();    }}</code></pre><p>然后就可以把<code>main()</code>方法的代码改成以下这样：</p><pre><code class="java">public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setAge(18);        user.setJob(&quot;程序员&quot;);        user.setSchool(&quot;家里蹲大学&quot;);        user.setNation(&quot;汉族&quot;);        //0-男 1-女        user.setGender((byte)0);        user.setPhone(&quot;110&quot;);        user.setPoliticalFeatures(&quot;群众&quot;);        user.setEducation(&quot;大学本科&quot;);        //调用克隆方法，复制第一个user对象        User user1 = user.clone();        user1.setId(2);        user1.setName(&quot;李四&quot;);        user1.setPhone(&quot;111&quot;);        System.out.println(user1);        //控制台打印结果        //User{id=2, name=&#39;李四&#39;, phone=&#39;111&#39;, nation=&#39;汉族&#39;...}}</code></pre><p>你是不是有疑问，这两个<code>user</code>对象内存地址是否一致呢？我们可以打印出来看看：</p><pre><code class="java">com.yehongzhi.httpclient.model.User@4c873330com.yehongzhi.httpclient.model.User@119d7047</code></pre><p>内存地址是不一样的，所以我们可以得出一个结论：<strong>克隆出来的对象是一个新的对象。</strong></p><p><strong>问题：</strong>克隆方法的底层是不是调用了构造器创建了一个对象的呢？</p><p>我们可以在构造器上面加一些打印语句来验证一下：</p><pre><code class="java">public class User implements Cloneable {    //其他非重点代码省略    //构造器，如果以下语句打印了两次，则证明clone调用了构造器创建对象    public User() {        System.out.println(&quot;调用了无参构造器&quot;);    }    //克隆方法    @Override    public User clone() throws CloneNotSupportedException {        System.out.println(&quot;调用了clone()方法&quot;);        return (User) super.clone();    }}</code></pre><p>我们运行<code>main()</code>方法后，可以看到控制台打印信息如下：</p><pre><code class="java">// 调用了无参构造器// 调用了clone()方法</code></pre><p>只调用了一次构造器，我们可以得出结论：</p><blockquote><p>clone()方法不是调用了构造器创建对象的。</p></blockquote><p>如果你刨根究底，究竟clone()方法是怎么创建对象的，其实也很简单，打开源码：</p><pre><code class="java">public class Object {    private static native void registerNatives();    static {        registerNatives();    }    //最终会调用Object的克隆方法，是一个native修饰的方法    protected native Object clone() throws CloneNotSupportedException;}</code></pre><p>native修饰的方法是什么意思呢？意思就是这个方法的实现不是用<code>java</code>，而是<code>C/C++</code>实现。这个native关键字我们可以单独写一篇文章细讲，这里就不深入展开。底层的实现逻辑就是拷贝一份数据，开辟一块新的内存。所以拷贝出来的对象，打印的内存地址和原来的对象不一样。</p><h2 id="使用Cloneable接口的问题"><a href="#使用Cloneable接口的问题" class="headerlink" title="使用Cloneable接口的问题"></a>使用Cloneable接口的问题</h2><p>使用<code>Cloneable</code>接口是不是就完美的呢，其实并不是，因为如果一个对象的字段也是一个对象，是一个引用数据类型时，那就会有问题。请看以下代码：</p><p>我们增加一个对象<code>IdCard</code>类</p><pre><code class="java">public class IdCard {    private String cardNo;    private Integer validityPeriod;    private Date createDate;    //省略getter、setter方法}</code></pre><pre><code class="java">public class User implements Cloneable {    //其他字段省略    //身份证对象    private IdCard idCard;    //省略getter、setter方法}</code></pre><p>然后我们在<code>main()</code>方法赋值：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        //省略其他字段的赋值        //创建一个IdCard对象        IdCard idCard = new IdCard();        //身份证号码        idCard.setCardNo(&quot;111111&quot;);        //创建日期        idCard.setCreateDate(new Date());        //身份证有效期        idCard.setValidityPeriod(10);        //user对象设置身份证对象        user.setIdCard(idCard);        //user克隆，得到user1        User user1 = user.clone();        //打印user、user1的IdCard对象的内存地址，内存地址一样！        System.out.println(user.getIdCard());//IdCard@4c873330        System.out.println(user1.getIdCard());//IdCard@4c873330        //当改变克隆体user1的IdCard里面的字段值        user1.getIdCard().setCardNo(&quot;222222&quot;);        //源对象user的IdCard里面的字段值也跟着一起改变了        System.out.println(user.getIdCard().getCardNo());//222222    }}</code></pre><p>明显这样的克隆是有巨大的问题的，因为项目中不可能只有基本数据类型。那怎么解决呢？</p><pre><code class="java">//IdCard对象也要实现Cloneable接口public class IdCard implements Cloneable{    //也需要重写clone()方法    @Override    protected IdCard clone() throws CloneNotSupportedException {        return (IdCard)super.clone();    }}</code></pre><pre><code class="java">public class User implements Cloneable {    @Override    public User clone() throws CloneNotSupportedException {        User user = (User) super.clone();        //获取idCard源对象        IdCard idCard = user.getIdCard();        //克隆一个idCard对象。然后set值到user对象中        user.setIdCard(idCard.clone());        return user;    }}</code></pre><p>最后我们再调用<code>main()</code>方法：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        //第一个用户        User user = new User();        //创建一个IdCard对象        IdCard idCard = new IdCard();        //身份证号码        idCard.setCardNo(&quot;111111&quot;);        //user对象设置身份证对象        user.setIdCard(idCard);        //克隆user对象，得到user1对象        User user1 = user.clone();        //打印user、user1的IdCard对象的内存地址，内存地址不一样了！        System.out.println(user.getIdCard());//IdCard@4c873330        System.out.println(user1.getIdCard());//IdCard@119d7047        //当改变克隆体user1的IdCard里面的字段值        user1.getIdCard().setCardNo(&quot;222222&quot;);        //源对象user的IdCard里面的字段值也跟着一起改变了        System.out.println(user.getIdCard().getCardNo());//111111    }}</code></pre><h2 id="使用序列化实现深克隆"><a href="#使用序列化实现深克隆" class="headerlink" title="使用序列化实现深克隆"></a>使用序列化实现深克隆</h2><p>上面使用<code>Cloneable</code>接口的方式，被称为浅克隆，如果你想要克隆的源对象里面又有对象时，里面的对象也要实现<code>Cloneable</code>接口，然后修改源对象的<code>clone()</code>方法，这样就非常麻烦，而且当扩展时会破坏开闭原则。</p><p>解决方法，我们可以采用序列化对象的方式，实现深克隆呢？请看以下代码：</p><p><code>User</code>对象实现<code>Serializable</code>接口:</p><pre><code class="java">public class User implements Serializable {    private static final long serialVersionUID = 8656071024384993135L;}</code></pre><p><code>IdCard</code>对象实现<code>Serializable</code>接口：</p><pre><code class="java">public class IdCard implements Serializable {    private static final long serialVersionUID = -422430076410272813L;}</code></pre><p>创建一个工具类<code>CloneUtil</code>实现深克隆：</p><pre><code class="java">public class CloneUtil {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T&gt; T depthClone(T t, Class&lt;T&gt; clazz) throws Exception {        ByteArrayOutputStream baos = null;        ObjectOutputStream ous = null;        ByteArrayInputStream bais = null;        ObjectInputStream ois = null;        try {            //将源对象序列化，写入流中，写入流的对象是一个拷贝的对象，原对象还在JVM中            baos = new ByteArrayOutputStream();            ous = new ObjectOutputStream(baos);            ous.writeObject(t);            //把流中的对象再读取到内存中，就获得了克隆后的对象            bais = new ByteArrayInputStream(baos.toByteArray());            ois = new ObjectInputStream(bais);            return (T) ois.readObject();        } catch (Exception e) {            e.printStackTrace();            throw new RuntimeException(&quot;深克隆出现异常&quot;);        } finally {            if (ous != null) {ous.close();}            if (baos != null) {baos.close();}            if (bais != null) {bais.close();}            if (ois != null) {ois.close();}        }    }}</code></pre><p>验证是否深克隆，在<code>main()</code>方法中打印内存地址查看即可：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        User user = new User();        user.setIdCard(new IdCard());        User user1 = CloneUtil.depthClone(user, User.class);        //内存地址都不相同，达到了深克隆的效果        System.out.println(user);//User@3d075dc0        System.out.println(user1);//User@2ef1e4fa        System.out.println(user.getIdCard());//IdCard@214c265e        System.out.println(user1.getIdCard());//IdCard@306a30c7    }}</code></pre><p>用序列化实现深克隆的优点就是，对源代码侵入性很低，只需要实现<code>Serializable</code>接口，不需要一层一层去实现<code>Cloneable</code>接口，还有重写<code>clone()</code>方法。</p><p><strong>问题：</strong>如果这个实体类是在<code>jar</code>包中的呢，我们没法去修改实体类的代码，那怎么实现克隆呢？</p><h2 id="使用反射实现克隆"><a href="#使用反射实现克隆" class="headerlink" title="使用反射实现克隆"></a>使用反射实现克隆</h2><p>利用反射，实际上我们可以拿到源对象的任何值，所以就可以实现克隆，请看以下代码：</p><p>我们创建一个<code>copyProperties()</code>方法，具体实现看以下代码：</p><pre><code class="java">public class CloneUtil {    public static void copyProperties(Object source, Object target) throws Exception {        //获取源对象的属性描述器        PropertyDescriptor[] sourceDescriptors = Introspector                .getBeanInfo(source.getClass())                .getPropertyDescriptors();        //获取目标对象的字段名称集合        List&lt;String&gt; targetFieldNames = Arrays                .stream(target.getClass().getDeclaredFields())                .map(Field::getName)                .collect(Collectors.toList());        for (PropertyDescriptor sourceProperty : sourceDescriptors) {            //获取源对象的属性名称            String name = sourceProperty.getName();            //源对象的getter方法            Method readMethod = sourceProperty.getReadMethod();            if (!readMethod.isAccessible()) {                //设置方法的可访问权限                readMethod.setAccessible(true);            }            //调用源对象的getter方法，获取到里面的每一个值            Object value = readMethod.invoke(source);            //如果源对象的属性名称包含在目标对象的字段名称集合中            if (targetFieldNames.contains(name)) {                //则通过源对象的属性名称获取目标对象属性的属性描述器                PropertyDescriptor propertyDescriptor = new PropertyDescriptor(name, target.getClass());                //获取目标对象的setter方法                Method writeMethod = propertyDescriptor.getWriteMethod();                writeMethod.setAccessible(true);                //执行setter方法，参数是从源对象getter方法获取到的值                writeMethod.invoke(target, value);            }        }    }}</code></pre><p>测试：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setId(1);        user.setName(&quot;张三&quot;);        user.setIdCard(new IdCard());        User user1 = new User();        CloneUtil.copyProperties(user, user1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三        System.out.println(user.getIdCard());//IdCard@b81eda8        System.out.println(user1.getIdCard());//IdCard@b81eda8    }</code></pre><p>这样实现的不是深克隆的效果，所以<code>IdCard</code>对象的内存地址还是一样的。为了避免这样的结果，我们可以在使用时注意一下：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setName(&quot;张三&quot;);        IdCard idCard = new IdCard();        user.setIdCard(idCard);        User user1 = new User();        //创建一个新的IdCard对象        IdCard idCard1 = new IdCard();        CloneUtil.copyProperties(user, user1);        //复制idCard的值到idCard1里        CloneUtil.copyProperties(idCard,idCard1);        //再设置idCard1到user1中        user1.setIdCard(idCard1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三        System.out.println(user.getIdCard());//IdCard@68de145        //内存地址不同        System.out.println(user1.getIdCard());//IdCard@27fa135a    }</code></pre><p>这样就避免产生内存地址一样的情况了。</p><h2 id="Spring的copyProperties"><a href="#Spring的copyProperties" class="headerlink" title="Spring的copyProperties()"></a>Spring的copyProperties()</h2><p>实际上在<code>Spring</code>框架中，已经提供了<code>copyProperties()</code>方法：</p><pre><code class="java">public static void main(String[] args) throws Exception {        User user = new User();        user.setName(&quot;张三&quot;);        User user1 = new User();        //Spring的copyProperties()方法        BeanUtils.copyProperties(user,user1);        System.out.println(user.getName());//张三        System.out.println(user1.getName());//张三    }</code></pre><p>一般在实际项目中，我们采用<code>copyProperties()</code>方法实现原型模式会更好，因为这样不会破坏开闭原则，即使是<code>jar</code>包中定义的实体类，也可以使用。缺点就是如果对象层级比较多的话，会比较麻烦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现原型模式的三种方式：实现<code>Cloneable</code>接口、序列化对象、反射机制。</p><p>原型模式的优点：</p><ol><li>提高了创建对象的性能，避免了调用构造器创建对象。</li><li>对于创建一个对象需要很多资源的情况，可以减少资源的浪费。</li></ol><p>原型模式的缺点：</p><ol><li>如果使用<code>Cloneable</code>接口的方式，需要实现<code>Cloneable</code>接口，对代码有一定的侵入性。</li><li>如果使用序列化方式，则需要实现<code>Serializable</code>接口，对代码也有一定的侵入性。</li><li>如果使用反射机制，层级较多时会比较难维护。</li></ol><p>以上就是原型模式的学习，更多的java技术分享，就关注<strong>java技术爱好者</strong>吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰者模式与IO流</title>
    <link href="/2020/05/04/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8EIO%E6%B5%81/"/>
    <url>/2020/05/04/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8EIO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>装饰者模式是一种<strong>对象结构型</strong>模式。<strong>动态</strong>地给一个对象添加一些<strong>额外的</strong>职责，就增加功能来说，装饰者模式比生成子类更为灵活。</p><a id="more"></a><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>上面的定义在网上是随处可见的描述，怎么解释呢。比如：我前几天和女朋友去买戒指，珠宝店的销售给我推荐了一种<strong>自由搭配</strong>的原创戒指。他跟我介绍戒指的元素需要选择材质(黄金，铂金，彩金)、表面工艺(拉丝，磨砂，光滑，铸造)、镶钻(内嵌，外嵌)、指环大小等等，然后组成一个戒指。这种就是装饰者模式的应用，原型是一个戒指，不断地给对象添加额外的职责，然后得到最终想要的产品。这样就可以通过不同的搭配产生很多不同类型的戒指。</p><p>后面那句<strong>装饰者模式比生成子类更为灵活</strong>怎么理解。如果用子类去描述的话，要把每一种搭配的结果都变成一个子类，也就是要穷举，就会产生很多子类，也就是造成<strong>“类爆炸”</strong>。所以就会说装饰者模式更加灵活。</p><h2 id="来个例子"><a href="#来个例子" class="headerlink" title="来个例子"></a>来个例子</h2><p>现在有一个需求，要求做一个加密的工具类，对传入的字符串加密。加密的算法有很多，有<strong>MD5、AES、DES等等</strong>，一般加密都不是单独使用一种加密算法，而是多种混合一起使用，这样可以提高安全性。</p><p>现在有三种算法：<code>MD5、AES、DES</code>。做一个工具类，给系统提供加密的服务，要求可以自由搭配使用。</p><h2 id="使用继承的方式实现"><a href="#使用继承的方式实现" class="headerlink" title="使用继承的方式实现"></a>使用继承的方式实现</h2><p>我们就创建一个抽象类<code>EncryptionBase</code>，每一种组合方式就创建一个子类继承<code>EncryptionBase</code>，现在有三种加密方式，很容易我们可以穷举完，总共有6种组合。请看以下代码：</p><p>首先创建一个抽象类<code>EncryptionBase</code>：</p><pre><code class="java">public abstract class EncryptionBase {    public abstract String encrypt(String string,String password);}</code></pre><p>接着创建子类继承抽象类，并且实现其方法。以其中一个为例，其他实现类都类似：</p><pre><code class="java">public class AESandDESandMD5Encryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        //网上可以找具体加密的代码，我这里篇幅受限就不展示了        //AES加密        byte[] encryptByAES = AESUtil.encrypt(string, password);        //DES加密        byte[] encryptByDES = DESUtil.encrypt(encryptByAES, password);        //MD5加密        return MD5Util.encryptByMD5(new String(encryptByDES) + password);    }}</code></pre><p>我们就可以实现以下效果，有6个实现类分别实现了3种加密算法的不同顺序。</p><pre><code class="java">public static void main(String[] args) {        String string = &quot;需要加密的字符串&quot;;        //秘钥        String password = &quot;12345678&quot;;        //第一种加密顺序：AES-&gt;DES-&gt;MD5        EncryptionBase AESandDESandMD5 = new AESandDESandMD5Encryption();        //第二种加密顺序：AES-&gt;MD5-&gt;DES        EncryptionBase AESandMD5andDES = new AESandMD5andDESEncryption();        //第三种加密顺序：DES-&gt;AES-&gt;MD5        EncryptionBase DESandAESandMD5 = new DESandAESandMD5Encryption();        //第四种加密顺序：DES-&gt;MD5-&gt;AES        EncryptionBase DESandMD5andAES = new DESandMD5andAESEncryption();        //第五种加密顺序：MD5-&gt;DES-&gt;AES        EncryptionBase MD5andDESandAES = new MD5andDESandAESEncryption();        //第六种加密顺序：MD5-&gt;AES-&gt;DES        EncryptionBase MD5andAESandDES = new MD5andAESandDESEncryption();    }</code></pre><p>以上就是使用继承的方式来完成这个需求。看起来没什么问题，但是仔细思考你会发现几个问题。</p><ol><li><strong>会创建很多子类。</strong>为什么3种算法是6个类呢？这是根据数学的排列组合<code>3*2*1=6</code>，假设再多两种算法呢？那就是<code>5*4*3*2*1=120</code>，那就是120个类了！这就是<strong>“类爆炸”</strong>。</li><li><strong>不符合开闭原则。</strong>假设增加了新的算法，那就要修改原来的类，不利于代码的维护。</li><li>假如其中一种加密算法要用两次，比如双重<code>MD5</code>加密，那也是很难扩展的。</li></ol><p>如果你不会装饰者模式，那估计要加班加点去写代码，创建很多类。如果你会装饰者模式，那问题就很简单了，那怎么做呢？请继续看下去。</p><h2 id="使用装饰者模式实现"><a href="#使用装饰者模式实现" class="headerlink" title="使用装饰者模式实现"></a>使用装饰者模式实现</h2><p>首先创建三种算法的基础类，继承<code>EncryptionBase</code>，实现三种加密算法。</p><p>MD5加密</p><pre><code class="java">public class MD5Encryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用MD5加密，得到基础密文&quot;);        return MD5Util.encryptByMD5(string + password);    }}</code></pre><p>AES加密</p><pre><code class="java">public class AESEncryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用AES加密，得到基础密文&quot;);        return new String(AESUtil.encrypt(string, password));    }}</code></pre><p>DES加密</p><pre><code class="java">public class DESEncryption extends EncryptionBase {    @Override    public String encrypt(String string, String password) {        System.out.println(&quot;使用DES加密，得到基础密文&quot;);        return new String(DESUtil.encrypt(string.getBytes(), password));    }}</code></pre><p>接着创建一个装饰抽象类<code>EncryptionDecorator</code>，需要继承<code>EncryptionBase</code></p><pre><code class="java">public abstract class EncryptionDecorator extends EncryptionBase {    //定义一个父类的成员变量，用来存储其他装饰类，或者基础加密类    private EncryptionBase encryption;    public EncryptionDecorator(EncryptionBase encryption) {        this.encryption = encryption;    }    @Override    public String encrypt(String string, String password) throws Exception{        return encryption.encrypt(string, password);    }}</code></pre><p>然后实现三种加密的装饰者实现类，需要继承抽象装饰者类<code>EncryptionDecorator</code>。</p><p>MD5加密装饰者实现类<code>MD5EncryptionDecorator</code></p><pre><code class="java">public class MD5EncryptionDecorator extends EncryptionDecorator {    public MD5EncryptionDecorator(EncryptionBase encryption) {        //有参构造器获取到参数，调用父类的有参构造器，        //当下面encrypt()方法里调用父类的加密算法就会调用传入的算法实现类的加密算法        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用MD5加密&quot;);        //得到的密文，再用MD5算法加密，返回        return MD5Util.encryptByMD5(encrypt + password);    }}</code></pre><p>AES加密装饰者实现类<code>AESEncryptionDecorator</code></p><pre><code class="java">public class AESEncryptionDecorator extends EncryptionDecorator {    public AESEncryptionDecorator(EncryptionBase encryption) {        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用AES加密&quot;);        //得到的密文，再用AES算法加密，返回        return new String(AESUtil.encrypt(encrypt, password),&quot;UTF-8&quot;);    }}</code></pre><p>DES加密装饰者实现类<code>DESEncryptionDecorator</code></p><pre><code class="java">public class DESEncryptionDecorator extends EncryptionDecorator {    public DESEncryptionDecorator(EncryptionBase encryption) {        super(encryption);    }    @Override    public String encrypt(String string, String password) throws Exception{        //首先调用父类的加密方法，得到父类的算法加密后的结果        String encrypt = super.encrypt(string, password);        System.out.println(&quot;使用DES加密&quot;);        //得到的密文，再用DES算法加密，返回        return new String(DESUtil.encrypt(encrypt.getBytes(), password),&quot;UTF-8&quot;);    }}</code></pre><p>大功告成！我们用<code>main()</code>方法测试一下：</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception{        String string = &quot;需要加密的字符串&quot;;        String password = &quot;12345678&quot;;        //第一种加密顺序：AES-&gt;DES-&gt;MD5        EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption()));        encryptionBase.encrypt(string, password);    }}</code></pre><p>控制台打印结果：</p><pre><code class="java">/**使用AES加密，得到基础密文使用DES加密使用MD5加密*/</code></pre><p>我们可以看到结果是很完美地实现了，你可以任意搭配加密算法，即使加多N种算法，我们也不会呈指数增加类的数量，只需要增加M*N个类即可，M是基础构件数量，N是具体装饰类数量。</p><p>原理是什么呢？我们不能说只学到形式，而不明白原理。接下来看类图。</p><p>在IDEA可以选中类名，然后右键，选中“Diagrams”，再选中“show Diagrams…”，就可以打开类图。</p><img src="https://static.lovebilibili.com/MD5EncryptionDecorator.png" srcset="/img/loading.gif"/><pre><code class="java">//MD5(DES(AES))，最顶层的父类是AES，所以先执行，第二层是DES，第二执行，最外层是MD5第三执行EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption()));encryptionBase.encrypt(string, password);</code></pre><p>以上面这句代码为例，那么调用顺序就是：AES-&gt;DES-&gt;MD5</p><img src="https://static.lovebilibili.com/decorator1.png" srcset="/img/loading.gif" style="width:100%;"/><p>这就是装饰者模式的原理，其实很简单的，很容易就可以看清楚。</p><h2 id="装饰者模式与I-O流"><a href="#装饰者模式与I-O流" class="headerlink" title="装饰者模式与I/O流"></a>装饰者模式与I/O流</h2><p>看了上面的代码，很容易我们能联想到IO流也有类似的创建方式，比如我们要用文件缓冲输入流，那就要这样创建：</p><pre><code class="java">InputStream inputStream     = new BufferedInputStream(new FileInputStream(new File(&quot;/D:abc.text&quot;)));</code></pre><p>可以看出IO流使用了装饰者模式。</p><p>如果我们打开源码，查看<code>BufferedInputStream</code>，我们可以看到：</p><pre><code class="java">public class BufferedInputStream extends FilterInputStream {    //有参构造器    public BufferedInputStream(InputStream in, int size) {        //调用父类构造器，这是关键        //通过上面我们学过的例子，可以知道BufferedInputStream是装饰实现类        super(in);        if (size &lt;= 0) {            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);        }        buf = new byte[size];    }}</code></pre><p>关键在<code>FilterInputStream</code>这个类，这是装饰者模式的基类。查看源码：</p><pre><code class="java">public class FilterInputStream extends InputStream {    /**     * The input stream to be filtered.     */    protected volatile InputStream in;    protected FilterInputStream(InputStream in) {        this.in = in;    }    public int read() throws IOException {        return in.read();    }}</code></pre><p><code>FilterInputStream</code>类似于加密算法例子的<code>EncryptionDecorator</code>类。我们可以通过加密算法的例子和这个作对比，就可以很容易地看出他们的关系。类图如下：</p><img src="https://static.lovebilibili.com/FilterInputStream.png" srcset="/img/loading.gif" style="width:100%;"/><p><code>FileInputStream</code>就是基础构件类，可以通过<code>FilterInputStream</code>的子类去做扩展，增加额外的功能，比如可以使用<code>BufferedInputStream</code>增加缓冲的作用。</p><p>接着我们真正理解了IO流的装饰者模式的应用后，我们可以写一个扩展类，实现一个功能：读取磁盘的文件，把所有字母变成大写的字母。代码如下：</p><pre><code class="java">public class CapitalizaInputStream extends FilterInputStream {    public CapitalizaInputStream(InputStream in) {        super(in);    }    @Override    public int read(byte[] b, int off, int len) throws IOException {        int result = super.read(b, off, len);        for (int i = off; i &lt; off + result; i++){            //如果是小写字母，转成大写，其他不是小写字母的不变            if(Character.isLetter((char)b[i])){                b[i] = (byte) Character.toUpperCase((char) b[i]);            }        }        return result;    }}</code></pre><p>abc.txt文件内容：</p><pre><code class="yaml">abcdefghijklmnopqrstuvwxyz</code></pre><p>Main方法测试代码：</p><pre><code class="java">public static void main(String[] args) throws Exception {        InputStream inputStream             = new CapitalizaInputStream(new FileInputStream(new File(&quot;D://abc.txt&quot;)));        byte[] bytes = new byte[1024 * 2];        int c;        while ((c = inputStream.read(bytes, 0, bytes.length)) != -1) {            System.out.println(new String(bytes, 0, c));        }        inputStream.close();    }</code></pre><p>控制台打印结果：</p><pre><code class="yaml">ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre><p>以上就是IO流关于装饰者模式的扩展，能够加深我们对装饰者模式的理解。很多博客写不清楚，讲得很复杂，或者讲得很简单，很大原因是我们只看，而没有动手去做，动手去自己写，自己琢磨，就很容易能理解。这是学习方法，不是关注了公众号，看几篇文章就能轻松学会的，学习总是要自己动手才会理解深刻。看我的文章可以提供一些思路，更容易去上手。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰者模式的优点：</p><ol><li>可以动态地扩展类的功能，不会相互耦合。</li><li>符合开闭原则，利于代码维护。</li><li>比继承扩展的方式要更加灵活。</li></ol><p>缺点：多层装饰，代码结构变得复杂。</p><p>更多的java技术分享，就关注java技术爱好者吧！</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式以及实际项目应用</title>
    <link href="/2020/05/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式（Observer），又叫<strong>发布-订阅模式（Publish/Subscribe）</strong>，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p><h2 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h2><p>比如我们在宿舍打斗地主，我们要找个人来“放风”，这个人在门口观察，如果有宿管过了检查，那么就通知宿舍其他的小伙伴停止斗地主回床上睡觉。这种模式就被称为观察者模式。</p><p>从这个例子看，“宿管是否过来宿舍”是订阅的主题，观察者是放风的人，订阅者是打斗地主的小伙伴，被观察者就是宿管。</p><h2 id="不使用观察者模式的问题"><a href="#不使用观察者模式的问题" class="headerlink" title="不使用观察者模式的问题"></a>不使用观察者模式的问题</h2><p>假设我们基于之前在策略模式讲的电子支付的例子，支付完成后要发送消息，发送的消息有：短信，公众号消息，APP站内消息，邮箱。如果不使用观察者模式，怎么做呢？看代码：</p><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        //发送短信        System.out.println(&quot;发送短信：&quot;+msg);        //发送微信公众号消息        System.out.println(&quot;发送微信公众号消息：&quot;+msg);        //发送邮件        System.out.println(&quot;发送邮件：&quot;+msg);        //发送APP系统信息        System.out.println(&quot;发送APP系统信息：&quot;+msg);        return msg;    }</code></pre><p>启动项目是没有问题的，我们调用接口后可以看到控制台打印以下信息：</p><pre><code class="java">/**发送短信：使用 支付宝支付 ,消费了 100 元发送微信公众号消息：使用 支付宝支付 ,消费了 100 元发送邮件：使用 支付宝支付 ,消费了 100 元发送APP系统信息：使用 支付宝支付 ,消费了 100 元*/</code></pre><p><strong>但是我们很明显可以看出有以下的问题：</strong></p><ul><li>每次支付如果需要新增一种消息通知方式，则要修改原来的类，不利于维护。</li><li>违反了开闭原则，对拓展开放，对修改关闭。</li><li>违反了单一职责原则，支付不应该糅杂消息通知的功能。</li></ul><p>上面就从代码演示了为什么要使用观察者模式，很多文章说不清楚，单纯地抛出一个概念和一些简单的例子，实际项目中肯定是没有那么简单。</p><h2 id="使用观察者模式优化"><a href="#使用观察者模式优化" class="headerlink" title="使用观察者模式优化"></a>使用观察者模式优化</h2><p>这里的话，我不使用<code>java</code>自带的<code>Observer</code>和<code>Observable</code>来做，因为实际项目中一般都会使用<code>Spring</code>框架，<code>Spring</code>框架有一个事件机制，也是使用观察者模式的这种设计模式，而且在实际项目中我们往往会采用这种成熟度更高的框架，就像代理模式我们也很少会直接使用原生的<code>JDK动态代理</code>，而是采用<code>SpringAOP</code>来实现。</p><h2 id="创建支付的事件"><a href="#创建支付的事件" class="headerlink" title="创建支付的事件"></a>创建支付的事件</h2><pre><code class="java">//继承ApplicationEvent类public class PayEvent extends ApplicationEvent {    //消息体    private Map&lt;String,String&gt; map;    //订阅主题    private String topic;    public PayEvent(Object source, Map&lt;String, String&gt; map, String topic) {        //调用父类的构造器        super(source);        this.map = map;        this.topic = topic;    }    public Map&lt;String, String&gt; getMap() {        return map;    }    public void setMap(Map&lt;String, String&gt; map) {        this.map = map;    }    public String getTopic() {        return topic;    }    public void setTopic(String topic) {        this.topic = topic;    }}</code></pre><h2 id="创建事件监听类"><a href="#创建事件监听类" class="headerlink" title="创建事件监听类"></a>创建事件监听类</h2><pre><code class="java">//短信监听，实现ApplicationListener接口，重写onApplicationEvent()方法@Componentpublic class SmsListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        //订阅主题        String topic = payEvent.getTopic();        //消息体        Map&lt;String, String&gt; map = payEvent.getMap();        //发送短信        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送短信:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//公众号监听@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//邮箱监听@Componentpublic class MailListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送邮件:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">//App站内消息监听@Componentpublic class AppListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送App站内消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><h2 id="重构PayServiceImpl类"><a href="#重构PayServiceImpl类" class="headerlink" title="重构PayServiceImpl类"></a>重构PayServiceImpl类</h2><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,msg);        //创建一个支付事件        PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;);        //获取Spring的ApplicationContext容器，发布事件，监听类监听到事件后就会发送消息        SpringContextUtil.getApplicationContext().publishEvent(payEvent);        return msg;    }</code></pre><p>然后我们启动项目，调用接口，控制台就可以打印的信息：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送公众号消息:使用 支付宝支付 ,消费了 100 元*/</code></pre><h2 id="异步监听事件，实现解耦"><a href="#异步监听事件，实现解耦" class="headerlink" title="异步监听事件，实现解耦"></a>异步监听事件，实现解耦</h2><p>改造之后是否就一劳永逸了呢，实际上并非如此。因为上面的消息发送的监听类是同步的，也就是如果发送消息出现异常，那就会导致支付的接口无法正常返回。请看以下代码：</p><pre><code class="java">@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        //在发送微信公众号消息的逻辑中制造异常        System.out.println(10 / 0);        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><pre><code class="java">    @Override    public String pay(String channel, String amount) throws Exception {        PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);        if(payStrategy == null){            return &quot;输入渠道码有误&quot;;        }        String msg = payStrategy.pay(channel, amount);        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,msg);        //创建一个支付事件        PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;);        //获取Spring的ApplicationContext容器，发布事件        SpringContextUtil.getApplicationContext().publishEvent(payEvent);        //发送消息后的逻辑，打印日志到控制台        System.out.println(&quot;发送消息后的逻辑代码...&quot;);        return msg;    }</code></pre><p>我们在发送公众号消息的逻辑里制造了一个异常，然后在<code>pay()</code>方法中加了一个打印日志在发布支付的事件后面，接下来调用接口，结果是：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/</code></pre><p>发送消息后的逻辑是没有被执行。这样显然是不符合业务要求的，因为在很多时候，发送消息失败是不能影响支付流程的，应该异步进行。怎么异步进行发送消息呢？</p><p>很简单，只需要两个步骤。</p><p><strong>第一步</strong>:在监听类或者方法上添加<code>@Async</code>注解，例如：</p><pre><code class="java">@Component@Async//加上异步执行的注解public class WechatListener implements ApplicationListener&lt;PayEvent&gt; {    @Override    public void onApplicationEvent(PayEvent payEvent) {        String topic = payEvent.getTopic();        Map&lt;String, String&gt; map = payEvent.getMap();        System.out.println(10 / 0);        System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;));    }}</code></pre><p><strong>第二步</strong>：在<code>SpringBoot</code>启动类上添加<code>@EnableAsync</code>注解，例如：</p><pre><code class="java">@SpringBootApplication@EnableAsync//添加启用异步的注解public class StrategyApplication {    public static void main(String[] args) {        SpringApplication.run(StrategyApplication.class, args);    }}</code></pre><p>然后就可以实现异步监听了，调用接口，我们可以看到控制台打印的日志如下：</p><pre><code class="java">/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元发送消息后的逻辑代码...使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/</code></pre><p>明显可以看到支付后的逻辑也能正常执行下去，证明实现了异步监听！</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在<code>Spring</code>里提供了许多的监听器，这里只是介绍了其中一种。</p><p>还有一种叫<code>SpringApplicationRunListener</code>也是很常用的监听器，可以监听<code>SpringBoot</code>项目启动的事件，用于在启动项目时加载一些配置。</p><p>还有一种叫<code>SmartApplicationListener</code>，这种监听器可以设置优先级。假设发送消息需要按顺序先发送短信，再发送公众号，再发送邮箱…，那就可以使用这种监听器实现，这里就不多做介绍了，小伙伴有兴趣的话，我可以再写一篇文章详细介绍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过重构之后，我们可以明显看到，如果以后要增加一种新的消息通知方式，是不需要修改<code>PayServiceImpl</code>的，我们只需要再增加一个监听类即可，这就符合了<code>开闭原则</code>。有利于代码的维护。而且最重要是解耦，支付的业务逻辑和发送消息的业务逻辑不会再糅合在一起了，符合<code>职责单一</code>原则。</p><p>在很多框架中，观察者模式都有应用，对于学习很多例如<code>zookeeper</code>、<code>消息中间件</code>、<code>微服务注册中心</code>等知识是有很大帮助的。在实际项目中，观察者模式也是一种很常用的设计模式。比如有一种业务场景，通讯录的部门里有员工离职，需要通知其他依赖于通讯录的应用都要同步部门的员工，那就可以使用这种方式来实现。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你用构建者(生成器)模式优雅地创建对象</title>
    <link href="/2020/04/27/%E6%95%99%E4%BD%A0%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85-%E7%94%9F%E6%88%90%E5%99%A8-%E6%A8%A1%E5%BC%8F%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/04/27/%E6%95%99%E4%BD%A0%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85-%E7%94%9F%E6%88%90%E5%99%A8-%E6%A8%A1%E5%BC%8F%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要用构建者模式"><a href="#为什么要用构建者模式" class="headerlink" title="为什么要用构建者模式"></a>为什么要用构建者模式</h1><p>很多博客文章上来就先抛出一个定义，我们不妨反过来问一句为什么要用构建者模式。<br>首先我们创建一个<code>User</code>类，然后采用有参构造器的方式创建对象。</p><pre><code class="java">public class User {    private String id;    private String name;    private String gender;    private String address;    private Integer age;    private String phone;    //省略无参构造器，有参构造器，getter，setter方法...}</code></pre><pre><code class="java">public static void main(String[] args) throws Exception {    String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);    User user = new User(id, &quot;张三&quot;, &quot;男&quot;, &quot;广州天河&quot;, 20, &quot;135461852xx&quot;);}</code></pre><p>我们通过有参构造器创建对象，并且赋值，看起来没什么问题，因为我们经常看到有人是这样写的。<br>事实上，如果<code>User</code>对象里面有更多的字段，通过有参构造器去创建对象是很难一眼看出字段具体是什么意思，我们经常要看着<code>User构造器</code>的代码，然后对照顺序才能看出字段的代表什么意思。</p><pre><code class="java">public User(String id, String name, String gender, String address, Integer age, String phone) {    this.id = id;    this.name = name;    this.gender = gender;    this.address = address;    this.age = age;    this.phone = phone;}</code></pre><p>比如通过上面这个，我们可以知道第一个参数是id，第二个参数是名字，第三个是性别…</p><h2 id="使用有参构造器的缺点："><a href="#使用有参构造器的缺点：" class="headerlink" title="使用有参构造器的缺点："></a>使用有参构造器的缺点：</h2><p>这显然不利于代码的维护性，对于不熟悉业务的新入职的员工，如果看到这种方式构建一个对象，估计要看上一会，有些项目我遇过一个构造器十几个参数的，更加离谱。而且一般老代码还不敢乱动他的这个构造器，一不小心你动了构造器里面的一个参数的顺序，直接GG；或者你在他原有的构造器后面加多一个参数，你会发现他很多地方都引用了这个有参构造器，你很多地方都要去修改，是真的恶心。</p><h2 id="解决方法一-使用无参构造器，通过setter方法设置属性值"><a href="#解决方法一-使用无参构造器，通过setter方法设置属性值" class="headerlink" title="解决方法一 使用无参构造器，通过setter方法设置属性值"></a>解决方法一 使用无参构造器，通过setter方法设置属性值</h2><pre><code class="java">public static void main(String[] args) throws Exception {    User user = new User();    user.setId(UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;));    user.setName(&quot;张三&quot;);    user.setAge(20);    user.setGender(&quot;男&quot;);    user.setPhone(&quot;135461852xx&quot;);    user.setAddress(&quot;广州天河&quot;);    out.println(user);}</code></pre><p>上面这样，显然比直接用有参构造器要好很多，因为这样就可以创建对象和赋值分开进行，一眼就可以看出对什么属性值赋值，而且如果加一个字段，我们不需要再每一处都去修改，因为用的是<strong>无参构造器</strong>，是不是这样写就是万全之计呢？<br>也不是，因为这样创建对象和赋值是分开的，各个参数的初始化被放到了不同的方法中调用，这会导致严重的线程不安全问题(使用构造器则不会有这个问题)，对象在一连串的set方法中，可能会出现状态不一致的情况，这是应该尽量避免的。</p><h2 id="解决方法二-通过构建者模式，链式调用构建方法设置属性值"><a href="#解决方法二-通过构建者模式，链式调用构建方法设置属性值" class="headerlink" title="解决方法二 通过构建者模式，链式调用构建方法设置属性值"></a>解决方法二 通过构建者模式，链式调用构建方法设置属性值</h2><p>什么是链式编程，就是调用一个方法，返回值是他本身，可以继续调用下一个方法，返回又是他本身，如此调用下去，看上去就像一条链子一样。典型的例子可以看<code>java8</code>新特性的<code>Stream</code>流操作。我们可以使用构建者模式，也能达到这种效果，并且线程安全，而且能直观地看到属性值的意思。总得来说，既保证线程安全，也很具有代码的可读性。先看结果代码：</p><pre><code class="java">public static void main(String[] args) throws Exception {    String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);    User user = UserBuilder.getInstance()            .newPojo()            .addId(id)            .addName(&quot;张三&quot;)            .addGender(&quot;男&quot;)            .addAge(20)            .addPhone(&quot;135461852xx&quot;)            .addAddress(&quot;广州天河&quot;)            .build();}</code></pre><p>怎么实现呢？其实很简单，我们只需要创建一个<code>UserBuilder</code>类即可。代码如下：</p><pre><code class="java">public class UserBuilder {    private User user;    private UserBuilder() {    }    public static UserBuilder getInstance() {        return new UserBuilder();    }    public UserBuilder newPojo() {        this.user = new User();        //返回本身        return this;    }    public UserBuilder addId(String id) {        this.user.setId(id);        //返回本身        return this;    }    public UserBuilder addName(String name) {        this.user.setName(name);        return this;    }    public UserBuilder addGender(String gender) {        this.user.setGender(gender);        return this;    }    public UserBuilder addAge(Integer age) {        this.user.setAge(age);        return this;    }    public UserBuilder addAddress(String address) {        this.user.setAddress(address);        return this;    }    public UserBuilder addPhone(String phone) {        this.user.setPhone(phone);        return this;    }    public User build() {        return this.user;    }}</code></pre><p>那么是不是这种方式就是万全之计呢，就一定没有缺点吗？</p><h3 id="构造者模式的缺点还是有的"><a href="#构造者模式的缺点还是有的" class="headerlink" title="构造者模式的缺点还是有的"></a>构造者模式的缺点还是有的</h3><p>1.代码冗长。如果一个对象的属性很多，那我们在创建一个对象时，链式就会变得很长，但是这也没有办法，无论采用构造器还是builder模式都会很长。如果非要变得简洁一点，那就只有采用原型模式(克隆)等其他方式了。<br>2.会产生很多<code>Builder</code>类。我们可以放在一个包下统一管理应该问题不大。<br>第二个缺点实际上可以使用<code>Lombok</code>插件，然后在实体类上使用<code>@Builder</code>注解，就不会产生过多的<code>Builder</code>类了。但是有些公司的技术总监不太建议使用<code>Lombok</code>，那就莫得办法了…</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>有很多博客的示范代码，<code>Builder</code>类的<code>addXXX</code>方法会写成<code>setXXX</code>方法，这是一个隐患。因为很多框架，对Setter方法比较敏感，往往会对<code>Setter</code>方法做一些处理，所以<code>Builder</code>类里的设置属性值方法尽量不要用<code>setXXX</code>命名，防止出现一些不明原因的错误。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>一般我们在项目中创建复杂的对象时，建议采用这种构建者模式创建对象。这样可以使代码可读性更好。<br>在java源码中，我们也可以看到构建者模式的应用。比如在<code>StringBuilder</code>类中：</p><pre><code class="java">@Overridepublic StringBuilder append(CharSequence s) {    super.append(s);    return this;}/** * @throws     IndexOutOfBoundsException {@inheritDoc} */@Overridepublic StringBuilder append(CharSequence s, int start, int end) {    super.append(s, start, end);    return this;}@Overridepublic StringBuilder append(char[] str) {    super.append(str);    return this;}</code></pre><p><code>StringBuilder</code>的<code>append()</code>方法也是通过返回<code>this</code>对象实现链式构建对象，人们经常说这个<code>StringBuilder</code>类线程不安全是因为<code>append()</code>方法没有用<code>synchronized</code>修饰。<code>StringBuffer</code>则用了<code>synchronized</code>修饰，所以就是线程安全的。<br>还有<code>Mybatis</code>框架中，构建<code>SqlSessionFactory</code>对象是使用<code>SqlSessionFactoryBuilder</code>类进行构建，构建者模式运用非常广泛，非常值得学习。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式以及应用</title>
    <link href="/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><strong>代理模式的定义：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</p><a id="more"></a><p>通俗点说，就是一个中介，比如有一个广州人，是个本地人，有两套房，他要租出去收租，但是除了收租，他还要去找租客，带租客看房，还要准备租房合同，核算水电费等等，很麻烦。这个本地人他也不想这么折腾，他只想<strong>完成他的核心业务(收钱)</strong>,其他杂七杂八的事情就不想管，但是总要有人去做，那就找<strong>租房中介</strong>，也就是二手房东。二手房东就代理这个广州本地人把房子租给租客。这个道理就是这么简单。</p><p>他们这些在广州有房子的本地人都可以找中介公司去代理租房是一样的。因为很多广州本地人都有这个需求，干脆就搞一个中介公司来专门去做租房子的事情。</p><p><strong>代理模式，运用在编程里，也是这个道理，有一些非核心业务的代码，在很多地方都需要用到的逻辑，可以交给代理对象完成，程序员只需要关心核心业务的逻辑即可。</strong></p><h1 id="实现代理模式的三种方式"><a href="#实现代理模式的三种方式" class="headerlink" title="实现代理模式的三种方式"></a>实现代理模式的三种方式</h1><p>项目就基于上一篇<code>模板模式</code>的文章的项目进行试验。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假设原来有一个接口<code>UserService</code>，controller层调用<code>userService</code>的<code>getAllUser()</code>方法。如下所示：</p><pre><code class="java">public interface UserService {    /**     * 获取所有用户信息     *     * @return List     * @author Ye hongzhi     * @date 2020/4/12     */    List&lt;User&gt; getAllUser() throws Exception;}</code></pre><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return userService.getAllUser();    }}</code></pre><p>如果用静态代理实现记录日志信息，怎么记录呢？</p><p>首先创建一个代理类<code>UserServiceProxy</code>，实现<code>UserService</code>接口，然后在<code>UserServiceProxy</code>里面创建一个成员变量<code>userService</code>，再写一个有参构造器来初始化<code>userService</code>。代码如下：</p><pre><code class="java">public class UserServiceProxy implements UserService {    private UserService userService;    public UserServiceProxy(UserService userService) {        this.userService = userService;    }    @Override    public List&lt;User&gt; getAllUser() throws Exception {        System.out.println(&quot;记录日志：执行getAllUser()方法前&quot;);        List&lt;User&gt; userList = userService.getAllUser();        System.out.println(userList);        System.out.println(&quot;记录日志：执行getAllUser()方法后&quot;);        return userList;    }}</code></pre><p>所以在controller层调用的方式就要改一下，是用代理类<code>UserServiceProxy</code>调用<code>getAllUser()</code>方法。如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource(name = &quot;userService&quot;)    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser()throws Exception{        return new UserServiceProxy(userService).getAllUser();    }}</code></pre><p>然后启动项目，调用一下接口，就可以看到控制台打印如下日志：</p><pre><code class="java">/*记录日志：执行getAllUser()方法前[User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser()方法后*/</code></pre><p>这就是静态代理的实现思路，很简单。但是一般我们肯定是不用这种方式。因为这种方式太笨了，很容易就可以看出几个缺点。</p><p><strong>1.要实现接口，也就是目标的方法要定义一个接口方法，实际上是运用了java多态的特性</strong></p><p><strong>2.第一点还不是致命的，因为JDK动态代理也是必须要定义接口；致命的是每一个你想代理的接口你都要去创建一个代理类去实现，假设有很多要代理的接口，那就创建很多代理类，这样显得很臃肿</strong></p><p>假设还是不理解为什么要动态代理，不妨我们再多加一个支付接口<code>PayService</code>，这个支付接口我们也要加上日志记录。</p><p>用静态代理怎么做？很简单呀，再创建一个<code>PayServiceProxy</code>类不就完了吗，如果还有<code>OrderService</code>(订单),</p><p><code>WarehouseService</code>(仓库)等等。那就要创建很多<code>XXXServiceProxy</code>类。如果使用动态代理，就没必要创建这么多代理类，创建一个代理类就够了！</p><blockquote><p>动态代理就是为了解决静态代理的这个缺点产生的。</p></blockquote><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK本身就带有动态代理，必须要满足一个条件，就是要有接口。原理其实和静态代理是一样的，也是用代理类去实现接口，但是代理类不是一开始就写好的，而是在程序运行时通过反射创建字节码文件然后加载到JVM。也就是动态生成的代理类对象。</p><p>下面就是用<code>JDK动态代理</code>实现代理模式。</p><pre><code class="java">public class LogRecordProxy&lt;T&gt; implements InvocationHandler {    private T target;    public LogRecordProxy(T t) {        this.target = t;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前&quot;);        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后&quot;);        return result;    }    /**     * 获取代理对象的方法     * */    @SuppressWarnings(&quot;unchecked&quot;)    public &lt;T&gt; T getProxy() throws Exception {        return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }}</code></pre><p>在controller层，就要改成这样。</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        //获取代理对象        UserService userServiceProxy = new LogRecordProxy&lt;&gt;(userService).getProxy();        return userServiceProxy.getAllUser();    }}</code></pre><p>假设有一个<code>PayService</code>也要做日志记录，就可以直接使用。</p><pre><code class="java">    @Resource(name = &quot;payService&quot;)    private PayService payService;        @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        //获取代理对象，实际上就在构造器上改一下传入的参数即可        PayService payServiceProxy = new LogRecordProxy&lt;&gt;(payService).getProxy();        return payServiceProxy.pay(channel,amount);    }</code></pre><p>很多文章给的例子都不带泛型，也可以，就是获取的代理对象需要强转一下，强转成对应的接口类。</p><p><strong>注意：这里一定要用接口接收代理对象，不能用实现类！</strong></p><p>因为返回的对象已经不是实现类的对象，而是和实现类有共同的接口类的代理类对象，所以当然只能用接口类去接收。</p><blockquote><p>这也是为什么一再强调要面向接口编程的原因，因为面向接口编程可以做更多的扩展。假设是面向实现类去编程，那就不能用JDK动态代理去扩展了！</p></blockquote><h2 id="CGLB动态代理"><a href="#CGLB动态代理" class="headerlink" title="CGLB动态代理"></a>CGLB动态代理</h2><p>那如果有些场景真的没有接口呢，我们怎么运用代理模式？</p><p>首先引入maven配置</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后创建一个方法拦截器<code>LogRecordInterceptor</code>，要实现<code>MethodInterceptor</code>类，如下：</p><pre><code class="java">public class LogRecordInterceptor implements MethodInterceptor {    private Object target;    public LogRecordInterceptor(Object target) {        this.target = target;    }    @Override    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前,参数：&quot; + Arrays.toString(args));        Object result = method.invoke(target, args);        System.out.println(result);        System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后,参数：&quot; + Arrays.toString(args));        return result;    }}</code></pre><p>然后再创建一个工厂类<code>InterceptorFactory</code>，用于创建代理对象。</p><pre><code class="java">public class InterceptorFactory {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T&gt; T getInterceptor(Class&lt;T&gt; clazz, MethodInterceptor methodInterceptor) {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(clazz);        enhancer.setCallback(methodInterceptor);        return (T) enhancer.create();    }}</code></pre><p>接着我们就可以创建一个没有接口的类，我这里就创建一个数学工具类进行测试</p><pre><code class="java">public class MathUtil {    /**     * 获取一个数的平方     * */    public String getSquare(int num) {        return String.valueOf(num * num);    }}</code></pre><p>然后在controller层定义一个接口来测试</p><pre><code class="java">@RequestMapping(&quot;/getSquare&quot;)    public String getSquare(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception {        MathUtil mathUtil = InterceptorFactory.getInterceptor(MathUtil.class, new LogRecordInterceptor(new MathUtil()));        return mathUtil.getSquare(num);    }</code></pre><p>用浏览器或者<code>POSTMAN</code>工具调用接口，就可以在控制台看到以下输出：</p><pre><code class="java">/*记录日志：执行getSquare方法前,参数：[2]4记录日志：执行getSquare方法后,参数：[2]*/</code></pre><p>这样就实现没有定义接口也可以实现动态代理！</p><p>实际上，定义接口的也可以用这种方法来进行扩展，比如上面的<code>userService</code>接口</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController {    @Resource    private UserService userService;    @RequestMapping(&quot;/getAllUser&quot;)    public List&lt;User&gt; getAllUser() throws Exception {        UserServiceImpl userServiceProxy = InterceptorFactory            .getInterceptor(UserServiceImpl.class,                            new LogRecordInterceptor(userService));        return userServiceProxy.getAllUser();    }}</code></pre><p>调用接口我们在控制台也是可以看到以下输出日志：</p><pre><code class="java">/*记录日志：执行getAllUser方法前,参数：[][User{id=1, name=&#39;大司马&#39;, age=36, job=&#39;厨师&#39;}, User{id=2, name=&#39;朴老师&#39;, age=36, job=&#39;主播&#39;}, User{id=3, name=&#39;王刚&#39;, age=30, job=&#39;厨师&#39;}, User{id=4, name=&#39;大sao&#39;, age=32, job=&#39;美食up主&#39;}, User{id=5, name=&#39;姚大秋&#39;, age=35, job=&#39;主持人&#39;}]记录日志：执行getAllUser方法后,参数：[]*/</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>以上就是代理模式的一些通俗的解释，还有三种实现的方式的学习</strong></p><p>多说几句，我们都知道<code>Spring</code>框架有两个核心技术，一个叫控制反转<code>IOC</code>，另一个叫切面编程<code>AOP</code>。切面编程大家都很熟悉，用的就是代理模式，那么<code>AOP</code>实现的代理模式用的是<code>JDK动态代理</code>还是<code>CLB动态代理</code>？</p><p>答曰：<strong>两个都用！</strong></p><p>最简单的，我们看<code>Spring</code>的事务管理，就是用代理模式实现的，如果有兴趣，其实我们自己也可以通过<code>JDK动态代理</code>手写实现事务管理，其实不是很难。篇幅有限，以后可以单独写一篇文章详细说明<code>Spring</code>的事务管理，敬请期待。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板模式以及实战应用</title>
    <link href="/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2020/04/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>上一篇讲了策略模式，知道了可以使用策略模式对多重if-else进行优化，而且符合开闭原则。那么除了策略模式，还有什么设计模式比较好用而且常用的呢。这就是今天要讲的模板模式。</p><a id="more"></a><p>模板模式解决什么问题呢？</p><h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><p>首先我们使用SpringBoot来搭建一个工程。</p><pre><code class="xml">    &lt;!-- maven配置 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;commons-lang&lt;/groupId&gt;        &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;        &lt;version&gt;2.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><p>application.yml配置如下：</p><pre><code class="yaml">server:  port: 8888spring:  datasource:    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8    username: 账号    password: 密码    driver-class-name: com.mysql.jdbc.Driver</code></pre><p>创建一个全局配置类<code>GlobalProperties</code>，我们通过这个类可以获取yml的配置信息</p><pre><code class="java">@Component(&quot;globalProperties&quot;)public class GlobalProperties {    @Value(&quot;${spring.datasource.driver-class-name}&quot;)    private String driverClass;    @Value(&quot;${spring.datasource.url}&quot;)    private String url;    @Value(&quot;${spring.datasource.username}&quot;)    private String username;    @Value(&quot;${spring.datasource.password}&quot;)    private String password;    //字段对应的getter、setter方法...</code></pre><p>创建一个连接工厂类<code>ConnectFactory</code>，获取数据库连接</p><pre><code class="java">public class ConnectFactory {    public static Connection getConnection() throws Exception{        //获取yml文件的配置，SpringContextUtil工具类在上一篇文章有介绍，可以参考上一篇文章的代码        GlobalProperties properties = SpringContextUtil                .getBean(&quot;globalProperties&quot;, GlobalProperties.class);        //加载数据驱动        Class.forName(properties.getDriverClass());        //获取数据库连接，返回数据库连接对象        return DriverManager.getConnection(properties.getUrl(),                properties.getUsername(), properties.getPassword());    }}</code></pre><p>创建实体类<code>User</code></p><pre><code class="java">public class User {    private Integer id;    private String name;    private Integer age;    private String job;    //字段对应的getter、setter方法...</code></pre><p>接着在mysql对应的数据库创建数据表<code>tb_user</code>，sql语句如下：</p><pre><code class="sql">CREATE TABLE `tb_user` (  `id` bigint(10) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,  `name` varchar(255) NOT NULL COMMENT &#39;名称&#39;,  `age` tinyint(4) NOT NULL COMMENT &#39;年龄&#39;,  `job` varchar(255) DEFAULT NULL COMMENT &#39;工作&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4</code></pre><p>插入一些测试数据</p><pre><code class="sql">INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大司马&#39;,36,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;朴老师&#39;,36,&#39;主播&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;王刚&#39;,30,&#39;厨师&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;大sao&#39;,32,&#39;美食up主&#39;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#39;姚大秋&#39;,35,&#39;主持人&#39;);</code></pre><p>假设我们有一张user表，我们通过原生的JDBC来进行数据库操作，那么需要在dao层完成以下几步。</p><p>1.装载相应的数据库的JDBC驱动并进行初始化</p><p>2.建立JDBC和数据库之间的Connection连接</p><p>3.创建Statement或者PreparedStatement接口，执行SQL语句</p><p>4.处理和显示结果</p><p>5.释放资源</p><p>例子如下：</p><pre><code class="java">    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        User user = new User();        //获取数据连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement             .executeQuery(String.format(GET_USER_BY_NAME_SQL, name))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        User user = new User();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet =             statement.executeQuery(String.format(GET_USER_BY_ID_SQL, id))        ) {            while (resultSet.next()) {                //获取id                user.setId(resultSet.getInt(&quot;id&quot;));                //获取名称                user.setName(resultSet.getString(&quot;name&quot;));                //获取年龄                user.setAge(resultSet.getInt(&quot;age&quot;));                //获取工作                user.setJob(resultSet.getString(&quot;job&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }        return user;    }</code></pre><p>PS:这里为了简单一点就直接把参数拼接sql语句，不采用预编译来处理sql的参数。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过上面的代码，我们很明显可以看到是有很大的问题的。</p><p>1.每次在进行数据库操作都需要获取<code>Connection</code>对象，创建<code>Statement</code>对象。</p><p>2.每次获取结果后，都要进行结果处理，而且如果是同一张表的查询，会很重复。每次都需要把结果值set回到对象的字段中。</p><p>模板模式就可以解决这个问题！</p><h2 id="使用模板模式重构代码"><a href="#使用模板模式重构代码" class="headerlink" title="使用模板模式重构代码"></a>使用模板模式重构代码</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>创建一个模板类<code>DaoTemplate</code>，如下：</p><pre><code class="java">/** * @author Ye Hongzhi * @program DaoTemplate * @description * @date 2020-04-12 17:04 **/@Componentpublic class DaoTemplate {    public &lt;T&gt; T query(String sql, Class&lt;T&gt; clazz) throws Exception {        //通过clazz创建返回值对象        T t = clazz.newInstance();        //获取数据库连接        try (Connection connection = ConnectFactory.getConnection();             Statement statement = connection.createStatement();             ResultSet resultSet = statement.executeQuery(sql)        ) {            while (resultSet.next()) {                //获取所有字段                Field[] fields = clazz.getDeclaredFields();                //获取所有方法                Method[] methods = clazz.getDeclaredMethods();                Map&lt;String, Method&gt; methodNameMap = Arrays.stream(methods)                        .collect(Collectors.toMap(Method::getName, Function.identity()));                //把数据库对应的列的值赋值给 泛型T对象的 对应的字段                for (Field field : fields) {                    //获取字段名                    String fieldName = field.getName();                    //获取set方法                    Method method = methodNameMap.get(&quot;set&quot; + change(fieldName));                    //获取数据库的列的值                    Object fieldValue = null;                    if (field.getType() == String.class) {                        fieldValue = resultSet.getString(fieldName);                    }                    if (field.getType() == Integer.class) {                        fieldValue = resultSet.getInt(fieldName);                    }                    if (field.getType() == Boolean.class) {                        fieldValue = resultSet.getBoolean(fieldName);                    }                    if (field.getType() == Long.class) {                        fieldValue = resultSet.getLong(fieldName);                    }                    if(field.getType() == Double.class){                        fieldValue = resultSet.getDouble(fieldName);                    }                    if(field.getType() == BigDecimal.class){                        fieldValue = resultSet.getBigDecimal(fieldName);                    }                    if (field.getType() == Date.class) {                        fieldValue = resultSet.getDate(fieldName);                    }                    //设置更多的字段类型...                    //利用反射执行对象的set方法，把数据库的值设置到对象的字段中                    method.invoke(t, fieldValue);                }            }        } catch (Exception e) {            e.printStackTrace();        }        return t;    }    /**     * 将一个字符串首字母大写，其它字母小写     *     * @param str 字符串     * @return     */    private static String change(String str) {        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();    }}</code></pre><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>创建模板后，可以在<code>DAO</code>层引入模板，然后使用。如下：</p><pre><code class="java">    //引入模板        @Resource    private DaoTemplate daoTemplate;    private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#39;%s&#39;&quot;;    @Override    public User getUserById(Integer id) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_ID_SQL, id), User.class);    }    private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#39;%s&#39;&quot;;    @Override    public User getUserByName(String name) throws Exception {        //使用模板的方法，查询        return daoTemplate.query(String.format(GET_USER_BY_NAME_SQL, name), User.class);    }</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><h1 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h1><p>实际上在Spring框架就有提供<code>JDBC</code>模板</p><p>我们可以在<code>MAVEN</code>中引入以下配置：</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>创建一个映射类<code>UserRowMapper</code></p><pre><code class="java">public class UserRowMapper implements RowMapper&lt;User&gt; {    @Override    public User mapRow(ResultSet resultSet, int i) throws SQLException {        User user = new User();        user.setId(resultSet.getInt(&quot;id&quot;));        user.setName(resultSet.getString(&quot;name&quot;));        user.setAge(resultSet.getInt(&quot;age&quot;));        user.setJob(resultSet.getString(&quot;job&quot;));        return user;    }}</code></pre><p>然后在<code>DAO</code>层的<code>UserDaoImpl</code>，我们就可以引入<code>JdbcTemplate</code></p><pre><code class="java">    @Resource    private JdbcTemplate jdbcTemplate;    //使用jdbcTemplate查询    @Override    public User getUserByName(String name) throws Exception {        return jdbcTemplate.queryForObject(String.format(GET_USER_BY_NAME_SQL, name), new UserRowMapper());    }</code></pre><p>从这里可以看出实际上<code>Spring</code>框架就是采用这种思想来实现<code>JdbcTemplate</code>模板。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>所以在实际项目的开发中，我们有时候遇到某些代码块的前后都有重复操作时，可以采用模板模式去重构代码，使代码更加简洁，容易维护。</p><p>更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你用策略模式解决多重if-else</title>
    <link href="/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/"/>
    <url>/2020/04/05/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>很多人可能在公司就是做普通的CRUD的业务，对于设计模式，即使学了好像也用处不大，顶多就在面试的时候能说上几种常见的单例模式，工厂模式。而在实际开发中，设计模式似乎很难用起来。</p><p>在现在的环境下，程序员的竞争已经非常激烈了，要体现出自身的价值，最直接的体现当然是差异化。这无需多说，我认为在实际开发中能运用设计模式，是很能体现差异化的。设计模式是一些前人总结的较好的方法，使程序能有更好的扩展性，可读性，维护性。</p><p>下面举个例子，使用策略模式解决多重if-else的代码结构。想学习更多的设计模式的实战经验，那就点个关注吧，谢谢大佬。</p><h1 id="使用if-else"><a href="#使用if-else" class="headerlink" title="使用if-else"></a>使用if-else</h1><p>假设我们要开发一个支付接口，要对接多种支付方式，通过渠道码区分各种的支付方式。于是定义一个枚举<code>PayEnum</code>，如下：</p><pre><code class="java">public enum PayEnum {    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;);    /**渠道*/    private String channel;    /**描述*/    private String description;    PayEnum(String channel, String description) {        this.channel = channel;        this.description = description;    }    /**以下省略字段的get、set方法*/</code></pre><p>创建一个<code>PayController</code>类，代码如下：</p><pre><code class="java">@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class PayController {    @Resource(name = &quot;payService&quot;)    private PayService payService;    /**    * 支付接口    * @param channel 渠道    * @param amount  消费金额    * @return String 返回消费结果    * @author Ye hongzhi    * @date 2020/4/5    */    @RequestMapping(&quot;/pay&quot;)    public String pay(@RequestParam(name = &quot;channel&quot;) String channel,                      @RequestParam(name = &quot;amount&quot;) String amount    )throws Exception{        return payService.pay(channel,amount);    }}</code></pre><p>再创建一个<code>PayService</code>接口以及实现类<code>PayServiceImpl</code></p><pre><code class="java">public interface PayService {    /**    * 支付接口    * @param channel 渠道    * @param amount  金额    * @return String    * @author Ye hongzhi    * @date 2020/4/5    */    String pay(String channel,String amount)throws Exception;}</code></pre><pre><code class="java">@Service(&quot;payService&quot;)public class PayServiceImpl implements PayService {    private static String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    @Override    public String pay(String channel, String amount) throws Exception {        if (PayEnum.ALI_PAY.getChannel().equals(channel)) {            //支付宝            //业务代码...            return String.format(MSG,PayEnum.ALI_PAY.getDescription(),amount);        }else if(PayEnum.WECHAT_PAY.getChannel().equals(channel)){            //微信支付            //业务代码...            return String.format(MSG,PayEnum.WECHAT_PAY.getDescription(),amount);        }else if(PayEnum.UNION_PAY.getChannel().equals(channel)){            //银联支付            //业务代码...            return         String.format(MSG,PayEnum.UNION_PAY.getDescription(),amount);        }else if(PayEnum.XIAO_MI_PAY.getChannel().equals(channel)){            //小米支付            //业务代码...            return String.format(MSG,PayEnum.XIAO_MI_PAY.getDescription(),amount);        }else{            return &quot;输入渠道码有误&quot;;        }    }}</code></pre><p>然后通过浏览器，我们可以看到效果</p><p><img src="https://static.lovebilibili.com/01.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://static.lovebilibili.com/02.png" srcset="/img/loading.gif" alt=""></p><p>这样看，以上代码的确可以实现需求，通过渠道码区分支付方式，可是看到上面那么多达4个的<code>if-else</code>的代码结构，已经开始显示出问题了。假设有更多的支付方式，那么这段代码就要写更多的<code>else if</code>去判断，这显然会不利于代码的扩展，这样会导致这个支付的方法越写越长。</p><p>在设计模式六大原则中，其中一个原则叫做<code>开闭原则</code>，对扩展开放，对修改关闭，应尽量在不修改原有代码的情况下进行扩展。</p><p>基于上面提到的<code>开闭原则</code>，我们可以使用策略模式进行重构。</p><h1 id="使用策略模式重构代码"><a href="#使用策略模式重构代码" class="headerlink" title="使用策略模式重构代码"></a>使用策略模式重构代码</h1><p>定义一个策略接口类<code>PayStrategy</code></p><pre><code class="java">public interface PayStrategy {    String MSG = &quot;使用 %s ,消费了 %s 元&quot;;    String pay(String channel,String amount)throws Exception;}</code></pre><p>然后再创建四种策略实现类实现接口</p><pre><code class="java">@Component(&quot;aliPayStrategy&quot;)public class AliPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.ALI_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;wechatPayStrategy&quot;)public class WechatPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.WECHAT_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;unionPayStrategy&quot;)public class UnionPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.UNION_PAY.getDescription(),amount);    }}</code></pre><pre><code class="java">@Component(&quot;xiaomiPayStrategy&quot;)public class XiaomiPayStrategyImpl implements PayStrategy{    @Override    public String pay(String channel, String amount) throws Exception {        return String.format(MSG, PayEnum.XIAO_MI_PAY.getDescription(),amount);    }}</code></pre><p>看到这里实际上已经很清晰了，思路就是通过渠道码，动态获取到具体的实现类，这样就可以实现不需要<code>if else</code>判断。怎么通过渠道码获取实现类呢？</p><p>在<code>PayEnum</code>枚举加上<code>BeanName</code>字段，然后增加一个通过渠道码获取<code>BeanName</code>的方法</p><pre><code class="java">    ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;,&quot;aliPayStrategy&quot;),    WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;,&quot;wechatPayStrategy&quot;),    UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;,&quot;unionPayStrategy&quot;),    XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;,&quot;xiaomiPayStrategy&quot;);    /**策略实现类对应的 beanName*/    private String beanName;    /**     * 通过渠道码获取枚举     * */    public static PayEnum findPayEnumBychannel(String channel){        PayEnum[] enums = PayEnum.values();        for (PayEnum payEnum : enums){            if(payEnum.getChannel().equals(channel)){                return payEnum;            }        }        return null;    }    //构造器    PayEnum(String channel, String description, String beanName) {        this.channel = channel;        this.description = description;        this.beanName = beanName;    }</code></pre><p>这时候还差一个获取Spring上下文对象的工具类，于是我们创建一个<code>SpringContextUtil</code>类</p><pre><code class="java">@Componentpublic class SpringContextUtil implements ApplicationContextAware {    /**     * 上下文对象实例     */    private static ApplicationContext applicationContext;    /**     * 获取applicationContext     */    private static ApplicationContext getApplicationContext() {        return applicationContext;    }    /**     * 通过name获取Bean     * */    public static Object getBean(String name){        return getApplicationContext().getBean(name);    }    /**     * 通过name,以及Clazz返回指定的Bean     * */    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz){        return getApplicationContext().getBean(name,clazz);    }    @Override    @Autowired    public void setApplicationContext(ApplicationContext applicationContext) throws         BeansException {        SpringContextUtil.applicationContext = applicationContext;    }</code></pre><p>接着定义一个工厂类，通过渠道码获取对应的策略实现类</p><pre><code class="java">public class PayStrategyFactory {    /**     * 通过渠道码获取支付策略具体实现类     * */    public static PayStrategy getPayStrategy(String channel){        PayEnum payEnum = PayEnum.findPayEnumBychannel(channel);        if(payEnum == null){            return null;        }        return SpringContextUtil.getBean(payEnum.getBeanName(),PayStrategy.class);    }}</code></pre><p>最后我们再改造一下原来的<code>PayServiceImpl</code>的<code>pay</code>方法</p><pre><code class="java">@Overridepublic String pay(String channel, String amount) throws Exception {    PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel);    if(payStrategy == null){        return &quot;输入渠道码有误&quot;;    }    return payStrategy.pay(channel,amount);}</code></pre><p>哇喔！突然间代码就显得清爽很多了！</p><p>小伙伴们看到这里，get到新的技能了吗？</p><blockquote><p>假设需要增加新的支付方式，就不需要再使用else if 去判断，而是在枚举中定义一个新的枚举对象，然后再增加一个策略实现类，实现对应的方法，那就可以很轻松地扩展。也实现了开闭原则。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>设计模式运用得熟练的话，很多代码可以写得很优雅。更多的设计模式实战经验的分享，就关注java技术小牛吧。</p><img src="https://me.lovebilibili.com/img/wechat.jpg-slim" srcset="/img/loading.gif" alt="100" style="zoom:50%;" /><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot系列之自定义spring-boot-starter</title>
    <link href="/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/"/>
    <url>/2020/02/17/SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>传统的 Maven项目一般将需要被复用的组件做成 Module来进行管理，以便二次调用；而在 Spring Boot项目中我们则可以使用更加优雅的 Spring Boot Starter来完成这一切。</p><a id="more"></a><p>这个开箱即用的魔法特性很大程度上来源于各式各样 Spring Boot Starter的加持，而且随着版本的迭代 Starter家族成员日益庞大，而且各种优秀开源作者也提供了很多非常好用的Spring Boot Starter。</p><p>本文尝试自定义一个Spring Boot Starter用于图片链接转换BASE64编码。</p><h1 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h1><ol><li>在GItHub上创建base64util-spring-boot-starter项目，然后clone下来本地进行开发。</li></ol><p><img src="https://static.lovebilibili.com/Github_Create.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>pom.xml文件配置如下</li></ol><pre><code class="xml">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;&lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;0.0.1&lt;/version&gt;&lt;dependencies&gt;    &lt;!-- 引入SpringBoot自动配置jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ol start="3"><li>业务代码</li></ol><pre><code class="java">import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL;/** * @author Ye Hongzhi * @program Base64Util * @description * @date 2020-02-17 14:04 **/public class Base64Util {    /**     * 本地图片转为BASE64编码     *     * @param imgFile 本地图片地址     * @return BASE64 解码后的字符串编码     * @description: 根据图片地址转换为base64编码字符串     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static String getImageFile(String imgFile) {        byte[] data = null;        try (InputStream inputStream = new FileInputStream(imgFile)) {            data = new byte[inputStream.available()];            int length = inputStream.read(data);            if (length == -1) {                return null;            }        } catch (Exception e) {            e.printStackTrace();        }        // 加密        BASE64Encoder encoder = new BASE64Encoder();        if (data != null) {            return encoder.encode(data);        } else {            return null;        }    }    public static String image2Base64(String imgUrl) throws Exception {        URL url = new URL(imgUrl);        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();        try(InputStream inputStream = urlConnection.getInputStream();            ByteArrayOutputStream baos = new ByteArrayOutputStream()) {            urlConnection.connect();            byte[] buffer = new byte[1024];            int len;            //使用一个输入流从buffer里把数据读取出来            while ((len = inputStream.read(buffer)) != -1) {                //用输出流往buffer里写入数据，中间参数代表从哪个位置开始读，len代表读取的长度                baos.write(buffer, 0, len);            }            // 对字节数组Base64编码            return Base64.encode(baos.toByteArray());        } catch (Exception e) {            e.printStackTrace();        } finally {            if (urlConnection != null) {                urlConnection.disconnect();            }        }        return imgUrl;    }    /**     * BASE64编码转为图片     * 注意：&quot;data:image/jpeg;base64,&quot; 解码之前得去掉。     *     * @param imgStr base64编码字符串     * @param path   图片路径-具体到文件     * @return 是否转换成功     * @description: 将base64编码字符串转换为图片     * @author: Ye Hongzhi     * @createTime: 2020/02/17     */    public static boolean generateImage(String imgStr, String path) {        if (imgStr == null) {            return false;        }        try (OutputStream out = new FileOutputStream(path)) {            BASE64Decoder decoder = new BASE64Decoder();            // 解密            byte[] b = decoder.decodeBuffer(imgStr);            // 处理数据            for (int i = 0; i &lt; b.length; ++i) {                if (b[i] &lt; 0) {                    b[i] += 256;                }            }            out.write(b);            out.flush();            return true;        } catch (Exception e) {            e.printStackTrace();            return false;        }    }}</code></pre><ol start="4"><li>创建一个service调用，这里为了简单，就不定义为接口的形式</li></ol><pre><code class="java">public class Base64Service {    /**     * 本地图片转为BASE64编码     */    public String getImageFile(String imgFile) {        return Base64Util.getImageFile(imgFile);    }    /**     * BASE64编码转为图片     * */    public boolean generateImage(String imgStr, String path) {        return Base64Util.generateImage(imgStr,path);    }    /**     * 在线图片转为BASE64编码     * */    public String image2Base64(String imgUrl) throws Exception{        return Base64Util.image2Base64(imgUrl);    }}</code></pre><ol start="5"><li>关键的一步，使用配置类，把service定义成bean，加入到spring容器中管理</li></ol><pre><code class="java">@Configurationpublic class Base64AutoConfiguration {    @Bean    Base64Service base64Service(){        return new Base64Service();    }}</code></pre><ol start="6"><li>最关键一步在于需要在resources文件夹下创建<code>META-INF/spring.factories</code>，<code>spring.factories</code>里的代码如下:</li></ol><pre><code class="yaml">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.lovebilibili.me.config.Base64AutoConfiguration</code></pre><p>这一步是重点，因为Spring Boot应用在启动过程中会通过 <code>SpringFactoriesLoader</code> 加载所有 <code>META-INF/spring.factories</code> 文件，通过一系列的处理流程最终将 spring.factories 文件中的定义的各种 <code>beans</code> 装载入 ApplicationContext容器。</p><blockquote><p>至此，自定义的用于base64转码工具的spring-boot-starter就完成了</p><p>可以通过使用maven命令<code>mvn install</code>打包，传到私有/公有Maven仓库使用。</p><p>形成一个公共的模块，供有需要的项目使用。</p></blockquote><ol start="7"><li>完成后把代码推送到Github仓库中，方便以后继续优化。</li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li>在其他项目中的pom文件加入以下依赖：</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.github.yehongzhi&lt;/groupId&gt;    &lt;artifactId&gt;base64util-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.0.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>在Controller层中，我们可以引入base64Service。</li></ol><pre><code class="java">@Resourceprivate Base64Service base64Service;</code></pre><ol start="3"><li>然后在Controller层中的@RequestMapping对应的方法中使用</li></ol><pre><code class="java">//把在线图片转为BASE64编码String base64 = base64Service.image2Base64(imgUrl);</code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><blockquote><p>能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要创建个人博客</title>
    <link href="/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>很高兴你能点进来看我的第一篇文章。</p><p>内容也和标题一样无聊，为什么要创建个人博客，既然我已经创建了还要找什么理由呢。但是你点进来很大原因是因为你还没有个人博客，所以想来听听我创建个人博客的理由，以此来驱动自己去创建个人博客。这非常好，证明你已经有冲动了，只差行动起来。</p><p>我的理由有以下几点：</p><ol><li>想要记录下一些自己的技术学习的过程。比记录在有道云笔记自己看更加有价值，因为博客是可以分享，可以传播，知识需要传播起来才有力量。这是最大的一个原因。</li><li>通过输出博客文章提升自己的技术水平。因为输出就是最好的学习，输出一篇好的技术文章，往往就是最好的学习方式。</li><li>通过这个博客和网友互相学习。毕竟外面的世界很大，可以通过博客这个窗口和网上的开发者互相学习讨论，不失为一种乐趣。</li><li>记录一些生活感想、读书笔记、美食经历等等。</li></ol><p>这就是我的理由。如果你想要创建个人博客的话，马上去做吧。</p><p>教程的话可以参考</p><p>B站up主“CodeSheep”的视频<a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></p><p>我的hexo主题使用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">fluid</a>,如果你觉得不错也可以使用哦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
